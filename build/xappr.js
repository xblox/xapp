define('dojo/has',["require", "module"], function(require, module){
	// module:
	//		dojo/has
	// summary:
	//		Defines the has.js API and several feature tests used by dojo.
	// description:
	//		This module defines the has API as described by the project has.js with the following additional features:
	//
	//		- the has test cache is exposed at has.cache.
	//		- the method has.add includes a forth parameter that controls whether or not existing tests are replaced
	//		- the loader's has cache may be optionally copied into this module's has cahce.
	//
	//		This module adopted from https://github.com/phiggins42/has.js; thanks has.js team!

	// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one
	// if using a foreign loader, then the has cache may be initialized via the config object for this module
	// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail
	var has = require.has || function(){};
	if(!has("dojo-has-api")){
		var
			isBrowser =
				// the most fundamental decision: are we in the browser?
				typeof window != "undefined" &&
				typeof location != "undefined" &&
				typeof document != "undefined" &&
				window.location == location && window.document == document,

			// has API variables
			global = (function () { return this; })(),
			doc = isBrowser && document,
			element = doc && doc.createElement("DiV"),
			cache = (module.config && module.config()) || {};

		has = function(name){
			// summary:
			//		Return the current value of the named feature.
			//
			// name: String|Integer
			//		The name (if a string) or identifier (if an integer) of the feature to test.
			//
			// description:
			//		Returns the value of the feature named by name. The feature must have been
			//		previously added to the cache by has.add.

			return typeof cache[name] == "function" ? (cache[name] = cache[name](global, doc, element)) : cache[name]; // Boolean
		};

		has.cache = cache;

		has.add = function(name, test, now, force){
			// summary:
			//	 	Register a new feature test for some named feature.
			// name: String|Integer
			//	 	The name (if a string) or identifier (if an integer) of the feature to test.
			// test: Function
			//		 A test function to register. If a function, queued for testing until actually
			//		 needed. The test function should return a boolean indicating
			//	 	the presence of a feature or bug.
			// now: Boolean?
			//		 Optional. Omit if `test` is not a function. Provides a way to immediately
			//		 run the test and cache the result.
			// force: Boolean?
			//	 	Optional. If the test already exists and force is truthy, then the existing
			//	 	test will be replaced; otherwise, add does not replace an existing test (that
			//	 	is, by default, the first test advice wins).
			// example:
			//		A redundant test, testFn with immediate execution:
			//	|	has.add("javascript", function(){ return true; }, true);
			//
			// example:
			//		Again with the redundantness. You can do this in your tests, but we should
			//		not be doing this in any internal has.js tests
			//	|	has.add("javascript", true);
			//
			// example:
			//		Three things are passed to the testFunction. `global`, `document`, and a generic element
			//		from which to work your test should the need arise.
			//	|	has.add("bug-byid", function(g, d, el){
			//	|		// g	== global, typically window, yadda yadda
			//	|		// d	== document object
			//	|		// el == the generic element. a `has` element.
			//	|		return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
			//	|	});

			(typeof cache[name]=="undefined" || force) && (cache[name]= test);
			return now && has(name);
		};

		// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize
		// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder
		// can optimize these away iff desired
		has.add("host-browser", isBrowser);
		has.add("host-node", (typeof process == "object" && process.versions && process.versions.node && process.versions.v8));
		has.add("host-rhino", (typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object")));
		has.add("dom", isBrowser);
		has.add("dojo-dom-ready-api", 1);
		has.add("dojo-sniff", 1);
	}

	if(has("host-browser")){
		// Common application level tests
		has.add("dom-addeventlistener", !!document.addEventListener);

		// Do the device and browser have touch capability?
		has.add("touch", "ontouchstart" in document
			|| ("onpointerdown" in document && navigator.maxTouchPoints > 0)
			|| window.navigator.msMaxTouchPoints);

		// Touch events support
		has.add("touch-events", "ontouchstart" in document);

		// Test if pointer events are supported and enabled, with either standard names ("pointerdown" etc.) or
		// IE specific names ("MSPointerDown" etc.).  Tests are designed to work on embedded C# WebBrowser Controls
		// in addition to IE, Edge, and future versions of Firefox and Chrome.
		// Note that on IE11, has("pointer-events") and has("MSPointer") are both true.
		has.add("pointer-events", "pointerEnabled" in window.navigator ?
				window.navigator.pointerEnabled : "PointerEvent" in window);
		has.add("MSPointer", window.navigator.msPointerEnabled);

		// I don't know if any of these tests are really correct, just a rough guess
		has.add("device-width", screen.availWidth || innerWidth);

		// Tests for DOMNode.attributes[] behavior:
		//	 - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes
		//	 - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify
		//	 - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.
		var form = document.createElement("form");
		has.add("dom-attributes-explicit", form.attributes.length == 0); // W3C
		has.add("dom-attributes-specified-flag", form.attributes.length > 0 && form.attributes.length < 40);	// IE8
	}

	has.clearElement = function(element){
		// summary:
		//	 Deletes the contents of the element passed to test functions.
		element.innerHTML= "";
		return element;
	};

	has.normalize = function(id, toAbsMid){
		// summary:
		//	 Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
		//
		// toAbsMid: Function
		//	 Resolves a relative module id into an absolute module id
		var
			tokens = id.match(/[\?:]|[^:\?]*/g), i = 0,
			get = function(skip){
				var term = tokens[i++];
				if(term == ":"){
					// empty string module name, resolves to 0
					return 0;
				}else{
					// postfixed with a ? means it is a feature to branch on, the term is the name of the feature
					if(tokens[i++] == "?"){
						if(!skip && has(term)){
							// matched the feature, get the first value from the options
							return get();
						}else{
							// did not match, get the second value, passing over the first
							get(true);
							return get(skip);
						}
					}
					// a module
					return term || 0;
				}
			};
		id = get();
		return id && toAbsMid(id);
	};

	has.load = function(id, parentRequire, loaded){
		// summary:
		//		Conditional loading of AMD modules based on a has feature test value.
		// id: String
		//		Gives the resolved module id to load.
		// parentRequire: Function
		//		The loader require function with respect to the module that contained the plugin resource in it's
		//		dependency list.
		// loaded: Function
		//	 Callback to loader that consumes result of plugin demand.

		if(id){
			parentRequire([id], loaded);
		}else{
			loaded();
		}
	};

	
	
	return has;
});

define('dojo/_base/config',["../has", "require"], function(has, require){
	// module:
	//		dojo/_base/config

/*=====
return {
	// summary:
	//		This module defines the user configuration during bootstrap.
	// description:
	//		By defining user configuration as a module value, an entire configuration can be specified in a build,
	//		thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
	//		Also, when multiple instances of dojo exist in a single application, each will necessarily be located
	//		at an unique absolute module identifier as given by the package configuration. Implementing configuration
	//		as a module allows for specifying unique, per-instance configurations.
	// example:
	//		Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
	//		dojo.js are already loaded).
	//		|	// specify a configuration that creates a new instance of dojo at the absolute module identifier "myDojo"
	//		|	require({
	//		|		packages:[{
	//		|			name:"myDojo",
	//		|			location:".", //assume baseUrl points to dojo.js
	//		|		}]
	//		|	});
	//		|
	//		|	// specify a configuration for the myDojo instance
	//		|	define("myDojo/config", {
	//		|		// normal configuration variables go here, e.g.,
	//		|		locale:"fr-ca"
	//		|	});
	//		|
	//		|	// load and use the new instance of dojo
	//		|	require(["myDojo"], function(dojo){
	//		|		// dojo is the new instance of dojo
	//		|		// use as required
	//		|	});

	// isDebug: Boolean
	//		Defaults to `false`. If set to `true`, ensures that Dojo provides
	//		extended debugging feedback to the console.
	isDebug: false,

	// locale: String
	//		The locale to assume for loading localized resources in this page,
	//		specified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		Must be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.
	//		See the documentation for `dojo.i18n` and `dojo.requireLocalization`
	//		for details on loading localized resources. If no locale is specified,
	//		Dojo assumes the locale of the user agent, according to `navigator.userLanguage`
	//		or `navigator.language` properties.
	locale: undefined,

	// extraLocale: Array
	//		No default value. Specifies additional locales whose
	//		resources should also be loaded alongside the default locale when
	//		calls to `dojo.requireLocalization()` are processed.
	extraLocale: undefined,

	// baseUrl: String
	//		The directory in which `dojo.js` is located. Under normal
	//		conditions, Dojo auto-detects the correct location from which it
	//		was loaded. You may need to manually configure `baseUrl` in cases
	//		where you have renamed `dojo.js` or in which `<base>` tags confuse
	//		some browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned
	//		either the value of `djConfig.baseUrl` if one is provided or the
	//		auto-detected root if not. Other modules are located relative to
	//		this path. The path should end in a slash.
	baseUrl: undefined,

	// modulePaths: [deprecated] Object
	//		A map of module names to paths relative to `dojo.baseUrl`. The
	//		key/value pairs correspond directly to the arguments which
	//		`dojo.registerModulePath` accepts. Specifying
	//		`djConfig.modulePaths = { "foo": "../../bar" }` is the equivalent
	//		of calling `dojo.registerModulePath("foo", "../../bar");`. Multiple
	//		modules may be configured via `djConfig.modulePaths`.
	modulePaths: {},

	// addOnLoad: Function|Array
	//		Adds a callback via dojo/ready. Useful when Dojo is added after
	//		the page loads and djConfig.afterOnLoad is true. Supports the same
	//		arguments as dojo/ready. When using a function reference, use
	//		`djConfig.addOnLoad = function(){};`. For object with function name use
	//		`djConfig.addOnLoad = [myObject, "functionName"];` and for object with
	//		function reference use
	//		`djConfig.addOnLoad = [myObject, function(){}];`
	addOnLoad: null,

	// parseOnLoad: Boolean
	//		Run the parser after the page is loaded
	parseOnLoad: false,

	// require: String[]
	//		An array of module names to be loaded immediately after dojo.js has been included
	//		in a page.
	require: [],

	// defaultDuration: Number
	//		Default duration, in milliseconds, for wipe and fade animations within dijits.
	//		Assigned to dijit.defaultDuration.
	defaultDuration: 200,

	// dojoBlankHtmlUrl: String
	//		Used by some modules to configure an empty iframe. Used by dojo/io/iframe and
	//		dojo/back, and dijit/popup support in IE where an iframe is needed to make sure native
	//		controls do not bleed through the popups. Normally this configuration variable
	//		does not need to be set, except when using cross-domain/CDN Dojo builds.
	//		Save dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`
	//		to the path on your domain your copy of blank.html.
	dojoBlankHtmlUrl: undefined,

	// ioPublish: Boolean?
	//		Set this to true to enable publishing of topics for the different phases of
	//		IO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list
	//		of topics that are published.
	ioPublish: false,

	// useCustomLogger: Anything?
	//		If set to a value that evaluates to true such as a string or array and
	//		isDebug is true and Firebug is not available or running, then it bypasses
	//		the creation of Firebug Lite allowing you to define your own console object.
	useCustomLogger: undefined,

	// transparentColor: Array
	//		Array containing the r, g, b components used as transparent color in dojo.Color;
	//		if undefined, [255,255,255] (white) will be used.
	transparentColor: undefined,
	
	// deps: Function|Array
	//		Defines dependencies to be used before the loader has been loaded.
	//		When provided, they cause the loader to execute require(deps, callback) 
	//		once it has finished loading. Should be used with callback.
	deps: undefined,
	
	// callback: Function|Array
	//		Defines a callback to be used when dependencies are defined before 
	//		the loader has been loaded. When provided, they cause the loader to 
	//		execute require(deps, callback) once it has finished loading. 
	//		Should be used with deps.
	callback: undefined,
	
	// deferredInstrumentation: Boolean
	//		Whether deferred instrumentation should be loaded or included
	//		in builds.
	deferredInstrumentation: true,

	// useDeferredInstrumentation: Boolean|String
	//		Whether the deferred instrumentation should be used.
	//
	//		* `"report-rejections"`: report each rejection as it occurs.
	//		* `true` or `1` or `"report-unhandled-rejections"`: wait 1 second
	//			in an attempt to detect unhandled rejections.
	useDeferredInstrumentation: "report-unhandled-rejections"
};
=====*/

	var result = {};
	if(has("dojo-config-api")){
		// must be the dojo loader; take a shallow copy of require.rawConfig
		var src = require.rawConfig, p;
		for(p in src){
			result[p] = src[p];
		}
	}else{
		var adviseHas = function(featureSet, prefix, booting){
			for(p in featureSet){
				p!="has" && has.add(prefix + p, featureSet[p], 0, booting);
			}
		};
		var global = (function () { return this; })();
		result = has("dojo-loader") ?
			// must be a built version of the dojo loader; all config stuffed in require.rawConfig
			require.rawConfig :
			// a foreign loader
			global.dojoConfig || global.djConfig || {};
		adviseHas(result, "config", 1);
		adviseHas(result.has, "", 1);
	}

	if(!result.locale && typeof navigator != "undefined"){
		// Default locale for browsers (ensure it's read from user-settings not download locale).
		var language = (navigator.languages && navigator.languages.length) ? navigator.languages[0] :
			(navigator.language || navigator.userLanguage);
		if(language){
			result.locale = language.toLowerCase();
		}
	}

	return result;
});


define('dojo/_base/kernel',["../has", "./config", "require", "module"], function(has, config, require, module){
	// module:
	//		dojo/_base/kernel

	// This module is the foundational module of the dojo boot sequence; it defines the dojo object.

	var
		// loop variables for this module
		i, p,

		// create dojo, dijit, and dojox
		// FIXME: in 2.0 remove dijit, dojox being created by dojo
		global = (function () { return this; })(),
		dijit = {},
		dojox = {},
		dojo = {
			// summary:
			//		This module is the foundational module of the dojo boot sequence; it defines the dojo object.

			// notice dojo takes ownership of the value of the config module
			config:config,
			global:global,
			dijit:dijit,
			dojox:dojox
		};


	// Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide
	// a _scopeName property for the dojo, dijit, and dojox root object so those packages can create
	// unique names in the global space.
	//
	// Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,
	// where global when in fact they are either global under different names or not global at all. In v1.6-, the
	// config variable "scopeMap" was used to map names as used within a module to global names. This has been
	// subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,
	// only the "*" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.
	//
	// The following computations contort the packageMap for this dojo instance into a scopeMap.
	var scopeMap =
			// a map from a name used in a legacy module to the (global variable name, object addressed by that name)
			// always map dojo, dijit, and dojox
			{
				dojo:["dojo", dojo],
				dijit:["dijit", dijit],
				dojox:["dojox", dojox]
			},

		packageMap =
			// the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config
			(require.map && require.map[module.id.match(/[^\/]+/)[0]]),

		item;


	// process all mapped top-level names for this instance of dojo
	for(p in packageMap){
		if(scopeMap[p]){
			// mapped dojo, dijit, or dojox
			scopeMap[p][0] = packageMap[p];
		}else{
			// some other top-level name
			scopeMap[p] = [packageMap[p], {}];
		}
	}

	// publish those names to _scopeName and, optionally, the global namespace
	for(p in scopeMap){
		item = scopeMap[p];
		item[1]._scopeName = item[0];
		if(!config.noGlobals){
			global[item[0]] = item[1];
		}
	}
	dojo.scopeMap = scopeMap;

	/*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/

	// FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated
	dojo.baseUrl = dojo.config.baseUrl = require.baseUrl;
	dojo.isAsync = !has("dojo-loader") || require.async;
	dojo.locale = config.locale;

	var rev = "$Rev$".match(/[0-9a-f]{7,}/);
	dojo.version = {
		// summary:
		//		Version number of the Dojo Toolkit
		// description:
		//		Hash about the version, including
		//
		//		- major: Integer: Major version. If total version is "1.2.0beta1", will be 1
		//		- minor: Integer: Minor version. If total version is "1.2.0beta1", will be 2
		//		- patch: Integer: Patch version. If total version is "1.2.0beta1", will be 0
		//		- flag: String: Descriptor flag. If total version is "1.2.0beta1", will be "beta1"
		//		- revision: Number: The Git rev from which dojo was pulled

		major: 1, minor: 12, patch: 0, flag: "-pre",
		revision: rev ? rev[0] : NaN,
		toString: function(){
			var v = dojo.version;
			return v.major + "." + v.minor + "." + v.patch + v.flag + " (" + v.revision + ")";	// String
		}
	};

	// If has("extend-dojo") is truthy, then as a dojo module is defined it should push it's definitions
	// into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object
	// as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code
	// is migrated. Absent specific advice otherwise, set extend-dojo to truthy.
	has.add("extend-dojo", 1);

	if(!has("csp-restrictions")){
		(Function("d", "d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}"))(dojo);
	}
	/*=====
	dojo.eval = function(scriptText){
		// summary:
		//		A legacy method created for use exclusively by internal Dojo methods. Do not use this method
		//		directly unless you understand its possibly-different implications on the platforms your are targeting.
		// description:
		//		Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
		//		that support indirect eval.
		//
		//		As usual, IE does not. On IE, the only way to implement global eval is to
		//		use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
		//		This implementation uses the technique of executing eval in the scope of a function that is a single scope
		//		frame below the global scope; thereby coming close to the global scope. Note carefully that
		//
		//		dojo.eval("var pi = 3.14;");
		//
		//		will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
		//		to define a global variable using dojo.eval, write something like
		//
		//		dojo.eval("window.pi = 3.14;")
		// scriptText:
		//		The text to evaluation.
		// returns:
		//		The result of the evaluation. Often `undefined`
	};
	=====*/


	if(has("host-rhino")){
		dojo.exit = function(exitcode){
			quit(exitcode);
		};
	}else{
		dojo.exit = function(){
		};
	}

	if(!has("host-webworker")){
		// console is immutable in FF30+, https://bugs.dojotoolkit.org/ticket/18100
		has.add("dojo-guarantee-console",
			// ensure that console.log, console.warn, etc. are defined
			1
		);
	}

	if(has("dojo-guarantee-console")){
		// IE 9 bug: https://bugs.dojotoolkit.org/ticket/18197
		has.add("console-as-object", Function.prototype.bind && console && typeof console.log === "object");
		typeof console != "undefined" || (console = {});  // intentional assignment
		//	Be careful to leave 'log' always at the end
		var cn = [
			"assert", "count", "debug", "dir", "dirxml", "error", "group",
			"groupEnd", "info", "profile", "profileEnd", "time", "timeEnd",
			"trace", "warn", "log"
		];
		var tn;
		i = 0;
		while((tn = cn[i++])){
			if(!console[tn]){
				(function(){
					var tcn = tn + "";
					console[tcn] = ('log' in console) ? function(){
						var a = Array.prototype.slice.call(arguments);
						a.unshift(tcn + ":");
						console["log"](a.join(" "));
					} : function(){};
					console[tcn]._fake = true;
				})();
			}else if(has("console-as-object")){
				console[tn] = Function.prototype.bind.call(console[tn], console);
			}
		}
	}

	has.add("dojo-debug-messages",
		// include dojo.deprecated/dojo.experimental implementations
		!!config.isDebug
	);
	dojo.deprecated = dojo.experimental =  function(){};
	if(has("dojo-debug-messages")){
		dojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){
			// summary:
			//		Log a debug message to indicate that a behavior has been
			//		deprecated.
			// behaviour: String
			//		The API or behavior being deprecated. Usually in the form
			//		of "myApp.someFunction()".
			// extra: String?
			//		Text to append to the message. Often provides advice on a
			//		new function or facility to achieve the same goal during
			//		the deprecation period.
			// removal: String?
			//		Text to indicate when in the future the behavior will be
			//		removed. Usually a version number.
			// example:
			//	| dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");

			var message = "DEPRECATED: " + behaviour;
			if(extra){ message += " " + extra; }
			if(removal){ message += " -- will be removed in version: " + removal; }
			console.warn(message);
		};

		dojo.experimental = function(/* String */ moduleName, /* String? */ extra){
			// summary:
			//		Marks code as experimental.
			// description:
			//		This can be used to mark a function, file, or module as
			//		experimental.	 Experimental code is not ready to be used, and the
			//		APIs are subject to change without notice.	Experimental code may be
			//		completed deleted without going through the normal deprecation
			//		process.
			// moduleName: String
			//		The name of a module, or the name of a module file or a specific
			//		function
			// extra: String?
			//		some additional message for the user
			// example:
			//	| dojo.experimental("dojo.data.Result");
			// example:
			//	| dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");

			var message = "EXPERIMENTAL: " + moduleName + " -- APIs subject to change without notice.";
			if(extra){ message += " " + extra; }
			console.warn(message);
		};
	}

	has.add("dojo-modulePaths",
		// consume dojo.modulePaths processing
		1
	);
	if(has("dojo-modulePaths")){
		// notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;
		// this is the v1.6- behavior.
		if(config.modulePaths){
			dojo.deprecated("dojo.modulePaths", "use paths configuration");
			var paths = {};
			for(p in config.modulePaths){
				paths[p.replace(/\./g, "/")] = config.modulePaths[p];
			}
			require({paths:paths});
		}
	}

	has.add("dojo-moduleUrl",
		// include dojo.moduleUrl
		1
	);
	if(has("dojo-moduleUrl")){
		dojo.moduleUrl = function(/*String*/module, /*String?*/url){
			// summary:
			//		Returns a URL relative to a module.
			// example:
			//	|	var pngPath = dojo.moduleUrl("acme","images/small.png");
			//	|	console.dir(pngPath); // list the object properties
			//	|	// create an image and set it's source to pngPath's value:
			//	|	var img = document.createElement("img");
			//	|	img.src = pngPath;
			//	|	// add our image to the document
			//	|	dojo.body().appendChild(img);
			// example:
			//		you may de-reference as far as you like down the package
			//		hierarchy.  This is sometimes handy to avoid lengthy relative
			//		urls or for building portable sub-packages. In this example,
			//		the `acme.widget` and `acme.util` directories may be located
			//		under different roots (see `dojo.registerModulePath`) but the
			//		the modules which reference them can be unaware of their
			//		relative locations on the filesystem:
			//	|	// somewhere in a configuration block
			//	|	dojo.registerModulePath("acme.widget", "../../acme/widget");
			//	|	dojo.registerModulePath("acme.util", "../../util");
			//	|
			//	|	// ...
			//	|
			//	|	// code in a module using acme resources
			//	|	var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
			//	|	var dataPath = dojo.moduleUrl("acme.util","resources/data.json");

			dojo.deprecated("dojo.moduleUrl()", "use require.toUrl", "2.0");

			// require.toUrl requires a filetype; therefore, just append the suffix "/*.*" to guarantee a filetype, then
			// remove the suffix from the result. This way clients can request a url w/out a filetype. This should be
			// rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).
			// Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.
			var result = null;
			if(module){
				result = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : "") + "/*.*").replace(/\/\*\.\*/, "") + (url ? "" : "/");
			}
			return result;
		};
	}

	dojo._hasResource = {}; // for backward compatibility with layers built with 1.6 tooling

	return dojo;
});

define('dojo/sniff',["./has"], function(has){
	// module:
	//		dojo/sniff

	/*=====
	return function(){
		// summary:
		//		This module sets has() flags based on the current browser.
		//		It returns the has() function.
	};
	=====*/

	if(has("host-browser")){
		var n = navigator,
			dua = n.userAgent,
			dav = n.appVersion,
			tv = parseFloat(dav);
		has.add("air", dua.indexOf("AdobeAIR") >= 0);
		has.add("wp", parseFloat(dua.split("Windows Phone")[1]) || undefined);
		has.add("msapp", parseFloat(dua.split("MSAppHost/")[1]) || undefined);
		has.add("khtml", dav.indexOf("Konqueror") >= 0 ? tv : undefined);
		has.add("edge", parseFloat(dua.split("Edge/")[1]) || undefined);
		has.add("opr", parseFloat(dua.split("OPR/")[1]) || undefined);
		// NOTE: https://dev.opera.com/blog/opera-user-agent-strings-opera-15-and-beyond/
		has.add("webkit", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
			&& !has("edge") && parseFloat(dua.split("WebKit/")[1]) || undefined);
		has.add("chrome", !has("edge") && !has("opr")
				&& parseFloat(dua.split("Chrome/")[1]) || undefined);
		has.add("android", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
				&& parseFloat(dua.split("Android ")[1]) || undefined);
		has.add("safari", dav.indexOf("Safari") >= 0
				&& !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
				&& !has("chrome") && !has("android") && !has("edge") && !has("opr") ?
			parseFloat(dav.split("Version/")[1]) : undefined);
		has.add("mac", dav.indexOf("Macintosh") >= 0);
		has.add("quirks", document.compatMode == "BackCompat");
		if(!has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
				&& dua.match(/(iPhone|iPod|iPad)/)){
			var p = RegExp.$1.replace(/P/, "p");
			var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
			var os = parseFloat(v.replace(/_/, ".").replace(/_/g, ""));
			has.add(p, os);		// "iphone", "ipad" or "ipod"
			has.add("ios", os);
		}
		has.add("bb", (dua.indexOf("BlackBerry") >= 0 || dua.indexOf("BB10") >= 0) && parseFloat(dua.split("Version/")[1]) || undefined);
		has.add("trident", parseFloat(dav.split("Trident/")[1]) || undefined);

		has.add("svg", typeof SVGAngle !== "undefined");

		if(!has("webkit")){
			// Opera
			if(dua.indexOf("Opera") >= 0){
				// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/
				// 9.8 has both styles; <9.8, 9.9 only old style
				has.add("opera", tv >= 9.8 ? parseFloat(dua.split("Version/")[1]) || tv : tv);
			}

			// Mozilla and firefox
			if(dua.indexOf("Gecko") >= 0 && !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1
					&& !has("khtml") && !has("trident") && !has("edge")){
				has.add("mozilla", tv);
			}
			if(has("mozilla")){
				//We really need to get away from this. Consider a sane isGecko approach for the future.
				has.add("ff", parseFloat(dua.split("Firefox/")[1] || dua.split("Minefield/")[1]) || undefined);
			}

			// IE
			if(document.all && !has("opera")){
				var isIE = parseFloat(dav.split("MSIE ")[1]) || undefined;

				//In cases where the page has an HTTP header or META tag with
				//X-UA-Compatible, then it is in emulation mode.
				//Make sure isIE reflects the desired version.
				//document.documentMode of 5 means quirks mode.
				//Only switch the value if documentMode's major version
				//is different from isIE's major version.
				var mode = document.documentMode;
				if(mode && mode != 5 && Math.floor(isIE) != mode){
					isIE = mode;
				}

				has.add("ie", isIE);
			}

			// Wii
			has.add("wii", typeof opera != "undefined" && opera.wiiremote);
		}
	}

	return has;
});

define('dojo/_base/lang',["./kernel", "../has", "../sniff"], function(dojo, has){
	// module:
	//		dojo/_base/lang

	has.add("bug-for-in-skips-shadowed", function(){
		// if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)
		for(var i in {toString: 1}){
			return 0;
		}
		return 1;
	});

	// Helper methods
	var _extraNames =
			has("bug-for-in-skips-shadowed") ?
				"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor".split(".") : [],

		_extraLen = _extraNames.length,

		getProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){
			if(!context){
				if(parts[0] && dojo.scopeMap[parts[0]]) {
					// Voodoo code from the old days where "dojo" or "dijit" maps to some special object
					// rather than just window.dojo
					context = dojo.scopeMap[parts.shift()][1];
				}else{
					context = dojo.global;
				}
			}

			try{
				for(var i = 0; i < parts.length; i++){
					var p = parts[i];
					if(!(p in context)){
						if(create){
							context[p] = {};
						}else{
							return;		// return undefined
						}
					}
					context = context[p];
				}
				return context; // mixed
			}catch(e){
				// "p in context" throws an exception when context is a number, boolean, etc. rather than an object,
				// so in that corner case just return undefined (by having no return statement)
			}
		},

		opts = Object.prototype.toString,

		efficient = function(obj, offset, startWith){
			return (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));
		},

		_pattern = /\{([^\}]+)\}/g;

	// Module export
	var lang = {
		// summary:
		//		This module defines Javascript language extensions.

		// _extraNames: String[]
		//		Lists property names that must be explicitly processed during for-in iteration
		//		in environments that have has("bug-for-in-skips-shadowed") true.
		_extraNames:_extraNames,

		_mixin: function(dest, source, copyFunc){
			// summary:
			//		Copies/adds all properties of source to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source.
			// source: Object
			//		The object from which to draw all properties to copy into dest.
			// copyFunc: Function?
			//		The process used to copy/add a property in source; defaults to the Javascript assignment operator.
			// returns:
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
			//		delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
			//		Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			var name, s, i, empty = {};
			for(name in source){
				// the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
				// inherited from Object.prototype.	 For example, if dest has a custom toString() method,
				// don't overwrite it with the toString() method that source inherited from Object.prototype
				name == 'keyLocation' && (name = 'location');
				s = source[name];
				if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
					dest[name] = copyFunc ? copyFunc(s) : s;
				}
			}

			if(has("bug-for-in-skips-shadowed")){
				if(source){
					for(i = 0; i < _extraLen; ++i){
						name = _extraNames[i];
						s = source[name];
						if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
							dest[name] = copyFunc ? copyFunc(s) : s;
						}
					}
				}
			}

			return dest; // Object
		},

		mixin: function(dest, sources){
			// summary:
			//		Copies/adds all properties of one or more sources to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source. If dest is falsy, then
			//		a new object is manufactured before copying/adding properties begins.
			// sources: Object...
			//		One of more objects from which to draw all properties to copy into dest. sources are processed
			//		left-to-right and if more than one of these objects contain the same property name, the right-most
			//		value "wins".
			// returns: Object
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
			//		The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
			//		executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			// example:
			//		make a shallow copy of an object
			//	|	var copy = lang.mixin({}, source);
			// example:
			//		many class constructors often take an object which specifies
			//		values to be configured on the object. In this case, it is
			//		often simplest to call `lang.mixin` on the `this` object:
			//	|	declare("acme.Base", null, {
			//	|		constructor: function(properties){
			//	|			// property configuration:
			//	|			lang.mixin(this, properties);
			//	|
			//	|			console.log(this.quip);
			//	|			//	...
			//	|		},
			//	|		quip: "I wasn't born yesterday, you know - I've seen movies.",
			//	|		// ...
			//	|	});
			//	|
			//	|	// create an instance of the class and configure it
			//	|	var b = new acme.Base({quip: "That's what it does!" });
			// example:
			//		copy in properties from multiple objects
			//	|	var flattened = lang.mixin(
			//	|		{
			//	|			name: "Frylock",
			//	|			braces: true
			//	|		},
			//	|		{
			//	|			name: "Carl Brutanananadilewski"
			//	|		}
			//	|	);
			//	|
			//	|	// will print "Carl Brutanananadilewski"
			//	|	console.log(flattened.name);
			//	|	// will print "true"
			//	|	console.log(flattened.braces);

			if(!dest){ dest = {}; }
			for(var i = 1, l = arguments.length; i < l; i++){
				lang._mixin(dest, arguments[i]);
			}
			return dest; // Object
		},

		setObject: function(name, value, context){
			// summary:
			//		Set a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			//		Objects are created as needed along `path`. Returns the passed
			//		value if setting is successful or `undefined` if not.
			// name: String
			//		Path to a property, in the form "A.B.C".
			// value: anything
			//		value or object to place at location given by name
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		`dojo.global`.
			// example:
			//		set the value of `foo.bar.baz`, regardless of whether
			//		intermediate objects already exist:
			//	| lang.setObject("foo.bar.baz", value);
			// example:
			//		without `lang.setObject`, we often see code like this:
			//	| // ensure that intermediate objects are available
			//	| if(!obj["parent"]){ obj.parent = {}; }
			//	| if(!obj.parent["child"]){ obj.parent.child = {}; }
			//	| // now we can safely set the property
			//	| obj.parent.child.prop = "some value";
			//		whereas with `lang.setObject`, we can shorten that to:
			//	| lang.setObject("parent.child.prop", "some value", obj);

			var parts = name.split("."), p = parts.pop(), obj = getProp(parts, true, context);
			return obj && p ? (obj[p] = value) : undefined; // Object
		},

		getObject: function(name, create, context){
			// summary:
			//		Get a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			// name: String
			//		Path to an property, in the form "A.B.C".
			// create: Boolean?
			//		Optional. Defaults to `false`. If `true`, Objects will be
			//		created at any point along the 'path' that is undefined.
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			return !name ? context : getProp(name.split("."), create, context); // Object
		},

		exists: function(name, obj){
			// summary:
			//		determine if an object supports a given method
			// description:
			//		useful for longer api chains where you have to test each object in
			//		the chain. Useful for object and method detection.
			// name: String
			//		Path to an object, in the form "A.B.C".
			// obj: Object?
			//		Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			// example:
			//	| // define an object
			//	| var foo = {
			//	|		bar: { }
			//	| };
			//	|
			//	| // search the global scope
			//	| lang.exists("foo.bar"); // true
			//	| lang.exists("foo.bar.baz"); // false
			//	|
			//	| // search from a particular scope
			//	| lang.exists("bar", foo); // true
			//	| lang.exists("bar.baz", foo); // false
			return lang.getObject(name, false, obj) !== undefined; // Boolean
		},

		// Crockford (ish) functions

		isString: function(it){
			// summary:
			//		Return true if it is a String
			// it: anything
			//		Item to test.
			return (typeof it == "string" || it instanceof String); // Boolean
		},

		isArray: Array.isArray || function(it){
			// summary:
			//		Return true if it is an Array.
			// it: anything
			//		Item to test.
			return opts.call(it) == "[object Array]"; // Boolean
		},

		isFunction: function(it){
			// summary:
			//		Return true if it is a Function
			// it: anything
			//		Item to test.
			return opts.call(it) === "[object Function]";
		},

		isObject: function(it){
			// summary:
			//		Returns true if it is a JavaScript object (or an Array, a Function
			//		or null)
			// it: anything
			//		Item to test.
			return it !== undefined &&
				(it === null || typeof it == "object" || lang.isArray(it) || lang.isFunction(it)); // Boolean
		},

		isArrayLike: function(it){
			// summary:
			//		similar to isArray() but more permissive
			// it: anything
			//		Item to test.
			// returns:
			//		If it walks like a duck and quacks like a duck, return `true`
			// description:
			//		Doesn't strongly test for "arrayness".  Instead, settles for "isn't
			//		a string or number and has a length property". Arguments objects
			//		and DOM collections will return true when passed to
			//		isArrayLike(), but will return false when passed to
			//		isArray().
			return !!it && // Boolean
				// keep out built-in constructors (Number, String, ...) which have length
				// properties
				!lang.isString(it) && !lang.isFunction(it) &&
				!(it.tagName && it.tagName.toLowerCase() == 'form') &&
				(lang.isArray(it) || isFinite(it.length));
		},

		isAlien: function(it){
			// summary:
			//		Returns true if it is a built-in function or some other kind of
			//		oddball that *should* report as a function but doesn't
			return it && !lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it)); // Boolean
		},

		extend: function(ctor, props){
			// summary:
			//		Adds all properties and methods of props to constructor's
			//		prototype, making them available to all instances created with
			//		constructor.
			// ctor: Object
			//		Target constructor to extend.
			// props: Object
			//		One or more objects to mix into ctor.prototype
			for(var i=1, l=arguments.length; i<l; i++){
				lang._mixin(ctor.prototype, arguments[i]);
			}
			return ctor; // Object
		},

		_hitchArgs: function(scope, method){
			var pre = lang._toArray(arguments, 2);
			var named = lang.isString(method);
			return function(){
				// arrayify arguments
				var args = lang._toArray(arguments);
				// locate our method
				var f = named ? (scope||dojo.global)[method] : method;
				// invoke with collected args
				return f && f.apply(scope || this, pre.concat(args)); // mixed
			}; // Function
		},

		hitch: function(scope, method){
			// summary:
			//		Returns a function that will only ever execute in the given scope.
			//		This allows for easy use of object member functions
			//		in callbacks and other places in which the "this" keyword may
			//		otherwise not reference the expected scope.
			//		Any number of default positional arguments may be passed as parameters
			//		beyond "method".
			//		Each of these values will be used to "placehold" (similar to curry)
			//		for the hitched function.
			// scope: Object
			//		The scope to use when method executes. If method is a string,
			//		scope is also the object containing method.
			// method: Function|String...
			//		A function to be hitched to scope, or the name of the method in
			//		scope to be hitched.
			// example:
			//	|	lang.hitch(foo, "bar")();
			//		runs foo.bar() in the scope of foo
			// example:
			//	|	lang.hitch(foo, myFunction);
			//		returns a function that runs myFunction in the scope of foo
			// example:
			//		Expansion on the default positional arguments passed along from
			//		hitch. Passed args are mixed first, additional args after.
			//	|	var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
			//	|	var fn = lang.hitch(foo, "bar", 1, 2);
			//	|	fn(3); // logs "1, 2, 3"
			// example:
			//	|	var foo = { bar: 2 };
			//	|	lang.hitch(foo, function(){ this.bar = 10; })();
			//		execute an anonymous function in scope of foo
			if(arguments.length > 2){
				return lang._hitchArgs.apply(dojo, arguments); // Function
			}
			if(!method){
				method = scope;
				scope = null;
			}
			if(lang.isString(method)){
				scope = scope || dojo.global;
				if(!scope[method]){ throw(['lang.hitch: scope["', method, '"] is null (scope="', scope, '")'].join('')); }
				return function(){ return scope[method].apply(scope, arguments || []); }; // Function
			}
			return !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function
		},

		delegate: (function(){
			// boodman/crockford delegation w/ cornford optimization
			function TMP(){}
			return function(obj, props){
				TMP.prototype = obj;
				var tmp = new TMP();
				TMP.prototype = null;
				if(props){
					lang._mixin(tmp, props);
				}
				return tmp; // Object
			};
		})(),
		/*=====
		delegate: function(obj, props){
			// summary:
			//		Returns a new object which "looks" to obj for properties which it
			//		does not have a value for. Optionally takes a bag of properties to
			//		seed the returned object with initially.
			// description:
			//		This is a small implementation of the Boodman/Crockford delegation
			//		pattern in JavaScript. An intermediate object constructor mediates
			//		the prototype chain for the returned object, using it to delegate
			//		down to obj for property lookup when object-local lookup fails.
			//		This can be thought of similarly to ES4's "wrap", save that it does
			//		not act on types but rather on pure objects.
			// obj: Object
			//		The object to delegate to for properties not found directly on the
			//		return object or in props.
			// props: Object...
			//		an object containing properties to assign to the returned object
			// returns:
			//		an Object of anonymous type
			// example:
			//	|	var foo = { bar: "baz" };
			//	|	var thinger = lang.delegate(foo, { thud: "xyzzy"});
			//	|	thinger.bar == "baz"; // delegated to foo
			//	|	foo.thud == undefined; // by definition
			//	|	thinger.thud == "xyzzy"; // mixed in from props
			//	|	foo.bar = "thonk";
			//	|	thinger.bar == "thonk"; // still delegated to foo's bar
		},
		=====*/

		_toArray: has("ie") ?
			(function(){
				function slow(obj, offset, startWith){
					var arr = startWith||[];
					for(var x = offset || 0; x < obj.length; x++){
						arr.push(obj[x]);
					}
					return arr;
				}
				return function(obj){
					return ((obj.item) ? slow : efficient).apply(this, arguments);
				};
			})() : efficient,
		/*=====
		 _toArray: function(obj, offset, startWith){
			 // summary:
			 //		Converts an array-like object (i.e. arguments, DOMCollection) to an
			 //		array. Returns a new Array with the elements of obj.
			 // obj: Object
			 //		the object to "arrayify". We expect the object to have, at a
			 //		minimum, a length property which corresponds to integer-indexed
			 //		properties.
			 // offset: Number?
			 //		the location in obj to start iterating from. Defaults to 0.
			 //		Optional.
			 // startWith: Array?
			 //		An array to pack with the properties of obj. If provided,
			 //		properties in obj are appended at the end of startWith and
			 //		startWith is the returned array.
		 },
		 =====*/

		partial: function(/*Function|String*/ method /*, ...*/){
			// summary:
			//		similar to hitch() except that the scope object is left to be
			//		whatever the execution context eventually becomes.
			// description:
			//		Calling lang.partial is the functional equivalent of calling:
			//		|	lang.hitch(null, funcName, ...);
			// method:
			//		The function to "wrap"
			var arr = [ null ];
			return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); // Function
		},

		clone: function(/*anything*/ src){
			// summary:
			//		Clones objects (including DOM nodes) and all children.
			//		Warning: do not clone cyclic structures.
			// src:
			//		The object to clone
			if(!src || typeof src != "object" || lang.isFunction(src)){
				// null, undefined, any non-object, or function
				return src;	// anything
			}
			if(src.nodeType && "cloneNode" in src){
				// DOM Node
				return src.cloneNode(true); // Node
			}
			if(src instanceof Date){
				// Date
				return new Date(src.getTime());	// Date
			}
			if(src instanceof RegExp){
				// RegExp
				return new RegExp(src);   // RegExp
			}
			var r, i, l;
			if(lang.isArray(src)){
				// array
				r = [];
				for(i = 0, l = src.length; i < l; ++i){
					if(i in src){
						r[i] = lang.clone(src[i]);
					}
				}
				// we don't clone functions for performance reasons
				//		}else if(d.isFunction(src)){
				//			// function
				//			r = function(){ return src.apply(this, arguments); };
			}else{
				// generic objects
				r = src.constructor ? new src.constructor() : {};
			}
			return lang._mixin(r, src, lang.clone);
		},


		trim: String.prototype.trim ?
			function(str){ return str.trim(); } :
			function(str){ return str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); },
		/*=====
		 trim: function(str){
			 // summary:
			 //		Trims whitespace from both sides of the string
			 // str: String
			 //		String to be trimmed
			 // returns: String
			 //		Returns the trimmed string
			 // description:
			 //		This version of trim() was selected for inclusion into the base due
			 //		to its compact size and relatively good performance
			 //		(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
			 //		Uses String.prototype.trim instead, if available.
			 //		The fastest but longest version of this function is located at
			 //		lang.string.trim()
		 },
		 =====*/

		replace: function(tmpl, map, pattern){
			// summary:
			//		Performs parameterized substitutions on a string. Throws an
			//		exception if any parameter is unmatched.
			// tmpl: String
			//		String to be used as a template.
			// map: Object|Function
			//		If an object, it is used as a dictionary to look up substitutions.
			//		If a function, it is called for every substitution with following parameters:
			//		a whole match, a name, an offset, and the whole template
			//		string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
			//		for more details).
			// pattern: RegEx?
			//		Optional regular expression objects that overrides the default pattern.
			//		Must be global and match one item. The default is: /\{([^\}]+)\}/g,
			//		which matches patterns like that: "{xxx}", where "xxx" is any sequence
			//		of characters, which doesn't include "}".
			// returns: String
			//		Returns the substituted string.
			// example:
			//	|	// uses a dictionary for substitutions:
			//	|	lang.replace("Hello, {name.first} {name.last} AKA {nick}!",
			//	|		{
			//	|			nick: "Bob",
			//	|			name: {
			//	|				first:	"Robert",
			//	|				middle: "X",
			//	|				last:		"Cringely"
			//	|			}
			//	|		});
			//	|	// returns: Hello, Robert Cringely AKA Bob!
			// example:
			//	|	// uses an array for substitutions:
			//	|	lang.replace("Hello, {0} {2}!",
			//	|		["Robert", "X", "Cringely"]);
			//	|	// returns: Hello, Robert Cringely!
			// example:
			//	|	// uses a function for substitutions:
			//	|	function sum(a){
			//	|		var t = 0;
			//	|		arrayforEach(a, function(x){ t += x; });
			//	|		return t;
			//	|	}
			//	|	lang.replace(
			//	|		"{count} payments averaging {avg} USD per payment.",
			//	|		lang.hitch(
			//	|			{ payments: [11, 16, 12] },
			//	|			function(_, key){
			//	|				switch(key){
			//	|					case "count": return this.payments.length;
			//	|					case "min":		return Math.min.apply(Math, this.payments);
			//	|					case "max":		return Math.max.apply(Math, this.payments);
			//	|					case "sum":		return sum(this.payments);
			//	|					case "avg":		return sum(this.payments) / this.payments.length;
			//	|				}
			//	|			}
			//	|		)
			//	|	);
			//	|	// prints: 3 payments averaging 13 USD per payment.
			// example:
			//	|	// uses an alternative PHP-like pattern for substitutions:
			//	|	lang.replace("Hello, ${0} ${2}!",
			//	|		["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
			//	|	// returns: Hello, Robert Cringely!

			return tmpl.replace(pattern || _pattern, lang.isFunction(map) ?
				map : function(_, k){ return lang.getObject(k, false, map); });
		}
	};

	has("extend-dojo") && lang.mixin(dojo, lang);

	return lang;
});

define('dojo/_base/declare',["./kernel", "../has", "./lang"], function(dojo, has, lang){
	// module:
	//		dojo/_base/declare

	var mix = lang.mixin, op = Object.prototype, opts = op.toString,
		xtor, counter = 0, cname = "constructor";

	if(!has("csp-restrictions")){
		xtor = new Function;
	}else{
		xtor = function(){};
	}

	function err(msg, cls){ throw new Error("declare" + (cls ? " " + cls : "") + ": " + msg); }

	// C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)
	function c3mro(bases, className){
		var result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,
			l = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;

		// build a list of bases naming them if needed
		for(; i < l; ++i){
			base = bases[i];
			if(!base){
				err("mixin #" + i + " is unknown. Did you use dojo.require to pull it in?", className);
			}else if(opts.call(base) != "[object Function]"){
				err("mixin #" + i + " is not a callable constructor.", className);
			}
			lin = base._meta ? base._meta.bases : [base];
			top = 0;
			// add bases to the name map
			for(j = lin.length - 1; j >= 0; --j){
				proto = lin[j].prototype;
				if(!proto.hasOwnProperty("declaredClass")){
					proto.declaredClass = "uniqName_" + (counter++);
				}
				name = proto.declaredClass;
				if(!nameMap.hasOwnProperty(name)){
					nameMap[name] = {count: 0, refs: [], cls: lin[j]};
					++clsCount;
				}
				rec = nameMap[name];
				if(top && top !== rec){
					rec.refs.push(top);
					++top.count;
				}
				top = rec;
			}
			++top.count;
			roots[0].refs.push(top);
		}

		// remove classes without external references recursively
		while(roots.length){
			top = roots.pop();
			result.push(top.cls);
			--clsCount;
			// optimization: follow a single-linked chain
			while(refs = top.refs, refs.length == 1){
				top = refs[0];
				if(!top || --top.count){
					// branch or end of chain => do not end to roots
					top = 0;
					break;
				}
				result.push(top.cls);
				--clsCount;
			}
			if(top){
				// branch
				for(i = 0, l = refs.length; i < l; ++i){
					top = refs[i];
					if(!--top.count){
						roots.push(top);
					}
				}
			}
		}
		if(clsCount){
			err("can't build consistent linearization", className);
		}

		// calculate the superclass offset
		base = bases[0];
		result[0] = base ?
			base._meta && base === result[result.length - base._meta.bases.length] ?
				base._meta.bases.length : 1 : 0;

		return result;
	}

	function inherited(args, a, f){
		var name, chains, bases, caller, meta, base, proto, opf, pos,
			cache = this._inherited = this._inherited || {};

		// crack arguments
		if(typeof args == "string"){
			name = args;
			args = a;
			a = f;
		}
		f = 0;

		caller = args.callee;
		name = name || caller.nom;
		if(!name){
			err("can't deduce a name to call inherited()", this.declaredClass);
		}

		meta = this.constructor._meta;
		bases = meta.bases;

		pos = cache.p;
		if(name != cname){
			// method
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				base = bases[0];
				meta = base._meta;
				if(meta.hidden[name] !== caller){
					// error detection
					chains = meta.chains;
					if(chains && typeof chains[name] == "string"){
						err("calling chained method with inherited: " + name, this.declaredClass);
					}
					// find caller
					do{
						meta = base._meta;
						proto = base.prototype;
						if(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
					pos = base ? pos : -1;
				}
			}
			// find next
			base = bases[++pos];
			if(base){
				proto = base.prototype;
				if(base._meta && proto.hasOwnProperty(name)){
					f = proto[name];
				}else{
					opf = op[name];
					do{
						proto = base.prototype;
						f = proto[name];
						if(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
				}
			}
			f = base && f || op[name];
		}else{
			// constructor
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				meta = bases[0]._meta;
				if(meta && meta.ctor !== caller){
					// error detection
					chains = meta.chains;
					if(!chains || chains.constructor !== "manual"){
						err("calling chained constructor with inherited", this.declaredClass);
					}
					// find caller
					while(base = bases[++pos]){ // intentional assignment
						meta = base._meta;
						if(meta && meta.ctor === caller){
							break;
						}
					}
					pos = base ? pos : -1;
				}
			}
			// find next
			while(base = bases[++pos]){	// intentional assignment
				meta = base._meta;
				f = meta ? meta.ctor : base;
				if(f){
					break;
				}
			}
			f = base && f;
		}

		// cache the found super method
		cache.c = f;
		cache.p = pos;

		// now we have the result
		if(f){
			return a === true ? f : f.apply(this, a || args);
		}
		// intentionally no return if a super method was not found
	}

	function getInherited(name, args){
		if(typeof name == "string"){
			return this.__inherited(name, args, true);
		}
		return this.__inherited(name, true);
	}

	function inherited__debug(args, a1, a2){
		var f = this.getInherited(args, a1);
		if(f){ return f.apply(this, a2 || a1 || args); }
		// intentionally no return if a super method was not found
	}

	var inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;

	// emulation of "instanceof"
	function isInstanceOf(cls){
		var bases = this.constructor._meta.bases;
		for(var i = 0, l = bases.length; i < l; ++i){
			if(bases[i] === cls){
				return true;
			}
		}
		return this instanceof cls;
	}

	function mixOwn(target, source){
		// add props adding metadata for incoming functions skipping a constructor
		for(var name in source){
			if(name != cname && source.hasOwnProperty(name)){
				target[name] = source[name];
			}
		}
		if(has("bug-for-in-skips-shadowed")){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				if(name != cname && source.hasOwnProperty(name)){
					  target[name] = source[name];
				}
			}
		}
	}

	// implementation of safe mixin function
	function safeMixin(target, source){
		// summary:
		//		Mix in properties skipping a constructor and decorating functions
		//		like it is done by declare().
		// target: Object
		//		Target object to accept new properties.
		// source: Object
		//		Source object for new properties.
		// description:
		//		This function is used to mix in properties like lang.mixin does,
		//		but it skips a constructor property and decorates functions like
		//		declare() does.
		//
		//		It is meant to be used with classes and objects produced with
		//		declare. Functions mixed in with dojo.safeMixin can use
		//		this.inherited() like normal methods.
		//
		//		This function is used to implement extend() method of a constructor
		//		produced with declare().
		//
		// example:
		//	|	var A = declare(null, {
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m1");
		//	|		}
		//	|	});
		//	|	B.extend({
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	dojo.safeMixin(x, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m1");
		//	|		},
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m2");
		//	|		}
		//	|	});
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m1
		//	|	// B.m1
		//	|	// X.m1

		var name, t;
		// add props adding metadata for incoming functions skipping a constructor
		for(name in source){
			t = source[name];
			if((t !== op[name] || !(name in op)) && name != cname){
				if(opts.call(t) == "[object Function]"){
					// non-trivial function method => attach its name
					t.nom = name;
				}
				target[name] = t;
			}
		}
		if(has("bug-for-in-skips-shadowed") && source){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				t = source[name];
				if((t !== op[name] || !(name in op)) && name != cname){
					if(opts.call(t) == "[object Function]"){
						// non-trivial function method => attach its name
						  t.nom = name;
					}
					target[name] = t;
				}
			}
		}
		return target;
	}

	function extend(source){
		declare.safeMixin(this.prototype, source);
		return this;
	}

    function createSubclass(mixins, props){
        // crack parameters
        if(!(mixins instanceof Array || typeof mixins == 'function')){
            props = mixins;
            mixins = undefined;
        }

        props = props || {};
        mixins = mixins || [];

        return declare([this].concat(mixins), props);
    }

	// chained constructor compatible with the legacy declare()
	function chainedConstructor(bases, ctorSpecial){
		return function(){
			var a = arguments, args = a, a0 = a[0], f, i, m,
				l = bases.length, preArgs;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial && (a0 && a0.preamble || this.preamble)){
				// full blown ritual
				preArgs = new Array(bases.length);
				// prepare parameters
				preArgs[0] = a;
				for(i = 0;;){
					// process the preamble of the 1st argument
					a0 = a[0];
					if(a0){
						f = a0.preamble;
						if(f){
							a = f.apply(this, a) || a;
						}
					}
					// process the preamble of this class
					f = bases[i].prototype;
					f = f.hasOwnProperty("preamble") && f.preamble;
					if(f){
						a = f.apply(this, a) || a;
					}
					// one peculiarity of the preamble:
					// it is called if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
					if(++i == l){
						break;
					}
					preArgs[i] = a;
				}
			}
			// 2) call all non-trivial constructors using prepared arguments
			for(i = l - 1; i >= 0; --i){
				f = bases[i];
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, preArgs ? preArgs[i] : a);
				}
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, args);
			}
		};
	}


	// chained constructor compatible with the legacy declare()
	function singleConstructor(ctor, ctorSpecial){
		return function(){
			var a = arguments, t = a, a0 = a[0], f;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial){
				// full blown ritual
				if(a0){
					// process the preamble of the 1st argument
					f = a0.preamble;
					if(f){
						t = f.apply(this, t) || t;
					}
				}
				f = this.preamble;
				if(f){
					// process the preamble of this class
					f.apply(this, t);
					// one peculiarity of the preamble:
					// it is called even if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
				}
			}
			// 2) call a constructor
			if(ctor){
				ctor.apply(this, a);
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	// plain vanilla constructor (can use inherited() to call its base constructor)
	function simpleConstructor(bases){
		return function(){
			var a = arguments, i = 0, f, m;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) do not call the preamble
			// 2) call the top constructor (it can use this.inherited())
			for(; f = bases[i]; ++i){ // intentional assignment
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, a);
					break;
				}
			}
			// 3) call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	function chain(name, bases, reversed){
		return function(){
			var b, m, f, i = 0, step = 1;
			if(reversed){
				i = bases.length - 1;
				step = -1;
			}
			for(; b = bases[i]; i += step){ // intentional assignment
				m = b._meta;
				f = (m ? m.hidden : b.prototype)[name];
				if(f){
					f.apply(this, arguments);
				}
			}
		};
	}

	// forceNew(ctor)
	// return a new object that inherits from ctor.prototype but
	// without actually running ctor on the object.
	function forceNew(ctor){
		// create object with correct prototype using a do-nothing
		// constructor
		xtor.prototype = ctor.prototype;
		var t = new xtor;
		xtor.prototype = null;	// clean up
		return t;
	}

	// applyNew(args)
	// just like 'new ctor()' except that the constructor and its arguments come
	// from args, which must be an array or an arguments object
	function applyNew(args){
		// create an object with ctor's prototype but without
		// calling ctor on it.
		var ctor = args.callee, t = forceNew(ctor);
		// execute the real constructor on the new object
		ctor.apply(t, args);
		return t;
	}

	function declare(className, superclass, props){
		// summary:
		//		Create a feature-rich constructor from compact notation.
		// className: String?
		//		The optional name of the constructor (loosely, a "class")
		//		stored in the "declaredClass" property in the created prototype.
		//		It will be used as a global name for a created constructor.
		// superclass: Function|Function[]
		//		May be null, a Function, or an Array of Functions. This argument
		//		specifies a list of bases (the left-most one is the most deepest
		//		base).
		// props: Object
		//		An object whose properties are copied to the created prototype.
		//		Add an instance-initialization function by making it a property
		//		named "constructor".
		// returns: dojo/_base/declare.__DeclareCreatedObject
		//		New constructor function.
		// description:
		//		Create a constructor using a compact notation for inheritance and
		//		prototype extension.
		//
		//		Mixin ancestors provide a type of multiple inheritance.
		//		Prototypes of mixin ancestors are copied to the new class:
		//		changes to mixin prototypes will not affect classes to which
		//		they have been mixed in.
		//
		//		Ancestors can be compound classes created by this version of
		//		declare(). In complex cases all base classes are going to be
		//		linearized according to C3 MRO algorithm
		//		(see http://www.python.org/download/releases/2.3/mro/ for more
		//		details).
		//
		//		"className" is cached in "declaredClass" property of the new class,
		//		if it was supplied. The immediate super class will be cached in
		//		"superclass" property of the new class.
		//
		//		Methods in "props" will be copied and modified: "nom" property
		//		(the declared name of the method) will be added to all copied
		//		functions to help identify them for the internal machinery. Be
		//		very careful, while reusing methods: if you use the same
		//		function under different names, it can produce errors in some
		//		cases.
		//
		//		It is possible to use constructors created "manually" (without
		//		declare()) as bases. They will be called as usual during the
		//		creation of an instance, their methods will be chained, and even
		//		called by "this.inherited()".
		//
		//		Special property "-chains-" governs how to chain methods. It is
		//		a dictionary, which uses method names as keys, and hint strings
		//		as values. If a hint string is "after", this method will be
		//		called after methods of its base classes. If a hint string is
		//		"before", this method will be called before methods of its base
		//		classes.
		//
		//		If "constructor" is not mentioned in "-chains-" property, it will
		//		be chained using the legacy mode: using "after" chaining,
		//		calling preamble() method before each constructor, if available,
		//		and calling postscript() after all constructors were executed.
		//		If the hint is "after", it is chained as a regular method, but
		//		postscript() will be called after the chain of constructors.
		//		"constructor" cannot be chained "before", but it allows
		//		a special hint string: "manual", which means that constructors
		//		are not going to be chained in any way, and programmer will call
		//		them manually using this.inherited(). In the latter case
		//		postscript() will be called after the construction.
		//
		//		All chaining hints are "inherited" from base classes and
		//		potentially can be overridden. Be very careful when overriding
		//		hints! Make sure that all chained methods can work in a proposed
		//		manner of chaining.
		//
		//		Once a method was chained, it is impossible to unchain it. The
		//		only exception is "constructor". You don't need to define a
		//		method in order to supply a chaining hint.
		//
		//		If a method is chained, it cannot use this.inherited() because
		//		all other methods in the hierarchy will be called automatically.
		//
		//		Usually constructors and initializers of any kind are chained
		//		using "after" and destructors of any kind are chained as
		//		"before". Note that chaining assumes that chained methods do not
		//		return any value: any returned value will be discarded.
		//
		// example:
		//	|	declare("my.classes.bar", my.classes.foo, {
		//	|		// properties to be added to the class prototype
		//	|		someValue: 2,
		//	|		// initialization function
		//	|		constructor: function(){
		//	|			this.myComplicatedObject = new ReallyComplicatedObject();
		//	|		},
		//	|		// other functions
		//	|		someMethod: function(){
		//	|			doStuff();
		//	|		}
		//	|	});
		//
		// example:
		//	|	var MyBase = declare(null, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass1 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass2 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyDiamond = declare([MyClass1, MyClass2], {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//
		// example:
		//	|	var F = function(){ console.log("raw constructor"); };
		//	|	F.prototype.method = function(){
		//	|		console.log("raw method");
		//	|	};
		//	|	var A = declare(F, {
		//	|		constructor: function(){
		//	|			console.log("A.constructor");
		//	|		},
		//	|		method: function(){
		//	|			console.log("before calling F.method...");
		//	|			this.inherited(arguments);
		//	|			console.log("...back in A");
		//	|		}
		//	|	});
		//	|	new A().method();
		//	|	// will print:
		//	|	// raw constructor
		//	|	// A.constructor
		//	|	// before calling F.method...
		//	|	// raw method
		//	|	// ...back in A
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			destroy: "before"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			console.log("B.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("B.destroy");
		//	|		}
		//	|	});
		//	|	var C = declare(B, {
		//	|		constructor: function(){
		//	|			console.log("C.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("C.destroy");
		//	|		}
		//	|	});
		//	|	new C().destroy();
		//	|	// prints:
		//	|	// B.constructor
		//	|	// C.constructor
		//	|	// C.destroy
		//	|	// B.destroy
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			constructor: "manual"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			// ...
		//	|			// call the base constructor with new parameters
		//	|			this.inherited(arguments, [1, 2, 3]);
		//	|			// ...
		//	|		}
		//	|	});
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			m1: "before"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		"-chains-": {
		//	|			m2: "after"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("B.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	x.m1();
		//	|	// prints:
		//	|	// B.m1
		//	|	// A.m1
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m2
		//	|	// B.m2

		// crack parameters
		if(typeof className != "string"){
			props = superclass;
			superclass = className;
			className = "";
		}
		props = props || {};

		var proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;

		// build a prototype
		if(opts.call(superclass) == "[object Array]"){
			// C3 MRO
			bases = c3mro(superclass, className);
			t = bases[0];
			mixins = bases.length - t;
			superclass = bases[mixins];
		}else{
			bases = [0];
			if(superclass){
				if(opts.call(superclass) == "[object Function]"){
					t = superclass._meta;
					bases = bases.concat(t ? t.bases : superclass);
				}else{
					err("base class is not a callable constructor.", className);
				}
			}else if(superclass !== null){
				err("unknown base class. Did you use dojo.require to pull it in?", className);
			}
		}
		if(superclass){
			for(i = mixins - 1;; --i){
				proto = forceNew(superclass);
				if(!i){
					// stop if nothing to add (the last base)
					break;
				}
				// mix in properties
				t = bases[i];
				(t._meta ? mixOwn : mix)(proto, t.prototype);
				// chain in new constructor
				ctor = new Function;
				ctor.superclass = superclass;
				ctor.prototype = proto;
				superclass = proto.constructor = ctor;
			}
		}else{
			proto = {};
		}
		// add all properties
		declare.safeMixin(proto, props);
		// add constructor
		t = props.constructor;
		if(t !== op.constructor){
			t.nom = cname;
			proto.constructor = t;
		}

		// collect chains and flags
		for(i = mixins - 1; i; --i){ // intentional assignment
			t = bases[i]._meta;
			if(t && t.chains){
				chains = mix(chains || {}, t.chains);
			}
		}
		if(proto["-chains-"]){
			chains = mix(chains || {}, proto["-chains-"]);
		}

		// build ctor
		t = !chains || !chains.hasOwnProperty(cname);
		bases[0] = ctor = (chains && chains.constructor === "manual") ? simpleConstructor(bases) :
			(bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));

		// add meta information to the constructor
		ctor._meta  = {bases: bases, hidden: props, chains: chains,
			parents: parents, ctor: props.constructor};
		ctor.superclass = superclass && superclass.prototype;
		ctor.extend = extend;
		ctor.createSubclass = createSubclass;
		ctor.prototype = proto;
		proto.constructor = ctor;

		// add "standard" methods to the prototype
		proto.getInherited = getInherited;
		proto.isInstanceOf = isInstanceOf;
		proto.inherited    = inheritedImpl;
		proto.__inherited  = inherited;

		// add name if specified
		if(className){
			proto.declaredClass = className;
			lang.setObject(className, ctor);
		}

		// build chains and add them to the prototype
		if(chains){
			for(name in chains){
				if(proto[name] && typeof chains[name] == "string" && name != cname){
					t = proto[name] = chain(name, bases, chains[name] === "after");
					t.nom = name;
				}
			}
		}
		// chained methods do not return values
		// no need to chain "invisible" functions

		return ctor;	// Function
	}

	/*=====
	declare.__DeclareCreatedObject = {
		// summary:
		//		dojo/_base/declare() returns a constructor `C`.   `new C()` returns an Object with the following
		//		methods, in addition to the methods and properties specified via the arguments passed to declare().

		inherited: function(name, args, newArgs){
			// summary:
			//		Calls a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// newArgs: Object?
			//		If "true", the found function will be returned without
			//		executing it.
			//		If Array, it will be used to call a super method. Otherwise
			//		"args" will be used.
			// returns:
			//		Whatever is returned by a super method, or a super method itself,
			//		if "true" was specified as newArgs.
			// description:
			//		This method is used inside method of classes produced with
			//		declare() to call a super method (next in the chain). It is
			//		used for manually controlled chaining. Consider using the regular
			//		chaining, because it is faster. Use "this.inherited()" only in
			//		complex cases.
			//
			//		This method cannot me called from automatically chained
			//		constructors including the case of a special (legacy)
			//		constructor chaining. It cannot be called from chained methods.
			//
			//		If "this.inherited()" cannot find the next-in-chain method, it
			//		does nothing and returns "undefined". The last method in chain
			//		can be a default method implemented in Object, which will be
			//		called last.
			//
			//		If "name" is specified, it is assumed that the method that
			//		received "args" is the parent method for this call. It is looked
			//		up in the chain list and if it is found the next-in-chain method
			//		is called. If it is not found, the first-in-chain method is
			//		called.
			//
			//		If "name" is not specified, it will be derived from the calling
			//		method (using a methoid property "nom").
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method1: function(a, b, c){
			//	|			this.inherited(arguments);
			//	|		},
			//	|		method2: function(a, b){
			//	|			return this.inherited(arguments, [a + b]);
			//	|		}
			//	|	});
			//	|	// next method is not in the chain list because it is added
			//	|	// manually after the class was created.
			//	|	B.prototype.method3 = function(){
			//	|		console.log("This is a dynamically-added method.");
			//	|		this.inherited("method3", arguments);
			//	|	};
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.inherited(arguments, true);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			return	{};	// Object
		},

		getInherited: function(name, args){
			// summary:
			//		Returns a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// returns:
			//		Returns a super method (Function) or "undefined".
			// description:
			//		This method is a convenience method for "this.inherited()".
			//		It uses the same algorithm but instead of executing a super
			//		method, it returns it, or "undefined" if not found.
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.getInherited(arguments);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			return	{};	// Object
		},

		isInstanceOf: function(cls){
			// summary:
			//		Checks the inheritance chain to see if it is inherited from this
			//		class.
			// cls: Function
			//		Class constructor.
			// returns:
			//		"true", if this object is inherited from this class, "false"
			//		otherwise.
			// description:
			//		This method is used with instances of classes produced with
			//		declare() to determine of they support a certain interface or
			//		not. It models "instanceof" operator.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var B = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var C = declare([A, B], {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var D = declare(A, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|
			//	|	var a = new A(), b = new B(), c = new C(), d = new D();
			//	|
			//	|	console.log(a.isInstanceOf(A)); // true
			//	|	console.log(b.isInstanceOf(A)); // false
			//	|	console.log(c.isInstanceOf(A)); // true
			//	|	console.log(d.isInstanceOf(A)); // true
			//	|
			//	|	console.log(a.isInstanceOf(B)); // false
			//	|	console.log(b.isInstanceOf(B)); // true
			//	|	console.log(c.isInstanceOf(B)); // true
			//	|	console.log(d.isInstanceOf(B)); // false
			//	|
			//	|	console.log(a.isInstanceOf(C)); // false
			//	|	console.log(b.isInstanceOf(C)); // false
			//	|	console.log(c.isInstanceOf(C)); // true
			//	|	console.log(d.isInstanceOf(C)); // false
			//	|
			//	|	console.log(a.isInstanceOf(D)); // false
			//	|	console.log(b.isInstanceOf(D)); // false
			//	|	console.log(c.isInstanceOf(D)); // false
			//	|	console.log(d.isInstanceOf(D)); // true
			return	{};	// Object
		},

		extend: function(source){
			// summary:
			//		Adds all properties and methods of source to constructor's
			//		prototype, making them available to all instances created with
			//		constructor. This method is specific to constructors created with
			//		declare().
			// source: Object
			//		Source object which properties are going to be copied to the
			//		constructor's prototype.
			// description:
			//		Adds source properties to the constructor's prototype. It can
			//		override existing properties.
			//
			//		This method is similar to dojo.extend function, but it is specific
			//		to constructors produced by declare(). It is implemented
			//		using dojo.safeMixin, and it skips a constructor property,
			//		and properly decorates copied functions.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "Popokatepetl"
			//	|	});
			//	|	A.extend({
			//	|		m1: function(){},
			//	|		m2: function(){},
			//	|		f1: true,
			//	|		d1: 42
			//	|	});
		},

		createSubclass: function(mixins, props){
			// summary:
			//		Create a subclass of the declared class from a list of base classes.
			// mixins: Function[]
			//		Specifies a list of bases (the left-most one is the most deepest
			//		base).
			// props: Object?
			//		An optional object whose properties are copied to the created prototype.
			// returns: dojo/_base/declare.__DeclareCreatedObject
			//		New constructor function.
			// description:
			//		Create a constructor using a compact notation for inheritance and
			//		prototype extension.
			//
			//		Mixin ancestors provide a type of multiple inheritance.
			//		Prototypes of mixin ancestors are copied to the new class:
			//		changes to mixin prototypes will not affect classes to which
			//		they have been mixed in.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "bar"
			//	|	});
			//	|	var B = declare(null, {
			//	|		m2: function(){},
			//	|		s2: "foo"
			//	|	});
			//	|	var C = declare(null, {
			//	|	});
			//	|	var D1 = A.createSubclass([B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d1 = new D1();
			//	|
			//	|	// this is equivalent to:
			//	|	var D2 = declare([A, B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d2 = new D2();
		}
	};
	=====*/

	// For back-compat, remove for 2.0
	dojo.safeMixin = declare.safeMixin = safeMixin;
	dojo.declare = declare;

	return declare;
});

define('dojo/errors/create',["../_base/lang"], function(lang){
	return function(name, ctor, base, props){
		base = base || Error;

		var ErrorCtor = function(message){
			if(base === Error){
				if(Error.captureStackTrace){
					Error.captureStackTrace(this, ErrorCtor);
				}

				// Error.call() operates on the returned error
				// object rather than operating on |this|
				var err = Error.call(this, message),
					prop;

				// Copy own properties from err to |this|
				for(prop in err){
					if(err.hasOwnProperty(prop)){
						this[prop] = err[prop];
					}
				}

				// messsage is non-enumerable in ES5
				this.message = message;
				// stack is non-enumerable in at least Firefox
				this.stack = err.stack;
			}else{
				base.apply(this, arguments);
			}
			if(ctor){
				ctor.apply(this, arguments);
			}
		};

		ErrorCtor.prototype = lang.delegate(base.prototype, props);
		ErrorCtor.prototype.name = name;
		ErrorCtor.prototype.constructor = ErrorCtor;

		return ErrorCtor;
	};
});

define('dojo/errors/CancelError',["./create"], function(create){
	// module:
	//		dojo/errors/CancelError

	/*=====
	return function(){
		// summary:
		//		Default error if a promise is canceled without a reason.
	};
	=====*/

	return create("CancelError", null, null, { dojoType: "cancel" });
});

define('dojo/promise/Promise',[
	"../_base/lang"
], function(lang){
	"use strict";

	// module:
	//		dojo/promise/Promise

	function throwAbstract(){
		throw new TypeError("abstract");
	}

	return lang.extend(function Promise(){
		// summary:
		//		The public interface to a deferred.
		// description:
		//		The public interface to a deferred. All promises in Dojo are
		//		instances of this class.
	}, {
		then: function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the promise.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			throwAbstract();
		},

		cancel: function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			throwAbstract();
		},

		isResolved: function(){
			// summary:
			//		Checks whether the promise has been resolved.
			// returns: Boolean

			throwAbstract();
		},

		isRejected: function(){
			// summary:
			//		Checks whether the promise has been rejected.
			// returns: Boolean

			throwAbstract();
		},

		isFulfilled: function(){
			// summary:
			//		Checks whether the promise has been resolved or rejected.
			// returns: Boolean

			throwAbstract();
		},

		isCanceled: function(){
			// summary:
			//		Checks whether the promise has been canceled.
			// returns: Boolean

			throwAbstract();
		},

		always: function(callbackOrErrback){
			// summary:
			//		Add a callback to be invoked when the promise is resolved
			//		or rejected.
			// callbackOrErrback: Function?
			//		A function that is used both as a callback and errback.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback/errback.

			return this.then(callbackOrErrback, callbackOrErrback);
		},

		otherwise: function(errback){
			// summary:
			//		Add new errbacks to the promise.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the errback.

			return this.then(null, errback);
		},

		trace: function(){
			return this;
		},

		traceRejected: function(){
			return this;
		},

		toString: function(){
			// returns: string
			//		Returns `[object Promise]`.

			return "[object Promise]";
		}
	});
});


define('dojo/Deferred',[
	"./has",
	"./_base/lang",
	"./errors/CancelError",
	"./promise/Promise",
	"./has!config-deferredInstrumentation?./promise/instrumentation"
], function(has, lang, CancelError, Promise, instrumentation){
	"use strict";

	// module:
	//		dojo/Deferred

	var PROGRESS = 0,
			RESOLVED = 1,
			REJECTED = 2;
	var FULFILLED_ERROR_MESSAGE = "This deferred has already been fulfilled.";

	var freezeObject = Object.freeze || function(){};

	var signalWaiting = function(waiting, type, result, rejection, deferred){
		if(has("config-deferredInstrumentation")){
			if(type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){
				Deferred.instrumentRejected(result, false, rejection, deferred);
			}
		}

		for(var i = 0; i < waiting.length; i++){
			signalListener(waiting[i], type, result, rejection);
		}
	};

	var signalListener = function(listener, type, result, rejection){
		var func = listener[type];
		var deferred = listener.deferred;
		if(func){
			try{
				var newResult = func(result);
				if(type === PROGRESS){
					if(typeof newResult !== "undefined"){
						signalDeferred(deferred, type, newResult);
					}
				}else{
					if(newResult && typeof newResult.then === "function"){
						listener.cancel = newResult.cancel;
						newResult.then(
								// Only make resolvers if they're actually going to be used
								makeDeferredSignaler(deferred, RESOLVED),
								makeDeferredSignaler(deferred, REJECTED),
								makeDeferredSignaler(deferred, PROGRESS));
						return;
					}
					signalDeferred(deferred, RESOLVED, newResult);
				}
			}catch(error){
				signalDeferred(deferred, REJECTED, error);
			}
		}else{
			signalDeferred(deferred, type, result);
		}

		if(has("config-deferredInstrumentation")){
			if(type === REJECTED && Deferred.instrumentRejected){
				Deferred.instrumentRejected(result, !!func, rejection, deferred.promise);
			}
		}
	};

	var makeDeferredSignaler = function(deferred, type){
		return function(value){
			signalDeferred(deferred, type, value);
		};
	};

	var signalDeferred = function(deferred, type, result){
		if(!deferred.isCanceled()){
			switch(type){
				case PROGRESS:
					deferred.progress(result);
					break;
				case RESOLVED:
					deferred.resolve(result);
					break;
				case REJECTED:
					deferred.reject(result);
					break;
			}
		}
	};

	var Deferred = function(canceler){
		// summary:
		//		Creates a new deferred. This API is preferred over
		//		`dojo/_base/Deferred`.
		// description:
		//		Creates a new deferred, as an abstraction over (primarily)
		//		asynchronous operations. The deferred is the private interface
		//		that should not be returned to calling code. That's what the
		//		`promise` is for. See `dojo/promise/Promise`.
		// canceler: Function?
		//		Will be invoked if the deferred is canceled. The canceler
		//		receives the reason the deferred was canceled as its argument.
		//		The deferred is rejected with its return value, or a new
		//		`dojo/errors/CancelError` instance.

		// promise: dojo/promise/Promise
		//		The public promise object that clients can add callbacks to. 
		var promise = this.promise = new Promise();

		var deferred = this;
		var fulfilled, result, rejection;
		var canceled = false;
		var waiting = [];

		if(has("config-deferredInstrumentation") && Error.captureStackTrace){
			Error.captureStackTrace(deferred, Deferred);
			Error.captureStackTrace(promise, Deferred);
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fulfilled === RESOLVED;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fulfilled === REJECTED;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return !!fulfilled;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		this.progress = function(update, strict){
			// summary:
			//		Emit a progress update on the deferred.
			// description:
			//		Emit a progress update on the deferred. Progress updates
			//		can be used to communicate updates about the asynchronous
			//		operation before it has finished.
			// update: any
			//		The progress update. Passed to progbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently no progress can be emitted.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				signalWaiting(waiting, PROGRESS, update, null, deferred);
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.resolve = function(value, strict){
			// summary:
			//		Resolve the deferred.
			// description:
			//		Resolve the deferred, putting it in a success state.
			// value: any
			//		The result of the deferred. Passed to callbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be resolved.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				// Set fulfilled, store value. After signaling waiting listeners unset
				// waiting.
				signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		var reject = this.reject = function(error, strict){
			// summary:
			//		Reject the deferred.
			// description:
			//		Reject the deferred, putting it in an error state.
			// error: any
			//		The error result of the deferred. Passed to errbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be rejected.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				if(has("config-deferredInstrumentation") && Error.captureStackTrace){
					Error.captureStackTrace(rejection = {}, reject);
				}
				signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.then = promise.then = function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the deferred.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			var listener = [progback, callback, errback];
			// Ensure we cancel the promise we're waiting for, or if callback/errback
			// have returned a promise, cancel that one.
			listener.cancel = promise.cancel;
			listener.deferred = new Deferred(function(reason){
				// Check whether cancel is really available, returned promises are not
				// required to expose `cancel`
				return listener.cancel && listener.cancel(reason);
			});
			if(fulfilled && !waiting){
				signalListener(listener, fulfilled, result, rejection);
			}else{
				waiting.push(listener);
			}
			return listener.deferred.promise;
		};

		this.cancel = promise.cancel = function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			if(!fulfilled){
				// Cancel can be called even after the deferred is fulfilled
				if(canceler){
					var returnedReason = canceler(reason);
					reason = typeof returnedReason === "undefined" ? reason : returnedReason;
				}
				canceled = true;
				if(!fulfilled){
					// Allow canceler to provide its own reason, but fall back to a CancelError
					if(typeof reason === "undefined"){
						reason = new CancelError();
					}
					reject(reason);
					return reason;
				}else if(fulfilled === REJECTED && result === reason){
					return reason;
				}
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}
		};

		freezeObject(promise);
	};

	Deferred.prototype.toString = function(){
		// returns: String
		//		Returns `[object Deferred]`.

		return "[object Deferred]";
	};

	if(instrumentation){
		instrumentation(Deferred);
	}

	return Deferred;
});

define('xdojo/declare',[
    'dojo/_base/declare'
], function (declare) {
    return declare;
});
define('xdojo/has',[
    "requirejs-dplugins/has"
], function (has) {
    return has;
});
(function(factory){
	if(typeof define != "undefined"){
		define('dcl/mini',[], factory);
	}else if(typeof module != "undefined"){
		module.exports = factory();
	}else{
		dcl = factory();
	}
})(function(){

	"use strict";

	var counter = 0, cname = "constructor", pname = "prototype", empty = {}, mix;

	var registry = {};

	function dcl(superClass, props){
		var bases = [0], proto, base, ctor, meta, connectionMap,
			output, vector, superClasses, i, j = 0, n;



		if(superClass){
			if(superClass instanceof Array){
				// mixins: C3 MRO
				connectionMap = {};
				superClasses = superClass.slice(0).reverse();
				for(i = superClasses.length - 1; i >= 0; --i){
					base = superClasses[i];
					// pre-process a base
					// 1) add a unique id
					base._uniqueId = base._uniqueId || counter++;
					// 2) build a connection map and the base list
					if((proto = base._meta)){   // intentional assignment
						for(vector = proto.bases, j = vector.length - 1; j > 0; --j){
							n = vector[j]._uniqueId;
							connectionMap[n] = (connectionMap[n] || 0) + 1;
						}
						superClasses[i] = vector.slice(0);
					}else{
						superClasses[i] = [base];
					}
				}
				// build output
				output = {};
				c: while(superClasses.length){
					for(i = 0; i < superClasses.length; ++i){
						vector = superClasses[i];
						base = vector[0];
						n = base._uniqueId;
						if(!connectionMap[n]){
							if(!output[n]){
								bases.push(base);
								output[n] = 1;
							}
							vector.shift();
							if(vector.length){
								--connectionMap[vector[0]._uniqueId];
							}else{
								superClasses.splice(i, 1);
							}
							continue c;
						}
					}
					// error
					dcl._error("cycle", props, superClasses);
				}
				// calculate a base class
				superClass = superClass[0];
				j = bases.length - ((meta = superClass._meta) && superClass === bases[bases.length - (j = meta.bases.length)] ? j : 1) - 1; // intentional assignments
			}else{
				// 1) add a unique id
				superClass._uniqueId = superClass._uniqueId || counter++;
				// 2) single inheritance
				bases = bases.concat((meta = superClass._meta) ? meta.bases : superClass);   // intentional assignment
			}
		}
		// create a base class
		proto = superClass ? dcl.delegate(superClass[pname]) : {};
		// the next line assumes that constructor is actually named "constructor", should be changed if desired
		vector = superClass && (meta = superClass._meta) ? dcl.delegate(meta.weaver) : {constructor: 2};   // intentional assignment

		// create prototype: mix in mixins and props
		for(; j > 0; --j){
			base = bases[j];
			meta = base._meta;
			dcl.mix(proto, meta && meta.ownProps || base[pname]);
			if(meta){
				for(n in (superClasses = meta.weaver)){    // intentional assignment
					vector[n] = (+vector[n] || 0) | superClasses[n];
				}
			}
		}
		for(n in props){
			if(isSuper(meta = props[n])){  // intentional assignment
				vector[n] = +vector[n] || 0;
			}else{
				proto[n] = meta;
			}
		}

		// create stubs with fake constructor
		//
		meta = {bases: bases, ownProps: props, weaver: vector, chains: {}};
		// meta information is coded like that:
		// bases: an array of super classes (bases) and mixins
		// ownProps: a bag of immediate prototype properties for the constructor
		// weaver: a bag of chain instructions (before is 1, after is 2)
		// chains: a bag of chains (ordered arrays)

		bases[0] = {_meta: meta, prototype: proto};
		buildStubs(meta, proto);
		ctor = proto[cname];

		// put in place all decorations and return a constructor
		ctor._meta  = meta;
		ctor[pname] = proto;
		//proto.constructor = ctor; // uncomment if constructor is not named "constructor"
		bases[0] = ctor;

		// each constructor may have two properties on it:
		// _meta: a meta information object as above
		// _uniqueId: a unique number, which is used to id the constructor

		var result = dcl._postprocess(ctor);    // fully prepared constructor

		if(props.declaredClass){
			registry[props.declaredClass] = result;
		}

		return result;

	}

	// decorators

	function Super(f){ this.around = f; }
	function isSuper(f){ return f && f.spr instanceof Super; }

	// utilities

	function allKeys(o){
		var keys = [];
		for(var name in o){
			keys.push(name);
		}
		return keys;
	}

	(mix = function(a, b){
		for(var n in b){
			a[n] = b[n];
		}
	})(dcl, {
		// piblic API
		mix: mix,
		delegate: function(o){
			return Object.create(o);
		},
		allKeys: allKeys,
		Super: Super,
		superCall: function superCall(f){ return dcl._makeSuper(f); },

		// protected API starts with _ (don't use it!)

		// make a Super marker
		_makeSuper: function makeSuper(advice, S){ var f = function(){}; f.spr = new (S || Super)(advice); return f; },

		// post-processor for a constructor, can be used to add more functionality
		// or augment its behavior
		_postprocess: function(ctor){ return ctor; },   // identity, used to hang on advices

		// error function, augmented by debug.js
		_error: function(msg){ throw Error("dcl: " + msg); },

		// supercall instantiation, augmented by debug.js
		_instantiate: function(advice, previous, node){ var t = advice.spr.around(previous); t.ctr = advice.ctr; return t; },

		// the "buildStubs()" helpers, can be overwritten
		_extractChain: function(bases, name, advice){
			var i = bases.length - 1, chain = [], base, f, around = advice == "around";
			for(; base = bases[i]; --i){
				// next line contains 5 intentional assignments
				if((f = base._meta) ? (f = f.ownProps).hasOwnProperty(name) && (isSuper(f = f[name]) ? (around ? f.spr.around : (f = f.spr[advice])) : around) : around && (f = name == cname ? base : base[pname][name]) && f !== empty[name]){
					if(typeof f == "function"){
						f.ctr = base;
						chain.push(f);
					}else{
						dcl._error("wrong super", base, name);
					}
				}
			}
			return chain;
		},
		_stubChain: function(chain){ // this is "after" chain
			var l = chain.length, f;
			return !l ? 0 : l == 1 ?
				(f = chain[0], function(){
					f.apply(this, arguments);
				}) :
				function(){
					for(var i = 0; i < l; ++i){
						chain[i].apply(this, arguments);
					}
				};
		},
		_stubSuper: function(chain, name){
			var i = 0, f, p = empty[name];
			for(; f = chain[i]; ++i){
				p = isSuper(f) ? (chain[i] = dcl._instantiate(f, p, name)) : f;
			}
			return name != cname ? p : function(){ p.apply(this, arguments); };
		},
		_stubChainSuper: function(chain, stub, name){
			var i = 0, f, diff, pi = 0;
			for(; f = chain[i]; ++i){
				if(isSuper(f)){
					diff = i - pi;
					chain[i] = dcl._instantiate(f, !diff ? 0 : diff == 1 ? chain[pi] : stub(chain.slice(pi, i)), name);
					pi = i;
				}
			}
			diff = i - pi;
			return !diff ? 0 : diff == 1 && name != cname ? chain[pi] : stub(pi ? chain.slice(pi) : chain);
		},
		_stub: /*generic stub*/ function(id, bases, name, chains){
			var f = chains[name] = dcl._extractChain(bases, name, "around");
			return (id ? dcl._stubChainSuper(f, dcl._stubChain, name) : dcl._stubSuper(f, name)) || function(){};
		}
	});

	function buildStubs(meta, proto){
		var weaver = meta.weaver, bases = meta.bases, chains = meta.chains;
		for(var name in weaver){
			proto[name] = dcl._stub(weaver[name], bases, name, chains);
		}
	}

	dcl.getObject=function(classString){
		return registry[classString];
	}

	return dcl;
});

(function(factory){
	if(typeof define != "undefined"){
		define('dcl/dcl',["./mini"], factory);
	}else if(typeof module != "undefined"){
		module.exports = factory(require("./mini"));
	}else{
		dcl = factory(dcl);
	}
})(function(dcl){
	"use strict";

	function nop(){}

	var Advice = dcl(dcl.Super, {
		//declaredClass: "dcl.Advice",
		constructor: function(){
			this.before = this.around.before;
			this.after  = this.around.after;
			this.around = this.around.around;
		}
	});
	function advise(advice){ return dcl._makeSuper(advice, Advice); }

	function makeAOPStub(before, after, around){
		var beforeChain = before || nop,
			afterChain  = after  || nop,
			aroundChain = around || nop,
			stub = function(){
				var r, thrown;
				// running the before chain
				beforeChain.apply(this, arguments);
				// running the around chain
				try{
					r = aroundChain.apply(this, arguments);
				}catch(e){
					r = e;
					thrown = true;
				}
				// running the after chain
				afterChain.call(this, arguments, r);
				if(thrown){
					throw r;
				}
				return r;
			};
		stub.advices = {before: before, after: after, around: around};
		return stub;
	}

	function chain(id){
		return function(ctor, name){
			var meta = ctor._meta, rule;
			if(meta){
				rule = +meta.weaver[name] || 0;
				if(rule && rule != id){
					dcl._error("set chaining", name, ctor, id, rule);
				}
				meta.weaver[name] = id;
			}
		};
	}

	dcl.mix(dcl, {
		// public API
		Advice: Advice,
		advise: advise,
		// expose helper methods
		before: function(f){ return dcl.advise({before: f}); },
		after:  function(f){ return dcl.advise({after:  f}); },
		around: dcl.superCall,
		// chains
		chainBefore: chain(1),
		chainAfter:  chain(2),
		isInstanceOf: function(o, ctor){
			if(o instanceof ctor){
				return true;
			}
			var t = o.constructor._meta, i;
			if(t){
				for(t = t.bases, i = t.length - 1; i >= 0; --i){
					if(t[i] === ctor){
						return true;
					}
				}
			}
			return false;
		},
		// protected API starts with _ (don't use it!)
		_stub: /*generic stub*/ function(id, bases, name, chains){
			var f = chains[name] = dcl._extractChain(bases, name, "around"),
				b = dcl._extractChain(bases, name, "before").reverse(),
				a = dcl._extractChain(bases, name, "after");
			f = id ? dcl._stubChainSuper(f, id == 1 ? function(f){ return dcl._stubChain(f.reverse()); } : dcl._stubChain, name) : dcl._stubSuper(f, name);
			return !b.length && !a.length ? f || function(){} : makeAOPStub(dcl._stubChain(b), dcl._stubChain(a), f);
		}
	});

	return dcl;
});

(function(factory){
	if(typeof define != "undefined"){
		define('dcl/advise',[], factory);
	}else if(typeof module != "undefined"){
		module.exports = factory();
	}else{
		advise = factory();
	}
})(function(){
	"use strict";

	function Node(instance, name){
		this.next_before = this.prev_before = this.next_after = this.prev_after =
			this.next_around = this.prev_around = this;
		this.instance = instance;
		this.name = name;
	}
	var p = Node.prototype = {
		add: function(before, after, around, original){
			var node = new Node(this.instance, this.name);
			node.parent = this;
			node.before = before;
			this._add("before", node);
			node.after = after;
			this._add("after", node);
			node.around = around;
			this._add("around", node, original);
			node.original = original;
			if(original){ node.around = advise._instantiate(original, node.prev_around.around, this); }
			return node;
		},
		_add: function(topic, node, flag){
			if(node[topic] || flag){
				var n = "next_" + topic, p = "prev_" + topic;
				(node[p] = this[p])[n] = (node[n] = this)[p] = node;
			}
		},
		remove: function(node){
			this._remove("before", node);
			this._remove("after",  node);
			this._remove("around", node);
		},
		_remove: function(topic, node){
			var n = "next_" + topic, p = "prev_" + topic;
			node[n][p] = node[p];
			node[p][n] = node[n];
		},
		destroy: function(){
			var around = this.prev_around.around, t = this.next_around, parent = this.parent;
			this.remove(this);
			if(t !== this){
				for(; t !== parent; around = t.around, t = t.next_around){
					if(t.original){
						t.around = advise._instantiate(t.original, around, this);
					}
				}
			}
			this.instance = 0;
		}
	};
	p.unadvise = p.destroy;   // alias

	function makeAOPStub(node){
		var f = function(){
			var p, r, t = this, a = arguments, thrown;
			// running the before chain
			for(p = node.prev_before; p !== node; p = p.prev_before){
				p.before.apply(t, a);
			}
			// running the around chain
			try{
				if(node.prev_around !== node){ r = node.prev_around.around.apply(t, a); }
			}catch(e){
				r = e;
				thrown = true;
			}
			// running the after chain
			for(p = node.next_after; p !== node; p = p.next_after){
				p.after.call(t, a, r);
			}
			if(thrown){
				throw r;
			}
			return r;
		};
		f.adviceNode = node;
		return f;
	}

	function advise(instance, name, advice){
		var f = instance[name], node;
		if(f && f.adviceNode && f.adviceNode instanceof Node){
			node = f.adviceNode;
		}else{
			node = new Node(instance, name);
			if(f && f.advices){
				f = f.advices;
				node.add(f.before, f.after, f.around);
			}else{
				node.add(0, 0, f);
			}
			instance[name] = makeAOPStub(node);
		}
		if(typeof advice == "function"){ advice = advice(name, instance); }
		return node.add(advice.before, advice.after, 0, advice.around);
	}

	advise.before = function(instance, name, f){ return advise(instance, name, {before: f}); };
	advise.after  = function(instance, name, f){ return advise(instance, name, {after:  f}); };
	advise.around = function(instance, name, f){ return advise(instance, name, {around: f}); };
	advise.Node = Node;

	advise._instantiate = function(advice, previous, node){ return advice(previous); };

	return advise;
});

define('dojo/_base/array',["./kernel", "../has", "./lang"], function(dojo, has, lang){
	// module:
	//		dojo/_base/array

	// our old simple function builder stuff
	var cache = {}, u;

	function buildFn(fn){
		return cache[fn] = new Function("item", "index", "array", fn); // Function
	}
	// magic snippet: if(typeof fn == "string") fn = cache[fn] || buildFn(fn);

	// every & some

	function everyOrSome(some){
		var every = !some;
		return function(a, fn, o){
			var i = 0, l = a && a.length || 0, result;
			if(l && typeof a == "string") a = a.split("");
			if(typeof fn == "string") fn = cache[fn] || buildFn(fn);
			if(o){
				for(; i < l; ++i){
					result = !fn.call(o, a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}else{
				for(; i < l; ++i){
					result = !fn(a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}
			return every; // Boolean
		};
	}

	// indexOf, lastIndexOf

	function index(up){
		var delta = 1, lOver = 0, uOver = 0;
		if(!up){
			delta = lOver = uOver = -1;
		}
		return function(a, x, from, last){
			if(last && delta > 0){
				// TODO: why do we use a non-standard signature? why do we need "last"?
				return array.lastIndexOf(a, x, from);
			}
			var l = a && a.length || 0, end = up ? l + uOver : lOver, i;
			if(from === u){
				i = up ? lOver : l + uOver;
			}else{
				if(from < 0){
					i = l + from;
					if(i < 0){
						i = lOver;
					}
				}else{
					i = from >= l ? l + uOver : from;
				}
			}
			if(l && typeof a == "string") a = a.split("");
			for(; i != end; i += delta){
				if(a[i] == x){
					return i; // Number
				}
			}
			return -1; // Number
		};
	}

	var array = {
		// summary:
		//		The Javascript v1.6 array extensions.

		every: everyOrSome(false),
		/*=====
		 every: function(arr, callback, thisObject){
			 // summary:
			 //		Determines whether or not every item in arr satisfies the
			 //		condition implemented by callback.
			 // arr: Array|String
			 //		the array to iterate on. If a string, operates on individual characters.
			 // callback: Function|String
			 //		a function is invoked with three arguments: item, index,
			 //		and array and returns true if the condition is met.
			 // thisObject: Object?
			 //		may be used to scope the call to callback
			 // returns: Boolean
			 // description:
			 //		This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
			 //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			 //		the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
			 //		For more details, see:
			 //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
			 // example:
			 //	|	// returns false
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>1; });
			 // example:
			 //	|	// returns true
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>0; });
		 },
		 =====*/

		some: everyOrSome(true),
		/*=====
		some: function(arr, callback, thisObject){
			// summary:
			//		Determines whether or not any item in arr satisfies the
			//		condition implemented by callback.
			// arr: Array|String
			//		the array to iterate over. If a string, operates on individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments: item, index,
			//		and array and returns true if the condition is met.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Boolean
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
			// example:
			//	| // is true
			//	| array.some([1, 2, 3, 4], function(item){ return item>1; });
			// example:
			//	| // is false
			//	| array.some([1, 2, 3, 4], function(item){ return item<1; });
		},
		=====*/

		indexOf: index(true),
		/*=====
		indexOf: function(arr, value, fromIndex, findLast){
			// summary:
			//		locates the first index of the provided value in the
			//		passed array. If the value is not found, -1 is returned.
			// description:
			//		This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
			//
			//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
			//		   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
			//		2. uses equality (==) rather than strict equality (===)
			//
			//		For details on this method, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
			// arr: Array
			// value: Object
			// fromIndex: Integer?
			// findLast: Boolean?
			//		Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
			// returns: Number
		},
		=====*/

		lastIndexOf: index(false),
		/*=====
		lastIndexOf: function(arr, value, fromIndex){
			// summary:
			//		locates the last index of the provided value in the passed
			//		array. If the value is not found, -1 is returned.
			// description:
		 	//		This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
		 	//
		 	//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
		 	//		   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
		 	//		2. uses equality (==) rather than strict equality (===)
		 	//
		 	//		For details on this method, see:
		 	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
			// arr: Array,
			// value: Object,
			// fromIndex: Integer?
			// returns: Number
		},
		=====*/

		forEach: function(arr, callback, thisObject){
			// summary:
			//		for every item in arr, callback is invoked. Return values are ignored.
			//		If you want to break out of the loop, consider using array.every() or array.some().
			//		forEach does not allow breaking out of the loop over the items in arr.
			// arr:
			//		the array to iterate over. If a string, operates on individual characters.
			// callback:
			//		a function is invoked with three arguments: item, index, and array
			// thisObject:
			//		may be used to scope the call to callback
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
			// example:
			//	| // log out all members of the array:
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item){
			//	|			console.log(item);
			//	|		}
			//	| );
			// example:
			//	| // log out the members and their indexes
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item, idx, arr){
			//	|			console.log(item, "at index:", idx);
			//	|		}
			//	| );
			// example:
			//	| // use a scoped object member as the callback
			//	|
			//	| var obj = {
			//	|		prefix: "logged via obj.callback:",
			//	|		callback: function(item){
			//	|			console.log(this.prefix, item);
			//	|		}
			//	| };
			//	|
			//	| // specifying the scope function executes the callback in that scope
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		obj.callback,
			//	|		obj
			//	| );
			//	|
			//	| // alternately, we can accomplish the same thing with lang.hitch()
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		lang.hitch(obj, "callback")
			//	| );
			// arr: Array|String
			// callback: Function|String
			// thisObject: Object?

			var i = 0, l = arr && arr.length || 0;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
                    if(!callback || typeof callback !=="function"){
                        console.error('array error');
                    }
					callback(arr[i], i, arr);
				}
			}
		},

		map: function(arr, callback, thisObject, Ctr){
			// summary:
			//		applies callback to each element of arr and returns
			//		an Array with the results
			// arr: Array|String
			//		the array to iterate on. If a string, operates on
			//		individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments, (item, index,
			//		array),	 and returns a value
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
			// example:
			//	| // returns [2, 3, 4, 5]
			//	| array.map([1, 2, 3, 4], function(item){ return item+1 });

			// TODO: why do we have a non-standard signature here? do we need "Ctr"?
			var i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					out[i] = callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					out[i] = callback(arr[i], i, arr);
				}
			}
			return out; // Array
		},

		filter: function(arr, callback, thisObject){
			// summary:
			//		Returns a new Array with those items from arr that match the
			//		condition implemented by callback.
			// arr: Array
			//		the array to iterate over.
			// callback: Function|String
			//		a function that is invoked with three arguments (item,
			//		index, array). The return of this function is expected to
			//		be a boolean which determines whether the passed-in item
			//		will be included in the returned array.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
			// example:
			//	| // returns [2, 3, 4]
			//	| array.filter([1, 2, 3, 4], function(item){ return item>1; });

			// TODO: do we need "Ctr" here like in map()?
			var i = 0, l = arr && arr.length || 0, out = [], value;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					value = arr[i];
					if(callback.call(thisObject, value, i, arr)){
						out.push(value);
					}
				}
			}else{
				for(; i < l; ++i){
					value = arr[i];
					if(callback(value, i, arr)){
						out.push(value);
					}
				}
			}
			return out; // Array
		},

		clearCache: function(){
			cache = {};
		}
	};


	has("extend-dojo") && lang.mixin(dojo, array);

	return array;
});

define('dojo/aspect',[], function(){

	// module:
	//		dojo/aspect

	"use strict";
	var undefined;
	function advise(dispatcher, type, advice, receiveArguments){
		var previous = dispatcher[type];
		var around = type == "around";
		var signal;
		if(around){
			var advised = advice(function(){
				return previous.advice(this, arguments);
			});
			signal = {
				remove: function(){
					if(advised){
						advised = dispatcher = advice = null;
					}
				},
				advice: function(target, args){
					return advised ?
						advised.apply(target, args) :  // called the advised function
						previous.advice(target, args); // cancelled, skip to next one
				}
			};
		}else{
			// create the remove handler
			signal = {
				remove: function(){
					if(signal.advice){
						var previous = signal.previous;
						var next = signal.next;
						if(!next && !previous){
							delete dispatcher[type];
						}else{
							if(previous){
								previous.next = next;
							}else{
								dispatcher[type] = next;
							}
							if(next){
								next.previous = previous;
							}
						}

						// remove the advice to signal that this signal has been removed
						dispatcher = advice = signal.advice = null;
					}
				},
				id: dispatcher.nextId++,
				advice: advice,
				receiveArguments: receiveArguments
			};
		}
		if(previous && !around){
			if(type == "after"){
				// add the listener to the end of the list
				// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
				while(previous.next && (previous = previous.next)){}
				previous.next = signal;
				signal.previous = previous;
			}else if(type == "before"){
				// add to beginning
				dispatcher[type] = signal;
				signal.next = previous;
				previous.previous = signal;
			}
		}else{
			// around or first one just replaces
			dispatcher[type] = signal;
		}
		return signal;
	}
	function aspect(type){
		return function(target, methodName, advice, receiveArguments){
			var existing = target[methodName], dispatcher;
			if(!existing || existing.target != target){
				// no dispatcher in place
				target[methodName] = dispatcher = function(){
					var executionId = dispatcher.nextId;
					// before advice
					var args = arguments;
					var before = dispatcher.before;
					while(before){
						if(before.advice){
							args = before.advice.apply(this, args) || args;
						}
						before = before.next;
					}
					// around advice
					if(dispatcher.around){
						var results = dispatcher.around.advice(this, args);
					}
					// after advice
					var after = dispatcher.after;
					while(after && after.id < executionId){
						if(after.advice){
							if(after.receiveArguments){
								var newResults = after.advice.apply(this, args);
								// change the return value only if a new value was returned
								results = newResults === undefined ? results : newResults;
							}else{
								results = after.advice.call(this, results, args);
							}
						}
						after = after.next;
					}
					return results;
				};
				if(existing){
					dispatcher.around = {advice: function(target, args){
						return existing.apply(target, args);
					}};
				}
				dispatcher.target = target;
				dispatcher.nextId = dispatcher.nextId || 0;
			}
			var results = advise((dispatcher || existing), type, advice, receiveArguments);
			advice = null;
			return results;
		};
	}

	// TODOC: after/before/around return object

	var after = aspect("after");
	/*=====
	after = function(target, methodName, advice, receiveArguments){
		// summary:
		//		The "after" export of the aspect module is a function that can be used to attach
		//		"after" advice to a method. This function will be executed after the original method
		//		is executed. By default the function will be called with a single argument, the return
		//		value of the original method, or the the return value of the last executed advice (if a previous one exists).
		//		The fourth (optional) argument can be set to true to so the function receives the original
		//		arguments (from when the original method was called) rather than the return value.
		//		If there are multiple "after" advisors, they are executed in the order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called after the original method
		// receiveArguments: Boolean?
		//		If this is set to true, the advice function receives the original arguments (from when the original mehtod
		//		was called) rather than the return value of the original/previous method.
		// returns:
		//		A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
		//		stop the advice function from being executed.
	};
	=====*/

	var before = aspect("before");
	/*=====
	before = function(target, methodName, advice){
		// summary:
		//		The "before" export of the aspect module is a function that can be used to attach
		//		"before" advice to a method. This function will be executed before the original method
		//		is executed. This function will be called with the arguments used to call the method.
		//		This function may optionally return an array as the new arguments to use to call
		//		the original method (or the previous, next-to-execute before advice, if one exists).
		//		If the before method doesn't return anything (returns undefined) the original arguments
		//		will be preserved.
		//		If there are multiple "before" advisors, they are executed in the reverse order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called before the original method
	};
	=====*/

	var around = aspect("around");
	/*=====
	 around = function(target, methodName, advice){
		// summary:
		//		The "around" export of the aspect module is a function that can be used to attach
		//		"around" advice to a method. The advisor function is immediately executed when
		//		the around() is called, is passed a single argument that is a function that can be
		//		called to continue execution of the original method (or the next around advisor).
		//		The advisor function should return a function, and this function will be called whenever
		//		the method is called. It will be called with the arguments used to call the method.
		//		Whatever this function returns will be returned as the result of the method call (unless after advise changes it).
		// example:
		//		If there are multiple "around" advisors, the most recent one is executed first,
		//		which can then delegate to the next one and so on. For example:
		//		|	around(obj, "foo", function(originalFoo){
		//		|		return function(){
		//		|			var start = new Date().getTime();
		//		|			var results = originalFoo.apply(this, arguments); // call the original
		//		|			var end = new Date().getTime();
		//		|			console.log("foo execution took " + (end - start) + " ms");
		//		|			return results;
		//		|		};
		//		|	});
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called around the original method
	};
	=====*/

	return {
		// summary:
		//		provides aspect oriented programming functionality, allowing for
		//		one to add before, around, or after advice on existing methods.
		// example:
		//	|	define(["dojo/aspect"], function(aspect){
		//	|		var signal = aspect.after(targetObject, "methodName", function(someArgument){
		//	|			this will be called when targetObject.methodName() is called, after the original function is called
		//	|		});
		//
		// example:
		//	The returned signal object can be used to cancel the advice.
		//	|	signal.remove(); // this will stop the advice from being executed anymore
		//	|	aspect.before(targetObject, "methodName", function(someArgument){
		//	|		// this will be called when targetObject.methodName() is called, before the original function is called
		//	|	 });

		before: before,
		around: around,
		after: after
	};
});

define('dojo/when',[
	"./Deferred",
	"./promise/Promise"
], function(Deferred, Promise){
	"use strict";

	// module:
	//		dojo/when

	return function when(valueOrPromise, callback, errback, progback){
		// summary:
		//		Transparently applies callbacks to values and/or promises.
		// description:
		//		Accepts promises but also transparently handles non-promises. If no
		//		callbacks are provided returns a promise, regardless of the initial
		//		value. Foreign promises are converted.
		//
		//		If callbacks are provided and the initial value is not a promise,
		//		the callback is executed immediately with no error handling. Returns
		//		a promise if the initial value is a promise, or the result of the
		//		callback otherwise.
		// valueOrPromise:
		//		Either a regular value or an object with a `then()` method that
		//		follows the Promises/A specification.
		// callback: Function?
		//		Callback to be invoked when the promise is resolved, or a non-promise
		//		is received.
		// errback: Function?
		//		Callback to be invoked when the promise is rejected.
		// progback: Function?
		//		Callback to be invoked when the promise emits a progress update.
		// returns: dojo/promise/Promise
		//		Promise, or if a callback is provided, the result of the callback.

		var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
		var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

		if(!receivedPromise){
			if(arguments.length > 1){
				return callback ? callback(valueOrPromise) : valueOrPromise;
			}else{
				return new Deferred().resolve(valueOrPromise);
			}
		}else if(!nativePromise){
			var deferred = new Deferred(valueOrPromise.cancel);
			valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
			valueOrPromise = deferred.promise;
		}

		if(callback || errback || progback){
			return valueOrPromise.then(callback, errback, progback);
		}
		return valueOrPromise;
	};
});

define('dstore/QueryMethod',[], function () {
	/*=====
	var __QueryMethodArgs = {
		// type: String
		//		The type of the query. This identifies the query's type in the query log
		//		and the name of the corresponding query engine method.
		// normalizeArguments: Function?
		//		A function that normalizes arguments for consumption by a query engine
		// applyQuery: Function?
		//		A function that takes the query's new subcollection and the query's log entry
		//		and applies it to the new subcollection. This is useful for collections that need
		//		to both declare and implement new query methods.
		// querierFactory: Function?
		//		A factory function that provides a default querier implementation to use when
		//		a collection does not define its own querier factory method for this query type.
	};
	=====*/
	return function QueryMethod(/*__QueryMethodArgs*/ kwArgs) {
		// summary:
		//		The constructor for a dstore collection query method
		// description:
		//		This is the constructor for a collection query method. It encapsulates the following:
		//		* Creating a new subcollection for the query results
		//		* Logging the query in the collection's `queryLog`
		//		* Normalizing query arguments
		//		* Applying the query engine
		// kwArgs:
		//		The properties that define the query method
		// returns: Function
		//		Returns a function that takes query arguments and returns a new collection with
		//		the query associated with it.

		var type = kwArgs.type,
			normalizeArguments = kwArgs.normalizeArguments,
			applyQuery = kwArgs.applyQuery,
			defaultQuerierFactory = kwArgs.querierFactory;

		return function () {
			// summary:
			//		A query method whose arguments are determined by the query type
			// returns: dstore/Collection
			//		A collection representing the query results

			var originalArguments = Array.prototype.slice.call(arguments),
				normalizedArguments = normalizeArguments
					? normalizeArguments.apply(this, originalArguments)
					: originalArguments,
				logEntry = {
					type: type,
					arguments: originalArguments,
					normalizedArguments: normalizedArguments
				},
				querierFactory = this._getQuerierFactory(type) || defaultQuerierFactory;

			if (querierFactory) {
				// Call the query factory in store context to support things like
				// mapping a filter query's string argument to a custom filter method on the collection
				logEntry.querier = querierFactory.apply(this, normalizedArguments);
			}

			var newCollection = this._createSubCollection({
				queryLog: this.queryLog.concat(logEntry)
			});

			return applyQuery ? applyQuery.call(this, newCollection, logEntry) : newCollection;
		};
	};
});

define('dstore/Filter',['dojo/_base/declare'], function (declare) {
	// a Filter builder
	function filterCreator(type) {
		// constructs a new filter based on type, used to create each method
		return function newFilter() {
			var Filter = this.constructor;
			var filter = new Filter();
			filter.type = type;
			filter.args = arguments;
			if (this.type) {
				// we are chaining, so combine with an and operator
				return filterCreator('and').call(Filter.prototype, this, filter);
			}
			return filter;
		};
	}
	var Filter = declare(null, {
		constructor: function (filterArg) {
			var argType = typeof filterArg;
			switch (argType) {
				case 'object':
					var filter = this;
					// construct a filter based on the query object
					for (var key in filterArg){
						var value = filterArg[key];
						if (value instanceof this.constructor) {
							// fully construct the filter from the single arg
							filter = filter[value.type](key, value.args[0]);
						} else if (value && value.test) {
							// support regex
							filter = filter.match(key, value);
						} else {
							filter = filter.eq(key, value);
						}
					}
					this.type = filter.type;
					this.args = filter.args;
					break;
				case 'function': case 'string':
					// allow string and function args as well
					this.type = argType;
					this.args = [filterArg];
			}
		},
		// define our operators
		and: filterCreator('and'),
		or: filterCreator('or'),
		eq: filterCreator('eq'),
		ne: filterCreator('ne'),
		lt: filterCreator('lt'),
		lte: filterCreator('lte'),
		gt: filterCreator('gt'),
		gte: filterCreator('gte'),
		contains: filterCreator('contains'),
		'in': filterCreator('in'),
		match: filterCreator('match')
	});
	Filter.filterCreator = filterCreator;
	return Filter;
});

define('dojo/on',["./has!dom-addeventlistener?:./aspect", "./_base/kernel", "./sniff"], function(aspect, dojo, has){

	"use strict";
	if(has("dom")){ // check to make sure we are in a browser, this module should work anywhere
		var major = window.ScriptEngineMajorVersion;
		has.add("jscript", major && (major() + ScriptEngineMinorVersion() / 10));
		has.add("event-orientationchange", has("touch") && !has("android")); // TODO: how do we detect this?
		has.add("event-stopimmediatepropagation", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);
		has.add("event-focusin", function(global, doc, element){
			return 'onfocusin' in element;
		});

		if(has("touch")){
			has.add("touch-can-modify-event-delegate", function(){
				// This feature test checks whether deleting a property of an event delegate works
				// for a touch-enabled device. If it works, event delegation can be used as fallback
				// for browsers such as Safari in older iOS where deleting properties of the original
				// event does not work.
				var EventDelegate = function(){};
				EventDelegate.prototype =
					document.createEvent("MouseEvents"); // original event
				// Attempt to modify a property of an event delegate and check if
				// it succeeds. Depending on browsers and on whether dojo/on's
				// strict mode is stripped in a Dojo build, there are 3 known behaviors:
				// it may either succeed, or raise an error, or fail to set the property
				// without raising an error.
				try{
					var eventDelegate = new EventDelegate;
					eventDelegate.target = null;
					return eventDelegate.target === null;
				}catch(e){
					return false; // cannot use event delegation
				}
			});
		}
	}
	var on = function(target, type, listener, dontFix){
		// summary:
		//		A function that provides core event listening functionality. With this function
		//		you can provide a target, event type, and listener to be notified of
		//		future matching events that are fired.
		// target: Element|Object
		//		This is the target object or DOM element that to receive events from
		// type: String|Function
		//		This is the name of the event to listen for or an extension event type.
		// listener: Function
		//		This is the function that should be called when the event fires.
		// returns: Object
		//		An object with a remove() method that can be used to stop listening for this
		//		event.
		// description:
		//		To listen for "click" events on a button node, we can do:
		//		|	define(["dojo/on"], function(on){
		//		|		on(button, "click", clickHandler);
		//		|		...
		//		Evented JavaScript objects can also have their own events.
		//		|	var obj = new Evented;
		//		|	on(obj, "foo", fooHandler);
		//		And then we could publish a "foo" event:
		//		|	on.emit(obj, "foo", {key: "value"});
		//		We can use extension events as well. For example, you could listen for a tap gesture:
		//		|	define(["dojo/on", "dojo/gesture/tap", function(on, tap){
		//		|		on(button, tap, tapHandler);
		//		|		...
		//		which would trigger fooHandler. Note that for a simple object this is equivalent to calling:
		//		|	obj.onfoo({key:"value"});
		//		If you use on.emit on a DOM node, it will use native event dispatching when possible.

        if(!target){
            console.error('have no target');
            return null;
        }
		if(typeof target.on == "function" && typeof type != "function" && !target.nodeType){
			// delegate to the target's on() method, so it can handle it's own listening if it wants (unless it
			// is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the
			// Element prototype
			return target.on(type, listener);
		}
		// delegate to main listener code
		return on.parse(target, type, listener, addListener, dontFix, this);
	};
	on.pausable =  function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but with pausable functionality. The
		//		returned signal object has pause() and resume() functions. Calling the
		//		pause() method will cause the listener to not be called for future events. Calling the
		//		resume() method will cause the listener to again be called for future events.
		var paused;
		var signal = on(target, type, function(){
			if(!paused){
				return listener.apply(this, arguments);
			}
		}, dontFix);
		signal.pause = function(){
			paused = true;
		};
		signal.resume = function(){
			paused = false;
		};
		return signal;
	};
	on.once = function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but will only call the listener once. The
		//		listener will be called for the first
		//		event that takes place and then listener will automatically be removed.
		var signal = on(target, type, function(){
			// remove this listener
			signal.remove();
			// proceed to call the listener
			return listener.apply(this, arguments);
		});
		return signal;
	};
	on.parse = function(target, type, listener, addListener, dontFix, matchesTarget){
		var events;
		if(type.call){
			// event handler function
			// on(node, touch.press, touchListener);
			return type.call(matchesTarget, target, listener);
		}

		if(type instanceof Array){
			// allow an array of event names (or event handler functions)
			events = type;
		}else if(type.indexOf(",") > -1){
			// we allow comma delimited event names, so you can register for multiple events at once
			events = type.split(/\s*,\s*/);
		}
		if(events){
			var handles = [];
			var i = 0;
			var eventName;
			while(eventName = events[i++]){ // intentional assignment
				handles.push(on.parse(target, eventName, listener, addListener, dontFix, matchesTarget));
			}
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		}
		return addListener(target, type, listener, dontFix, matchesTarget);
	};
	var touchEvents = /^touch/;
	function addListener(target, type, listener, dontFix, matchesTarget){
		// event delegation:
		var selector = type.match(/(.*):(.*)/);
		// if we have a selector:event, the last one is interpreted as an event, and we use event delegation
		if(selector){
			type = selector[2];
			selector = selector[1];
			// create the extension event for selectors and directly call it
			return on.selector(selector, type).call(matchesTarget, target, listener);
		}
		// test to see if it a touch event right now, so we don't have to do it every time it fires
		if(has("touch")){
			if(touchEvents.test(type)){
				// touch event, fix it
				listener = fixTouchListener(listener);
			}
			if(!has("event-orientationchange") && (type == "orientationchange")){
				//"orientationchange" not supported <= Android 2.1,
				//but works through "resize" on window
				type = "resize";
				target = window;
				listener = fixTouchListener(listener);
			}
		}
		if(addStopImmediate){
			// add stopImmediatePropagation if it doesn't exist
			listener = addStopImmediate(listener);
		}
		// normal path, the target is |this|
		if(target.addEventListener){
			// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)
			// check for capture conversions
			var capture = type in captures,
				adjustedType = capture ? captures[type] : type;
			target.addEventListener(adjustedType, listener, capture);
			// create and return the signal
			return {
                type:adjustedType,
				remove: function(){
					target.removeEventListener(adjustedType, listener, capture);
				}
			};
		}
		type = "on" + type;
		if(fixAttach && target.attachEvent){
			return fixAttach(target, type, listener);
		}
		throw new Error("Target must be an event emitter");
	}
	on.matches = function(node, selector, context, children, matchesTarget) {
		// summary:
		//		Check if a node match the current selector within the constraint of a context
		// node: DOMNode
		//		The node that originate the event
		// selector: String
		//		The selector to check against
		// context: DOMNode
		//		The context to search in.
		// children: Boolean
		//		Indicates if children elements of the selector should be allowed. This defaults to
		//		true
		// matchesTarget: Object|dojo/query?
		//		An object with a property "matches" as a function. Default is dojo/query.
		//		Matching DOMNodes will be done against this function
		//		The function must return a Boolean.
		//		It will have 3 arguments: "node", "selector" and "context"
		//		True is expected if "node" is matching the current "selector" in the passed "context"
		// returns: DOMNode?
		//		The matching node, if any. Else you get false

		// see if we have a valid matchesTarget or default to dojo/query
		matchesTarget = matchesTarget && (typeof matchesTarget.matches == "function") ? matchesTarget : dojo.query;
		children = children !== false;
		// there is a selector, so make sure it matches
		if(node.nodeType != 1){
			// text node will fail in native match selector
			node = node.parentNode;
		}
		while(!matchesTarget.matches(node, selector, context)){
			if(node == context || children === false || !(node = node.parentNode) || node.nodeType != 1){ // intentional assignment
				return false;
			}
		}
		return node;
	};
	on.selector = function(selector, eventType, children){
		// summary:
		//		Creates a new extension event with event delegation. This is based on
		//		the provided event type (can be extension event) that
		//		only calls the listener when the CSS selector matches the target of the event.
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		// selector:
		//		The CSS selector to use for filter events and determine the |this| of the event listener.
		// eventType:
		//		The event to listen for
		// children:
		//		Indicates if children elements of the selector should be allowed. This defaults to
		//		true
		// example:
		// |	require(["dojo/on", "dojo/mouse", "dojo/query!css2"], function(on, mouse){
		// |		on(node, on.selector(".my-class", mouse.enter), handlerForMyHover);
		return function(target, listener){
			// if the selector is function, use it to select the node, otherwise use the matches method
			var matchesTarget = typeof selector == "function" ? {matches: selector} : this,
				bubble = eventType.bubble;
			function select(eventTarget){
				return on.matches(eventTarget, selector, target, children, matchesTarget);
			}
			if(bubble){
				// the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself
				return on(target, bubble(select), listener);
			}
			// standard event delegation
			return on(target, eventType, function(event){
				// call select to see if we match
				var eventTarget = select(event.target);
				// if it matches we call the listener
				if (eventTarget) {
					// We save the matching target into the event, so it can be accessed even when hitching (see #18355)
					event.selectorTarget = eventTarget;
					return listener.call(eventTarget, event);
				}
			});
		};
	};

	function syntheticPreventDefault(){
		this.cancelable = false;
		this.defaultPrevented = true;
	}
	function syntheticStopPropagation(){
		this.bubbles = false;
	}
	var slice = [].slice,
		syntheticDispatch = on.emit = function(target, type, event){
		// summary:
		//		Fires an event on the target object.
		// target:
		//		The target object to fire the event on. This can be a DOM element or a plain
		//		JS object. If the target is a DOM element, native event emitting mechanisms
		//		are used when possible.
		// type:
		//		The event type name. You can emulate standard native events like "click" and
		//		"mouseover" or create custom events like "open" or "finish".
		// event:
		//		An object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent
		//		for some of the properties. These properties are copied to the event object.
		//		Of particular importance are the cancelable and bubbles properties. The
		//		cancelable property indicates whether or not the event has a default action
		//		that can be cancelled. The event is cancelled by calling preventDefault() on
		//		the event object. The bubbles property indicates whether or not the
		//		event will bubble up the DOM tree. If bubbles is true, the event will be called
		//		on the target and then each parent successively until the top of the tree
		//		is reached or stopPropagation() is called. Both bubbles and cancelable
		//		default to false.
		// returns:
		//		If the event is cancelable and the event is not cancelled,
		//		emit will return true. If the event is cancelable and the event is cancelled,
		//		emit will return false.
		// details:
		//		Note that this is designed to emit events for listeners registered through
		//		dojo/on. It should actually work with any event listener except those
		//		added through IE's attachEvent (IE8 and below's non-W3C event emitting
		//		doesn't support custom event types). It should work with all events registered
		//		through dojo/on. Also note that the emit method does do any default
		//		action, it only returns a value to indicate if the default action should take
		//		place. For example, emitting a keypress event would not cause a character
		//		to appear in a textbox.
		// example:
		//		To fire our own click event
		//	|	require(["dojo/on", "dojo/dom"
		//	|	], function(on, dom){
		//	|		on.emit(dom.byId("button"), "click", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			screenX: 33,
		//	|			screenY: 44
		//	|		});
		//		We can also fire our own custom events:
		//	|		on.emit(dom.byId("slider"), "slide", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			direction: "left-to-right"
		//	|		});
		//	|	});
		var args = slice.call(arguments, 2);
		var method = "on" + type;
		if("parentNode" in target){
			// node (or node-like), create event controller methods
			var newEvent = args[0] = {};
			for(var i in event){
				newEvent[i] = event[i];
			}
			newEvent.preventDefault = syntheticPreventDefault;
			newEvent.stopPropagation = syntheticStopPropagation;
			newEvent.target = target;
			newEvent.type = type;
			event = newEvent;
		}
		do{
			// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)
			target[method] && target[method].apply(target, args);
			// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)
		}while(event && event.bubbles && (target = target.parentNode));
		return event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen
	};
	var captures = has("event-focusin") ? {} : {focusin: "focus", focusout: "blur"};
	if(!has("event-stopimmediatepropagation")){
		var stopImmediatePropagation =function(){
			this.immediatelyStopped = true;
			this.modified = true; // mark it as modified so the event will be cached in IE
		};
		var addStopImmediate = function(listener){
			return function(event){
				if(!event.immediatelyStopped){// check to make sure it hasn't been stopped immediately
					event.stopImmediatePropagation = stopImmediatePropagation;
					return listener.apply(this, arguments);
				}
			};
		};
	}
	if(has("dom-addeventlistener")){
		// emitter that works with native event handling
		on.emit = function(target, type, event){
			if(target.dispatchEvent && document.createEvent){
				// use the native event emitting mechanism if it is available on the target object
				// create a generic event
				// we could create branch into the different types of event constructors, but
				// that would be a lot of extra code, with little benefit that I can see, seems
				// best to use the generic constructor and copy properties over, making it
				// easy to have events look like the ones created with specific initializers
				var ownerDocument = target.ownerDocument || document;
				var nativeEvent = ownerDocument.createEvent("HTMLEvents");
				nativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);
				// and copy all our properties over
				for(var i in event){
					if(!(i in nativeEvent)){
						nativeEvent[i] = event[i];
					}
				}
				return target.dispatchEvent(nativeEvent) && nativeEvent;
			}
			return syntheticDispatch.apply(on, arguments); // emit for a non-node
		};
	}else{
		// no addEventListener, basically old IE event normalization
		on._fixEvent = function(evt, sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt:
			//		native event object
			// sender:
			//		node to treat as "currentTarget"
			if(!evt){
				var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
				evt = w.event;
			}
			if(!evt){return evt;}
			try{
				if(lastEvent && evt.type == lastEvent.type  && evt.srcElement == lastEvent.target){
					// should be same event, reuse event object (so it can be augmented);
					// accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below
					evt = lastEvent;
				}
			}catch(e){
				// will occur on IE on lastEvent.type reference if lastEvent points to a previous event that already
				// finished bubbling, but the setTimeout() to clear lastEvent hasn't fired yet
			}
			if(!evt.target){ // check to see if it has been fixed yet
				evt.target = evt.srcElement;
				evt.currentTarget = (sender || evt.srcElement);
				if(evt.type == "mouseover"){
					evt.relatedTarget = evt.fromElement;
				}
				if(evt.type == "mouseout"){
					evt.relatedTarget = evt.toElement;
				}
				if(!evt.stopPropagation){
					evt.stopPropagation = stopPropagation;
					evt.preventDefault = preventDefault;
				}
				switch(evt.type){
					case "keypress":
						var c = ("charCode" in evt ? evt.charCode : evt.keyCode);
						if (c==10){
							// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla
							c=0;
							evt.keyCode = 13;
						}else if(c==13||c==27){
							c=0; // Mozilla considers ENTER and ESC non-printable
						}else if(c==3){
							c=99; // Mozilla maps CTRL-BREAK to CTRL-c
						}
						// Mozilla sets keyCode to 0 when there is a charCode
						// but that stops the event on IE.
						evt.charCode = c;
						_setKeyChar(evt);
						break;
				}
			}
			return evt;
		};
		var lastEvent, IESignal = function(handle){
			this.handle = handle;
		};
		IESignal.prototype.remove = function(){
			delete _dojoIEListeners_[this.handle];
		};
		var fixListener = function(listener){
			// this is a minimal function for closing on the previous listener with as few as variables as possible
			return function(evt){
				evt = on._fixEvent(evt, this);
				var result = listener.call(this, evt);
				if(evt.modified){
					// cache the last event and reuse it if we can
					if(!lastEvent){
						setTimeout(function(){
							lastEvent = null;
						});
					}
					lastEvent = evt;
				}
				return result;
			};
		};
		var fixAttach = function(target, type, listener){
			listener = fixListener(listener);
			if(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top ||
						has("jscript") < 5.8) &&
					!has("config-_allow_leaks")){
				// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.
				// Here we use global redirection to solve the memory leaks
				if(typeof _dojoIEListeners_ == "undefined"){
					_dojoIEListeners_ = [];
				}
				var emitter = target[type];
				if(!emitter || !emitter.listeners){
					var oldListener = emitter;
					emitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');
					emitter.listeners = [];
					target[type] = emitter;
					emitter.global = this;
					if(oldListener){
						emitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);
					}
				}
				var handle;
				emitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));
				return new IESignal(handle);
			}
			return aspect.after(target, type, listener, true);
		};

		var _setKeyChar = function(evt){
			evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
			evt.charOrCode = evt.keyChar || evt.keyCode;	// TODO: remove for 2.0
		};
		// Called in Event scope
		var stopPropagation = function(){
			this.cancelBubble = true;
		};
		var preventDefault = on._preventDefault = function(){
			// Setting keyCode to 0 is the only way to prevent certain keypresses (namely
			// ctrl-combinations that correspond to menu accelerator keys).
			// Otoh, it prevents upstream listeners from getting this information
			// Try to split the difference here by clobbering keyCode only for ctrl
			// combinations. If you still need to access the key upstream, bubbledKeyCode is
			// provided as a workaround.
			this.bubbledKeyCode = this.keyCode;
			if(this.ctrlKey){
				try{
					// squelch errors when keyCode is read-only
					// (e.g. if keyCode is ctrl or shift)
					this.keyCode = 0;
				}catch(e){
				}
			}
			this.defaultPrevented = true;
			this.returnValue = false;
			this.modified = true; // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE
		};
	}
	if(has("touch")){
		var EventDelegate = function(){};
		var windowOrientation = window.orientation;
		var fixTouchListener = function(listener){
			return function(originalEvent){
				//Event normalization(for ontouchxxx and resize):
				//1.incorrect e.pageX|pageY in iOS
				//2.there are no "e.rotation", "e.scale" and "onorientationchange" in Android
				//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY

				// see if it has already been corrected
				var event = originalEvent.corrected;
				if(!event){
					var type = originalEvent.type;
					try{
						delete originalEvent.type; // on some JS engines (android), deleting properties makes them mutable
					}catch(e){}
					if(originalEvent.type){
						// Deleting the property of the original event did not work (this is the case of
						// browsers such as older Safari iOS), hence fallback:
						if(has("touch-can-modify-event-delegate")){
							// If deleting properties of delegated event works, use event delegation:
							EventDelegate.prototype = originalEvent;
							event = new EventDelegate;
						}else{
							// Otherwise last fallback: other browsers, such as mobile Firefox, do not like
							// delegated properties, so we have to copy
							event = {};
							for(var name in originalEvent){
								event[name] = originalEvent[name];
							}
						}
						// have to delegate methods to make them work
						event.preventDefault = function(){
							originalEvent.preventDefault();
						};
						event.stopPropagation = function(){
							originalEvent.stopPropagation();
						};
					}else{
						// deletion worked, use property as is
						event = originalEvent;
						event.type = type;
					}
					originalEvent.corrected = event;
					if(type == 'resize'){
						if(windowOrientation == window.orientation){
							return null;//double tap causes an unexpected 'resize' in Android
						}
						windowOrientation = window.orientation;
						event.type = "orientationchange";
						return listener.call(this, event);
					}
					// We use the original event and augment, rather than doing an expensive mixin operation
					if(!("rotation" in event)){ // test to see if it has rotation
						event.rotation = 0;
						event.scale = 1;
					}
					//use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target
					var firstChangeTouch = event.changedTouches[0];
					for(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here
						delete event[i]; // delete it first to make it mutable
						event[i] = firstChangeTouch[i];
					}
				}
				return listener.call(this, event);
			};
		};
	}
	return on;
});

define('dojo/Evented',["./aspect", "./on"], function(aspect, on){
	// module:
	//		dojo/Evented

 	"use strict";
 	var after = aspect.after;
	function Evented(){
		// summary:
		//		A class that can be used as a mixin or base class,
		//		to add on() and emit() methods to a class
		//		for listening for events and emitting events:
		// example:
		//		|	define(["dojo/Evented", "dojo/_base/declare", "dojo/Stateful"
		//		|	], function(Evented, declare, Stateful){
		//		|		var EventedStateful = declare([Evented, Stateful], {...});
		//		|		var instance = new EventedStateful();
		//		|		instance.on("open", function(event){
		//		|		... do something with event
		//		|	 });
		//		|
		//		|	instance.emit("open", {name:"some event", ...});
	}
	Evented.prototype = {
		on: function(type, listener){
			return on.parse(this, type, listener, function(target, type){
				return after(target, 'on' + type, listener, true);
			});
		},
		emit: function(type, event){
			var args = [this];
			args.push.apply(args, arguments);
			return on.emit.apply(on, args);
		}
	};
	return Evented;
});

define('dstore/Store',[
	'dojo/_base/lang',
	'dojo/_base/array',
	'dojo/aspect',
	'dojo/has',
	'dojo/when',
	'dojo/Deferred',
	'dojo/_base/declare',
	'dstore/QueryMethod',
	'dstore/Filter',
	'dojo/Evented'
], function (lang, arrayUtil, aspect, has, when, Deferred, declare, QueryMethod, Filter, Evented) {

	// module:
	//		dstore/Store
	/* jshint proto: true */
	// detect __proto__, and avoid using it on Firefox, as they warn about
	// deoptimizations. The watch method is a clear indicator of the Firefox
	// JS engine.
	has.add('object-proto', !!{}.__proto__ && !({}).watch);
	var hasProto = has('object-proto');

	function emitUpdateEvent(type) {
		return function (result, args) {
			var self = this;
			when(result, function (result) {
				var event = { target: result },
					options = args[1] || {};
				if ('beforeId' in options) {
					event.beforeId = options.beforeId;
				}
				self.emit(type, event);
			});

			return result;
		};
	}

	var base = Evented;
	/*=====
	base = [ Evented, Collection ];
	=====*/

	return /*==== Store= ====*/declare(base, {
		constructor: function (options) {
			// perform the mixin
			options && declare.safeMixin(this, options);

			if (this.Model && this.Model.createSubclass) {
				// we need a distinct model for each store, so we can
				// save the reference back to this store on it.
				// we always create a new model to be safe.
				this.Model = this.Model.createSubclass([]).extend({
					// give a reference back to the store for saving, etc.
					_store: this
				});
			}

			// the object the store can use for holding any local data or events
			this.storage = new Evented();
			var store = this;
			if (this.autoEmitEvents) {
				// emit events when modification operations are called
				aspect.after(this, 'add', emitUpdateEvent('add'));
				aspect.after(this, 'put', emitUpdateEvent('update'));
				aspect.after(this, 'remove', function (result, args) {
					when(result, function () {
						store.emit('delete', {id: args[0]});
					});
					return result;
				});
			}
		},

		// autoEmitEvents: Boolean
		//		Indicates if the events should automatically be fired for put, add, remove
		//		method calls. Stores may wish to explicitly fire events, to control when
		//		and which event is fired.
		autoEmitEvents: true,

		// idProperty: String
		//		Indicates the property to use as the identity property. The values of this
		//		property should be unique.
		idProperty: 'id',

		// queryAccessors: Boolean
		//		Indicates if client-side query engine filtering should (if the store property is true)
		//		access object properties through the get() function (enabling querying by
		//		computed properties), or if it should (by setting this to false) use direct/raw
		// 		property access (which may more closely follow database querying style).
		queryAccessors: true,

		getIdentity: function (object) {
			// summary:
			//		Returns an object's identity
			// object: Object
			//		The object to get the identity from
			// returns: String|Number

			return object.get ? object.get(this.idProperty) : object[this.idProperty];
		},

		_setIdentity: function (object, identityArg) {
			// summary:
			//		Sets an object's identity
			// description:
			//		This method sets an object's identity and is useful to override to support
			//		multi-key identities and object's whose properties are not stored directly on the object.
			// object: Object
			//		The target object
			// identityArg:
			//		The argument used to set the identity

			if (object.set) {
				object.set(this.idProperty, identityArg);
			} else {
				object[this.idProperty] = identityArg;
			}
		},

		forEach: function (callback, thisObject) {
			var collection = this;
			return when(this.fetch(), function (data) {
				for (var i = 0, item; (item = data[i]) !== undefined; i++) {
					callback.call(thisObject, item, i, collection);
				}
				return data;
			});
		},
		on: function (type, listener) {
			return this.storage.on(type, listener);
		},
		emit: function (type, event) {
			event = event || {};
			event.type = type;
			try {
				return this.storage.emit(type, event);
			} finally {
				// Return the initial value of event.cancelable because a listener error makes it impossible
				// to know whether the event was actually canceled
				return event.cancelable;
			}
		},

		// parse: Function
		//		One can provide a parsing function that will permit the parsing of the data. By
		//		default we assume the provide data is a simple JavaScript array that requires
		//		no parsing (subclass stores may provide their own default parse function)
		parse: null,

		// stringify: Function
		//		For stores that serialize data (to send to a server, for example) the stringify
		//		function can be specified to control how objects are serialized to strings
		stringify: null,

		// Model: Function
		//		This should be a entity (like a class/constructor) with a 'prototype' property that will be
		//		used as the prototype for all objects returned from this store. One can set
		//		this to the Model from dmodel/Model to return Model objects, or leave this
		//		to null if you don't want any methods to decorate the returned
		//		objects (this can improve performance by avoiding prototype setting),
		Model: null,

		_restore: function (object, mutateAllowed) {
			// summary:
			//		Restores a plain raw object, making an instance of the store's model.
			//		This is called when an object had been persisted into the underlying
			//		medium, and is now being restored. Typically restored objects will come
			//		through a phase of deserialization (through JSON.parse, DB retrieval, etc.)
			//		in which their __proto__ will be set to Object.prototype. To provide
			//		data model support, the returned object needs to be an instance of the model.
			//		This can be accomplished by setting __proto__ to the model's prototype
			//		or by creating a new instance of the model, and copying the properties to it.
			//		Also, model's can provide their own restore method that will allow for
			//		custom model-defined behavior. However, one should be aware that copying
			//		properties is a slower operation than prototype assignment.
			//		The restore process is designed to be distinct from the create process
			//		so their is a clear delineation between new objects and restored objects.
			// object: Object
			//		The raw object with the properties that need to be defined on the new
			//		model instance
			// mutateAllowed: boolean
			//		This indicates if restore is allowed to mutate the original object
			//		(by setting its __proto__). If this isn't true, than the restore should
			//		copy the object to a new object with the correct type.
			// returns: Object
			//		An instance of the store model, with all the properties that were defined
			//		on object. This may or may not be the same object that was passed in.
			var Model = this.Model;
			if (Model && object) {
				var prototype = Model.prototype;
				var restore = prototype._restore;
				if (restore) {
					// the prototype provides its own restore method
					object = restore.call(object, Model, mutateAllowed);
				} else if (hasProto && mutateAllowed) {
					// the fast easy way
					// http://jsperf.com/setting-the-prototype
					object.__proto__ = prototype;
				} else {
					// create a new object with the correct prototype
					object = lang.delegate(prototype, object);
				}
			}
			return object;
		},

		create: function (properties) {
			// summary:
			//		This creates a new instance from the store's model.
			//	properties:
			//		The properties that are passed to the model constructor to
			//		be copied onto the new instance. Note, that should only be called
			//		when new objects are being created, not when existing objects
			//		are being restored from storage.
			return new this.Model(properties);
		},

		_createSubCollection: function (kwArgs) {
			var newCollection = lang.delegate(this.constructor.prototype);

			for (var i in this) {
				if (this._includePropertyInSubCollection(i, newCollection)) {
					newCollection[i] = this[i];
				}
			}

			return declare.safeMixin(newCollection, kwArgs);
		},

		_includePropertyInSubCollection: function (name, subCollection) {
			return !(name in subCollection) || subCollection[name] !== this[name];
		},

		// queryLog: __QueryLogEntry[]
		//		The query operations represented by this collection
		queryLog: [],	// NOTE: It's ok to define this on the prototype because the array instance is never modified

		filter: new QueryMethod({
			type: 'filter',
			normalizeArguments: function (filter) {
				var Filter = this.Filter;
				if (filter instanceof Filter) {
					return [filter];
				}
				return [new Filter(filter)];
			}
		}),

		Filter: Filter,

		sort: new QueryMethod({
			type: 'sort',
			normalizeArguments: function (property, descending) {
				var sorted;
				if (typeof property === 'function') {
					sorted = [ property ];
				} else {
					if (property instanceof Array) {
						sorted = property.slice();
					} else if (typeof property === 'object') {
						sorted = [].slice.call(arguments);
					} else {
						sorted = [{ property: property, descending: descending }];
					}

					sorted = arrayUtil.map(sorted, function (sort) {
						// copy the sort object to avoid mutating the original arguments
						sort = lang.mixin({}, sort);
						sort.descending = !!sort.descending;
						return sort;
					});
					// wrap in array because sort objects are a single array argument
					sorted = [ sorted ];
				}
				return sorted;
			}
		}),

		select: new QueryMethod({
			type: 'select'
		}),

		_getQuerierFactory: function (type) {
			var uppercaseType = type[0].toUpperCase() + type.substr(1);
			return this['_create' + uppercaseType + 'Querier'];
		}

/*====,
		get: function (id) {
			// summary:
			//		Retrieves an object by its identity
			// id: Number
			//		The identity to use to lookup the object
			// returns: Object
			//		The object in the store that matches the given id.
		},
		put: function (object, directives) {
			// summary:
			//		Stores an object
			// object: Object
			//		The object to store.
			// directives: dstore/Store.PutDirectives?
			//		Additional directives for storing objects.
			// returns: Object
			//		The object that was stored, with any changes that were made by
			//		the storage system (like generated id)
		},
		add: function (object, directives) {
			// summary:
			//		Creates an object, throws an error if the object already exists
			// object: Object
			//		The object to store.
			// directives: dstore/Store.PutDirectives?
			//		Additional directives for creating objects.
			// returns: Object
			//		The object that was stored, with any changes that were made by
			//		the storage system (like generated id)
		},
		remove: function (id) {
			// summary:
			//		Deletes an object by its identity
			// id: Number
			//		The identity to use to delete the object
		},
		transaction: function () {
			// summary:
			//		Starts a new transaction.
			//		Note that a store user might not call transaction() prior to using put,
			//		delete, etc. in which case these operations effectively could be thought of
			//		as "auto-commit" style actions.
			// returns: dstore/Store.Transaction
			//		This represents the new current transaction.
		},
		getChildren: function (parent) {
			// summary:
			//		Retrieves the children of an object.
			// parent: Object
			//		The object to find the children of.
			// returns: dstore/Store.Collection
			//		A result set of the children of the parent object.
		}
====*/
	});
});


/*====
	var Collection = declare(null, {
		// summary:
		//		This is an abstract API for a collection of objects, which can be filtered,
		//		sorted, and sliced to create new collections. This is considered to be base
		//		interface for all stores and  query results in dstore. Note that the objects in the
		//		collection may not be immediately retrieved from the underlying data
		//		storage until they are actually accessed through forEach() or fetch().

		filter: function (query) {
			// summary:
			//		Filters the collection, returning a new subset collection
			// query: String|Object|Function
			//		The query to use for retrieving objects from the store.
			// returns: Collection
		},
		sort: function (property, descending) {
			// summary:
			//		Sorts the current collection into a new collection, reordering the objects by the provided sort order.
			// property: String|Function
			//		The property to sort on. Alternately a function can be provided to sort with
			// descending?: Boolean
			//		Indicate if the sort order should be descending (defaults to ascending)
			// returns: Collection
		},
		fetchRange: function (kwArgs) {
			// summary:
			//		Retrieves a range of objects from the collection, returning a promise to an array.
			// kwArgs.start: Number
			//		The starting index of objects to return (0-indexed)
			// kwArgs.end: Number
			//		The exclusive end of objects to return
			// returns: Collection
		},
		forEach: function (callback, thisObject) {
			// summary:
			//		Iterates over the query results, based on
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach.
			//		Note that this may executed asynchronously (in which case it will return a promise),
			//		and the callback may be called after this function returns.
			// callback:
			//		Function that is called for each object in the query results
			// thisObject:
			//		The object to use as |this| in the callback.
			// returns:
			//		undefined|Promise
		},
		fetch: function () {
			// summary:
			//		This can be called to materialize and request the data behind this collection.
			//		Often collections may be lazy, and won't retrieve their underlying data until
			//		forEach or fetch is called. This returns an array, or for asynchronous stores,
			//		this will return a promise, resolving to an array of objects, once the
			//		operation is complete.
			//	returns Array|Promise
		},
		on: function (type, listener) {
			// summary:
			//		This registers a callback for notification of when data is modified in the query results.
			// type: String
			//		There are four types of events defined in this API:
			//		- add - A new object was added
			//		- update - An object was updated
			//		- delete - An object was deleted
			// listener: Function
			//		The listener function is called when objects in the query results are modified
			//		to affect the query result. The listener function is called with a single event object argument:
			//		| listener(event);
			//
			//		- The event object as the following properties:
			//		- type - The event type (of the four above)
			//		- target - This indicates the object that was create or modified.
			//		- id - If an object was removed, this indicates the object that was removed.
			//		The next two properties will only be available if array tracking is employed,
			//		which is usually provided by dstore/Trackable
			//		- previousIndex - The previousIndex parameter indicates the index in the result array where
			//		the object used to be. If the value is -1, then the object is an addition to
			//		this result set (due to a new object being created, or changed such that it
			//		is a part of the result set).
			//		- index - The inex parameter indicates the index in the result array where
			//		the object should be now. If the value is -1, then the object is a removal
			//		from this result set (due to an object being deleted, or changed such that it
			//		is not a part of the result set).

		}
	});

	Collection.SortInformation = declare(null, {
		// summary:
		//		An object describing what property to sort on, and the direction of the sort.
		// property: String
		//		The name of the property to sort on.
		// descending: Boolean
		//		The direction of the sort.  Default is false.
	});
	Store.Collection = Collection;

	Store.PutDirectives = declare(null, {
		// summary:
		//		Directives passed to put() and add() handlers for guiding the update and
		//		creation of stored objects.
		// id: String|Number?
		//		Indicates the identity of the object if a new object is created
		// beforeId: String?
		//		If the collection of objects in the store has a natural ordering,
		//		this indicates that the created or updated object should be placed before the
		//		object whose identity is specified as the value of this property. A value of null indicates that the
		//		object should be last.
		// parent: Object?,
		//		If the store is hierarchical (with single parenting) this property indicates the
		//		new parent of the created or updated object.
		// overwrite: Boolean?
		//		If this is provided as a boolean it indicates that the object should or should not
		//		overwrite an existing object. A value of true indicates that a new object
		//		should not be created, the operation should update an existing object. A
		//		value of false indicates that an existing object should not be updated, a new
		//		object should be created (which is the same as an add() operation). When
		//		this property is not provided, either an update or creation is acceptable.
	});

	Store.Transaction = declare(null, {
		// summary:
		//		This is an object returned from transaction() calls that represents the current
		//		transaction.

		commit: function () {
			// summary:
			//		Commits the transaction. This may throw an error if it fails. Of if the operation
			//		is asynchronous, it may return a promise that represents the eventual success
			//		or failure of the commit.
		},
		abort: function (callback, thisObject) {
			// summary:
			//		Aborts the transaction. This may throw an error if it fails. Of if the operation
			//		is asynchronous, it may return a promise that represents the eventual success
			//		or failure of the abort.
		}
	});

	var __QueryLogEntry = {
		type: String
			The query type
		arguments: Array
			The original query arguments
		normalizedArguments: Array
			The normalized query arguments
		querier: Function?
			A client-side implementation of the query that takes an item array and returns an item array
	};
====*/
;
define('dstore/QueryResults',['dojo/_base/lang', 'dojo/when'], function (lang, when) {
	function forEach(callback, instance) {
		return when(this, function(data) {
			for (var i = 0, l = data.length; i < l; i++){
				callback.call(instance, data[i], i, data);
			}
		});
	}
	return function (data, options) {
		var hasTotalLength = options && 'totalLength' in options;
		if(data.then) {
			data = lang.delegate(data);
			// a promise for the eventual realization of the totalLength, in
			// case it comes from the resolved data
			var totalLengthPromise = data.then(function (data) {
				// calculate total length, now that we have access to the resolved data
				var totalLength = hasTotalLength ? options.totalLength :
						data.totalLength || data.length;
				// make it available on the resolved data
				data.totalLength = totalLength;
				// don't return the totalLength promise unless we need to, to avoid
				// triggering a lazy promise
				return !hasTotalLength && totalLength;
			});
			// make the totalLength available on the promise (whether through the options or the enventual
			// access to the resolved data)
			data.totalLength = hasTotalLength ? options.totalLength : totalLengthPromise;
			// make the response available as well
			data.response = options && options.response;
		} else {
			data.totalLength = hasTotalLength ? options.totalLength : data.length;
		}

		data.forEach = forEach;

		return data;
	};
});

define('dstore/Promised',[
	'dojo/_base/declare',
	'dojo/Deferred',
	'./QueryResults',
	'dojo/when'
], function (declare, Deferred, QueryResults, when) {
	// module:
	//		this is a mixin that can be used to provide async methods,
	// 		by implementing their sync counterparts
	function promised(method, query) {
		return function() {
			var deferred = new Deferred();
			try {
				deferred.resolve(this[method].apply(this, arguments));
			} catch (error) {
				deferred.reject(error);
			}
			if (query) {
				// need to create a QueryResults and ensure the totalLength is
				// a promise.
				var queryResults = new QueryResults(deferred.promise);
				queryResults.totalLength = when(queryResults.totalLength);
				return queryResults;
			}
			return deferred.promise;
		};
	}
	return declare(null, {
		get: promised('getSync'),
		put: promised('putSync'),
		add: promised('addSync'),
		remove: promised('removeSync'),
		fetch: promised('fetchSync', true),
		fetchRange: promised('fetchRangeSync', true)
	});
});

define('dstore/SimpleQuery',[
	'dojo/_base/declare',
	'dojo/_base/array'
], function (declare, arrayUtil) {

	// module:
	//		dstore/SimpleQuery

	function makeGetter(property, queryAccessors) {
		if (property.indexOf('.') > -1) {
			var propertyPath = property.split('.');
			var pathLength = propertyPath.length;
			return function (object) {
				for (var i = 0; i < pathLength; i++) {
					object = object && (queryAccessors && object.get ? object.get(propertyPath[i]) : object[propertyPath[i]]);
				}
				return object;
			};
		}
		// else
		return function (object) {
			return object.get ? object.get(property) : object[property];
		};
	}

	var comparators = {
		eq: function (value, required) {
			return value === required;
		},
		'in': function(value, required) {
			// allow for a collection of data
			return arrayUtil.indexOf(required.data || required, value) > -1;
		},
		ne: function (value, required) {
			return value !== required;
		},
		lt: function (value, required) {
			return value < required;
		},
		lte: function (value, required) {
			return value <= required;
		},
		gt: function (value, required) {
			return value > required;
		},
		gte: function (value, required) {
			return value >= required;
		},
		match: function (value, required, object) {
			return required.test(value, object);
		},
		contains: function (value, required, object, key) {
			var collection = this;
			return arrayUtil.every(required.data || required, function (requiredValue) {
				if (typeof requiredValue === 'object' && requiredValue.type) {
					var comparator = collection._getFilterComparator(requiredValue.type);
					return arrayUtil.some(value, function (item) {
						return comparator.call(collection, item, requiredValue.args[1], object, key);
					});
				}
				return arrayUtil.indexOf(value, requiredValue) > -1;
			});
		}
	};

	return declare(null, {
		// summary:
		//		Mixin providing querier factories for core query types

		_createFilterQuerier: function (filter) {
			// create our matching filter function
			var queryAccessors = this.queryAccessors;
			var collection = this;
			var querier = getQuerier(filter);

			function getQuerier(filter) {
				var type = filter.type;
				var args = filter.args;
				var comparator = collection._getFilterComparator(type);
				if (comparator) {
					// it is a comparator
					var firstArg = args[0];
					var getProperty = makeGetter(firstArg, queryAccessors);
					var secondArg = args[1];
					if (secondArg && secondArg.fetchSync) {
						// if it is a collection, fetch the contents (for `in` and `contains` operators)
						secondArg = secondArg.fetchSync();
					}
					return function (object) {
						// get the value for the property and compare to expected value
						return comparator.call(collection, getProperty(object), secondArg, object, firstArg);
					};
				}
				switch (type) {
					case 'and': case 'or':
						for (var i = 0, l = args.length; i < l; i++) {
							// combine filters, using and or or
							var nextQuerier = getQuerier(args[i]);
							if (querier) {
								// combine the last querier with a new one
								querier = (function(a, b) {
									return type === 'and' ?
										function(object) {
											return a(object) && b(object);
										} :
										function(object) {
											return a(object) || b(object);

										};
								})(querier, nextQuerier);
							} else {
								querier = nextQuerier;
							}
						}
						return querier;
					case 'function':
						return args[0];
					case 'string':
						// named filter
						var filterFunction = collection[args[0]];
						if (!filterFunction) {
							throw new Error('No filter function ' + args[0] + ' was found in the collection');
						}
						return filterFunction;
					case undefined:
						return function () {
							return true;
						};
					default:
						throw new Error('Unknown filter operation "' + type + '"');
				}
			}
			return function (data) {
				return arrayUtil.filter(data, querier);
			};
		},

		_getFilterComparator: function (type) {
			// summary:
			//		Get the comparator for the specified type
			// returns: Function?

			return comparators[type] || this.inherited(arguments);
		},

		_createSelectQuerier: function (properties) {
			return function (data) {
				var l = properties.length;
				return arrayUtil.map(data, properties instanceof Array ?
					// array of properties
					function (object) {
						var selectedObject = {};
						for (var i = 0; i < l; i++) {
							var property = properties[i];
							selectedObject[property] = object[property];
						}
						return selectedObject;
					} :
					// single property
					function (object) {
						return object[properties];
					});
			};
		},

		_createSortQuerier: function (sorted) {
			var queryAccessors = this.queryAccessors;
			return function (data) {
				data = data.slice();
				data.sort(typeof sorted == 'function' ? sorted : function (a, b) {
					for (var i = 0; i < sorted.length; i++) {
						var comparison;
						var sorter = sorted[i];
						if (typeof sorter == 'function') {
							comparison = sorter(a, b);
						} else {
							var getProperty = sorter.get || (sorter.get = makeGetter(sorter.property, queryAccessors));
							var descending = sorter.descending;
							var aValue = getProperty(a);
							var bValue = getProperty(b);

							aValue != null && (aValue = aValue.valueOf());
							bValue != null && (bValue = bValue.valueOf());

							comparison = aValue === bValue
								? 0
								: (!!descending === (aValue === null || aValue > bValue && bValue !== null) ? -1 : 1);
						}

						if (comparison !== 0) {
							return comparison;
						}
					}
					return 0;
				});
				return data;
			};
		}
	});
});

define('dstore/Memory',[
	'dojo/_base/declare',
	'dojo/_base/lang',
	'dojo/_base/array',
	'./Store',
	'./Promised',
	'./SimpleQuery',
	'./QueryResults'
], function (declare, lang, arrayUtil, Store, Promised, SimpleQuery, QueryResults) {

	// module:
	//		dstore/Memory
	return declare([Store, Promised, SimpleQuery ], {
		constructor: function () {
			// summary:
			//		Creates a memory object store.
			// options: dstore/Memory
			//		This provides any configuration information that will be mixed into the store.
			//		This should generally include the data property to provide the starting set of data.

			// Add a version property so subcollections can detect when they're using stale data
			this.storage.version = 0;
		},

		postscript: function () {
			this.inherited(arguments);

			// Set the data in `postscript` so subclasses can override `data` in their constructors
			// (e.g., a LocalStorage store that retrieves its data from localStorage)
			this.setData(this.data || []);
		},

		// data: Array
		//		The array of all the objects in the memory store
		data: null,

		autoEmitEvents: false, // this is handled by the methods themselves

		getSync: function (id) {
			// summary:
			//		Retrieves an object by its identity
			// id: Number
			//		The identity to use to lookup the object
			// returns: Object
			//		The object in the store that matches the given id.
			return this.storage.fullData[this.storage.index[id]];
		},
		putSync: function (object, options) {
			// summary:
			//		Stores an object
			// object: Object
			//		The object to store.
			// options: dstore/Store.PutDirectives?
			//		Additional metadata for storing the data.  Includes an 'id'
			//		property if a specific id is to be used.
			// returns: Number

			options = options || {};

			var storage = this.storage,
				index = storage.index,
				data = storage.fullData;

			var Model = this.Model;
			if (Model && !(object instanceof Model)) {
				// if it is not the correct type, restore a
				// properly typed version of the object. Note that we do not allow
				// mutation here
				object = this._restore(object);
			}
			var id = this.getIdentity(object);
			if (id == null) {
				this._setIdentity(object, ('id' in options) ? options.id : Math.random());
				id = this.getIdentity(object);
			}
			storage.version++;

			var eventType = id in index ? 'update' : 'add',
				event = { target: object },
				previousIndex,
				defaultDestination;
			if (eventType === 'update') {
				if (options.overwrite === false) {
					throw new Error('Object already exists');
				} else {
					data.splice(previousIndex = index[id], 1);
					defaultDestination = previousIndex;
				}
			} else {
				defaultDestination = this.defaultNewToStart ? 0 : data.length;
			}

			var destination;
			if ('beforeId' in options) {
				var beforeId = options.beforeId;

				if (beforeId === null) {
					destination = data.length;
				} else {
					destination = index[beforeId];

					// Account for the removed item
					if (previousIndex < destination) {
						--destination;
					}
				}

				if (destination !== undefined) {
					event.beforeId = beforeId;
				} else {
					console.error('options.beforeId was specified but no corresponding index was found');
					destination = defaultDestination;
				}
			} else {
				destination = defaultDestination;
			}
			data.splice(destination, 0, object);

			// the fullData has been changed, so the index needs updated
			var i = isFinite(previousIndex) ? Math.min(previousIndex, destination) : destination;
			for (var l = data.length; i < l; ++i) {
				index[this.getIdentity(data[i])] = i;
			}

			this.emit(eventType, event);

			return object;
		},
		addSync: function (object, options) {
			// summary:
			//		Creates an object, throws an error if the object already exists
			// object: Object
			//		The object to store.
			// options: dstore/Store.PutDirectives?
			//		Additional metadata for storing the data.  Includes an 'id'
			//		property if a specific id is to be used.
			// returns: Number
			(options = options || {}).overwrite = false;
			// call put with overwrite being false
			return this.putSync(object, options);
		},
		removeSync: function (id) {
			// summary:
			//		Deletes an object by its identity
			// id: Number
			//		The identity to use to delete the object
			// returns: Boolean
			//		Returns true if an object was removed, falsy (undefined) if no object matched the id
			var storage = this.storage;
			var index = storage.index;
			var data = storage.fullData;
			if (id in index) {
				var removed = data.splice(index[id], 1)[0];
				// now we have to reindex
				this._reindex();
				this.emit('delete', {id: id, target: removed});
				return true;
			}
		},
		setData: function (data) {
			// summary:
			//		Sets the given data as the source for this store, and indexes it
			// data: Object[]
			//		An array of objects to use as the source of data. Note that this
			//		array will not be copied, it is used directly and mutated as
			//		data changes.

			if (this.parse) {
				data = this.parse(data);
			}
			if (data.items) {
				// just for convenience with the data format ItemFileReadStore expects
				this.idProperty = data.identifier || this.idProperty;
				data = data.items;
			}
			var storage = this.storage;
			storage.fullData = this.data = data;
			this._reindex();
		},

		_reindex: function () {
			var storage = this.storage;
			var index = storage.index = {};
			var data = storage.fullData;
			var Model = this.Model;
			var ObjectPrototype = Object.prototype;
			for (var i = 0, l = data.length; i < l; i++) {
				var object = data[i];
				if (Model && !(object instanceof Model)) {
					var restoredObject = this._restore(object,
							// only allow mutation if it is a plain object
							// (which is generally the expected input),
							// if "typed" objects are actually passed in, we will
							// respect that, and leave the original alone
							object.__proto__ === ObjectPrototype);
					if (object !== restoredObject) {
						// a new object was generated in the restoration process,
						// so we have to update the item in the data array.
						data[i] = object = restoredObject;
					}
				}
				index[this.getIdentity(object)] = i;
			}
			storage.version++;
		},

		fetchSync: function () {
			var data = this.data;
			if (!data || data._version !== this.storage.version) {
				// our data is absent or out-of-date, so we requery from the root
				// start with the root data
				data = this.storage.fullData;
				var queryLog = this.queryLog;
				// iterate through the query log, applying each querier
				for (var i = 0, l = queryLog.length; i < l; i++) {
					data = queryLog[i].querier(data);
				}
				// store it, with the storage version stamp
				data._version = this.storage.version;
				this.data = data;
			}
			return new QueryResults(data);
		},

		fetchRangeSync: function (kwArgs) {
			var data = this.fetchSync(),
				start = kwArgs.start,
				end = kwArgs.end;
			return new QueryResults(data.slice(start, end), {
				totalLength: data.length
			});
		},

		_includePropertyInSubCollection: function (name) {
			return name !== 'data' && this.inherited(arguments);
		}
	});
});

define('dstore/Tree',[
	'dojo/_base/declare'
	/*=====, 'dstore/Store'=====*/
], function (declare /*=====, Store=====*/) {
	return declare(null, {
		constructor: function () {
			this.root = this;
		},

		mayHaveChildren: function (object) {
			// summary:
			//		Check if an object may have children
			// description:
			//		This method is useful for eliminating the possibility that an object may have children,
			//		allowing collection consumers to determine things like whether to render UI for child-expansion
			//		and whether a query is necessary to retrieve an object's children.
			// object:
			//		The potential parent
			// returns: boolean

			return 'hasChildren' in object ? object.hasChildren : true;
		},

		getRootCollection: function () {
			// summary:
			//		Get the collection of objects with no parents
			// returns: dstore/Store.Collection

			return this.root.filter({ parent: null });
		},

		getChildren: function (object) {
			// summary:
			//		Get a collection of the children of the provided parent object
			// object:
			//		The parent object
			// returns: dstore/Store.Collection

			return this.root.filter({ parent: this.getIdentity(object) });
		}
	});
});

define('dojo/promise/all',[
	"../_base/array",
	"../Deferred",
	"../when"
], function(array, Deferred, when){
	"use strict";

	// module:
	//		dojo/promise/all

	var some = array.some;

	return function all(objectOrArray){
		// summary:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected.
		// description:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected. If one of
		//		the promises is rejected, the returned promise is also rejected. Canceling
		//		the returned promise will *not* cancel any passed promises.
		// objectOrArray: Object|Array?
		//		The promise will be fulfilled with a list of results if invoked with an
		//		array, or an object of results when passed an object (using the same
		//		keys). If passed neither an object or array it is resolved with an
		//		undefined value.
		// returns: dojo/promise/Promise

		var object, array;
		if(objectOrArray instanceof Array){
			array = objectOrArray;
		}else if(objectOrArray && typeof objectOrArray === "object"){
			object = objectOrArray;
		}

		var results;
		var keyLookup = [];
		if(object){
			array = [];
			for(var key in object){
				if(Object.hasOwnProperty.call(object, key)){
					keyLookup.push(key);
					array.push(object[key]);
				}
			}
			results = {};
		}else if(array){
			results = [];
		}

		if(!array || !array.length){
			return new Deferred().resolve(results);
		}

		var deferred = new Deferred();
		deferred.promise.always(function(){
			results = keyLookup = null;
		});
		var waiting = array.length;
		some(array, function(valueOrPromise, index){
			if(!object){
				keyLookup.push(index);
			}
			when(valueOrPromise, function(value){
				if(!deferred.isFulfilled()){
					results[keyLookup[index]] = value;
					if(--waiting === 0){
						deferred.resolve(results);
					}
				}
			}, deferred.reject);
			return deferred.isFulfilled();
		});
		return deferred.promise;	// dojo/promise/Promise
	};
});

define('dstore/Trackable',[
	'dojo/_base/lang',
	'dojo/_base/declare',
	'dojo/aspect',
	'dojo/when',
	'dojo/promise/all',
	'dojo/_base/array',
	'dojo/on'
	/*=====, './api/Store' =====*/
], function (lang, declare, aspect, when, whenAll, arrayUtil, on /*=====, Store =====*/) {

	// module:
	//		dstore/Trackable
	var revision = 0;

	function createRange(newStart, newEnd) {
		return {
			start: newStart,
			count: newEnd - newStart
		};
	}

	function registerRange(ranges, newStart, newEnd) {
		for (var i = ranges.length - 1; i >= 0; --i) {
			var existingRange = ranges[i],
				existingStart = existingRange.start,
				existingEnd = existingStart + existingRange.count;

			if (newStart > existingEnd) {
				// existing range completely precedes new range. we are done.
				ranges.splice(i + 1, 0, createRange(newStart, newEnd));
				return;
			} else if (newEnd >= existingStart) {
				// the ranges overlap and must be merged into a single range
				newStart = Math.min(newStart, existingStart);
				newEnd = Math.max(newEnd, existingEnd);
				ranges.splice(i, 1);
			}
		}

		ranges.unshift(createRange(newStart, newEnd));
	}

	function unregisterRange(ranges, start, end) {
		for (var i = 0, range; (range = ranges[i]); ++i) {
			var existingStart = range.start,
				existingEnd = existingStart + range.count;

			if (start <= existingStart) {
				if (end >= existingEnd) {
					// The existing range is within the forgotten range
					ranges.splice(i, 1);
				} else {
					// The forgotten range overlaps the beginning of the existing range
					range.start = end;
					range.count = existingEnd - range.start;

					// Since the forgotten range ends before the existing range,
					// there are no more ranges to update, and we are done
					return;
				}
			} else if (start < existingEnd) {
				if (end > existingStart) {
					// The forgotten range is within the existing range
					ranges.splice(i, 1, createRange(existingStart, start), createRange(end, existingEnd));

					// We are done because the existing range bounded the forgotten range
					return;
				} else {
					// The forgotten range overlaps the end of the existing range
					range.count = start - range.start;
				}
			}
		}
	}

	var trackablePrototype = {
		track: function () {
			var store = this.store || this;

			// monitor for updates by listening to these methods
			var handles = [];
			var eventTypes = {add: 1, update: 1, 'delete': 1};
			// register to listen for updates
			for (var type in eventTypes) {
				handles.push(
					this.on(type, (function (type) {
						return function (event) {
							notify(type, event);
						};
					})(type))
				);
			}

			function makeFetch() {
				return function () {
					var self = this;
					var fetchResults = this.inherited(arguments);
					when(fetchResults, function (results) {
						results = self._results = results.slice();
						if (self._partialResults) {
							// clean this up, as we don't need this anymore
							self._partialResults = null;
						}
						self._ranges = [];
						registerRange(self._ranges, 0, results.length);
					});
					return fetchResults;
				};
			}
			function makeFetchRange() {
				return function (kwArgs) {
					var self = this,
						start = kwArgs.start,
						end = kwArgs.end,
						fetchResults = this.inherited(arguments);
					// only use this if we don't have all the data
					if (!this._results) {
						when(fetchResults, function (results) {
							return when(results.totalLength, function (totalLength) {
								var partialResults = self._partialResults || (self._partialResults = []);
								end = Math.min(end, start + results.length);

								partialResults.length = totalLength;

								// copy the new ranged data into the parent partial data set
								var spliceArgs = [ start, end - start ].concat(results);
								partialResults.splice.apply(partialResults, spliceArgs);
								registerRange(self._ranges, start, end);

								return results;
							});
						});
					}
					return fetchResults;
				};
			}

			// delegate rather than call _createSubCollection because we are not ultimately creating
			// a new collection, just decorating an existing collection with item index tracking.
			// If we use _createSubCollection, it will return a new collection that may exclude
			// important, defining properties from the tracked collection.
			var observed = declare.safeMixin(lang.delegate(this), {
				_ranges: [],

				fetch: makeFetch(),
				fetchRange: makeFetchRange(),

				releaseRange: function (start, end) {
					if (this._partialResults) {
						unregisterRange(this._ranges, start, end);

						for (var i = start; i < end; ++i) {
							delete this._partialResults[i];
						}
					}
				},

				on: function (type, listener) {
					var self = this,
						inheritedOn = this.getInherited(arguments);
					return on.parse(observed, type, listener, function (target, type) {
						return type in eventTypes ?
							aspect.after(observed, 'on_tracked' + type, listener, true) :
							inheritedOn.call(self, type, listener);
					});
				},

				tracking: {
					remove: function () {
						while (handles.length > 0) {
							handles.pop().remove();
						}

						this.remove = function () {};
					}
				},
				// make sure track isn't called twice
				track: null
			});
			if (this.fetchSync) {
				// only add these if we extending a sync-capable store
				declare.safeMixin(observed, {
					fetchSync: makeFetch(),
					fetchRangeSync: makeFetchRange()
				});

				// we take the presence of fetchSync to indicate that the results can be
				// retrieved cheaply, and then we can just automatically fetch and start
				// tracking results
				observed.fetchSync();
			}

			// Create a function that applies all queriers in the query log
			// in order to determine whether a new or updated item belongs
			// in the results and at what position.
			var queryExecutor;
			arrayUtil.forEach(this.queryLog, function (entry) {
				var existingQuerier = queryExecutor,
					querier = entry.querier;

				if (querier) {
					queryExecutor = existingQuerier
						? function (data) { return querier(existingQuerier(data)); }
						: querier;
				}
			});

			var defaultEventProps = {
					'add': { index: undefined },
					'update': { previousIndex: undefined, index: undefined },
					'delete': { previousIndex: undefined }
				},
				findObject = function (data, id, start, end) {
					start = start !== undefined ? start : 0;
					end = end !== undefined ? end : data.length;
					for (var i = start; i < end; ++i) {
						if (store.getIdentity(data[i]) === id) {
							return i;
						}
					}
					return -1;
				};

			function notify(type, event) {

				revision++;
				var target = event.target;
				event = lang.delegate(event, defaultEventProps[type]);

				when(observed._results || observed._partialResults, function (resultsArray) {
					/* jshint maxcomplexity: 32 */

					function emitEvent() {
						// TODO: Eventually we will want to aggregate all the listener events
						// in an event turn, but we will wait until we have a reliable, performant queueing
						// mechanism for this (besides setTimeout)
						var method = observed['on_tracked' + type];
						method && method.call(observed, event);
					}

					if (!resultsArray) {
						// without data, we have no way to determine the indices effected by the change,
						// so just pass along the event and return.
						emitEvent();
						return;
					}

					var i, j, l, ranges = observed._ranges, range;
					/*if(++queryRevision != revision){
						throw new Error('Query is out of date, you must observe() the' +
						' query prior to any data modifications');
					}*/

					var targetId = 'id' in event ? event.id : store.getIdentity(target);
					var removedFrom = -1,
						removalRangeIndex = -1,
						insertedInto = -1,
						insertionRangeIndex = -1;
					if (type === 'delete' || type === 'update') {
						// remove the old one
						for (i = 0; removedFrom === -1 && i < ranges.length; ++i) {
							range = ranges[i];
							for (j = range.start, l = j + range.count; j < l; ++j) {
								var object = resultsArray[j];
								// often ids can be converted strings (if they are used as keys in objects),
								// so we do a coercive equality check
								/* jshint eqeqeq: false */
								if (store.getIdentity(object) == targetId) {
									removedFrom = event.previousIndex = j;
									removalRangeIndex = i;
									resultsArray.splice(removedFrom, 1);

									range.count--;
									for (j = i + 1; j < ranges.length; ++j) {
										ranges[j].start--;
									}

									break;
								}
							}
						}
					}

					if (type === 'add' || type === 'update') {
						if (queryExecutor) {
							// with a queryExecutor, we can determine the correct sorted index for the change

							if (queryExecutor([target]).length) {
								var begin = 0,
									end = ranges.length - 1,
									sampleArray,
									candidateIndex = -1,
									sortedIndex,
									adjustedIndex;
								while (begin <= end && insertedInto === -1) {
									// doing a binary search for the containing range
									i = begin + Math.round((end - begin) / 2);
									range = ranges[i];

									sampleArray = resultsArray.slice(range.start, range.start + range.count);

									if ('beforeId' in event) {
										candidateIndex = event.beforeId === null
											? sampleArray.length
											: findObject(sampleArray, event.beforeId);
									}

									if (candidateIndex === -1) {
										// If the original index came from this range, put back in the original slot
										// so it doesn't move unless it needs to (relying on a stable sort below)
										if (removedFrom >= Math.max(0, range.start - 1)
											&& removedFrom <= (range.start + range.count)) {
											candidateIndex = removedFrom;
										} else {
											candidateIndex = store.defaultNewToStart ? 0 : sampleArray.length;
										}
									}
									sampleArray.splice(candidateIndex, 0, target);

									sortedIndex = arrayUtil.indexOf(queryExecutor(sampleArray), target);
									adjustedIndex = range.start + sortedIndex;

									if (sortedIndex === 0 && range.start !== 0) {
										end = i - 1;
									} else if (sortedIndex >= (sampleArray.length - 1) &&
											adjustedIndex < resultsArray.length) {
										begin = i + 1;
									} else {
										insertedInto = adjustedIndex;
										insertionRangeIndex = i;
									}
								}
								if (insertedInto === -1 && begin > 0 && begin < ranges.length) {
									var betweenRanges = true;
								}
							}
						} else {
							// we don't have a queryExecutor, so we can't provide any information
							// about where it was inserted or moved to. If it is an update, we leave
							// its position alone. otherwise, we at least indicate a new object

							var range,
								possibleRangeIndex = -1;
							if ('beforeId' in event) {
								if (event.beforeId === null) {
									insertedInto = resultsArray.length;
									possibleRangeIndex = ranges.length - 1;
								} else {
									for (i = 0, l = ranges.length; insertionRangeIndex === -1 && i < l; ++i) {
										range = ranges[i];

										insertedInto = findObject(
											resultsArray,
											event.beforeId,
											range.start,
											range.start + range.count
										);

										if (insertedInto !== -1) {
											insertionRangeIndex = i;
										}
									}
								}
							} else {
								if (type === 'update') {
									insertedInto = removedFrom;
									insertionRangeIndex = removalRangeIndex;
								} else {
									if (store.defaultNewToStart) {
										insertedInto = 0;
										possibleRangeIndex = 0;
									} else {
										// default to the bottom
										insertedInto = resultsArray.length;
										possibleRangeIndex = ranges.length - 1;
									}
								}
							}

							if (possibleRangeIndex !== -1 && insertionRangeIndex === -1) {
								range = ranges[possibleRangeIndex];
								if (range && range.start <= insertedInto
									&& insertedInto <= (range.start + range.count)) {
									insertionRangeIndex = possibleRangeIndex;
								}
							}
						}

						// an item only truly has a known index if it is in a known range
						if (insertedInto > -1 && insertionRangeIndex > -1) {
							event.index = insertedInto;
							resultsArray.splice(insertedInto, 0, target);

							// update the count and start of the appropriate ranges
							ranges[insertionRangeIndex].count++;
							for (i = insertionRangeIndex + 1; i < ranges.length; ++i) {
								ranges[i].start++;
							}
						} else if (betweenRanges) {
							// the begin index will be after the inserted item, and is
							// where we can begin incrementing start values
							event.beforeIndex = ranges[begin].start;
							for (i = begin; i < ranges.length; ++i) {
								ranges[i].start++;
							}
						}
					}
					// update the total
					event.totalLength = resultsArray.length;

					emitEvent();
				});
			}

			return observed;
		}
	};

	var Trackable =  declare(null, trackablePrototype);

	Trackable.create = function (target, properties) {
		// create a delegate of an existing store with trackability functionality mixed in
		target = declare.safeMixin(lang.delegate(target), trackablePrototype);
		declare.safeMixin(target, properties);
		return target;
	};
	return Trackable;
});

define('dstore/mainr',[
    "dstore/Memory",
    "dstore/Promised",
    "dstore/QueryMethod",
    "dstore/QueryResults",
    "dstore/SimpleQuery",
    "dstore/Store",
    "dstore/Tree",
    "dstore/Filter",
    "dstore/Trackable"
    //"dstore/legacy/DstoreAdapter"
], function () {

});
define('xide/utils',[
    "dcl/dcl"
], function (dcl) {
    return dcl(null, {
        declaredClass:"xide.utils"
    });
});
/** @module xide/model/Base **/
define('xide/model/Base',[
    'dcl/dcl',
    "dojo/_base/declare",
    "xide/utils"
], function (dcl,declare,utils) {
    
    var Implementation = {
        declaredClass:"xide/model/Base",
        /**
         * Mixin constructor arguments into this.
         * This could have been done in another base class but performance matters
         * @todo use a mixin from lodash
         * @constructor
         */
        constructor: function (args) {
            utils.mixin(this, args);
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Public interface, keep it small and easy
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * Return a human friendly name
         * @abstract
         * @returns {string|null}
         */
        getLabel: function () {
            return null;
        },
        /**
         * Return a unique ID.
         * @abstract
         * @returns {string|null}
         */
        getID: function () {
            return null;
        }
    }

    var Module = declare("xide/model/Base",null,Implementation);
    Module.dcl = dcl(null,Implementation);
    return Module;
});


define('xide/types',[
    "dcl/dcl"
],function(dcl){
    return dcl(null,{
        declaredClass:"xide/types"
    });
});
define('xide/factory',[
],function(){
    return {

    }
});
/** @module xide/mixins/EventedMixin **/
define('xide/mixins/EventedMixin',[
    "dojo/_base/array",
    "dcl/dcl",
    "xdojo/declare",
    "xdojo/has",
    'xide/types',
    'xide/factory'
], function (array,dcl,declare, has, types, factory) {

    var toString = Object.prototype.toString;
    /**
     * Adds convenient functions for events to the consumer, generalizing dojo.subscribe/publish or dojo.on.
     * This mixin can be applied to anything dijit/_Widget based or custom functional classes(needs to call destroy!)
     *
     * Check online-documentation {@link http://rawgit.com/mc007/xjs/dgrid_update/src/lib/xide/out/xide/0.1.1-dev/EventedMixin.html|here}
     *
     * @class module:xide/mixins/EventedMixin
     */
    var Impl = {

        _didRegisterSubscribers:false,

        subscribers:null,
        /**
         * Subscription filter map
         * @type {Object.<string,boolean}
         */
        subscribes: {},
        /**
         * Emit filter map
         * @type {Object.<string,boolean}
         */
        emits: {},
        /**
         * Array of dojo subscribe/on handles, destroyed on this.destroy();
         * @private
         * @type {Object[]}
         */
        __events: null,
        /**
         * Add emit filter
         * @param type
         * @param data
         */
        addPublishFilter:function(type,data){
            if(type){
                if(data!=null){
                    this.emits[type]=data;
                }else if(type in this.emits){
                    delete this.emits[type];
                }
            }
        },
        /**
         * Simple filter function to block subscriptions.
         * @param key
         * @returns {boolean}
         */
        filterSubscribe: function (key) {

            if (this.subscribes) {
                return this.subscribes[key] !== false;
            }
            return true;
        },
        /**
         * Simple filter function to block publishing.
         * @param key
         * @returns {boolean}
         */
        filterPublish: function (key) {
            if (this.emits) {
                return this.emits[key] !== false;
            }
            return true;
        },
        /**
         * Subscribe to an event or multiple events. Attention, this is NOT checking for duplicates!
         *
         * @example
         *
         * // widget case with event callback delegation to 'this', code is written inside a custom widget or whatever
         * // class subclassing from this mixin:
         * // pre-requisites for dijit/dojox widgets: lang.extend(dijit.Button,EventedMixin.prototype);
         *
         * //simple example #1
         * var button = new dijit.Button({});
         * button.subscribe('click',this.onButtonClick,this);//calls this.onButtonClick with scope this
         *
         * //simple example #2
         * var button = new dijit.Button({});
         * button.subscribe('click',null,this);//calls this.click with scope this
         *
         * //multi-event example #1
         * var button = new dijit.Button({});
         * button.subscribe(['click','dblclick'],null,this);//calls this.click and this.dblclick with scope this
         *
         * // custom events (using dojo-publish/subscribe or dojo.topic)
         * // assuming you want listen to the events of dijit/layout/TabContainer or any other StackContainer. Notice,
         * // that stack-containers will publish events like this: topic.publish(this.id + "-removeChild", page);
         *
         * var tabContainerId = 'tabContainer';
         *
         * this.subscribe(tabContainerId + 'addChild',this.childAdded);//notice that the scope is set here automatically!
         *
         * //multi-event version, this will call this['tabContainerId-addChild'] and this['tabContainerId-removeChild']
         *
         * this.subscribe([tabContainerId + 'addChild',tabContainerId + 'removeChild']);
         *
         *
         *
         *
         *
         *
         * @param keys {String|String[]} : The event key(s), given as single string or an array of strings, holding all
         * event keys for publishing multiple events in one row.
         *
         * @param cb {Function} : callback, by the default the callback's scope will 'this'
         *
         * @param to {Object} : override 'this' scope to something else
         */
        subscribe: function (keys, cb, to) {
            if (!this.__events) {
                this.__events = {};
            }
            var self = this,
                events = factory.subscribe(keys, cb, to || self, self.filterSubscribe.bind(self)),
                container = self.__events;

            //replay on local tracking map
            for(var i=0, l=events.length; i<l ; i++){
                var _type = events[i].type;
                if(!container[_type]){
                    container[_type]=[];
                }
                container[_type].push(events[i]);
            }
            return events;

        },
        /**
         * Publish an event (uses dojo.publish)
         *
         * @param keys {String|String[]} : The event key, given as string or array for publishing multiple events in one row
         *
         * @param data {Object|null} : The actual event data.
         *
         * @param from {Object|null} : Send event 'as' this source. By default, its using 'this' as sender.
         *
         * @param delay {Number|null} : Send event with a delay, otherwise call now
         *
         */
        publish: function (keys, data, from, delay) {
            var self = this;
            if (delay > 0) {
                setTimeout(function () {
                    factory.publish(keys, data, from || self, self.filterPublish.bind(self));
                }.bind(self), delay);
            } else {
                factory.publish(keys, data, from || self, self.filterPublish.bind(self));
            }
        },
        /**
         * @TODO: deal with unsubscribe in _EventedMixin
         * @param key
         * @private
         */
        _destroyHandle: function (key) {},
        /**
         * Turns the lights off, kills all event handles.
         * @private
         * @returns void
         */
        _destroyHandles: function () {
            if (this.__events) {
                for(var type in this.__events){
                    array.forEach(this.__events[type], function(item){
                        if(item && item.remove){
                            item.remove();
                        }
                    });
                }
                delete this.__events;
            }
        },
        /**
         * When using subscribe, all event subscription handles are stored in this.__events.
         * This function will remove all the event handles, using this._destroyHandles()
         */
        destroy: function () {
            this.inherited && this.inherited(arguments);
            this._destroyHandles();
        },
        /**
         * Adds a one time listener for the event. This listener is invoked only the
         * next time the event is fired, after which it is removed.
         *
         * @name emitter.once(event, listener)
         * @param {String} event- The event name/id to listen for
         * @param {Function} listener - The function to bind to the event
         * @api public
         *
         * ```javascript
         * db.once('unauthorized', function (req) {
         *     // this event listener will fire once, then be unbound
         * });
         * ```
         */
        once : function(type, listener) {
            var self = this;
            function wrapped() {
                self.unsubscribe(type, listener);
                return listener.apply(self, arguments);
            }
            wrapped.listener = listener;
            self._on(type, wrapped);
            return this;
        },
        /**
         * Execute each of the listeners in order with the supplied arguments.
         *
         * @name emitter.emit(event, [arg1], [arg2], [...])
         * @param {String} event - The event name/id to fire
         * @api public
         */
        _emit:function(type) {
            if (!this.__events)
                return;

            if(!this._didRegisterSubscribers && this.subscribers){
                for(var i=0;i<this.subscribers.length ; i++){
                    var subscriber = this.subscribers[i];
                    this._on(subscriber.event,subscriber.handler,subscriber.owner);
                }
                this._didRegisterSubscribers = true;
            }

            if (arguments[2] === true)
                throw new Error("Please use emit.sticky() instead of passing sticky=true for event: " + type);

            var handler = this.__events[type],
                eventArgs = arguments.length>1 ? arguments[2] : null;

            if (!handler)
                return;

            var returnValue;

            if (typeof handler == 'function') {
                switch (arguments.length) {
                    // fast cases
                    case 1:
                        return handler.call(this);
                    case 2:
                        return handler.call(this, arguments[1]);
                    case 3:
                        return handler.call(this, arguments[1], arguments[2]);
                    // slower
                    default:
                        var args = Array.prototype.slice.call(arguments, 1);
                        returnValue = handler.apply(this, args);
                }
            }

            else if (_.isArray(handler)) {
                var args = Array.prototype.slice.call(arguments, 1);
                var listeners = handler.slice(), temp;
                var _listener = null;
                var who = null;

                for (var i = 0, l = listeners.length; i < l; i++) {

                    _listener = listeners[i];
                    who = _listener.owner|| this;
                    args && args[0] && (args[0].owner =args[0] ? args[0].owner || who : null);
                    temp = _listener.handler.apply(who, args);
                    if (temp !== undefined)
                        returnValue = temp;
                }
            }

            //forward to global
            eventArgs && eventArgs['public']===true && this.publish(type,args);

            return returnValue;
        },
        /**
         * Remove a listener from the listener array for the specified event. Caution:
         * changes array indices in the listener array behind the listener.
         *
         * @name emitter.removeListener(event, listener)
         * @param {String} event - The event name/id to remove the listener from
         * @param {Function} listener - The listener function to remove
         * @api public
         *
         * ```javascript
         * var callback = function (init) {
         *     console.log('duality app loaded');
         * };
         * devents.on('init', callback);
         * // ...
         * devents.removeListener('init', callback);
         * ```
         */
        unsubscribe:function(type,listener){

            // does not use listeners(), so no side effect of creating __events[type]
            if (!this.__events || !this.__events[type]) return this;

            // no listener given, unsubscribe all per type
            if (('function' !== typeof listener || !listener)) {
                array.forEach(this.__events[type], dojo.unsubscribe);
                delete this.__events[type];
                this.__events[type] = [];
                return this;
            }
            var list = this.__events[type];
            if (_.isArray(list)) {
                var _remove =[];
                _.each(list,function(handle,a,b){
                    var which= handle.handler == listener ? handle.handler : handle.handler.listener == listener ? handle.handler.listener : null;
                    if(which) {
                        _remove.push(handle);
                    }
                });
                _.each(_remove,function(handler){
                    handler.remove();
                });

                /*
                if (!list.some(function(l, i){
                    if ((l.listener || l) == listener) {
                        list.splice(i, 1);
                        return true;
                    }
                    }));
                return this;
                */
                if (list.length === 0) {
                    delete this.__events[type];
                }
            }else if ((this.__events[type].listener || this.__events[type]) === listener) {
                delete this.__events[type];
            }

            //if (type != "removeListener") {
            //    this.emit('removeListener', type, listener);
            //}

            return this;
        },
        /**
         * Returns an array of listeners for the specified event. This array can be
         * manipulated, e.g. to remove listeners.
         *
         * @name emitter.listeners(event)
         * @param {String} events - The event name/id to return listeners for
         * @api public
         *
         * ```javascript
         * session.on('change', function (stream) {
         *     console.log('session changed');
         * });
         * console.log(util.inspect(session.listeners('change'))); // [ [Function] ]
         * ```
         */
        listeners:function(type) {
            if (!this.__events) this.__events = {};
            if (!this.__events[type]) this.__events[type] = [];
            if (!isArray(this.__events[type])) {
                this.__events[type] = [this.__events[type]];
            }
            return this.__events[type];
        },
        /**
         *
         * @param type
         * @param handle
         * @returns {*}
         */
        addHandle:function(type,handle){
            if(!this.__events){
                this.__events = {}
            }
            if(!this.__events[type]){
                this.__events[type]=[];
            }
            handle.type = type;
            this.__events[type].push(handle);
            return handle;
        },
        /**
         * jQuery sub
         * @param element
         * @param type
         * @param selector
         * @param handler
         * @returns {{handler: *, owner: (exports|module.exports|module:xide/mixins/EventedMixin), type: *, element: (*|jQuery|HTMLElement), selector: *, remove: _handle.remove}}
         */
        __on:function(element,type,selector,handler){

            var _handler = handler;

            if(typeof selector =='function' && !handler){
                //no selector given
                handler = selector;
                selector = null;
            }

            element = element.jquery ? element : $(element);
            element.on(type,selector,handler);

            if (!this.__events) this.__events = {};
            if (!this.__events[type]) {
                this.__events[type] = [];
            }
            var eventList = this.__events[type];
            var _handle = {
                handler: _handler,
                owner: this,
                type: type,
                element:element,
                selector:selector,
                remove: function () {
                    eventList.remove(this);
                    this.element.off(this.type,this.selector,this.handler);
                }
            };
            eventList.push(_handle);
            return _handle;

        },
        /**
         * Dojo based sub
         * @param type
         * @param listener
         * @param owner
         * @returns {*}
         * @private
         */
        _on: function(type, listener,owner) {
            try {
                if (!this.__events) this.__events = {};

                if (!this.__events[type]) {
                    this.__events[type] = [];
                }

                var eventList = this.__events[type];

                if (!eventList) {
                    // Optimize the case of one listener. Don't need the extra array object.
                    this.__events[type] = listener;
                }
                else if (_.isArray(eventList)) {

                    if (eventList.indexOf(listener) != -1)
                       return console.warn("adding same listener twice", type);

                    // If we've already got an array, just append.
                    var _handle = {
                        handler: listener,
                        owner: owner || this,
                        type: type,
                        remove: function () {
                            eventList.remove(this);
                            this.owner = null;
                            this.handler = null;
                            delete this.type;
                        }
                    };
                    eventList.push(_handle);
                    return _handle;
                }
            }catch(e){
                logError(e);
            }
            return this;
        }
    };

    //package via declare
    var Module = declare(null, Impl);
    //static access to Impl.
    Module.Impl = Impl;
    Module.dcl = dcl(null,Impl);
    dcl.chainAfter(Module.dcl,'destroy');
    return Module;
});


/** @module xide/mixins/ReloadMixin **/
define('xide/mixins/ReloadMixin',[
    "xdojo/declare",
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    'xide/mixins/EventedMixin'
], function (declare,dcl,types, utils,EventedMixin) {

    /**
     * Mixin which adds functions for module reloading to the consumer. All functions
     * of the reloaded module will be overridden with the re-loaded module's version.
     * Recommended: turn off web-cache and use turn on 'cacheBust' in your Dojo-Config.
     *
     *
     *  <b>Usage</b> :
     *  1. call initReload manually (subscribes to types.EVENTS.ON_MODULE_RELOADED which is triggered by module:xide/manager/Context )
     *  2. that's it actually.
     *  3. optionally add a function 'onReloaded' to your sub class and refresh yourself, ie: re-create widgets or simply test
     *  a piece of code
     *
     *
     * @mixin module:xide/mixins/ReloadMixin
     * @requires module:xide/mixins/EventedMixin
     */
    var Impl = {
        /**
         *
         * Not used yet, but at @TODO: some flags to describe the hot-replace for reloaded modules
         *
         */
        _mergeFunctions: true,
        _mergeMissingVariables: true,
        /**
         * Cross instanceOf equal check, tries:
         *
         *  1. native
         *  2. Dojo::isInstanceOf
         *  3. baseClasses
         *
         * @param cls {Object}
         * @returns {boolean}
         */
        isInstanceOf_: function (cls) {

            try {

                //Try native and then Dojo declare's _Stateful::isInstanceOf
                if (!!this instanceof cls
                    || (this.isInstanceOf && this.isInstanceOf(cls))) {

                    return true;

                }else{

                    //manual lookup, browse all base classes and their superclass
                    var bases = utils.getAt(this, 'constructor._meta.bases', []),//save get, return base::at[path] or empty array
                        _clsClass = cls.prototype.declaredClass;    //cache

                    //save space
                    return _.findWhere(bases, function (_base) {

                        return _base == cls    //direct cmp
                        || utils.getAt(_base, 'superclass.declaredClass') === _clsClass   //mostly here
                        || utils.getAt(_base, 'prototype.declaredClass') === _clsClass;    //sometimes

                    });

                }

            } catch (e) {
                //may crash, no idea why!
                console.log('ReloadMixin :: this.isInstanceOf_ crashed ' + e);
            }

            return false;

        },
        /**
         * @TODO: use flag guarded mixin
         *
         * @param target
         * @param source
         */
        mergeFunctions: function (target, source) {
            for (var i in source) {
                var o = source[i];
                if (i === 'constructor' || i === 'inherited') {
                    continue;
                }
                if (_.isFunction(source[i])) {
                    target[i] = null;//be nice
                    target[i] = source[i];//override
                }
                //support missing properties
                if (_.isArray(source[i])) {
                    if (target[i] == null) {
                        target[i] = source[i];
                    }
                }
            }
        },
        /**
         * Event callback for xide/types/EVENTS/ON_MODULE_RELOADED when a module has been reloaded.
         * @member
         * @param evt
         */
        onModuleReloaded: function (evt) {
            var newModule = evt.newModule;
            if (!newModule || !newModule.prototype || evt._processed) {
                return;
            }
            var moduleProto = newModule.prototype,
                moduleClass = moduleProto.declaredClass,
                matchedByClass = false,
                thisClass = this.declaredClass,
                thiz=this;

            if(!moduleClass){
                return;
            }
            if (moduleClass && thisClass) {
                //determine by dotted normalized declaredClass
                matchedByClass = utils.replaceAll('/', '.', thisClass) === utils.replaceAll('/', '.', moduleClass);
            }
            if (matchedByClass) {
                thiz.mergeFunctions(thiz, moduleProto);
                if (thiz.onReloaded) {
                    evt._processed = true;
                    thiz.onReloaded(newModule);
                }
            } else if (evt.module && utils.replaceAll('//', '/', evt.module) === thisClass) {//not sure this needed left
                //dcl module!
                thiz.mergeFunctions(thiz, moduleProto);
            }
        },
        /**
         * Public entry; call that in your sub-class to init this functionality!
         */
        initReload: function () {
            this.subscribe(types.EVENTS.ON_MODULE_RELOADED);
        }
    };

    //package via declare
    var _class = declare(null,Impl);

    //static access to Impl.
    _class.Impl = Impl;

    _class.dcl = dcl(EventedMixin.dcl,Impl);

    return _class;

});
/** @module xide/model/Component **/
define('xide/model/Component',[
    "dojo/_base/declare",
    "dojo/Deferred",
    "dojo/has",
    "require",
    "xide/model/Base",
    "xide/types",
    "xide/mixins/EventedMixin",
    "xide/mixins/ReloadMixin"
], function (declare, Deferred, has, require, Base, types, EventedMixin, ReloadMixin) {
    /**
     * COMPONENT_FLAGS is a number of flags being used for the component's instance creation. Use an object instead of
     * an integer, never know how big this becomes and messing with 64bit integers doesn't worth the effort.
     *
     * @enum module:xide/types/COMPONENT_FLAGS
     * @memberOf module:xide/types
     * @extends xide/types
     */
    types.COMPONENT_FLAGS = {
        /**
         * Due the object instantiation, instruct the component loader to call ::load()
         * @constant
         */
        LOAD: 1,
        /**
         * Due the object instantiation, instruct the component loader to call ::run()
         * @constant
         */
        RUN: 1
    };

    /**
     *
     *
     * @class xide/model/Component
     *
     * @augments xide/mixins/EventedMixin
     * @augments xide/mixins/ReloadMixin
     * @extends xide/model/Base
     */
    return declare("xide/model/Component", [Base, EventedMixin, ReloadMixin], {
        /**
         * Flag indicating that all dependencies are fully loaded
         * @type {boolean}
         * @default false
         */
        _loaded: false,
        /**
         * Pointer to a context, filled by the component loader
         * @member module:xide/manager/Context
         */
        ctx: null,
        /**
         * Pointer to an optional owner
         * @member {Object|null}
         */
        owner: {
            reloadComponent: function () {
            }
        },
        /**
         * Usually a component is about a new beantype.
         * @TODO handle many
         */
        beanType: null,
        /**
         * Array of typical JS packages
         * @member {Array|null} packages
         */
        packages: null,

        /**
         * Array of resources. A components has typically a bunch of resources like CSS.
         * @member {Array} resources
         */
        resources: [],
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Implement base interface
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        getDependencies: function () {
            return [];
        },
        hasEditors: function () {
            return [];
        },
        /**
         * Return a human readable string
         * @returns {string}
         */
        getLabel: function () {
            return "Have no label";
        },
        /**
         * If this component has additional dependencies, load them here!
         * @returns {dojo.Deferred}
         */
        load: function (hasName) {
            var _defered = new Deferred(),
                thiz = this,
                _re = require;

            hasName = hasName || this.getLabel();

            _re(this.getDependencies(), function () {
                thiz._loaded = true;
                if (hasName) {
                    has.add(hasName, function () {
                        return true
                    });
                }
                _defered.resolve();
            });
            return _defered.promise;
        },
        run: function () {
            return false;
        },
        onModuleReloaded: function () {
            this.owner.reloadComponent(this);
        },
        isLoaded: function () {
            return this._loaded;
        }
    });
});


define('xblox/component',[
    "dojo/_base/declare",
    "xdojo/has",
    "xide/model/Component"
], function (declare,has,Component) {
    /**
     * @class xblox.component
     * @inheritDoc
     */
    return declare([Component], {
        /**
         * @inheritDoc
         */
        beanType:'BLOCK',
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Implement base interface
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        _load:function(){
            /*
            var dfd = new Deferred();
            var _re = require,
                thiz = this;//hide from gcc
            _re('xblox/xblox', function () {
                thiz.inherited(arguments).then(function(){
                    dfd.resolve();
                })
            });
            return dfd.promise;
            */
        },
        hasEditors:function(){
            return ['xblox'];
        },
        getDependencies:function(){

            if(has('xblox-ui')) {

                return [
                    'xide/xide',
                    'xblox/types/Types',
                    'xblox/manager/BlockManager',
                    'xblox/manager/BlockManagerUI',
                    'xblox/embedded_ui',
                    'xide/widgets/ExpressionJavaScript',
                    'xide/widgets/Expression',
                    'xide/widgets/RichTextWidget',
                    'xide/widgets/ExpressionEditor',
                    'xide/widgets/WidgetReference'
                    //'xide/widgets/DomStyleProperties',
                    //'xblox/views/BlocksFileEditor'
                    //'xide/widgets/BlockPickerWidget',
                    //'xide/widgets/BlockSettingsWidget'
                ];
            }else{
                return [
                    'xide/xide',
                    'xblox/types/Types',
                    'xblox/manager/BlockManager',
                    'xblox/embedded'
                ];
            }
        },
        /**
         * @inheritDoc
         */
        getLabel: function () {
            return 'xblox';
        },
        /**
         * @inheritDoc
         */
        getBeanType:function(){
            return this.beanType;
        }
    });
});


define('dojo/json',["./has"], function(has){
	"use strict";
	var hasJSON = typeof JSON != "undefined";
	has.add("json-parse", hasJSON); // all the parsers work fine
		// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184
	has.add("json-stringify", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{"a":1}');

	/*=====
	return {
		// summary:
		//		Functions to parse and serialize JSON

		parse: function(str, strict){
			// summary:
			//		Parses a [JSON](http://json.org) string to return a JavaScript object.
			// description:
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Throws for invalid JSON strings. This delegates to eval() if native JSON
			//		support is not available. By default this will evaluate any valid JS expression.
			//		With the strict parameter set to true, the parser will ensure that only
			//		valid JSON strings are parsed (otherwise throwing an error). Without the strict
			//		parameter, the content passed to this method must come
			//		from a trusted source.
			// str:
			//		a string literal of a JSON item, for instance:
			//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
			// strict:
			//		When set to true, this will ensure that only valid, secure JSON is ever parsed.
			//		Make sure this is set to true for untrusted content. Note that on browsers/engines
			//		without native JSON support, setting this to true will run slower.
		},
		stringify: function(value, replacer, spacer){
			// summary:
			//		Returns a [JSON](http://json.org) serialization of an object.
			// description:
			//		Returns a [JSON](http://json.org) serialization of an object.
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Note that this doesn't check for infinite recursion, so don't do that!
			// value:
			//		A value to be serialized.
			// replacer:
			//		A replacer function that is called for each value and can return a replacement
			// spacer:
			//		A spacer string to be used for pretty printing of JSON
			// example:
			//		simple serialization of a trivial object
			//	|	define(["dojo/json"], function(JSON){
			// 	|		var jsonStr = JSON.stringify({ howdy: "stranger!", isStrange: true });
			//	|		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
		}
	};
	=====*/

	if(has("json-stringify")){
		return JSON;
	}else{
		var escapeString = function(/*String*/str){
			// summary:
			//		Adds escape sequences for non-visual characters, double quote and
			//		backslash and surrounds with double quotes to form a valid string
			//		literal.
			return ('"' + str.replace(/(["\\])/g, '\\$1') + '"').
				replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").
				replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r"); // string
		};
		return {
			parse: has("json-parse") ? JSON.parse : function(str, strict){
				if(strict && !/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(str)){
					throw new SyntaxError("Invalid characters in JSON");
				}
				return eval('(' + str + ')');
			},
			stringify: function(value, replacer, spacer){
				var undef;
				if(typeof replacer == "string"){
					spacer = replacer;
					replacer = null;
				}
				function stringify(it, indent, key){
					if(replacer){
						it = replacer(key, it);
					}
					var val, objtype = typeof it;
					if(objtype == "number"){
						return isFinite(it) ? it + "" : "null";
					}
					if(objtype == "boolean"){
						return it + "";
					}
					if(it === null){
						return "null";
					}
					if(typeof it == "string"){
						return escapeString(it);
					}
					if(objtype == "function" || objtype == "undefined"){
						return undef; // undefined
					}
					// short-circuit for objects that support "json" serialization
					// if they return "self" then just pass-through...
					if(typeof it.toJSON == "function"){
						return stringify(it.toJSON(key), indent, key);
					}
					if(it instanceof Date){
						return '"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'.replace(/\{(\w+)(\+)?\}/g, function(t, prop, plus){
							var num = it["getUTC" + prop]() + (plus ? 1 : 0);
							return num < 10 ? "0" + num : num;
						});
					}
					if(it.valueOf() !== it){
						// primitive wrapper, try again unwrapped:
						return stringify(it.valueOf(), indent, key);
					}
					var nextIndent= spacer ? (indent + spacer) : "";
					/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ 
				
					var sep = spacer ? " " : "";
					var newLine = spacer ? "\n" : "";
				
					// array
					if(it instanceof Array){
						var itl = it.length, res = [];
						for(key = 0; key < itl; key++){
							var obj = it[key];
							val = stringify(obj, nextIndent, key);
							if(typeof val != "string"){
								val = "null";
							}
							res.push(newLine + nextIndent + val);
						}
						return "[" + res.join(",") + newLine + indent + "]";
					}
					// generic object code path
					var output = [];
					for(key in it){
						var keyStr;
						if(it.hasOwnProperty(key)){
							if(typeof key == "number"){
								keyStr = '"' + key + '"';
							}else if(typeof key == "string"){
								keyStr = escapeString(key);
							}else{
								// skip non-string or number keys
								continue;
							}
							val = stringify(it[key], nextIndent, key);
							if(typeof val != "string"){
								// skip non-serializable values
								continue;
							}
							// At this point, the most non-IE browsers don't get in this branch 
							// (they have native JSON), so push is definitely the way to
							output.push(newLine + nextIndent + keyStr + ":" + sep + val);
						}
					}
					return "{" + output.join(",") + newLine + indent + "}"; // String
				}
				return stringify(value, "", "");
			}
		};
	}
});

define('dojo/_base/json',["./kernel", "../json"], function(dojo, json){

// module:
//		dojo/_base/json

/*=====
return {
	// summary:
	//		This module defines the dojo JSON API.
};
=====*/

dojo.fromJson = function(/*String*/ js){
	// summary:
	//		Parses a JavaScript expression and returns a JavaScript value.
	// description:
	//		Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
	//		always delegates to eval(). The content passed to this method must therefore come
	//		from a trusted source.
	//		It is recommend that you use dojo/json's parse function for an
	//		implementation uses the (faster) native JSON parse when available.
	// js:
	//		a string literal of a JavaScript expression, for instance:
	//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`

	return eval("(" + js + ")"); // Object
};

/*=====
dojo._escapeString = function(){
	// summary:
	//		Adds escape sequences for non-visual characters, double quote and
	//		backslash and surrounds with double quotes to form a valid string
	//		literal.
};
=====*/
dojo._escapeString = json.stringify; // just delegate to json.stringify

dojo.toJsonIndentStr = "\t";
dojo.toJson = function(/*Object*/ it, /*Boolean?*/ prettyPrint){
	// summary:
	//		Returns a [JSON](http://json.org) serialization of an object.
	// description:
	//		Returns a [JSON](http://json.org) serialization of an object.
	//		Note that this doesn't check for infinite recursion, so don't do that!
	//		It is recommend that you use dojo/json's stringify function for an lighter
	//		and faster implementation that matches the native JSON API and uses the
	//		native JSON serializer when available.
	// it:
	//		an object to be serialized. Objects may define their own
	//		serialization via a special "__json__" or "json" function
	//		property. If a specialized serializer has been defined, it will
	//		be used as a fallback.
	//		Note that in 1.6, toJson would serialize undefined, but this no longer supported
	//		since it is not supported by native JSON serializer.
	// prettyPrint:
	//		if true, we indent objects and arrays to make the output prettier.
	//		The variable `dojo.toJsonIndentStr` is used as the indent string --
	//		to use something other than the default (tab), change that variable
	//		before calling dojo.toJson().
	//		Note that if native JSON support is available, it will be used for serialization,
	//		and native implementations vary on the exact spacing used in pretty printing.
	// returns:
	//		A JSON string serialization of the passed-in object.
	// example:
	//		simple serialization of a trivial object
	//		|	var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
	//		|	doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
	// example:
	//		a custom serializer for an objects of a particular class:
	//		|	dojo.declare("Furby", null, {
	//		|		furbies: "are strange",
	//		|		furbyCount: 10,
	//		|		__json__: function(){
	//		|		},
	//		|	});

	// use dojo/json
	return json.stringify(it, function(key, value){
		if(value){
			var tf = value.__json__||value.json;
			if(typeof tf == "function"){
				return tf.call(value);
			}
		}
		return value;
	}, prettyPrint && dojo.toJsonIndentStr);	// String
};

return dojo;
});

/** @module xide/types
 *  @description All the package's constants and enums in C style structures.
 */
define('xide/types/Types',[
    'dojo/_base/lang',
    'xide/types',
    'dojo/_base/json',
    'dojo/_base/kernel'
], function (lang, types, json, dojo) {
    /**
     * @TODO:
     * - apply xide/registry for types
     * - move mime handling to xfile
     * - remove ui types
     * - remove all other things which are part of ui or server only
     */
    /**
     * Custom CI Types, see ECITYPE enumeration. Each enum is mapped to a widget.
     */
    if (types['customTypes'] == null) {
        types['customTypes'] = {};
    }
    /**
     * ECTYPE_ENUM is mapped to and label-value option array
     */
    if (types['customEnumerations'] == null) {
        types['customEnumerations'] = {};
    }
    /**
     * The actual mapping of custom types to widget proto classes
     */
    if (types['widgetMappings'] == null) {
        types['widgetMappings'] = {};
    }
    /**
     * Mixes in new mime icons per ECITYPE & file extensions. Rendered by FontAwesome
     */
    if (types['customMimeIcons'] == null) {
        types['customMimeIcons'] = {};
    }

    /**
     * Public ECI_TYPE registry getter
     * @param type
     * @returns {*}
     */
    types.resolveType = function (type) {
        if (types['customTypes'][type]) {
            return types['customTypes'][type];
        }
        return null;
    };
    /**
     * Public ECI_TYPE registry setter
     * @param type
     * @param map
     */
    types.registerType = function (type, map) {
        types['customTypes'][type] = map;
    };
    /**
     * Public widget-type registry setter
     * @param type
     * @param map
     */
    types.registerWidgetMapping = function (type, map) {
        types['widgetMappings'][type] = map;
    };
    /**
     * Public custom enum registry setter
     * @param type
     * @param map
     */
    types.registerEnumeration = function (type, map) {
        types['customEnumerations'][type] = map;
    };
    /**
     * Public custom enumeration registry getter
     * @param type
     */
    types.resolveEnumeration = function (type) {
        if (types['customEnumerations'][type]) {
            return types['customEnumerations'][type];
        }
        return null;
    };
    /**
     * Public type-widget mapping registry setter
     * @param type
     */
    types.resolveWidgetMapping = function (type) {
        if (types['widgetMappings'][type]) {
            return types['widgetMappings'][type];
        }
        return null;
    };
    types.GRID_FEATURE = {
        KEYBOARD_NAVIGATION: 'KEYBOARD_NAVIGATION',
        KEYBOARD_SELECT: 'KEYBOARD_SELECT',
        SELECTION: 'SELECTION',
        ACTIONS: 'ACTIONS',
        CONTEXT_MENU: 'CONTEXT_MENU'
    };
    types.VIEW_FEATURE = {
        KEYBOARD_NAVIGATION: 'KEYBOARD_NAVIGATION',
        KEYBOARD_SELECT: 'KEYBOARD_SELECT',
        SELECTION: 'SELECTION',
        ACTIONS: 'ACTIONS',
        CONTEXT_MENU: 'CONTEXT_MENU'
    };
    types.KEYBOARD_PROFILE = {
        DEFAULT: {
            prevent_default: true,
            prevent_repeat: false
        },
        PASS_THROUGH: {
            prevent_default: false,
            prevent_repeat: false
        },
        SEQUENCE: {
            prevent_default: true,
            is_sequence: true,
            prevent_repeat: true
        }
    };
    /////////////////////////////////////////////////////////////////////////////
    //
    // CORE TYPES
    //
    /////////////////////////////////////////////////////////////////////////////
    /**
     * A 'Configurable Information's ("CI") processing state during post or pre-processing.
     *
     * @enum {int} module:xide/types/CI_STATE
     * @memberOf module:xide/types
     */
    types.CI_STATE = {
        /**
         * Nothing done, could also mean there is nothing to do all
         * @constant
         * @type int
         */
        NONE: 0x00000000,
        /**
         * In pending state. At that time the compiler has accepted additional work and ci flag processing is queued
         * but not scheduled yet.
         * @constant
         * @type int
         */
        PENDING: 0x00000001,
        /**
         * The processing state.
         * @constant
         * @type int
         */
        PROCESSING: 0x00000002,
        /**
         * The CI has been processed but it failed.
         * @constant
         * @type int
         */
        FAILED: 0x00000004,
        /**
         * The CI was successfully processed.
         * @constant
         * @type int
         */
        SUCCESSED: 0x00000008,
        /**
         * The CI has been processed.
         * @constant
         * @type int
         */
        PROCESSED: 0x00000010,
        /**
         * The CI left the post/pre processor entirly but has not been accepted by the originating source.
         * This state can happen when the source became invalid and so its sort of orphan.
         * @constant
         * @type int
         */
        DEQUEUED: 0x00000020,
        /**
         * The CI fully resolved and no references except by the source are around.
         * @constant
         * @type int
         */
        SOLVED: 0x00000040,
        /**
         * Flag to mark the core's end of this bitmask, from here its user land
         * @constant
         * @type int
         */
        END: 0x00000080
    }
    /**
     * A 'Configurable Information's ("CI") type flags for post and pre-processing a value.
     * This is user configurable and needs to stay in the in integer limit.
     *
     * @TODO: 64 bit integers?
     *
     * @enum {string} module:xide/types/CIFlag
     * @memberOf module:xide/types
     */

    types.CIFLAG = {
        /**
         * Instruct for no additional extra processing
         * @constant
         * @type int
         */
        NONE: 0x00000000,
        /**
         * Will instruct the pre/post processor to base-64 decode or encode
         * @constant
         * @type int
         */
        BASE_64: 0x00000001,
        /**
         * Post/Pre process the value with a user function
         * @constant
         * @type int
         */
        USE_FUNCTION: 0x00000002,
        /**
         * Replace variables with local scope's variables during the post/pre process
         * @constant
         * @type int
         */
        REPLACE_VARIABLES: 0x00000004,
        /**
         * Replace variables with local scope's variables during the post/pre process but evaluate the whole string
         * as Javascript
         * @constant
         * @type int
         */
        REPLACE_VARIABLES_EVALUATED: 0x00000008,
        /**
         * Will instruct the pre/post processor to escpape evaluated or replaced variables or expressions
         * @constant
         * @type int
         */
        ESCAPE: 0x00000010,
        /**
         * Will instruct the pre/post processor to replace block calls with oridinary vanilla script
         * @constant
         * @type int
         */
        REPLACE_BLOCK_CALLS: 0x00000020,
        /**
         * Will instruct the pre/post processor to remove variable delimitters/placeholders from the final string
         * @constant
         * @type int
         */
        REMOVE_DELIMTTERS: 0x00000040,
        /**
         * Will instruct the pre/post processor to remove   "[" ,"]" , "(" , ")" , "{", "}" , "*" , "+" , "."
         * @constant
         * @type int
         */
        ESCAPE_SPECIAL_CHARS: 0x00000080,
        /**
         * Will instruct the pre/post processor to use regular expressions over string substitution
         * @constant
         * @type int
         */
        USE_REGEX: 0x00000100,
        /**
         * Will instruct the pre/post processor to use Filtrex (custom bison parser, needs xexpression) over string substitution
         * @constant
         * @type int
         */
        USE_FILTREX: 0x00000200,
        /**
         * Cascade entry. There are cases where #USE_FUNCTION is not enough or we'd like to avoid further type checking.
         * @constant
         * @type int
         */
        CASCADE: 0x00000400,
        /**
         * Cascade entry. There are cases where #USE_FUNCTION is not enough or we'd like to avoid further type checking.
         * @constant
         * @type int
         */
        EXPRESSION: 0x00000800,
        /**
         * Dont parse anything
         * @constant
         * @type int
         */
        DONT_PARSE: 0x000001000,
        /**
         * Convert to hex
         * @constant
         * @type int
         */
        TO_HEX: 0x000002000,
        /**
         * Convert to hex
         * @constant
         * @type int
         */
        REPLACE_HEX: 0x000004000,
        /**
         * Flag to mark the maximum core bit mask, after here its user land
         * @constant
         * @type int
         */
        END: 0x000008000
    }
    /**
     * A CI's default post-pre processing order.
     *
     * @enum {string} module:xide/types/CI_STATE
     * @memberOf module:xide/types
     */
    types.CI_CORDER = {}
    /**
     * A 'Configurable Information's ("CI") type information. Every CI has this information. You can
     * re-composite new types with ECIType.STRUCTURE. However all 'beans' (rich objects) in the system all displayed through a set of CIs,
     * also called the CIS (Configurable Information Set). There are many types already :
     *
     * Each ECIType has mapped widgets, BOOL : checkbox, STRING: Text-Areay and so forth.
     *
     * @enum {string} module:xide/types/ECIType
     * @memberOf module:xide/types
     */
    types.ECIType = {
        /**
         * @const
         * @type { int}
         */
        BOOL: 0,
        /**
         * @const
         * @type { int}
         */
        BOX: 1,
        /**
         * @const
         * @type { int}
         */
        COLOUR: 2,
        /**
         * @const
         * @type { int}
         */
        ENUMERATION: 3,
        /**
         * @const
         * @type { int}
         */
        FILE: 4,
        /**
         * @const
         * @type { int}
         */
        FLAGS: 5,
        /**
         * @const
         * @type { int}
         */
        FLOAT: 6,
        /**
         * @const
         * @type { int}
         */
        INTEGER: 7,
        /**
         * @const
         * @type { int}
         */
        MATRIX: 8,
        /**
         * @const
         * @type { int}
         */
        OBJECT: 9,
        /**
         * @const
         * @type { int}
         */
        REFERENCE: 10,
        /**
         * @const
         * @type { int}
         */
        QUATERNION: 11,
        /**
         * @const
         * @type { int}
         */
        RECTANGLE: 12,
        /**
         * @const
         * @type { int}
         */
        STRING: 13,
        /**
         * @const
         * @type { int}
         */
        VECTOR: 14,
        /**
         * @const
         * @type { int}
         */
        VECTOR2D: 15,
        /**
         * @const
         * @type { int}
         */
        VECTOR4D: 16,
        /**
         * @const
         * @type { int}
         */
        ICON: 17,
        /**
         * @const
         * @type { int}
         */
        IMAGE: 18,
        /**
         * @const
         * @type { int}
         */
        BANNER: 19,
        /**
         * @const
         * @type { int}
         */
        LOGO: 20,
        /**
         * @const
         * @type { int}
         */
        STRUCTURE: 21,
        /**
         * @const
         * @type { int}
         */
        BANNER2: 22,
        /**
         * @const
         * @type { int}
         */
        ICON_SET: 23,
        /**
         * @const
         * @type { int}
         */
        SCRIPT: 24,
        /**
         * @const
         * @type { int}
         */
        EXPRESSION: 25,
        /**
         * @const
         * @type { int}
         */
        RICHTEXT: 26,
        /**
         * @const
         * @type { int}
         */
        ARGUMENT: 27,
        /**
         * @const
         * @type { int}
         */
        JSON_DATA: 28,
        /**
         * @const
         * @type { int}
         */
        EXPRESSION_EDITOR: 29,
        /**
         * @const
         * @type { int}
         */
        WIDGET_REFERENCE: 30,
        /**
         * @const
         * @type { int}
         */
        DOM_PROPERTIES: 31,

        /**
         * @const
         * @type { int}
         */
        BLOCK_REFERENCE: 32,

        /**
         * @const
         * @type { int}
         */
        BLOCK_SETTINGS: 33,
        /**
         * @const
         * @type { int}
         */
        FILE_EDITOR: 34,
        /**
         * @const
         * @type { int}
         */
        END: 35,
        /**
         * @const
         * @type { int}
         */
        UNKNOWN: -1
    }
    /**
     * Stub for registered bean types. This value is needed to let the UI switch between configurations per such type.
     * At the very root is the bean action context which may include more contexts.
     * @enum {string} module:xide/types/ITEM_TYPE
     * @memberOf module:xide/types
     */
    types.ITEM_TYPE = {
        /**
         * Bean type 'file' is handled by the xfile package
         * @constant
         */
        FILE: 'BTFILE',         //file object
        /**
         * Bean type 'widget' is handled by the xide/ve and davinci package
         * @constant
         */
        WIDGET: 'WIDGET',       //ui designer
        /**
         * Bean type 'block' is handled by the xblox package
         * @constant
         */
        BLOCK: 'BLOCK',         //xblox
        /**
         * Bean type 'text' is used for text editors
         * @constant
         */
        TEXT: 'TEXT',           //xace
        /**
         * Bean type 'xexpression' is used for user expressions
         * @constant
         */
        EXPRESSION: 'EXPRESSION'       //xexpression
    }

    /**
     * Expression Parser is a map of currently existing parsers
     * and might be extended by additional modules. Thus, it acts as registry
     * and is here as stub.
     *
     * @enum module:xide/types/EXPRESSION_PARSER
     * @memberOf module:xide/types
     */
    if (!types.EXPRESSION_PARSER) {
        types.EXPRESSION_PARSER = {}
    }
    /**
     * Component names stub, might be extended by sub-classing applications
     * @constant xide.types.COMPONENT_NAMES
     */
    types.COMPONENT_NAMES = {
        XIDEVE: 'xideve',
        XNODE: 'xnode',
        XBLOX: 'xblox',
        XFILE: 'xfile',
        XACE: 'xace',
        XEXPRESSION: 'xexpression',
        XCONSOLE: 'xconsole'
    }

    /**
     * WIDGET_REFERENCE_MODE enumerates possible modes to resolve a string expression
     * into instances. There are a few CI based widgets subclassed from xide/widgets/Referenced.
     * The reference structure consist out of this mode and that expression.
     *
     * @constant {Array.<module:xide/types~WidgetReferenceMode>}
     *     module:xide/types~WIDGET_REFERENCE_MODE
     */
    types.WIDGET_REFERENCE_MODE = {
        BY_ID: 'byid',
        BY_CLASS: 'byclass',
        BY_CSS: 'bycss',
        BY_EXPRESSION: 'expression'
    }
    /**
     * Possible split modes for rich editors with preview or live coding views.
     *
     * @constant {Array.<module:xide/types~ViewSplitMode>}
     *     module:xide/types~VIEW_SPLIT_MODE
     */
    types.VIEW_SPLIT_MODE = {
        DESIGN: 1,
        SOURCE: 2,
        SPLIT_VERTICAL: 6,
        SPLIT_HORIZONTAL: 7
    }

    /**
     * All client resources are through variables on the server side. Here the minimum variables for an xjs application.
     *
     * @constant {Array.<module:xide/types~RESOURCE_VARIABLES>}
     *     module:xide/types~RESOURCE_VARIABLES
     */
    types.RESOURCE_VARIABLES = {
        ACE: 'ACE',
        APP_URL: 'APP_URL',
        SITE_URL: 'SITE_URL'
    }
    /**
     * Events of xide.*
     * @enum {string} module:xide/types/EVENTS
     * @memberOf module:xide/types
     * @extends xide/types
     */
    types.EVENTS = {

        /**
         * generic
         */
        ERROR: 'onError',//xhr
        STATUS: 'onStatus',//xhr
        ON_CREATED_MANAGER: 'onCreatedManager',//context

        /**
         * item events, to be renoved
         */
        ON_ITEM_SELECTED: 'onItemSelected',
        ON_ITEM_REMOVED: 'onItemRemoved',
        ON_ITEM_CLOSED: 'onItemClosed',
        ON_ITEM_ADDED: 'onItemAdded',
        ON_ITEM_MODIFIED: 'onItemModified',
        ON_NODE_SERVICE_STORE_READY: 'onNodeServiceStoreReady',
        /**
         * old, to be removd
         */
        ON_FILE_STORE_READY: 'onFileStoreReady',
        ON_CONTEXT_MENU_OPEN: 'onContextMenuOpen',
        /**
         * CI events
         */
        ON_CI_UPDATE: 'onCIUpdate',

        /**
         * widgets
         */
        ON_WIDGET_READY: 'onWidgetReady',
        ON_CREATED_WIDGET: 'onWidgetCreated',
        RESIZE: 'onResize',
        /**
         * Event to notify classes about a reloaded module
         * @constant
         * @type string
         */
        ON_MODULE_RELOADED: 'onModuleReloaded',
        ON_MODULE_UPDATED: 'onModuleUpdated',


        ON_DID_OPEN_ITEM: 'onDidOpenItem',//remove
        ON_DID_RENDER_COLLECTION: 'onDidRenderCollection',//move

        ON_PLUGIN_LOADED: 'onPluginLoaded',
        ON_PLUGIN_READY: 'onPluginReady',
        ALL_PLUGINS_READY: 'onAllPluginsReady',

        /**
         * editors
         */
        ON_CREATE_EDITOR_BEGIN: 'onCreateEditorBegin',//move to xedit
        ON_CREATE_EDITOR_END: 'onCreateEditorEnd',//move to xedit
        REGISTER_EDITOR: 'registerEditor',//move to xedit
        ON_EXPRESSION_EDITOR_ADD_FUNCTIONS: 'onExpressionEditorAddFunctions',//move to xedit
        ON_ACE_READY: 'onACEReady',//remove

        /**
         * Files
         */
        ON_UNSAVED_CONTENT: 'onUnSavedContent',
        ON_FILE_CHANGED: 'fileChanged',
        ON_FILE_DELETED: 'fileDeleted',
        IMAGE_LOADED: 'imageLoaded',
        IMAGE_ERROR: 'imageError',
        UPLOAD_BEGIN: 'uploadBegin',
        UPLOAD_PROGRESS: 'uploadProgress',
        UPLOAD_FINISH: 'uploadFinish',
        UPLOAD_FAILED: 'uploadFailed',
        ON_FILE_CONTENT_CHANGED: 'onFileContentChanged',
        ON_COPY_BEGIN: 'onCopyBegin',
        ON_COPY_END: 'onCopyEnd',
        ON_DELETE_BEGIN: 'onDeleteBegin',
        ON_DELETE_END: 'onDeleteEnd',
        ON_MOVE_BEGIN: 'onMoveBegin',
        ON_MOVE_END: 'onMoveEnd',
        ON_CHANGED_CONTENT: 'onChangedContent',
        ON_COMPRESS_BEGIN: 'onCompressBegin',
        ON_COMPRESS_END: 'onCompressEnd',



        ON_COMPONENT_READY: 'onComponentReady',
        ON_ALL_COMPONENTS_LOADED: 'onAllComponentsLoaded',
        ON_APP_READY: 'onAppReady',
        /**
         * Store
         */
        ON_CREATE_STORE: 'onCreateStore',
        ON_STORE_CREATED: 'onStoreCreated',
        ON_STORE_CHANGED: 'onStoreChanged',
        ON_STATUS_MESSAGE: 'onStatusMessage',
        /**
         * layout
         */
        SAVE_LAYOUT: 'layoutSave',
        RESTORE_LAYOUT: 'layoutRestore',
        /**
         * views, panels and 'main view'
         */
        ON_SHOW_PANEL: 'onShowPanel',
        ON_PANEL_CLOSED: 'onPanelClosed',
        ON_PANEL_CREATED: 'onPanelCreated',

        ON_MAIN_VIEW_READY: 'onMainViewReady',
        ON_MAIN_MENU_READY: 'onMainMenuReady',
        ON_MAIN_MENU_OPEN: 'onMainMenuOpen',
        ON_VIEW_REMOVED: 'onViewRemoved',
        ON_VIEW_SHOW: 'onViewShow',
        ON_VIEW_HIDE: 'onViewHide',
        ON_VIEW_ADDED: 'onViewAdded',
        ON_OPEN_VIEW: 'onOpenView',
        ON_VIEW_MAXIMIZE_START: 'onViewMaximizeStart',
        ON_VIEW_MAXIMIZE_END: 'onViewMaximizeEnd',
        ON_CONTAINER_ADDED: 'onContainerAdded',
        ON_CONTAINER_REMOVED: 'onContainerRemoved',
        ON_REMOVE_CONTAINER: 'onRemoveContainer',
        ON_CONTAINER_REPLACED: 'onContainerReplaced',
        ON_CONTAINER_SPLIT: 'onContainerSplit'
    }
    /**
     * To be moved
     * @type {{SIZE_NORMAL: string, SIZE_SMALL: string, SIZE_WIDE: string, SIZE_LARGE: string}}
     */
    types.DIALOG_SIZE = {
        SIZE_NORMAL: 'size-normal',
        SIZE_SMALL: 'size-small',
        SIZE_WIDE: 'size-wide',    // size-wide is equal to modal-lg
        SIZE_LARGE: 'size-large'
    }

    /**
     * To be moved
     * @type {{DEFAULT: string, INFO: string, PRIMARY: string, SUCCESS: string, WARNING: string, DANGER: string}}
     */
    types.DIALOG_TYPE = {
        DEFAULT: 'type-default',
        INFO: 'type-info',
        PRIMARY: 'type-primary',
        SUCCESS: 'type-success',
        WARNING: 'type-warning',
        DANGER: 'type-danger'
    }
    /**
     * @TODO: remove, defined in xideve
     */
    lang.mixin(types, {
        LAYOUT_RIGHT_CENTER_BOTTOM: 'LAYOUT_RIGHT_CENTER_BOTTOM',
        LAYOUT_CENTER_BOTTOM: 'LAYOUT_CENTER_BOTTOM',
        LAYOUT_CENTER_RIGHT: 'LAYOUT_CENTER_RIGHT',
        LAYOUT_LEFT_CENTER_RIGHT: 'LAYOUT_LEFT_CENTER_RIGHT',
        LAYOUT_LEFT_CENTER_RIGHT_BOTTOM: 'LAYOUT_LEFT_CENTER_RIGHT_BOTTOM'
    })

    /**
     * Hard Dojo override to catch malformed JSON.
     * @param js
     * @returns {*}
     */
    dojo.fromJson = function (js, debug) {
        var res = null;
        var didFail = false;
        try {
            res = eval("(" + js + ")");
        } catch (e) {
            didFail = true;
        }
        if (didFail) {
            var js2 = js.substring(js.indexOf('{'), js.lastIndexOf('}') + 1);
            try {
                js2 && (res = eval("(" + js2 + ")"));
            } catch (e) {
                debug !== false && console.error('error in json parsing! ' + js);
                if (js.indexOf('error') !== -1) {
                    return {
                        "jsonrpc": "2.0",
                        "result": {
                            "error": {
                                "code": 1,
                                "message": js,
                                "data": null
                            }
                        }, "id": 0
                    };
                    return {
                        error: '1',
                        message: js
                    }
                }
                throw new Error(js);
            }
        }
        return res;
    };
    return types;
});
define('xblox/types/Types',[
    'xide/types/Types',
    'dojo/_base/lang'
],function(types,lang)
    {



        types.BLOCK_MODE = {
            NORMAL:0,
            UPDATE_WIDGET_PROPERTY:1
        };

        lang.mixin(types.EVENTS,{

            ON_RUN_BLOCK:                   'onRunBlock',
            ON_RUN_BLOCK_FAILED:            'onRunBlockFailed',
            ON_RUN_BLOCK_SUCCESS:           'onRunBlockSuccess',
            ON_BLOCK_SELECTED:              'onItemSelected',
            ON_BLOCK_UNSELECTED:            'onBlockUnSelected',
            ON_BLOCK_EXPRESSION_FAILED:     'onExpressionFailed',
            ON_BUILD_BLOCK_INFO_LIST:       'onBuildBlockInfoList',
            ON_BUILD_BLOCK_INFO_LIST_END:   'onBuildBlockInfoListEnd',
            ON_BLOCK_PROPERTY_CHANGED:      'onBlockPropertyChanged',
            ON_SCOPE_CREATED:               'onScopeCreated',
            ON_VARIABLE_CHANGED:            'onVariableChanged',
            ON_CREATE_VARIABLE_CI:          'onCreateVariableCI'

        });


        types.BlockType = {

            AssignmentExpression: 'AssignmentExpression',
            ArrayExpression: 'ArrayExpression',
            BlockStatement: 'BlockStatement',
            BinaryExpression: 'BinaryExpression',
            BreakStatement: 'BreakStatement',
            CallExpression: 'CallExpression',
            CatchClause: 'CatchClause',
            ConditionalExpression: 'ConditionalExpression',
            ContinueStatement: 'ContinueStatement',
            DoWhileStatement: 'DoWhileStatement',
            DebuggerStatement: 'DebuggerStatement',
            EmptyStatement: 'EmptyStatement',
            ExpressionStatement: 'ExpressionStatement',
            ForStatement: 'ForStatement',
            ForInStatement: 'ForInStatement',
            FunctionDeclaration: 'FunctionDeclaration',
            FunctionExpression: 'FunctionExpression',
            Identifier: 'Identifier',
            IfStatement: 'IfStatement',
            Literal: 'Literal',
            LabeledStatement: 'LabeledStatement',
            LogicalExpression: 'LogicalExpression',
            MemberExpression: 'MemberExpression',
            NewExpression: 'NewExpression',
            ObjectExpression: 'ObjectExpression',
            Program: 'Program',
            Property: 'Property',
            ReturnStatement: 'ReturnStatement',
            SequenceExpression: 'SequenceExpression',
            SwitchStatement: 'SwitchStatement',
            SwitchCase: 'SwitchCase',
            ThisExpression: 'ThisExpression',
            ThrowStatement: 'ThrowStatement',
            TryStatement: 'TryStatement',
            UnaryExpression: 'UnaryExpression',
            UpdateExpression: 'UpdateExpression',
            VariableDeclaration: 'VariableDeclaration',
            VariableDeclarator: 'VariableDeclarator',
            WhileStatement: 'WhileStatement',
            WithStatement: 'WithStatement'
        };

        return types;
});
/** @module xblox/model/ModelBase
 *  @description The base for block related classes, this must be kept small and light as possible
 */
define('xblox/model/ModelBase',[
    'dcl/dcl',
    "xide/utils",
    "xide/types"
], function(dcl,utils,types){

    /**
     * The model mixin for a block
     * @class module:xblox.model.ModelBase
     */
    return dcl(null,{
        declaredClass:'xblox.model.ModelBase',
        id:null,
        description:'',
        parent:null,
        parentId:null,
        group:null,
        order:0,
        _store:null,
        ////////////////////////////////////////////////////////////
        //
        //  Functions to expose out & in - lets
        //
        ////////////////////////////////////////////////////////////
        /**
         *
         * Implmented by the subclass. Each block must provide an output signature.
         * The format is currently the same as Dojo SMD
         *
         * @returns {Array}
         */
        outputs:function(){
           return [];
        },
        /**
         *
         * Implmented by the subclass. Each block must provide an input signature.
         * The format is currently the same as Dojo SMD
         *
         * @returns {Array}
         */
        takes:function(){
            return [];
        },
        /**
         *
         * Implmented by the subclass. Each block must provide an needed input signature.
         * The format is currently the same as Dojo SMD. This is a filtered version of
         * 'takes'
         *
         * @returns {Array}
         */
        needs:function(){
            return [];
        },
        ////////////////////////////////////////////////////////////
        //
        //  Functions to expose outlets
        //
        ////////////////////////////////////////////////////////////
        /***
         * Standard constructor for all subclassing blocks
         * @param {array} arguments
         */
        constructor: function(args){


            //simple mixin of constructor arguments
            for (var prop in args) {
                if (args.hasOwnProperty(prop)) {
                    this[prop] = args[prop];
                }
            }

            if(!this.id){
                this.id = this.createUUID();
            }

            //short cuts
            this.utils=utils;
            this.types=types;


        },
        ////////////////////////////////////////////////////////////
        //
        //  Standard tools
        //
        ////////////////////////////////////////////////////////////
        keys: function (a) {
            var b = [];
            for (var c in a) {
                b.push(c);
            }
            return b;
        },
        values: function (b) {
            var a = [];
            for (var c in b) {
                a.push(b[c]);
            }
            return a;
        },
        toArray: function () {
            return this.map();
        },
        size: function () {
            return this.toArray().length;
        },
        createUUID:function(){
            // summary:
            //		Create a basic UUID
            // description:
            //		The UUID is created with Math.Random
            var S4 = function() {
                return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
            };
            return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4()); //String
        },
        canEdit:function(){
            return true;
        },
        getFields:function(){
            return null;
        },
        isString: function (a) {
            return typeof a == "string"
        },
        isNumber: function (a) {
            return typeof a == "number"
        },
        isBoolean: function (a) {
            return typeof a == "boolean"
        },
        isObject:function(a){
            return typeof a === 'object';
        },
        isArray:function(a){
            if (Array.isArray){
                return Array.isArray(a);
            }
            return false;
        },
        getValue:function(val){

            var _float = parseFloat(val);

            if(!isNaN(_float)){
               return _float;
            }
            if(val==='true' || val===true){
                return true;
            }
            if(val==='false' || val===false){
                return false;
            }
            return val;

        },
        isScript:function(val){
            return this.isString(val) &&(
                    val.indexOf('return')!=-1||
                    val.indexOf(';')!=-1||
                    val.indexOf('(')!=-1||
                    val.indexOf('+')!=-1||
                    val.indexOf('-')!=-1||
                    val.indexOf('<')!=-1||
                    val.indexOf('*')!=-1||
                    val.indexOf('/')!=-1||
                    val.indexOf('%')!=-1||
                    val.indexOf('=')!=-1||
                    val.indexOf('==')!=-1||
                    val.indexOf('>')!=-1||
                    val.indexOf('[')!=-1||
                    val.indexOf('{')!=-1||
                    val.indexOf('}')!=-1
                );
        },
        replaceAll:function(find, replace, str) {
            if(this.isString(str)){
                return str.split(find).join(replace);//faster!
            }
            return str;
        },
        isInValidState:function(){
            return true;
        }
    });
});

/** @module xblox/model/Block **/
define('xblox/model/Block',[
    'dcl/dcl',
    "dojo/Deferred",
    "dojo/_base/lang",
    "dojo/has",
    "xblox/model/ModelBase",
    "xide/factory",
    "xide/utils",
    "xide/types",
    "xdojo/has!xblox-ui?xblox/model/Block_UI"
], function (dcl,Deferred, lang, has, ModelBase, factory, utils, types, Block_UI) {

    var bases = [ModelBase];

    if(!has('host-browser')){

        bases.push(dcl(null,{
            getStatusIcon:function(){},
            getStatusClass:function(){},
            setStatusClass:function(){},
            onActivity:function(){},
            onRun:function(){},
            onFailed:function(){},
            onSuccess:function(){},
            getIconClass:function(){}
        }));

    }

    /***
     * First things first, extend the core types for block flags:
     */
    utils.mixin(types, {
        /**
         * Flags to describe flags of the inner state of a block which might change upon the optimization. It also
         * contains some other settings which might be static, default or changed by the UI(debugger, etc...)
         *
         * @enum module:xide/types/BLOCK_FLAGS
         * @memberOf module:xide/types
         */
        BLOCK_FLAGS: {

            NONE: 0x00000000,	// Reserved for future use
            ACTIVE: 0x00000001,	// This behavior is active
            SCRIPT: 0x00000002,	// This behavior is a script
            RESERVED1: 0x00000004,	// Reserved for internal use
            USEFUNCTION: 0x00000008,	// Block uses a function and not a graph
            RESERVED2: 0x00000010,	// Reserved for internal use
            SINGLE: 0x00000020,	// Only this block will excecuted, child blocks not.
            WAITSFORMESSAGE: 0x00000040,	// Block is waiting for a message to activate one of its outputs
            VARIABLEINPUTS: 0x00000080,	// Block may have its inputs changed by editing them
            VARIABLEOUTPUTS: 0x00000100,	// Block may have its outputs changed by editing them
            VARIABLEPARAMETERINPUTS: 0x00000200,	// Block may have its number of input parameters changed by editing them
            VARIABLEPARAMETEROUTPUTS: 0x00000400,	// Block may have its number of output parameters changed by editing them
            TOPMOST: 0x00004000,	// No other Block includes this one
            BUILDINGBLOCK: 0x00008000,	// This Block is a building block (eg: not a transformer of parameter operation)
            MESSAGESENDER: 0x00010000,	// Block may send messages during its execution
            MESSAGERECEIVER: 0x00020000,	// Block may check messages during its execution
            TARGETABLE: 0x00040000,	// Block may be owned by a different object that the one to which its execution will apply
            CUSTOMEDITDIALOG: 0x00080000,	// This Block have a custom Dialog Box for parameters edition .
            RESERVED0: 0x00100000,	// Reserved for internal use.
            EXECUTEDLASTFRAME: 0x00200000,	// This behavior has been executed during last process. (Available only in profile mode )
            DEACTIVATENEXTFRAME: 0x00400000,	// Block will be deactivated next frame
            RESETNEXTFRAME: 0x00800000,	// Block will be reseted next frame

            INTERNALLYCREATEDINPUTS: 0x01000000,	// Block execution may create/delete inputs
            INTERNALLYCREATEDOUTPUTS: 0x02000000,	// Block execution may create/delete outputs
            INTERNALLYCREATEDINPUTPARAMS: 0x04000000,	// Block execution may create/delete input parameters or change their type
            INTERNALLYCREATEDOUTPUTPARAMS: 0x08000000,	// Block execution may create/delete output parameters or change their type
            INTERNALLYCREATEDLOCALPARAMS: 0x40000000,	// Block execution may create/delete local parameters or change their type

            ACTIVATENEXTFRAME: 0x10000000,	// Block will be activated next frame
            LOCKED: 0x20000000,	// Block is locked for utilisation in xblox
            LAUNCHEDONCE: 0x80000000	// Block has not yet been launched...
        },

        /**
         *  Mask for the messages the callback function of a block should be aware of. This goes directly in
         *  the EventedMixin as part of the 'emits' chain (@TODO)
         *
         * @enum module:xide/types/BLOCK_CALLBACKMASK
         * @memberOf module:xide/types
         */
        BLOCK_CALLBACKMASK: {
            PRESAVE: 0x00000001,	// Emits PRESAVE messages
            DELETE: 0x00000002,	// Emits DELETE messages
            ATTACH: 0x00000004,	// Emits ATTACH messages
            DETACH: 0x00000008,	// Emits DETACH messages
            PAUSE: 0x00000010,	// Emits PAUSE messages
            RESUME: 0x00000020,	// Emits RESUME messages
            CREATE: 0x00000040,	// Emits CREATE messages
            RESET: 0x00001000,	// Emits RESET messages
            POSTSAVE: 0x00000100,	// Emits POSTSAVE messages
            LOAD: 0x00000200,	// Emits LOAD messages
            EDITED: 0x00000400,	// Emits EDITED messages
            SETTINGSEDITED: 0x00000800,	// Emits SETTINGSEDITED messages
            READSTATE: 0x00001000,	// Emits READSTATE messages
            NEWSCENE: 0x00002000,	// Emits NEWSCENE messages
            ACTIVATESCRIPT: 0x00004000,	// Emits ACTIVATESCRIPT messages
            DEACTIVATESCRIPT: 0x00008000,	// Emits DEACTIVATESCRIPT messages
            RESETINBREAKPOINT: 0x00010000,	// Emits RESETINBREAKPOINT messages
            RENAME: 0x00020000,	// Emits RENAME messages
            BASE: 0x0000000E,	// Base flags :attach /detach /delete
            SAVELOAD: 0x00000301,	// Base flags for load and save
            PPR: 0x00000130,	// Base flags for play/pause/reset
            EDITIONS: 0x00000C00,	// Base flags for editions of settings or parameters
            ALL: 0xFFFFFFFF	// All flags
        }

    });
    /**
     * Base block class.
     *
     * @class module:xblox/model/Block
     * @augments module:xblox/model/ModelBase
     * @extends module:xblox/model/Block_UI
     */
    var Block = dcl(bases, {
        declaredClass:"xblox.model.Block",
        scopeId: null,
        isCommand:false,
        postCreate:function(){},
        /**
         * 
         * @param clz
         * @returns {Array}
         */
        childrenByClass:function(clz){            
            var all = this.getChildren();
            var out = [];
            for (var i = 0; i < all.length; i++) {
                var obj = all[i];
                if(obj.isInstanceOf(clz)){
                    out.push(obj);
                }
            }            
            return out;
        },
        /**
         *
         * @param clz
         * @returns {Array}
         */
        childrenByNotClass:function(clz){
            var all = this.getChildren();
            
            var out = [];
            
            
            for (var i = 0; i < all.length; i++) {
                var obj = all[i];
                if(!obj.isInstanceOf(clz)){
                    out.push(obj);
                }
            }
            return out;
        },
        /**
         *
         * @returns {null}
         */
        getInstance:function(){
            var instance = this.scope.instance;
            if(instance) {
                return instance;
            }
            return null;
        },
        reset:function(){
            this._lastSettings = {};
            if(this._loop){
                clearTimeout(this._loop);
                this._loop = null;
            }
        },
        stop:function(){
            if(this._loop){
                clearTimeout(this._loop);
                this._loop=null;
            }
            this.reset();
        },
        mergeNewModule: function (source) {
            for (var i in source) {
                var o = source[i];
                if (o && _.isFunction(o) /*&& lang.isFunction(target[i])*/) {
                    this[i] = o;//swap
                }
            }
        },
        __onReloaded:function(newModule){

            this.mergeNewModule(newModule.prototype);

            var _class = this.declaredClass;
            var _module = lang.getObject(utils.replaceAll('/', '.', _class)) || lang.getObject(_class);
            if(_module){
                if(_module.prototype && _module.prototype.solve){

                    this.mergeNewModule(_module.prototype);

                }
            }else {

            }
        },
        reparent:function(){

            var item = this;
            if (!item) {
                return false;
            }
            var parent = item.getParent();
            if(parent){
            }else{
                var _next = item.next(null,1) || item.next(null,-1);
                if(_next){
                    item.group=null;
                    _next._add(item);
                }
            }
        },
        unparent:function(blockgroup,move){

            var item = this;

            if (!item) {
                return false;
            }

            var parent = item.getParent();

            if (parent && parent.removeBlock) {
                parent.removeBlock(item,false);
            }

            item.group = blockgroup;
            item.parentId = null;
            item.parent = null;

            if(move!==false) {
                item._place(null, -1, null);
                item._place(null, -1, null);
            }
        },
        move: function (dir) {

            var item = this;

            if (!item) {
                return false;
            }

            var parent = item.getParent();

            var items = null;

            var store = item._store;

            if (parent) {


                items = parent[parent._getContainer(item)];

                if (!items || items.length < 2 || !this.containsItem(items, item)) {
                    return false;
                }

                var cIndex = this.indexOf(items, item);


                if (cIndex + (dir) < 0) {
                    return false;
                }
                var upperItem = items[cIndex + (dir)];
                if (!upperItem) {
                    return false;
                }
                items[cIndex + (dir)] = item;
                items[cIndex] = upperItem;

                return true;

            } else {


                if (store && item.group) {
                    items = store.storage.fullData;
                }

                /*
                 var next = item.next(null,dir);
                 if (!next) {
                 console.warn('have no next');
                 return false;
                 }else{

                 }*/

                //console.log('next is ' + next.id);
                //console.log('next:: is ' + item.next(null,dir).id);
                /*
                 var _dstIndex = 0;
                 var step = 1;

                 function _next(item,items,dir){

                 var cIndex = item.indexOf(items, item);
                 var upperItem = items[cIndex + (dir * step)];
                 if(upperItem){
                 if(!upperItem.parentId && upperItem.group && upperItem.group===item.group){

                 _dstIndex = cIndex + (dir * step);
                 return upperItem;
                 }else{
                 step++;
                 return _next(item,items,dir);
                 }
                 }
                 return null;
                 }
                 */


                item._place(null, dir);

                return true;
            }
        },
        _place: function (ref, direction, items) {

            var store = this._store,
                dst = this;

            ref = ref || dst.next(null, direction);

            if (!ref) {
                console.error('have no next', this);
                return;
            }

            ref = _.isString(ref) ? store.getSync(ref) : ref;

            dst = _.isString(dst) ? store.getSync(dst) : dst;

            items = items || store.storage.fullData;

            direction = direction == -1 ? 0 : 1;

            function index(what) {
                for (var j = 0; j < items.length; j++) {
                    if (what.id === items[j].id) {
                        return j;
                    }
                }
            }

            function compare(left, right) {
                return index(left) - index(right);
            }

            items.remove(dst);

            if (direction == -1) {
                direction = 0;
            }

            items.splice(Math.max(index(ref) + direction, 0), 0, dst);

            store._reindex();
        },
        index:function(){

            var item = this,
                parent = item.getParent(),
                items = null,
                group = item.group,
                store = this._store;

            if (parent) {

                items = parent[parent._getContainer(item)] || [];

                items = items.filter(function(item){
                    return item.group ===group;
                });

                if (!items || items.length < 2 || !this.containsItem(items, item)) {
                    return false;
                }
                return this.indexOf(items, item);

            }else{
                items = store.storage.fullData;
                items = items.filter(function(item){
                    return item.group ===group;
                });
                return this.indexOf(items, item);
            }
        },
        numberOfParents:function(){

            var result = 0;
            var parent = this.getParent();
            if(parent){
                result++;
                result+=parent.numberOfParents();
            }
            return result;
        },
        next: function (items, dir) {

            var _dstIndex = 0;
            var step = 1;

            items = items || this._store.storage.fullData;


            function _next(item, items, dir) {
                var cIndex = item.indexOf(items, item);
                var _nIndex = cIndex + (dir * step);

                var upperItem = items[cIndex + (dir * step)];

                if (upperItem) {
                    if (!upperItem.parentId && upperItem.group && upperItem.group === item.group) {
                        _dstIndex = cIndex + (dir * step);
                        return upperItem;
                    } else {
                        step++;
                        return _next(item, items, dir);
                    }
                }
                return null;
            };

            return _next(this, items, dir);
        },
        getParent: function () {
            if (this.parentId) {
                return this.scope.getBlockById(this.parentId);
            }
            return null;
        },

        getScope: function () {
            var scope = this.scope;
            if (this.scopeId && this.scopeId.length > 0) {
                var owner = scope.owner;
                if (owner && owner.hasScope) {
                    if (owner.hasScope(this.scopeId)) {
                        scope = owner.getScope(this.scopeId);
                    } else {
                        console.error('have scope id but cant resolve it', this);
                    }
                }
            }
            return scope;
        },

        /**
         * Switch to include the block for execution.
         * @todo, move to block flags
         * @type {boolean}
         * @default true
         */
        enabled: true,
        /**
         * Switch to include the block for serialization.
         * @todo, move to block flags
         * @type {boolean}
         * @default true
         */
        serializeMe: true,
        /**
         * Name is used for the interface, mostly as prefix within
         * this.toText() which includes also the 'icon' (as icon font).
         * This should be unique and expressive.
         *
         * This field can be changed by the user. Examples
         * 'Run Script' will result in result 'Run Script + this.script'
         *
         * @todo: move that in user space, combine that with a template system, so any block ui parts gets off from here!
         * @type {string}
         * @default null
         * @required false
         */
        name: null,
        /**
         * @todo: same as name, move that in user space, combine that with a template system, so any block ui parts gets off from here!
         * @type {string}
         * @default 'No Description'
         * @required true
         */
        shareTitle: '',
        /**
         * The blocks internal user description
         * Description is used for the interface. This should be short and expressive and supports plain and html text.
         *
         * @todo: same as name, move that in user space, combine that with a template system, so any block ui parts gets off from here!
         * @type {string}
         * @default 'No Description'
         * @required true
         */
        sharable: false,
        /**
         * Container holding a 'child' blocks. Subclassing block might hold that somewhere else.
         * @type {Block[]}
         * @default null
         * @required false
         */
        items: null,
        /**
         * Parent up-link
         * @type {string|Block}
         * @default null
         * @required false
         */
        parent: null,
        /**
         * @var temporary variable to hold remainin blocks to run
         */
        _return: null,

        /**
         * @var temporary variable to store the last result
         */
        _lastResult: null,

        _deferredObject: null,

        _currentIndex: 0,

        _lastRunSettings: null,

        _onLoaded: false,

        beanType: 'BLOCK',

        override: {},
        /**
         * ignore these due to serialization
         */
        ignoreSerialize: [
            '_didSubscribe',
            '_currentIndex',
            '_deferredObject',
            '_return',
            'parent',
            'ignoreSerialize',
            '_lastRunSettings',
            '_onLoaded',
            'beanType',
            'sharable',
            'override',
            'virtual',
            '_scenario',
            '_didRegisterSubscribers',
            'additionalProperties',
            'renderBlockIcon',
            'serializeMe',
            '_statusIcon',
            '_statusClass',
            'hasInlineEdits',
            '_loop',
            'help',
            'owner'
        ],

        //  standard call from interface
        canAdd: function () {
            return null;
        },
        getTarget: function () {

            var _res = this._targetReference;
            if (_res) {
                return _res;
            }

            var _parent = this.getParent();
            if (_parent && _parent.getTarget) {
                _res = _parent.getTarget();
            }
            return _res;
        },

        // adds array2 at the end of array1 => useful for returned "solve" commands
        addToEnd: function (array1, array2) {
            if (array2 && array1.length != null && array2.length != null) {
                array1.push.apply(array1, array2);
            } else {
                //console.error('add to end failed : invalid args in' + this.name);
            }
            return array1;
        },
        /**
         *
         * @param what
         * @param del delete block
         */
        removeBlock: function (what, del) {
            if (what) {

                if (del !== false && what.empty) {
                    what.empty();
                }

                if (del !== false) {
                    delete what.items;
                }
                what.parent = null;

                if (this.items) {
                    this.items.remove(what);
                }
            }
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Accessors
        //
        /////////////////////////////////////////////////////////////////////////////////////
        _getContainer: function (item) {
            return 'items';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Utils
        //
        /////////////////////////////////////////////////////////////////////////////////////
        empty: function (what) {
            try {
                this._empty(what)
            } catch (e) {

                debugger;
            }
        },
        /*
         * Empty : removes all child blocks, recursivly
         * @param proto : prototype|instance
         * @param ctrArgs
         * @returns {*}
         */
        _empty: function (what) {

            var data = what || this.items;
            if (data) {
                for (var i = 0; i < data.length; i++) {
                    var subBlock = data[i];

                    if (subBlock && subBlock.empty) {
                        subBlock.empty();
                    }
                    if (subBlock && this.scope && this.scope.blockStore) {
                        this.scope.blockStore.remove(subBlock.id);
                    }
                }
            }
        },
        /**
         * This was needed. FF bug.
         * @param data
         * @param obj
         * @returns {boolean}
         */
        containsItem: function (data, obj) {
            var i = data.length;
            while (i--) {
                if (data[i].id === obj.id) {
                    return true;
                }
            }
            return false;
        },
        /**
         * This was needed. FF bug
         * @param data
         * @param obj
         * @returns {*}
         */
        indexOf: function (data, obj) {
            var i = data.length;
            while (i--) {
                if (data[i].id === obj.id) {
                    return i;
                }
            }
            return -1;
        },
        _getBlock: function (dir) {
            try {
                var item = this;
                if (!item || !item.parentId) {
                    return false;
                }
                //get parent
                var parent = this.scope.getBlockById(item.parentId);
                if (!parent) {
                    return null;
                }
                var items = parent[parent._getContainer(item)];
                if (!items || items.length < 2 || !this.containsItem(items, item)) {
                    return null;
                }
                var cIndex = this.indexOf(items, item);
                if (cIndex + (dir) < 0) {
                    return false;
                }
                var upperItem = items[cIndex + (dir)];
                if (upperItem) {
                    return upperItem;
                }
            } catch (e) {
                debugger;
            }
            return null;
        },
        getPreviousBlock: function () {
            return this._getBlock(-1);
        },
        getNextBlock: function () {
            return this._getBlock(1);
        },
        getPreviousResult: function () {

            var parent = this.getPreviousBlock() || this.getParent();
            if (parent && parent._lastResult != null) {

                if (this.isArray(parent._lastResult)) {
                    return parent._lastResult;
                } else {
                    return [parent._lastResult];
                }
            }
            return null;
        },
        _getArg: function (val,escape) {


            //try auto convert to number
            var _float = parseFloat(val);
            if (!isNaN(_float)) {
                return _float;
            } else {

                if (val === 'true' || val === 'false') {
                    return utils.toBoolean(val);
                }else if(val && escape && _.isString(val)){
                    return '\'' + val + '\'';
                }
                return val;
            }
        },
        /**
         *
         * @returns {Array}
         */
        getArgs: function (settings) {

            var result = [],
                _inArgs = this._get('args');

            if(settings && settings.override && settings.override.args){
                _inArgs = settings.override.args;
            }

            if (_inArgs) {//direct json
                result = utils.getJson(_inArgs,null,false);
                if (result != null && _.isArray(result)) {
                    //return result;
                }
            }


            //try comma separated list
            if (result && result.length == 0 && _inArgs && _inArgs.length && _.isString(_inArgs)) {

                if (_inArgs.indexOf(',') !== -1) {
                    var _splitted = _inArgs.split(',');
                    for (var i = 0; i < _splitted.length; i++) {

                        //try auto convert to number
                        var _float = parseFloat(_splitted[i]);
                        if (!isNaN(_float)) {
                            result.push(_float);
                        } else {

                            if (_splitted[i] === 'true' || _splitted[i] === 'false') {
                                result.push(utils.toBoolean(_splitted[i]));
                            } else {
                                result.push(_splitted[i]);//whatever
                            }
                        }
                    }
                    return result;
                } else {
                    result = [this._getArg(_inArgs)];//single argument
                }
            }

            //add previous result
            var previousResult = this.getPreviousResult();
            if (previousResult != null) {
                if (lang.isArray(previousResult) && previousResult.length == 1) {
                    result.push(previousResult[0]);
                } else {
                    result.push(previousResult);
                }
            }

            return result || [_inArgs];
        },
        /*
         * Remove : as expected, removes a block
         * @param proto : prototype|instance
         * @param ctrArgs
         * @returns {*}
         */
        remove: function (what) {

            this._destroyed = true;

            if (this.parentId != null && this.parent == null) {
                this.parent = this.scope.getBlockById(this.parentId);
            }

            if (this.parent && this.parent.removeBlock) {
                this.parent.removeBlock(this);
                return;
            }
            what = what || this;
            if (what) {

                if (what.empty) {
                    what.empty();
                }

                delete what.items;
                what.parent = null;
                if (this.items) {
                    this.items.remove(what);
                }
            }

        },
        prepareBlockContructorArgs: function (ctorArgs) {
            if (!ctorArgs) {
                ctorArgs = {};
            }
            //prepare items
            if (!ctorArgs['id']) {
                ctorArgs['id'] = this.createUUID();
            }
            if (!ctorArgs['items']) {
                ctorArgs['items'] = [];
            }

            //create a global scope if none has been provided
            if (!ctorArgs['scope']) {
                //ctorArgs['scope']=thiz.getScope('global')
            }
        },
        /**
         * Private add-block function
         * @param proto
         * @param ctrArgs
         * @param where
         * @param publish
         * @returns {*}
         * @private
         */
        _add: function (proto, ctrArgs, where,publish) {

            var _block = null;
            try {
                //create or set
                if (ctrArgs) {

                    //use case : normal object construction
                    this.prepareBlockContructorArgs(ctrArgs);
                    _block = factory.createBlock(proto, ctrArgs,null,publish);
                } else {
                    //use case : object has been created so we only do the leg work
                    if (ctrArgs == null) {
                        _block = proto;
                    }
                    //@TODO : allow use case to use ctrArgs as mixin for overriding
                }
                ///////////////////////
                //  post work

                //inherit scope
                _block.scope = this.scope;

                //add to scope
                if (this.scope) {
                    _block = this.scope.registerBlock(_block,publish);
                }
                if (_block.id === this.id) {
                    var sameInstance = _block == this;
                    console.error('adding new block to our self');
                    debugger;
                }

                //pass parent
                _block.parent = this;
                //pass parent id
                _block.parentId = this.id;

                var container = where || this._getContainer();
                if (container) {

                    if (!this[container]) {
                        this[container] = [];
                    }

                    var index = this.indexOf(this[container], _block);
                    if (index != -1) {
                        console.error(' have already ' + _block.id + ' in ' + container);
                    } else {
                        if (this.id == _block.id) {
                            console.error('tried to add our self to ' + container);
                            return;
                        }
                        this[container].push(_block);
                    }
                }

                return _block;

            } catch (e) {
                logError(e,'_add');
            }
            return null;

        },
        getStore:function(){
            return this.getScope().getStore();
        },
        /**
         * Public add block function
         * @param proto
         * @param ctrArgs
         * @param where
         * @returns {*}
         */
        add: function (proto, ctrArgs, where) {

            var block = this._add(proto, ctrArgs, where);

            return block.getStore().getSync(block.id);

        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Run 
        //
        /////////////////////////////////////////////////////////////////////////////////////
        getContext: function () {

            if (this.scope.instance && this.scope.instance) {
                return this.scope.instance;
            }
            return null;
        },
        resolved: function () {

            if (this._deferredObject) {
                this._deferredObject.resolve();
                delete this._deferredObject;
            }
        },
        /***
         * Solves all the commands into items[]
         *
         * @param manager   =>  BlockManager
         * @return  list of commands to send
         */
        _solve: function (scope, settings) {

            settings = settings || {
                    highlight: false
                };
            var ret = [];
            for (var n = 0; n < this.items.length; n++) {
                var block = this.items[n];
                this.addToEnd(ret, block.solve(scope, settings));
            }

            return ret;
        },
        /***
         * Solves all the commands into items[]
         *
         * @param manager   =>  BlockManager
         * @return  list of commands to send
         */
        solve: function (scope, settings) {

            settings = settings || {
                    highlight: false
                };
            var ret = [];

            for (var n = 0; n < this.items.length; n++) {
                var block = this.items[n];
                this.addToEnd(ret, block.solve(scope, settings));
            }
            return ret;
        },
        /***
         * Solves all the commands into items[]
         *
         * @param manager   =>  BlockManager
         * @return  list of commands to send
         */
        solveMany: function (scope, settings) {

            if (!this._lastRunSettings && settings) {
                this._lastRunSettings = settings;
            }

            settings = this._lastRunSettings || settings;

            this._currentIndex = 0;
            this._return = [];

            var ret = [], items = this[this._getContainer()];
            if (items.length) {
                var res = this.runFrom(items, 0, settings);
                this.onSuccess(this, settings);
                return res;
            } else {
                this.onSuccess(this, settings);
            }
            return ret;
        },
        runFrom: function (blocks, index, settings) {

            var thiz = this,
                blocks = blocks || this.items;

            var onFinishBlock = function (block, results) {
                block._lastResult = block._lastResult || results;
                thiz._currentIndex++;
                thiz.runFrom(blocks, thiz._currentIndex, settings);
            };

            var wireBlock = function (block) {
                block._deferredObject.then(function (results) {
                    onFinishBlock(block, results);
                });
            };

            if (blocks.length) {
                for (var n = index; n < blocks.length; n++) {
                    var block = blocks[n];
                    if (block.deferred === true) {
                        block._deferredObject = new Deferred();
                        this._currentIndex = n;
                        wireBlock(block);
                        this.addToEnd(this._return, block.solve(this.scope, settings));
                        break;
                    } else {
                        this.addToEnd(this._return, block.solve(this.scope, settings));
                    }
                }

            } else {
                this.onSuccess(this, settings);
            }

            return this._return;
        },
        serializeField: function (name) {
            return this.ignoreSerialize.indexOf(name) == -1;//is not in our array
        },
        onLoad: function () {
        },
        activate: function () {
        },
        deactivate: function () {
        },
        _get: function (what) {
            return (what in this.override ? this.override[what] : this[what]);
        },
        onDidRun: function () {
            this.override = {};
        },
        destroy:function(){
            this.stop();
        }
    });

    //global short-cuts
    Block.FLAGS = types.BLOCK_FLAGS;
    Block.EMITS = types.BLOCK_CALLBACKMASK;

    //that's really weird: using dynamic base classes nor Block.extend doesnt work.
    //however, move dojo complete out of blox
    if (has('xblox-ui')) {
        lang.mixin(Block.prototype, Block_UI.prototype);
    }

    if (!Block.prototype.onSuccess) {
        Block.prototype.onSuccess = function () {};
        Block.prototype.onRun = function () {}
        Block.prototype.onFailed = function () {}
    }
    dcl.chainAfter(Block,'stop');
    dcl.chainAfter(Block,'destroy');
    return Block;
});
define('xblox/model/logic/BreakBlock',[
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'xblox/model/Block'
], function(dcl,utils,types,Block){

    // summary:
    //		The Case Block model. Each case block contains a comparation and a commands block.
    //      If the comparation result is true, the block is executed
    //
    //      This block should have an "SwitchBlock" parent

    // module:
    //		xblox.model.logic.CaseBlock
    return dcl(Block,{
        declaredClass:"xblox.model.logic.BreakBlock",
        name:'Break',
        icon:'fa-stop',
        hasInlineEdits:false,
        canAdd:false,
        toText:function(){
            return '&nbsp;<span class="fa-stop text-warning"></span>&nbsp;&nbsp;<span>' + this.name + '</span>';
        },
        /***
         * Solves the case block
         * @param scope
         * @param switchBlock   => parent SwitchCommand block
         */
        solve:function(scope,settings) {
            this.onSuccess(this, settings);
        },
        //  standard call for editing
        getFields:function(){

            var fields = this.inherited(arguments) || this.getDefaultFields();
            return fields;
        }
    });
});
define('xblox/model/logic/CaseBlock',[
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'xblox/model/Block',
    'dojo/Deferred',
    "xblox/model/logic/BreakBlock"
], function(dcl,utils,types,Block,Deferred,BreakBlock){

    // summary:
    //		The Case Block model. Each case block contains a comparation and a commands block.
    //      If the comparation result is true, the block is executed
    //
    //      This block should have an "SwitchBlock" parent

    // module:
    //		xblox.model.logic.CaseBlock
    return dcl(Block,{
        declaredClass:"xblox.model.logic.CaseBlock",
        //comparator: xblox.model.Comparator
        // Comparison to be applied -> compare <switch variable> width <expression>
        comparator:null,

        //expression: xblox.model.Expression
        // expression to be compared
        expression:null,

        //items: Array (xblox.model.Block)
        //  block to be executed if the comparison result is true
        items:null,

        name:'Case',

        icon:'',

        hasInlineEdits:true,


        toText:function(){

            var _comparator = '' + this.comparator;
            if(_comparator=='=='){
                //_comparator =''
            }
            return '<span style="text-indent: 1em;">&nbsp;&nbsp;&nbsp;' +this.getBlockIcon('I') + this.name + ' ' + this.makeEditable('comparator','right','text','Enter a comparison','inline') + (this.expression !=null ?  ' ' + this.makeEditable('expression','right','text','Enter a value to compare') : '') + '</span>';
        },

        canAdd:function(){
            return [];
        },
        /***
         * Solves all the commands into items[]
         *
         * @param manager   =>  BlockManager
         * @return  list of commands to send
         */
        _solve: function (scope, settings,switchblock) {

            settings = settings || {
                    highlight: false
                };
            var ret = [];
            for (var n = 0; n < this.items.length; n++) {
                var block = this.items[n];
                if(block.declaredClass.indexOf('BreakBlock')!==-1){
                    switchblock.stop();
                }
                this.addToEnd(ret, block.solve(scope, settings));
            }

            return ret;
        },
        /***
         * Solves the case block
         * @param scope
         * @param switchBlock   => parent SwitchCommand block
         */
        solve:function(scope,switchBlock,settings) {

            try {
                var _var = scope.getVariableById(switchBlock.variable);
                //console.log('case block: ' + this.comparator + this.expression,_var);
                // Get the variable to evaluate
                var switchVarValue = '';
                if (_var) {
                    switchVarValue = this._getArg(_var.value, true);
                } else {
                    this.onFailed(this, settings);
                    // Comparation is false
                    return false;
                }


                //var compResult = scope.parseExpression("'" + switchVarValue+ "'" + this.comparator + this.expression);
                var compResult = scope.parseExpression("" + switchVarValue + "" + this.comparator + this._getArg(this.expression, true));

                if (compResult === true) {
                    this.onSuccess(this, settings);
                    // Comparation is true. Return block.solve();
                    this._solve(scope, settings,switchBlock);
                    return true;
                } else {
                    this.onFailed(this, settings);
                    // Comparation is false
                    return false;
                }
            }catch (e){
                console.error('case block crashed! ',e.stack);
                console.trace();
            }
        },
        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren:function(parent){
            return this.items;
        },
        //  standard call for editing
        getFields:function(){

            var fields = this.inherited(arguments) || this.getDefaultFields();

            fields.push(utils.createCI('Expression',13,this.expression,{
                    group:'General',
                    title:'Expression',
                    dst:'expression'
                }));

            function makeOption(value,label){
                return {
                    label:label || value,
                    value:value
                }
            }

            fields.push(utils.createCI('Comparator',3,this.comparator,{
                    group:'General',
                    title:'Comparator',
                    dst:'comparator',
                    widget:{
                        options:[
                            /*makeOption('==',"Equals"),
                            makeOption('<=',"Smaller or equal"),
                            makeOption('=>',"Greater or equal"),
                            makeOption('!=',"Not equal"),
                            makeOption('<',"Smaller than"),
                            makeOption('>',"Greater than")*/
                            makeOption('=='),
                             makeOption('<='),
                             makeOption('=>'),
                             makeOption('!='),
                             makeOption('<'),
                             makeOption('>')
                        ],
                        editable:true
                    }
            }));
            return fields;
        },
        runAction:function(action){

            if(action.command==='New/Break'){
                var dfd = new Deferred();
                var newBlock = this.add(BreakBlock,{
                    group:null
                });

                var defaultDfdArgs = {
                    select: [newBlock],
                    focus: true,
                    append: false
                };
                dfd.resolve(defaultDfdArgs);
                newBlock.refresh();
                return dfd;
            }
        },
        getActions:function(){

            return [this.createAction({
                    label: 'Break',
                    command: 'New/Break',
                    tab: 'Home',
                    icon:'fa-stop',
                    group: 'File',
                    mixin: {
                        addPermission: true,
                        custom:true,
                        quick:false
                    }
                })
            ]
        }
    });
});
define('xblox/model/functions/CallBlock',[
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'dojo/Deferred',
    "xblox/model/Block"
], function(dcl,utils,types,Deferred,Block){

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.functions.CallBlock
    /**
     * @augments module:xide/mixins/EventedMixin
     * @extends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    return dcl(Block,{
        declaredClass:"xblox.model.functions.CallBlock",
        //command: (String)
        //  block action name
        command:'Select command please',

        icon:'',

        args:null,

        _timeout:100,

        /***
         * Returns the block run result
         * @param scope
         */
        solve:function(scope,settings) {

            var timeout = this._timeout || 50;

            var dfd = new Deferred();

            setTimeout(function(){


                if (this.command){
                    var _args = null;
                    if(this.args){
                        settings.override = settings.override || {};
                        var args = scope.expressionModel.replaceVariables(scope,this.args,false,false,null,null,{
                            begin:"%%",
                            end:"%%"
                        });

                        _args = utils.fromJson(args);
                        settings.override['args']=[args];
                        settings.override['mixin']=_args;
                    }
                    //console.log('solve command');
                    var res = scope.solveBlock(this.command,settings);
                    if(res){
                        this.onSuccess(this,settings);
                    }else{
                        this.onFailed(this,settings);
                    }


                    dfd.resolve(res);

                    return res;
                }
            }.bind(this),timeout);

            return dfd;
        },
        hasInlineEdits:true,
        /**
         *
         * @param field
         * @param pos
         * @param type
         * @param title
         * @param mode: inline | popup
         * @returns {string}
         */
        makeEditable:function(field,pos,type,title,mode,options,value){

            var optionsString = "";
            if(options){

            }

            return "<a " + optionsString + "  tabIndex=\"-1\" pos='" + pos +"' display-mode='" + (mode||'popup') + "' display-type='" + (type || 'text') +"' data-prop='" + field + "' data-title='" + title + "' class='editable editable-click'  href='#'>" + this[field] +"</a>";
        },
        getFieldOptions:function(field){

            if(field ==="command"){
                return this.scope.getCommandsAsOptions("text");
            }
        },
        toText:function(){

            var text = 'Unknown';
            var block = this.scope.getBlock(this.command);
            if(block){
                text = block.name;
            }
            if(this.command.indexOf('://')!==-1) {
                text = '<span class="text-info">' +this.scope.toFriendlyName(this,this.command) + '</span>';
            }
            //var _out = this.getBlockIcon('D') + 'Call Command : ' + this.makeEditable('command','bottom','select','Enter a unique name','inline');
            var _out = this.getBlockIcon('D') + 'Call Command : ' + text;
            return _out;
        },
        onChangeField:function(what,value){
            //debugger;
        },
        //  standard call for editing
        getFields:function(){

            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz=this;

            var title = 'Command';
            if(this.command.indexOf('://')){
                title = this.scope.toFriendlyName(this,this.command);
            }
            fields.push(utils.createCI('value','xcf.widgets.CommandPicker',this.command,{
                    group:'General',
                    title:'Command',
                    dst:'command',
                    options:this.scope.getCommandsAsOptions(),
                    block:this,
                    pickerType:'command',
                    value:this.command
            }));

            fields.push(utils.createCI('arguments',27,this.args,{
                group:'Arguments',
                title:'Arguments',
                dst:'args'
            }));

            return fields;
        }
    });
});
define('xblox/model/code/CallMethod',[
    'dcl/dcl',
    "xblox/model/Block",
    'xide/utils'
], function(dcl,Block,utils){

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    return dcl(Block,{
        declaredClass:"xblox.model.code.CallMethod",
        //method: (String)
        //  block action name
        name:'Call Method',
        //method: (String)
        //  block action name
        method:'',
        args:'',

        sharable:true,
        /***
         * Returns the block run result
         * @param scope
         */
        solve:function(scope,settings) {
            var context = this.getContext();
            if (context && context[this.method]!=null)
            {


                var res = [];
                var _fn = context[this.method];
                try{
                    var _args = this.getArgs(settings);
                    console.log('args',_args);
                    var _res = _fn.apply(context,_args||[]);
                    res = _res;
                    this.onSuccess(this,settings);
                    return res;
                }catch(e){
                    console.error('call method ' + this.method + ' failed: '+e);
                    logError(e);
                    this.onFailed(this,settings);
                }
            }else{
                this.onFailed(this,settings);
                return [];
            }
            return [];
        },
        toText:function(){

            var result = this.getBlockIcon() + ' ' + this.name + ' ';
            if(this.method){
                result+= this.makeEditable('method','bottom','text','Enter a driver method','inline');
            }
            return result;
        },

        //  standard call for editing
        getFields:function(){

            var fields = this.getDefaultFields();

            var context = this.getContext();
/*
            console.log('call method ', this.getScope().getContext());
            console.log('call method ', context);*/


            fields.push(utils.createCI('value',13,this.method,{
                    group:'General',
                    title:'Method',
                    dst:'method'
                }));

            fields.push(utils.createCI('value',27,this.args,{
                    group:'Arguments',
                    dst:'args',
                    widget:{
                        title:''
                    }
                }));

            return fields;
        },
        getBlockIcon:function(){
            return '<span class="fa-caret-square-o-right"></span>';
        }
    });
});
define('xblox/model/Contains',[
    'dcl/dcl',
    "dojo/promise/all",
    "xide/types"
], function(dcl,all,types){
    /**
     * Contains provides implements functions to deal with sub blocks.
     *
     */
    return dcl(null,{

        declaredClass:'xblox.model.Contains',
        getContainer:function(){
            return this[this._getContainer()];
        },
        /**
         * Store is asking this!
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren:function(parent){
            var items = this[this._getContainer()];
            return items!=null && items.length>0;
        },
        /**
         * Store function
         * @param parent
         * @returns {Array}
         */
        getChildren:function(parent){
            return this[this._getContainer()];
        },
        //  standard call from interface
        canAdd:function(){
            return [];
        },
        runFrom: function (_blocks, index, settings) {

            var thiz = this,
                blocks = _blocks || this.items,
                allDfds = [];

            var onFinishBlock = function (block, results) {
                block._lastResult = block._lastResult || results;
                thiz._currentIndex++;
                thiz.runFrom(blocks, thiz._currentIndex, settings);
            };

            var wireBlock = function (block) {
                block._deferredObject.then(function (results) {
                    console.log('----def block finish');
                    onFinishBlock(block, results);
                });
            };

            if (blocks.length) {

                for (var n = index; n < blocks.length; n++) {
                    var block = blocks[n];
                    if (block.deferred === true) {
                        block._deferredObject = new Deferred();
                        this._currentIndex = n;
                        wireBlock(block);
                        //this.addToEnd(this._return, block.solve(this.scope, settings));
                        var blockDfd = block.solve(this.scope, settings);
                        allDfds.push(blockDfd);
                        break;
                    } else {
                        //this.addToEnd(this._return, block.solve(this.scope, settings));

                        var blockDfd = block.solve(this.scope, settings);
                        allDfds.push(blockDfd);
                    }

                }

            } else {
                this.onSuccess(this, settings);
            }

            return allDfds;
        },
        /***
         * Generic: run sub blocks
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {Array}
         */
        _solve:function(scope,settings,run,error) {

            if(!this._lastRunSettings && settings){
                this._lastRunSettings= settings;
            }

            settings = this._lastRunSettings || settings;


            this._currentIndex=0;
            this._return=[];

            var ret=[], items = this[this._getContainer()];
            if(items.length) {
                var res = this.runFrom(items,0,settings);
                this.onSuccess(this, settings);
                return res;
            }else{
                this.onSuccess(this, settings);
            }
            return ret;
        },
        onDidRunItem:function(dfd,result,settings){

            settings = settings || {};

            var listener = settings.listener,
                thiz = this;
            this._emit(types.EVENTS.ON_RUN_BLOCK_SUCCESS, thiz);
            dfd.resolve(result);
        },
        onDidRunItemError:function(dfd,result,settings){

            settings = settings || {};

            var listener = settings.listener,
                thiz = this;

            dfd.reject(result);
        },
        onRunThis:function(settings){

            settings = settings || {};

            var listener = settings.listener,
                thiz = this;

            if(listener) {
                //listener._emit(types.EVENTS.ON_RUN_BLOCK, thiz);
            }
            this._emit(types.EVENTS.ON_RUN_BLOCK, thiz);
        },
        onDidRunThis:function(dfd,result,items,settings){

            var thiz = this;

            //more blocks?
            if(items.length) {

                var subDfds = thiz.runFrom(items,0,settings);

                all(subDfds).then(function(what){
                    console.log('all solved!',what);
                    thiz.onDidRunItem(dfd,result,settings);
                },function(err){
                    console.error('error in chain',err);
                    thiz.onDidRunItem(dfd,err,settings);
                });

            }else{
                thiz.onDidRunItem(dfd,result,settings);
            }
        },
        ___solve:function(scope,settings,run,error) {


            /*
            if(!this._lastRunSettings && settings){
                this._lastRunSettings= settings;
            }

            settings = this._lastRunSettings || settings;


            this._currentIndex=0;
            this._return=[];

            var ret=[], items = this[this._getContainer()];
            if(items.length) {

                var res = this.runFrom(items,0,settings);

                this.onSuccess(this, settings);

                return res;

            }else{

                this.onSuccess(this, settings);
            }
            return ret;
            */
        }
    });
});
define('xblox/model/code/RunScript',[
    'dcl/dcl',
    'xdojo/has',
    "dojo/Deferred",
    "xblox/model/Block",
    'xide/utils',
    'xblox/model/Contains',
    'dojo/promise/all',
    'xide/types',
    'module'
    //'xdojo/has!host-node?dojo/node!tracer',
    //'xdojo/has!host-node?nxapp/utils/_console'
    //"xdojo/has!xblox-ui?dojo/text!./RunScript.html"
    //"xdojo/has!xblox-ui?dojo/text!xblox/docs/code/RunScript.md"
], function(dcl,has,Deferred,Block,utils,Contains,all,types,module,tracer,_console,Description,Help){

    
    var isServer = has('host-node');
    var console = typeof window !== 'undefined' ? window.console : global.console;
    if(isServer && tracer && console && console.error){
        console = _console;
    }else{
        //console.error('have no tracer ' + (tracer!=null && tracer.error!=null ? 'tracer ok ' : 'no ') + ' | ' + (console.error!=null ? 'errir ok ' : 'no error') );
        //console.dir(tracer);
    }

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    return dcl([Block,Contains],{
        declaredClass:"xblox.model.code.RunScript",
        //method: (String)
        //  block action name
        name:'Run Script',
        //method: (String)
        //  block action name
        method:'',
        args:'',
        deferred:false,
        sharable:true,
        context:null,
        icon:'fa-code',
        observed:[
            'method'
        ],
        getContext:function(){
            return this.context || (this.scope.getContext ?  this.scope.getContext() : this);
            /*
             sudo /Applications/Install\ OS\ X\ El\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/USB --applicationpath /Applications/Install\ OS\ X\ El\ Capitan.app --nointeraction
            if(this.scope.context && this.scope.context.instance){
                return this.scope.context.instance;
            }*/
            return this.context || this;
        },
        /***
         * Returns the block run result
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {Array}
         */
        solve2:function(scope,settings,run,error) {

            this._currentIndex = 0;
            this._return=[];
            var _script = '' + this._get('method');
            var thiz=this,
                ctx = this.getContext();
            if(_script && _script.length) {

                //bloody promises, still not working as real monads
                //TODO, look at arrowlets
                //  move out exception shit

                var runScript = function() {

                    /*this = scope.global;*/
                    var _function = new Function("{" + _script + "}");
                    var _args = thiz.getArgs() || [];
                    try {

                        var _parsed = _function.apply(ctx, _args || {});

                        thiz._lastResult = _parsed;

                        if (run) {
                            run('Expression ' + _script + ' evaluates to ' + _parsed);
                        }
                        if (_parsed !== 'false' && _parsed !== false) {
                            thiz.onSuccess(thiz, settings,{
                                result:_parsed
                            });
                        } else {
                            thiz.onFailed(thiz, settings);
                            return [];
                        }
                    } catch (e) {

                        if (error) {
                            error('invalid expression : \n' + _script + ': ' + e);
                        }
                        thiz.onFailed(thiz, settings);
                        return [];
                    }
                };

                if(scope.global){
                    (function() {
                        window = scope.global;
                        var _args = thiz.getArgs() || [];
                        try {
                            var _parsed = null;
                            if(!ctx.runExpression) {
                                var _function = new Function("{" + _script + "}").bind(this);
                                _parsed = _function.apply(ctx, _args || {});
                            }else{
                                _parsed = ctx.runExpression(_script,null,_args);
                            }

                            thiz._lastResult = _parsed;

                            if (run) {
                                run('Expression ' + _script + ' evaluates to ' + _parsed);
                            }
                            if (_parsed !== 'false' && _parsed !== false) {
                                thiz.onSuccess(thiz, settings);
                            } else {
                                thiz.onFailed(thiz, settings);
                                return [];
                            }


                        } catch (e) {

                            thiz._lastResult = null;
                            if (error) {
                                error('invalid expression : \n' + _script + ': ' + e);
                            }
                            thiz.onFailed(thiz, settings);
                            return [];
                        }

                    }).call(scope.global);

                }else{
                    return runScript();
                }


            }else{
                console.error('have no script');
            }
            var ret=[], items = this[this._getContainer()];
            if(items.length) {
                this.runFrom(items,0,settings);
            }else{
                this.onSuccess(this, settings);
            }

            this.onDidRun();

            return ret;
        },
        /**
         *
         * @param scope
         * @param settings
         * @param run
         * @param error
         */
        solve:function(scope,settings,isInterface,send,run,error){

            this._currentIndex = 0;
            this._return=[];


            //console.log('Run RunScript');

            settings = settings || {};
            var _script = send || ('' + this._get('method'));

            var thiz=this,
                ctx = this.getContext(),
                items = this[this._getContainer()],

                //outer,head dfd
                dfd = new Deferred,
                listener = settings.listener,

                isDfd = thiz.deferred;


            this.onRunThis(settings);

            function globalEval(text) {
                var ret;
                // Properly escape \, " and ' in the input, normalize \r\n to an escaped \n
                text = text.replace(/["'\\]/g, "\\$&").replace(/\r\n/g, "\\n");

                // You have to use eval() because not every expression can be used with an assignment operator
                var where = typeof window!=='undefined' ? window : global;

                where.execScript("globalEval.____lastInputResult____ = eval('" + text + "');} }");

                // Store the result and delete the property
                ret = globalEval.____lastInputResult____;
                delete globalEval.____lastInputResult____;

                return ret;
            }

            //var _scope.parseExpression(this.condition +';',null,null);

            //expression = this.replaceAll("''","'",expression);//weird!
            //expression = this.replaceBlockCalls(scope,expression);

            //var expressionContext = context || scope.context || scope.getContext() ||{};
            //var useVariableGetter  = expressionContext['getVariable'] !=null;


            var expression = scope.expressionModel.replaceVariables(scope,_script,null,null);

            //console.error('parse '+expression);

            var _function = new Function("{" + expression + "}");
            //var _function = new Function(_script);
            var _args = thiz.getArgs(settings) || [];
            try {

                if(isDfd){
                    ctx.resolve=function(result){
                        if(thiz._deferredObject) {
                            thiz._deferredObject.resolve();
                        }
                        //_headDone(result);
                        thiz.onDidRunThis(dfd,result,items,settings);
                    }
                }
                var _parsed = _function.apply(ctx, _args || {});
                //var _parsed = globalEval(_script);
                //console.log('---' + _parsed);
                thiz._lastResult = _parsed;
                if (run) {
                    run('Expression ' + _script + ' evaluates to ' + _parsed);
                }


                if(!isDfd) {
                   // console.log('root block done');
                    //_headDone(_parsed);
                    thiz.onDidRunThis(dfd,_parsed,items,settings);
                }

                if (_parsed !== 'false' && _parsed !== false) {
                    thiz.onSuccess(thiz, settings);
                } else {
                    //console.log('----false result');
                    thiz.onFailed(thiz, settings);
                    //return [];
                }
            } catch (e) {
                e=e ||{};
                thiz.onDidRunItemError(dfd,e,settings);
                thiz.onFailed(thiz,settings);
                if (error) {
                    error('invalid expression : \n' + _script + ': ' + e);
                }
                //thiz.onFailed(thiz, settings);
                //return [];
            }

            return dfd;

        },

        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText:function(){

            var result = '<span style="">' + this.getBlockIcon() + ' ' + this.name + ' :: '+'</span>';
            if(this.method){
                result+= this.method.substr(0,50);
            }
            return result;
        },

        //  standard call from interface
        canAdd:function(){
            return [];
        },
        //  standard call for editing
        getFields:function(){

            if(this.description === 'No Description'){
                this.description = Description;
            }

            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz=this;

            fields.push(
                utils.createCI('name',13,this.name,{
                    group:'General',
                    title:'Name',
                    dst:'name'
                })
            );

            fields.push(
                utils.createCI('deferred',0,this.deferred,{
                    group:'General',
                    title:'Deferred',
                    dst:'deferred'
                })
            );




            fields.push(utils.createCI('arguments',27,this.args,{
                    group:'Arguments',
                    title:'Arguments',
                    dst:'args'
                }));

            fields.push(

                utils.createCI('value',types.ECIType.EXPRESSION_EDITOR,this.method,{
                    group:'Script',
                    title:'Script',
                    dst:'method',
                    select:true,
                    widget:{
                        allowACECache:true,
                        showBrowser:false,
                        showSaveButton:true,
                        editorOptions:{
                            showGutter:true,
                            autoFocus:false
                        },
                        item:this
                    },
                    delegate:{
                        runExpression:function(val,run,error){
                            var old = thiz.method;
                            thiz.method=val;
                            var _res = thiz.solve(thiz.scope,null,run,error);
                        }
                    }
                }));
            return fields;
        }
    });
});
define('xblox/model/code/RunBlock',[
    'dcl/dcl',
    "xblox/model/Block",
    'xide/types',
    'xide/utils'
], function(dcl,Block,types,utils){

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod


    return dcl(Block,{
        declaredClass:"xblox.model.code.RunBlock",
        //method: (String)
        //  block action name
        name:'Run Block',

        file:'',
        //method: (String)
        //  block action name
        method:'',

        args:'',

        sharable:true,

        block:'',

        description:"Runs another Block",
        /***
         * Returns the block run result
         * @param scope
         */
        solve:function(scope,settings) {

            var context = this.getContext();
            if (context && context[this.method]!=null)
            {
                var res = [];
                var _fn = context[this.method];
                try{
                    var _args = this._getArgs();
                    var _res = _fn.apply(context,_args||[]);
                    res = _res;
                    this.onSuccess(this,settings);
                    return res;
                }catch(e){
                    console.error('call method failed');
                    this.onFailed(this,settings);
                }
            }else{
                this.onFailed(this,settings);
                return [];
            }
            return [];
        },
        toText:function(){

            var result = this.getBlockIcon() + ' ' + this.name + ' ';
            if(this.method){
                result+= this.method.substr(0,20);
            }
            return result;
        },

        //  standard call for editing
        getFields:function(){


            var fields = this.getDefaultFields();


            fields.push(utils.createCI('Block', types.ECIType.BLOCK_REFERENCE, this.block, {
                toolTip:'Enter  block, you can use also the block\'s share title',
                group: 'General',
                dst: 'block',
                value: this.block,
                title:'Block',
                scope:this.scope
            }));

            fields.push(utils.createCI('File', types.ECIType.FILE, this.file, {
                toolTip:'Leave empty to auto-select this file',
                group: 'General',
                dst: 'file',
                value: this.file,
                intermediateChanges: false,
                acceptFolders: false,
                acceptFiles: true,
                encodeFilePath: false,
                buildFullPath: true,
                filePickerOptions: {
                    dialogTitle: 'Select Block File',
                    filePickerMixin: {
                        beanContextName: this.id,
                        persistent: false,
                        globalPanelMixin: {
                            allowLayoutCookies: false
                        }
                    },
                    configMixin: {
                        beanContextName: this.id,
                        LAYOUT_PRESET: types.LAYOUT_PRESET.SINGLE,
                        PANEL_OPTIONS:{
                            ALLOW_MAIN_MENU:false,
                            ALLOW_NEW_TABS:true,
                            ALLOW_MULTI_TAB:false,
                            ALLOW_INFO_VIEW:true,
                            ALLOW_LOG_VIEW:false,
                            ALLOW_CONTEXT_MENU:true,
                            ALLOW_LAYOUT_SELECTOR:true,
                            ALLOW_SOURCE_SELECTOR:true,
                            ALLOW_COLUMN_RESIZE:true,
                            ALLOW_COLUMN_REORDER:true,
                            ALLOW_COLUMN_HIDE:true,
                            ALLOW_ACTION_TOOLBAR:true,
                            ALLOW_BREADCRUMBS:false
                        }
                    },
                    defaultStoreOptions: {
                        "fields": 1663,
                        "includeList": "xblox",
                        "excludeList": "*"
                    },
                    startPath: this.file
                }
            }));

            return fields;

            /*
            fields.push(utils.createCI('value',27,this.args,{
                    group:'General',
                    title:'Arguments',
                    dst:'args'
                }));

            return fields;
            */
        },
        getBlockIcon:function(){
            return '<span class="el-icon-share-alt"></span>';
        }


    });
});
/** @module xblox/model/variables/Variable */
define('xblox/model/variables/Variable',[
    'dcl/dcl',
    'xide/types',
    "xblox/model/Block"
], function(dcl,types,Block){
    /**
     *  The command model. A 'command' consists out of a few parameters and a series of
     *  expressions. Those expressions need to be evaluated before send them to the device
     *
     * @class module:xblox.model.variables.Variable
     * @augments module:xide/mixins/EventedMixin
     * @extends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     */
    return dcl(Block,{
        declaredClass:"xblox.model.variables.Variable",
        //name: String
        //  the variable's name, it should be unique within a scope
        name:null,

        //value: Current variable value
        value:null,

        register:true,

        readOnly:false,

        initial:null,

        getValue:function(){
            return this.value;
        },
        canDisable:function(){
            return false;
        },
        canMove:function(){
            return false;
        },
        getIconClass:function(){
            return 'el-icon-quotes-alt';
        },
        getBlockIcon:function(){
            return '<span class="'+this.icon+'"></span> ';
        },
        toText:function(){
            return "<span class='text-primary'>" + this.getBlockIcon() +  this.makeEditable('name','right','text','Enter a unique name','inline') +"</span>";
        },
        solve:function(){

            var _result = this.scope.parseExpression(this.getValue(),true);
            //console.log('resolved variable ' + this.title + ' to ' + _result);
            return [];

        },
        getFields:function(){

            var fields = this.getDefaultFields();
            var thiz=this,
                defaultArgs = {
                    allowACECache:true,
                    showBrowser:false,
                    showSaveButton:true,
                    editorOptions:{
                        showGutter:false,
                        autoFocus:false,
                        hasConsole:false
                    },
                    aceOptions:{
                        hasEmmet:false,
                        hasLinking:false,
                        hasMultiDocs:false
                    },
                    item:this
                };

            fields.push(this.utils.createCI('title',types.ECIType.STRING,this.name,{
                group:'General',
                title:'Name',
                dst:'name'
            }));



            fields.push(this.utils.createCI('value',types.ECIType.EXPRESSION,this.value,{
                group:'General',
                title:'Value',
                dst:'value',
                delegate:{
                    runExpression:function(val,run,error){
                        return thiz.scope.expressionModel.parse(thiz.scope,val,false,run,error);
                    }
                }
            }));


            //this.types.ECIType.EXPRESSION_EDITOR
            /*
            fields.push(this.utils.createCI('initial',this.types.ECIType.EXPRESSION,this.initial,{
                group:'General',
                title:'Initial',
                dst:'initial',
                widget:defaultArgs,
                delegate:{
                    runExpression:function(val,run,error){
                        if(thiz.group=='processVariables'){
                            var _val = thiz.scope.getVariable("value");
                            var extra = "";
                            if(_val) {
                                _val = _val.value;
                                if(!thiz.isNumber(_val)){
                                    _val = ''+_val;
                                    _val = "'" + _val + "'";
                                }
                                extra = "var value = " + _val +";\n";
                            }
                        }
                        return thiz.scope.expressionModel.parse(thiz.scope,extra + val,false,run,error);
                    }
                }
            }));
            */
            return fields;
        }
    });
});
define('xblox/model/loops/ForBlock',[
    "dcl/dcl",
    "xblox/model/Block",
    "xblox/model/variables/Variable",
    'xblox/model/Contains',
    "dojo/promise/all",
    "dojo/Deferred"
], function(dcl,Block,Variable,Contains,all,Deferred){

    // summary:
    //		The for block model. It repeats a block a number of times, while the condition is true.
    //

    // module:
    //		xblox.model.loops.ForBlock
    return dcl([Block,Contains],{
        declaredClass:"xblox.model.loops.ForBlock",
        // initial: xcf.model.Expression
        // the initial value
        initial: null,

        // final: xcf.model.Expression
        // the final value to be compared with the counter. Once the final value equals to the counter, the loop stops
        "final": null,
        //comparator: xblox.model.Comparator
        // Comparison to be applied -> compare <counter variable> width <final>
        comparator: null,
        // modifier: xcf.model.Expression
        // expression to be applied to the counter on every step. Expression: "<counter><modifier>"
        modifier: null,

        //items: Array (xblox.model.Block)
        //  block to be executed while the condition compare <counter variable> width <final> is false
        items: null,

        //counterName: String
        // the counter variable name
        counterName: null,

        // (private) counter: xblox.model.Variable
        // counter to be compared and updated on every step
        _counter: null,
        name:'For',
        sharable:true,
        icon:'',
        ignoreErrors:false,
        runFrom: function (_blocks, index, settings) {

            var thiz = this,
                blocks = _blocks || this.items,
                allDfds = [];

            var onFinishBlock = function (block, results) {
                block._lastResult = block._lastResult || results;
                thiz._currentIndex++;
                thiz.runFrom(blocks, thiz._currentIndex, settings);
            };

            var wireBlock = function (block) {
                block._deferredObject.then(function (results) {
                    console.log('----def block finish');
                    onFinishBlock(block, results);
                });
            };

            if (blocks.length) {

                for (var n = index; n < blocks.length; n++) {

                    var block = blocks[n];

                    if(block.enabled===false){
                        continue;
                    }

                    //console.log('run child');

                    if (block.deferred === true) {
                        block._deferredObject = new Deferred();
                        this._currentIndex = n;
                        wireBlock(block);
                        //this.addToEnd(this._return, block.solve(this.scope, settings));
                        var blockDfd = block.solve(this.scope, settings);
                        allDfds.push(blockDfd);
                        break;
                    } else {

                        //this.addToEnd(this._return, block.solve(this.scope, settings));

                        var blockDfd = block.solve(this.scope, settings);
                        allDfds.push(blockDfd);
                    }

                }

            } else {
                this.onSuccess(this, settings);
            }

            return allDfds;
        },
        _currentForIndex:0,
        solveSubs:function(dfd,result,items,settings){

            var thiz = this;

            settings.override = settings.override || {};

            settings.override['args']=[this._currentForIndex];



            //more blocks?
            if(items.length) {

                //console.log('---solve subs');

                var subDfds = thiz.runFrom(items,0,settings);

                all(subDfds).then(function(what){
                    //console.log('all solved!',what);
                    //thiz.onDidRunItem(dfd,result,settings);
                },function(err){
                    console.error('error in chain',err);
                    thiz.onDidRunItem(dfd,err,settings);
                });

                return subDfds;

            }else{
                thiz.onDidRunItem(dfd,result,settings);
            }
        },
        _solve:function(scope,settings){

            var ret=[];

            var dfd = new Deferred(),
                self = this;

            var result = this.solveSubs(dfd,null,this.items,settings);

            //console.log('subs' , result);

            /*
            dfd.then(function(res){
               console.error('dfd head ',res);
            });
            */

            all(result).then(function(res){
                var falsy = res.indexOf(false);
                //console.error('subs '+falsy,res);
                if(self.ignoreErrors!==true && falsy!==-1){
                    dfd.resolve(false);
                }else{
                    dfd.resolve(true);
                }
            });


            /*
            for(var n = 0; n < this.items.length ; n++)
            {
                //this.addToEnd( ret , this.items[n].solve(scope,settings) );
                if(this.items[n].enabled) {
                    //this.addToEnd(ret,this.items[n].solve(scope,settings));
                    var sub = this.items[n].solve(scope,settings);
                    ret.push(sub);
                }
            }
            */
            //console.dir(ret);
            return dfd;
        },

        step:function(scope,settings){

            var state = this._checkCondition(scope,settings);

            var dfd = new Deferred(),
                self = this;

            if(state){
                //console.log('cond ok');

                //run blocks
                var subs = this._solve(scope,settings);
                subs.then(function(result){
                    //console.log('sub step result ' + result);
                    if(result==true){
                        //console.log('continue');
                        dfd.resolve(true);
                    }else{
                        //console.log('break');
                        dfd.resolve(false);

                    }
                });
            }
            return dfd;

        },
        _forState:false,
        loop:function(scope,settings){

            var stepResult = this.step(scope,settings),
                self = this;

            stepResult.then(function(proceed){
                self._updateCounter(scope);
                //console.log('proceed ' + proceed + ' _ ' + self._forState + ' ' + self._counter.value);
                self._currentForIndex = self._counter.value;
                if(proceed==true){
                    self.loop(scope,settings);
                }else{
                    self.onFailed(self,settings);
                }
            });
        },

        // solves the for block (runs the loop)
        solve:function(scope,settings) {

            var ret = [];
            var noInfinite = true;


            // 1. Create and initialize counter variable
            this._counter = new Variable({
                title : this.counterName,
                value : this.initial,
                scope : scope,
                register:false
            });

            var cond = null;

            //prepare
            this._forState = true;

            this._currentForIndex = this.initial;


            this.loop(scope,settings);




            // 2. Compare counter width final using comparator
            // 3. IF TRUE -
            //while (this._checkCondition(scope,settings)) {
                //var p = this.inherited(arguments);
                //console.error('parents : ' + p);
                // 4. Run Block
                //this.addToEnd( ret , this._solve(scope,settings) );
            /*
                var subs = this._solve(scope,settings);

                console.log('subs',subs);

                all(subs,function(result){
                    console.log('subs done',result);
                });


                // 5. Update counter
                noInfinite = this._updateCounter(scope);

                if (!noInfinite){
                    break;
                }
            */
                // 6. go back to (2)
            //}
            /*
            while (this._checkCondition(scope,settings)) {
                //var p = this.inherited(arguments);
                //console.error('parents : ' + p);
                // 4. Run Block
                //this.addToEnd( ret , this._solve(scope,settings) );

                var subs = this._solve(scope,settings);

                console.log('subs',subs);

                all(subs,function(result){
                   console.log('subs done',result);
                });


                // 5. Update counter
                noInfinite = this._updateCounter(scope);

                if (!noInfinite){
                    break;
                }
                // 6. go back to (2)
            }
            */


            return ret;
        },

        // checks the loop condition
        _checkCondition:function(scope,settings) {

            var expression = '' + this._counter.value + this.comparator + this['final'];
            var result = scope.parseExpression(expression);
            //console.log('FOR LOOP STEP ' + expression + ' = ' + result);

            if(result==false){
                //this.onFailed(this,settings);
            }else{
                this.onSuccess(this,settings);
            }

            this._forState=result;

            return result;
        },

        // updates the counter
        _updateCounter:function(scope) {
            var value = this._counter.value;
            var expression = '' + value + this.modifier;
            value = scope.parseExpression(expression);
            //console.log('       update counter ' + expression + " = " + value);
            // Detect infinite loops
            if (value == this._counter.value) {
                return false;
            } else {
                this._counter.value = value;
                return true;
            }
        },
        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren:function(parent){
            return this.items!=null && this.items.length>0;
        },
        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren:function(parent){
            var result=[];

            if(this.items){
                result=result.concat(this.items);
            }
            return result;
        },
        /**
         * @TODO
         * should return a number of valid classes
         * @returns {Array}
         */
        canAdd:function(){
            return [];
        },
        /**
         * UI, Block row editor, returns the entire text for this block
         * @returns {string}
         */
        toText:function(){
            return this.getBlockIcon('F') + this.name + ' ' + this.initial + ' ' + this.comparator + ' ' + this['final']  + ' with ' + this.modifier;
        },
        /**
         * UI
         * @returns {*[]}
         */
        getFields:function(){

            var fields = this.inherited(arguments) || this.getDefaultFields();


            fields = fields.concat([

                this.utils.createCI('initial',13,this.initial,{
                    group:'General',
                    title:'Initial',
                    dst:'initial'
                }),
                this.utils.createCI('Final',13,this['final'],{
                    group:'General',
                    title:'Final',
                    dst:'final'
                }),
                this.utils.createCI('comparator',13,this.comparator,{
                    group:'General',
                    title:'Comparision',
                    dst:'comparator'
                }),
                this.utils.createCI('modifier',13,this.modifier,{
                    group:'General',
                    title:'Modifier',
                    dst:'modifier'
                }),
                this.utils.createCI('Abort on Error',0,this.ignoreErrors,{
                    group:'General',
                    title:'Ignore Errors',
                    dst:'ignoreErrors'
                })
            ]);
            //fields = fields.concat(this.inherited(arguments));
            return fields;
        }
    });
});
define('xblox/model/loops/WhileBlock',[
    "dcl/dcl",
    "xblox/model/Block",
    "xblox/model/variables/Variable"
], function(dcl,Block,Variable){

    // summary:
    //		The while block model. It repeats a block a number of times, while the condition is true.
    //

    // module:
    //		xblox.model.loops.WhileBlock
    return dcl(Block,{

        declaredClass:"xblox.model.loops.WhileBlock",
        // condition: (String) expression to be evaluated every step
        condition: null,
        /**
         * Blocks to be executed while the condition is true
         * @type {xblox.model.Block[]}
         * @inheritDoc
         */
        items: null,

        loopLimit: 1500,

        name:'While',

        wait:0,

        _currentIndex:0,

        sharable:true,

        icon:"",

        _timer:null,

        //  standard call from interface
        canAdd:function(){
            return [];
        },
        _solve:function(scope,settings){
            var ret=[];
            for(var n = 0; n < this.items.length ; n++)
            {
                this.items[n].solve(scope,settings);
            }
            return ret;
        },

        doStep:function(settings){

            if(this._currentIndex < this.loopLimit){

                var ret = [];

                var _cond = this._checkCondition(this.scope);
                if(_cond) {
                    this.onSuccess(this,settings);
                    this.addToEnd( ret , this._solve(this.scope,settings));
                    this._currentIndex++;
                }else{
                    if(this._timer){
                        clearInterval(this._timer);
                    }


                    this.onFailed(this,settings);
                }
            }else{
                console.error('--while block : reached loop limit');
                this.reset();
            }
        },
        reset:function(){
            if(this._timer){
                clearTimeout(this._timer);
                this._timer = null;
            }
            this._currentIndex=0;


        },
        // solves the while block (runs the loop)
        solve:function(scope,settings) {

            //console.log('solve while ');
            this.loopLimit = 1500;
            settings = settings || { };

            var iterations = 0;

            var ret = [],
                thiz = this;

            var delay = this._getArg(this.wait);

            this.reset();

            // has delay
            if(delay>0){

                this._timer = setInterval(function(){
                    thiz.doStep(settings);
                },delay);

                return [];
            }

            // Evaluate condition
            while ((this._checkCondition(scope)) && (iterations < this.loopLimit)) {
                this._solve(scope,settings);
                iterations++;
            }
            //cleanup

            this.reset();

            return ret;

        },

        /**
         * Block row editor, returns the entire text for this block
         * @returns {string}
         */
        toText:function(){
            return this.getBlockIcon('G') + this.name + ' ' + this.condition;
        },

        // checks the loop condition
        _checkCondition:function(scope) {
            return scope.parseExpression(this.condition);
        },
        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren:function(parent){
            return this.items!=null && this.items.length>0;
        },

        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren:function(parent){
            var result=[];

            if(this.items){
                result=result.concat(this.items);
            }
            return result;
        },
        getFields:function(){


            var thiz=this;

            var fields = this.inherited(arguments) || this.getDefaultFields();

            fields.push(

                this.utils.createCI('condition',25,this.condition,{
                    group:'General',
                    title:'Expression',
                    dst:'condition',
                    delegate:{
                        runExpression:function(val,run,error){
                            return thiz.scope.expressionModel.parse(thiz.scope,val,false,run,error);
                        }
                    }
                })
            );

            fields.push(this.utils.createCI('wait',13,this.wait,{
                    group:'General',
                    title:'Wait',
                    dst:'wait'
            }));
            return fields;
        }


    });
});
define('dojo/store/util/QueryResults',["../../_base/array", "../../_base/lang", "../../when"
], function(array, lang, when){

// module:
//		dojo/store/util/QueryResults

var QueryResults = function(results){
	// summary:
	//		A function that wraps the results of a store query with additional
	//		methods.
	// description:
	//		QueryResults is a basic wrapper that allows for array-like iteration
	//		over any kind of returned data from a query.  While the simplest store
	//		will return a plain array of data, other stores may return deferreds or
	//		promises; this wrapper makes sure that *all* results can be treated
	//		the same.
	//
	//		Additional methods include `forEach`, `filter` and `map`.
	// results: Array|dojo/promise/Promise
	//		The result set as an array, or a promise for an array.
	// returns:
	//		An array-like object that can be used for iterating over.
	// example:
	//		Query a store and iterate over the results.
	//
	//	|	store.query({ prime: true }).forEach(function(item){
	//	|		//	do something
	//	|	});

	if(!results){
		return results;
	}

	var isPromise = !!results.then;
	// if it is a promise it may be frozen
	if(isPromise){
		results = lang.delegate(results);
	}
	function addIterativeMethod(method){
		// Always add the iterative methods so a QueryResults is
		// returned whether the environment is ES3 or ES5
		results[method] = function(){
			var args = arguments;
			var result = when(results, function(results){
				Array.prototype.unshift.call(args, results);
				return QueryResults(array[method].apply(array, args));
			});
			// forEach should only return the result of when()
			// when we're wrapping a promise
			if(method !== "forEach" || isPromise){
				return result;
			}
		};
	}

	addIterativeMethod("forEach");
	addIterativeMethod("filter");
	addIterativeMethod("map");
	if(results.total == null){
		results.total = when(results, function(results){
			return results.length;
		});
	}
	return results; // Object
};

lang.setObject("dojo.store.util.QueryResults", QueryResults);

return QueryResults;

});

define('dstore/legacy/DstoreAdapter',[
	'dojo/_base/declare',
	'dojo/_base/array',
	'dojo/store/util/QueryResults'
	/*=====, "dstore/api/Store" =====*/
], function (declare, arrayUtil, QueryResults /*=====, Store =====*/) {
// module:
//		An adapter mixin that makes a dstore store object look like a legacy Dojo object store.

	function passthrough(data) {
		return data;
	}

	// No base class, but for purposes of documentation, the base class is dstore/api/Store
	var base = null;
	/*===== base = Store; =====*/

	var adapterPrototype = {

		// store:
		//		The dstore store that is wrapped as a Dojo object store
		store: null,

		constructor: function (store) {
			this.store = store;

			if (store._getQuerierFactory('filter') || store._getQuerierFactory('sort')) {
				this.queryEngine = function (query, options) {
					options = options || {};

					var filterQuerierFactory = store._getQuerierFactory('filter');
					var filter = filterQuerierFactory ? filterQuerierFactory(query) : passthrough;

					var sortQuerierFactory = store._getQuerierFactory('sort');
					var sort = passthrough;
					if (sortQuerierFactory) {
						sort = sortQuerierFactory(arrayUtil.map(options.sort, function (criteria) {
							return {
								property: criteria.attribute,
								descending: criteria.descending
							};
						}));
					}

					var range = passthrough;
					if (!isNaN(options.start) || !isNaN(options.count)) {
						range = function (data) {
							var start = options.start || 0,
								count = options.count || Infinity;

							var results = data.slice(start, start + count);
							results.total = data.length;
							return results;
						};
					}

					return function (data) {
						return range(sort(filter(data)));
					};
				};
			}
			var objectStore = this;
			// we call notify on events to mimic the old dojo/store/Trackable
			store.on('add,update,delete', function (event) {
				var type = event.type;
				var target = event.target;
				objectStore.notify(
					(type === 'add' || type === 'update') ? target : undefined,
					(type === 'delete' || type === 'update') ?
						('id' in event ? event.id : store.getIdentity(target)) : undefined);
			});
		},
		labelAttr:'title',
		getLabel:function(item){
			return this.store.getLabel(item);
		},
		query: function (query, options) {
			// summary:
			//		Queries the store for objects. This does not alter the store, but returns a
			//		set of data from the store.
			// query: String|Object|Function
			//		The query to use for retrieving objects from the store.
			// options: dstore/api/Store.QueryOptions
			//		The optional arguments to apply to the resultset.
			// returns: dstore/api/Store.QueryResults
			//		The results of the query, extended with iterative methods.
			//
			// example:
			//		Given the following store:
			//
			//	...find all items where "prime" is true:
			//
			//	|	store.query({ prime: true }).forEach(function(object){
			//	|		// handle each object
			//	|	});
			options = options || {};

			var results = this.store.filter(query);
			var queryResults;
			var tracked;
			var total;

			// Apply sorting
			var sort = options.sort;
			if (sort) {
				if (Object.prototype.toString.call(sort) === '[object Array]') {
					var sortOptions;
					while ((sortOptions = sort.pop())) {
						results = results.sort(sortOptions.attribute, sortOptions.descending);
					}
				} else {
					results = results.sort(sort);
				}
			}

			if (results.track && !results.tracking) {
				// if it is trackable, always track, so that observe can
				// work properly.
				results = results.track();
				tracked = true;
			}
			if ('start' in options) {
				// Apply a range
				var start = options.start || 0;
				// object stores support sync results, so try that if available
				queryResults = results[results.fetchRangeSync ? 'fetchRangeSync' : 'fetchRange']({
					start: start,
					end: options.count ? (start + options.count) : Infinity
				});
			}
			queryResults = queryResults || results[results.fetchSync ? 'fetchSync' : 'fetch']();
			total = queryResults.totalLength;
			queryResults = new QueryResults(queryResults);
			queryResults.total = total;
			queryResults.observe = function (callback, includeObjectUpdates) {
				// translate observe to event listeners
				function convertUndefined(value) {
					if (value === undefined && tracked) {
						return -1;
					}
					return value;
				}
				var addHandle = results.on('add', function (event) {
					callback(event.target, -1, convertUndefined(event.index));
				});
				var updateHandle = results.on('update', function (event) {
					if (includeObjectUpdates || event.previousIndex !== event.index || !isFinite(event.index)) {
						callback(event.target, convertUndefined(event.previousIndex), convertUndefined(event.index));
					}
				});
				var removeHandle = results.on('delete', function (event) {
					callback(event.target, convertUndefined(event.previousIndex), -1);
				});
				var handle = {
					remove: function () {
						addHandle.remove();
						updateHandle.remove();
						removeHandle.remove();
					}
				};
				handle.cancel = handle.remove;
				return handle;
			};
			return queryResults;
		},
		notify: function () {

		}
	};

	var delegatedMethods = [ 'get', 'put', 'add', 'remove', 'getIdentity' ];
	arrayUtil.forEach(delegatedMethods, function (methodName) {
		adapterPrototype[methodName] = function () {
			var store = this.store;
			// try sync first, since dojo object stores support that directly
			return (store[methodName + 'Sync'] || store[methodName]).apply(store, arguments);
		};
	});

	return declare(base, adapterPrototype);
});

/** @module xblox/model/variables/VariableAssignmentBlock **/
define('xblox/model/variables/VariableAssignmentBlock',[
    'dcl/dcl',
    "xblox/model/Block",
    "xide/utils",
    "xide/types",
    'dstore/legacy/DstoreAdapter',
    "xide/factory"
], function(dcl,Block,utils,types,DstoreAdapter,factory){

    /**
     *
     * @class module:xblox/model/variables/VariableAssignmentBlock
     * @extends xblox/model/Block
     */
    return dcl(Block,{
        declaredClass: "xblox.model.variables.VariableAssignmentBlock",

        //variable: (String)
        //  variable title
        variable:null,

        //value: (String)
        // Expression to be asigned
        value:null,
        name:'Set Variable',
        icon:'',
        hasInlineEdits:true,
        toText:function(){

            var _variable = this.scope.getVariableById(this.variable);
            var _text = _variable ? _variable.name : '';
            if(this.variable.indexOf('://')!==-1) {
                _text = '<span class="text-info">' +this.scope.toFriendlyName(this, this.variable)+'</span>';
            }
            return this.getBlockIcon('C') + this.name + ' ' + _text  + "<span class='text-muted small'> to <kbd class='text-warning'>" + this.makeEditable("value",'bottom','text','Enter the string to send','inline') + "</kbd></span>";
        },
        /***
         * Makes the assignation
         * @param scope
         */

        solve:function(scope,settings) {
            var value = this.value;
            if(!value){
                var _value = this.getArgs();
                if(_value.length>0){
                    value = _value[0];
                }
            }
            if (this.variable && value!==null){
                this.onRun(this,settings);
                //var _variable = scope.getVariable(this.variable).value = scope.parseExpression(this.value);
                var _variable = this.variable.indexOf('://')!==-1 ? this.scope.resolveBlock(this.variable) : scope.getVariableById(this.variable);
                var _value = this._getArg(value);
                if(!_variable){
                    console.error('     no such variable : ' + this.variable);
                    return [];
                }
                var _parsed = null;
                if(this.isScript(_value)){
                    _parsed = scope.parseExpression(_value);
                    _parsed = this.replaceAll("'",'',_parsed);
                    //_variable.value = scope.parseExpression(_value);
                    //_variable.value = this.replaceAll("'",'',_variable.value);

                }else{
                    _variable.value = _value;
                    _parsed = _value;
                }

                _variable.set('value',_parsed);

                factory.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED,{
                    item:_variable,
                    scope:this.scope,
                    save:false,
                    block:this,
                    name:_variable.name,
                    value:_value
                });
                this.onSuccess(this,settings);
                return [];
            }
        },
        canAdd:function(){
            return null;
        },
        getFields:function(){

            var fields = this.inherited(arguments) || this.getDefaultFields(false);
            var thiz=this;

            /*
            fields.push(this.utils.createCI('Variable',3,this.variable,{
                    group:'General',
                    dst:'variable',
                    widget:{
                        store:new DstoreAdapter(this.scope.blockStore),
                        query:{
                            group:'basicVariables'
                        }
                    }
            }));
            */




            fields.push(this.utils.createCI('value',29,this.value,{
                    group:'General',
                    title:'Value',
                    dst:'value',
                    widget:{
                        allowACECache:true,
                        showBrowser:false,
                        showSaveButton:true,
                        editorOptions:{
                            showGutter:false,
                            autoSelect: false,
                            autoFocus: false,
                            hasConsole:false,
                            hasItemActions:function(){
                                return false
                            }
                        },
                        item:this
                    },
                    delegate:{
                        runExpression:function(val,run,error){
                            return thiz.scope.expressionModel.parse(thiz.scope,val,false,run,error);
                        }
                    }
            }));




            fields.push(utils.createCI('value','xcf.widgets.CommandPicker',this.variable,{
                group:'Variable',
                title:'Variable',
                dst:'variable',
                //options:this.scope.getVariablesAsOptions(),
                block:this,
                pickerType:'variable',
                value:this.variable,
                widget:{
                    store:this.scope.blockStore,
                    labelField:'name',
                    valueField:'id',
                    value:this.variable,
                    query:[
                        {
                            group:'basicVariables'
                        },
                        {
                            group:'processVariables'
                        }
                    ]

                }
            }));

            return fields;
        }
    });
});
define('xblox/model/Statement',[
    "dcl/dcl",
    "xblox/model/Block"
], function(dcl,Block){

    // summary:
    //		The statement block is only a wrapper for items like in 'else'

    // module:
    //		xblox.model.Statement
    return dcl(Block,{
        declaredClass:"xblox.model.Statement",
        /**
         * Return block name
         * @returns {name|*}
         */
        toText:function(){
            return this.name;
        },
        /**
         *
         * @returns {items|*}
         */
        getChildren:function(){
            return this.items;
        }
    });
});
define('xblox/model/logic/ElseIfBlock',[
    "dcl/dcl",
    "xblox/model/Block",
    "xblox/model/Contains"
], function(dcl,Block,Contains){

    // summary:
    //		The ElseIf Block model. Each ElseIf block contains a condition and a consequent to be run if the condition
    //          is true
    //
    //      This block should have an "IfBlock" parent

    // module:
    //		xblox.model.logic.ElseIfBlock
    return dcl([Block,Contains],{
        declaredClass:"xblox.model.logic.ElseIfBlock",
        //  condition: (String) expression to be evaluated
        condition: "",
        //  consequent: (Block) block to be run if the condition is true
        consequent:null,
        name:'else if',
        icon:'',
        solve:function(scope,settings) {
            if(this._checkCondition(scope)) {
                return this._solve(scope, settings)
            }
            return false;
        },
        toText:function(){
            return "<span class='text-primary'>" + this.getBlockIcon('E') + this.name + " </span>" +  "<span class='text-warning small'>" + (this.condition || "") +"<span>";
        },
        // checks the ElseIf condition
        _checkCondition:function(scope) {
            if(this.condition!==null) {
                var res = scope.parseExpression(this.condition);
                return res;
            }
            return false;
        },
        getFields:function(){

            var thiz=this;
            var fields = this.inherited(arguments) || this.getDefaultFields();
            fields.push(
                this.utils.createCI('condition',this.types.ECIType.EXPRESSION_EDITOR,this.condition,{
                    group:'General',
                    title:'Expression',
                    dst:'condition',
                    delegate:{
                        runExpression:function(val,run,error){
                            return thiz.scope.expressionModel.parse(thiz.scope,val,false,run,error);
                        }
                    }
                })
            );
            return fields;
        }
    });
});
/** @module xblox/model/logic/IfBlock **/
define('xblox/model/logic/IfBlock',[
    "dcl/dcl",
    "xblox/model/Block",
    "xblox/model/Statement",
    "xblox/model/logic/ElseIfBlock",
    "dojo/Deferred",
    "xide/utils"
], function(dcl,Block,Statement,ElseIfBlock,Deferred,utils){
    /**
     * Base block class.
     *
     * @class module:xblox/model/logic/IfBlock
     * @augments module:xblox/model/ModelBase
     * @extends module:xblox/model/Block
     */
    return dcl(Block,{
        declaredClass:"xblox.model.logic.IfBlock",
        // condition: (String) expression to be evaluated
        condition: 'Invalid Expression',

        // consequent: (Block) block to be run if the condition is true
        consequent:null,

        // elseIfBlocks: (optional) Array[ElseIfBlock] -> blocks to be run if the condition is false. If any of these blocks condition is
        //          true, the elseIf/else sequence stops
        elseIfBlocks:null,

        // alternate: (optional) (Block) -> block to be run if the condition is false and none of the "elseIf" blocks is true
        alternate: null,

        //  standard call from interface
        canAdd:function(){
            return [];
        },

        //  autoCreateElse : does auto creates the else part
        autoCreateElse:true,

        //  name : this name is displayed in the block row editor
        name:'if',

        icon:'',
        //  add
        //
        // @param proto {mixed : Prototype|Object} : the new block's call prototype or simply a ready to use block
        // @param ctrArgs {Array} : constructor arguments for the new block
        // @param where {String} : consequent or alternate or elseif
        // @returns {Block}
        //
        add:function(proto,ctrArgs,where){
            if(where==null){
                where = 'consequent';
            }
            return this._add(proto,ctrArgs,where,false);
        },

        //  overrides default store integration
        __addToStore:function(store){
            //add our self to the store
            store.put(this);
        },

        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren:function(parent){
            return (this.items !==null && this.items.length) ||
                (this.elseIfBlocks !==null && this.elseIfBlocks.length) ||
                (this.consequent!=null && this.consequent.length>0) ||
                (this.alternate!=null && this.alternate.length>0);

        },

        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren:function(parent){
            var result=[];

            if(this.consequent){
                result=result.concat(this.consequent);
            }

            if(this.elseIfBlocks){
                result=result.concat(this.elseIfBlocks);
            }
            if(this.alternate){
                result=result.concat(this.alternate);
            }
            return result;
        },

        /**
         * Block row editor, returns the entire text for this block
         * @returns {string}
         */
        toText:function(){
            return "<span class='text-primary'>" + this.getBlockIcon('E') + this.name + " </span>" +  "<span class='text-warning small'>" + this.condition +"<span>";
        },
        _checkCondition:function(scope) {
            //console.log('cond ' + this.condition.length);
            return scope.parseExpression(this.condition,null,null);
        },
        /***
         * Solves the if block
         * @param scope
         */
        solve:function(scope,settings) {
            // 1. Check the condition
            var solvedCondition = this._checkCondition(scope);
            //console.log('elseIfBlocks ',this.alternate);
            var elseIfBlocks = this.getElseIfBlocks();
            var others = this.childrenByNotClass(ElseIfBlock);

            others = others.filter(function(block){
               return !block.isInstanceOf(Statement);
            });

            // 2. TRUE? => run consequent
            if (solvedCondition==true || solvedCondition > 0) {
                this.onSuccess(this,settings);
                var result = null;
                if(others && others.length ){
                    for(var i = 0;i <others.length ; i++){
                        result = others[i].solve(scope,settings);
                    }
                }
                return result;
            } else {
                // 3. FALSE?
                var anyElseIf = false;

                this.onFailed(this,settings);

                if (elseIfBlocks)
                {
                    // 4. ---- check all elseIf blocks. If any of the elseIf conditions is true, run the elseIf consequent and
                    //           stop the process
                    for( var n = 0;  ( n < elseIfBlocks.length ) && (!anyElseIf) ; n++){
                        var _elseIfBlock = elseIfBlocks[n];
                        if (_elseIfBlock._checkCondition(scope)){
                            _elseIfBlock.onSuccess(_elseIfBlock,settings);
                            anyElseIf = true;
                            return _elseIfBlock.solve(scope,settings);
                        }else{
                            _elseIfBlock.onFailed(_elseIfBlock,settings);
                        }
                    }
                }

                var alternate = this.childrenByClass(Statement);

                // 5. ---- If none of the ElseIf blocks has been run, run the alternate
                if (alternate.length>0 && (!anyElseIf))
                {
                    var result = null;
                    for(var i = 0;i <alternate.length ; i++){
                        result = alternate[i].solve(scope,settings);
                    }
                    return result;
                }
            }
            return [];
        },
        /**
         * Default override empty. We have 3 arrays to clean : items, alternate and consequent
         * @param what
         */
        empty:function(what){
            this._empty(this.alternate);
            this._empty(this.consequent);
            this._empty(this.items);
            this._empty(this.elseIfBlocks);
        },
        /**
         * Deletes us or children block in alternate or consequent
         * @param what
         */
        removeBlock:function(what){
            if(what){
                if(what && what.empty){
                    what.empty();
                }
                delete what.items;
                what.parent=null;
                this.alternate.remove(what);
                this.consequent.remove(what);
                this.elseIfBlocks.remove(what);
                this.items.remove(what);
            }
        },
        // evaluate the if condition
        _getContainer:function(item){

            if(this.consequent.indexOf(item)!=-1){
                return 'consequent';
            }else if(this.alternate.indexOf(item)!=-1){
                return 'alternate';
            }else if(this.elseIfBlocks.indexOf(item)!=-1){
                return 'elseIfBlocks';
            }

            return '_';
        },
        /**
         * Default override, prepare all variables
         */
        init:function(){

            this.alternate = this.alternate||[];
            this.consequent = this.consequent||[];
            this.elseIfBlocks = this.elseIfBlocks||[];

            for(var i = 0;i <this.alternate.length ; i++){
                this.alternate[i].parentId=this.id;
                this.alternate[i].parent=this;
            }
            for(var i = 0;i <this.elseIfBlocks.length ; i++){
                this.elseIfBlocks[i].parentId=this.id;
                this.elseIfBlocks[i].parent=this;
            }
            for(var i = 0;i <this.consequent.length ; i++){
                this.consequent[i].parentId=this.id;
                this.consequent[i].parent=this;
            }
            //var store = this.scope.blockStore;
        },
        getFields:function(){

            var thiz=this;
            var fields = this.inherited(arguments) || this.getDefaultFields();
            fields.push(
                this.utils.createCI('condition',this.types.ECIType.EXPRESSION_EDITOR,this.condition,{
                    group:'General',
                    title:'Expression',
                    dst:'condition',
                    delegate:{
                        runExpression:function(val,run,error){
                            return thiz.scope.expressionModel.parse(thiz.scope,val,false,run,error);
                        }
                    }
                })
            );

            return fields;
        },
        postCreate:function(){
            if(this._postCreated){
                return;
            }
            this._postCreated = true;
            var store = this.scope.blockStore;
        },
        toCode:function(lang,params){
        },
        getElseIfBlocks:function(){
            return this.childrenByClass(ElseIfBlock);
        },
        runAction:function(action){
            var store = this.scope.blockStore;
            var command = action.command;

            if(command==='New/Else' || command ==='New/Else If'){

                var newBlockClass = command ==='New/Else If' ? ElseIfBlock : Statement;

                var args = utils.mixin({
                    name:'else',
                    //items:this.alternate,
                    items:[],
                    //group:this.group,//if we are child, don't set the group, otherwise it goes as top-level-block!
                    dstField:'alternate',
                    parentId:this.id,
                    parent:this,
                    scope:this.scope,
                    canAdd:function(){
                        return [];
                    },
                    canEdit:function(){
                        return false;
                    }
                }, newBlockClass == ElseIfBlock ? {
                    name:'else if',
                    dstField:'elseIfBlocks'
                } : {
                    name:'else',
                    dstField:'alternate'
                } );

                var newBlock = this.add(newBlockClass,args, newBlockClass == Statement ? 'alternate' : 'elseIfBlocks');

                var defaultDfdArgs = {
                    select: [newBlock],
                    focus: true,
                    append: false,
                    expand:true,
                    delay:10
                };

                var dfd = new Deferred();
                this.items.push(newBlock);
                store._emit('added',{
                    target:newBlock
                });
                dfd.resolve(defaultDfdArgs);
                newBlock.refresh();
                return dfd;

            }
/*
            if(action.command==='New/Else If'){
                var dfd = new Deferred();
                var newBlock = this.add(ElseIfBlock,{
                    name:'else if',
                    //items:this.alternate,
                    items:[],
                    //group:this.group,//if we are child, don't set the group, otherwise it goes as top-level-block!
                    dstField:'elseIfBlocks',
                    parentId:this.id,
                    parent:this,
                    scope:this.scope,
                    canAdd:function(){
                        return [];
                    },
                    canEdit:function(){
                        return true;
                    }
                },'elseIfBlocks');

                this.items.push(newBlock);

                var defaultDfdArgs = {
                    select: [newBlock],
                    focus: true,
                    append: false,
                    expand:true,
                    delay:1
                };

                store.emit('added',{
                    target:newBlock
                });
                //this.refresh();
                dfd.resolve(defaultDfdArgs);
                newBlock.refresh();
                return dfd;
            }
            */
        },
        getActions:function(){

            var result = [];

            if(this.alternate.length==0) {
                result.push(this.createAction({
                    label: 'Else',
                    command: 'New/Else',
                    icon: this.getBlockIcon('I'),
                    tab: 'Home',
                    group: 'File',
                    mixin: {
                        addPermission: true,
                        custom: true
                    }
                }));
            }

            result.push(this.createAction({
                label: 'Else If',
                command: 'New/Else If',
                icon: this.getBlockIcon('I'),
                tab: 'Home',
                group: 'File',
                mixin: {
                    addPermission: true,
                    custom: true
                }
            }));

            return result;
        }
    });
});
define('xblox/model/logic/SwitchBlock',[
    'dcl/dcl',
    "xblox/model/Block",
    "xblox/model/logic/CaseBlock"
], function(dcl,Block,CaseBlock){

    // summary:
    //		Switchs on  a variable's value and runs one case block

    // module:
    //		xblox.model.SwitchBlock
    return dcl(Block,{
        declaredClass:"xblox.model.logic.SwitchBlock",
        // switchVariable: xcf.model.Variable
        //  3.12.10.3. The “variable” field indicates the variable name to be evaluated
        //  into the switch block
        variable: 'PowerState',

        //items: Array (xblox.model.CaseBlock / xblox.model.Block)
        //  Each case to be evaluated / Block to be executed if none of the cases occurs.
        //
        //
        items:null,

        name:'Switch',

        toText:function(){
            return this.getBlockIcon('H') + this.name + ' ' + this.variable;
        },

        canAdd:function(){
            return [];
        },

        /***
         * Solve the switchblock
         *
         * @param scope
         * @returns {string} execution result
         */
        solve:function(scope,settings) {
            this._stopped = false;
            var anyCase = false;    // check if any case is reached
            var ret = [];
            this.onSuccess(this,settings);
            // iterate all case blocks
            for(var n = 0; n < this.items.length ; n++)
            {
                var block = this.items[n];

                if (block.declaredClass==='xblox.model.logic.CaseBlock'/* instanceof CaseBlock*/)
                {
                    var caseret;
                    // solve each case block. If the comparison result is false, the block returns "false"
                    caseret = block.solve(scope,this,settings);
                    if (caseret != false)
                    {

                        // If the case block return is not false, don't run "else" block
                        anyCase = true;
                        this.addToEnd( ret , caseret);
                        break;
                    }else{
                        /*this.onFailed(block,settings);*/
                    }
                }
                if(this._stopped){
                    break;
                }
            }
            // iterate all "else" blocks if none of the cases occurs
            if (!anyCase) {
                for(var n = 0; n < this.items.length ; n++)
                {
                    var block = this.items[n];

                    if ( !(block.declaredClass=='xblox.model.logic.CaseBlock') )
                    {
                        this.addToEnd( ret , block.solve(scope,settings) );
                    }
                }
            }

            return ret;
        },
        init:function(){

        },
        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren:function(parent){
            return this.items;
        },
        postCreate:function(){

            this.add(CaseBlock,{
                comparator : "==",
                expression : "'ON'",
                group:null
            });

            this.add(CaseBlock,{
                comparator : "==",
                expression : "'Standby'",
                group:null
            });
        }
    });
});
define('xblox/model/logic/DefaultBlock',[
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'xblox/model/Block'
], function(dcl,utils,types,Block){

    // summary:
    //		The Case Block model. Each case block contains a comparation and a commands block.
    //      If the comparation result is true, the block is executed
    //
    //      This block should have an "SwitchBlock" parent

    // module:
    //		xblox.model.logic.CaseBlock
    return dcl(Block,{
        declaredClass:"xblox.model.logic.DefaultBlock",
        name:'Default',
        icon:'',
        hasInlineEdits:false,
        toText:function(){
            return '&nbsp;<span class="fa-eject text-info"></span>&nbsp;&nbsp;<span>' + this.name + '</span>';
        },
        solve:function(scope,settings) {
            this.onSuccess(this, settings);
            return this._solve(scope, settings);
        },
        //  standard call for editing
        getFields:function(){
            var fields = this.inherited(arguments) || this.getDefaultFields();
            return fields;
        }
    });
});
define('xblox/model/variables/VariableSwitch',[
    'dcl/dcl',
    "xblox/model/logic/SwitchBlock",
    'xide/types',
    "xblox/model/logic/CaseBlock",
    "xblox/model/logic/DefaultBlock",
    "dojo/Deferred"
], function(dcl,SwitchBlock,types,CaseBlock,DefaultBlock,Deferred){

    // summary:
    //		The switch command model. These kind of commands takes a existing variable and applies some comparison.
    //      Depending on the comparison results, the code into each case block is executed or not.

    // module:
    //		xblox.model.VariableSwitch
    return dcl(SwitchBlock,{
        declaredClass:"xblox.model.variables.VariableSwitch",
        name:'Switch on Variable',
        icon:'',
        toText:function(){
            var _variable = this.scope.getVariableById(this.variable);
            var _text = _variable ? _variable.name : '';
            return this.getBlockIcon('H')  + this.name + ' ' + _text;
        },
        //  standard call for editing
        getFields:function(){
            //options:this.scope.getVariablesAsOptions(),
            var fields = this.inherited(arguments) || this.getDefaultFields();
            fields = fields.concat([
                this.utils.createCI('Variable',3,this.variable,
                    {
                        group:'General',
                        widget:{
                            store:this.scope.blockStore,
                            labelField:'name',
                            valueField:'id',
                            query:[
                                {
                                    group:'basicVariables'
                                },
                                {
                                    group:'processVariables'
                                }
                            ]

                        },
                        dst:'variable'
                    }
                )
            ]);
            return fields;
        },
        stop:function(){
            this._stopped = true;
        },
        runAction:function(action){

            if(action.command==='New/Case'){
                var dfd = new Deferred();
                var newBlock = this.add(CaseBlock,{
                    comparator : "==",
                    expression : "on",
                    group:null
                });

                var defaultDfdArgs = {
                    select: [newBlock],
                    focus: true,
                    append: false
                };
                dfd.resolve(defaultDfdArgs);
                newBlock.refresh();
                return dfd;
            }

            if(action.command==='New/Default'){
                var dfd = new Deferred();
                var newBlock = this.add(DefaultBlock,{
                    group:null
                });

                var defaultDfdArgs = {
                    select: [newBlock],
                    focus: true,
                    append: false
                };
                dfd.resolve(defaultDfdArgs);
                newBlock.refresh();
                return dfd;
            }

        },
        getActions:function(){

            var result = [this.createAction({
                label: 'New Case',
                command: 'New/Case',
                icon: this.getBlockIcon('I'),
                tab: 'Home',
                group: 'File',
                mixin: {
                    addPermission: true,
                    custom:true,
                    quick:false
                }
            })];


            if(!_.find(this.items,{
                    declaredClass:'xblox.model.logic.DefaultBlock'
                })){
                result.push(this.createAction({
                    label: 'Default',
                    command: 'New/Default',
                    icon: 'fa-eject',
                    tab: 'Home',
                    group: 'File',
                    mixin: {
                        addPermission: true,
                        custom:true,
                        quick:false
                    }
                }));
            }

            return result;
        }
    });
});
define('dojo/_base/window',["./kernel", "./lang", "../sniff"], function(dojo, lang, has){
// module:
//		dojo/_base/window

var ret = {
	// summary:
	//		API to save/set/restore the global/document scope.

	global: dojo.global,
	/*=====
	 global: {
		 // summary:
		 //		Alias for the current window. 'global' can be modified
		 //		for temporary context shifting. See also withGlobal().
		 // description:
		 //		Use this rather than referring to 'window' to ensure your code runs
		 //		correctly in managed contexts.
	 },
	 =====*/

	doc: dojo.global["document"] || null,
	/*=====
	doc: {
		// summary:
		//		Alias for the current document. 'doc' can be modified
		//		for temporary context shifting. See also withDoc().
		// description:
		//		Use this rather than referring to 'window.document' to ensure your code runs
		//		correctly in managed contexts.
		// example:
		//	|	n.appendChild(dojo.doc.createElement('div'));
	},
	=====*/

	body: function(/*Document?*/ doc){
		// summary:
		//		Return the body element of the specified document or of dojo/_base/window::doc.
		// example:
		//	|	win.body().appendChild(dojo.doc.createElement('div'));

		// Note: document.body is not defined for a strict xhtml document
		// Would like to memoize this, but dojo.doc can change vi dojo.withDoc().
		doc = doc || dojo.doc;
		return doc.body || doc.getElementsByTagName("body")[0]; // Node
	},

	setContext: function(/*Object*/ globalObject, /*DocumentElement*/ globalDocument){
		// summary:
		//		changes the behavior of many core Dojo functions that deal with
		//		namespace and DOM lookup, changing them to work in a new global
		//		context (e.g., an iframe). The varibles dojo.global and dojo.doc
		//		are modified as a result of calling this function and the result of
		//		`dojo.body()` likewise differs.
		dojo.global = ret.global = globalObject;
		dojo.doc = ret.doc = globalDocument;
	},

	withGlobal: function(	/*Object*/ globalObject,
							/*Function*/ callback,
							/*Object?*/ thisObject,
							/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc.
		// description:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc. If provided, globalObject
		//		will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo.global
		//		and dojo.doc will be restored to its previous state.

		var oldGlob = dojo.global;
		try{
			dojo.global = ret.global = globalObject;
			return ret.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);
		}finally{
			dojo.global = ret.global = oldGlob;
		}
	},

	withDoc: function(	/*DocumentElement*/ documentObject,
						/*Function*/ callback,
						/*Object?*/ thisObject,
						/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with documentObject as dojo/_base/window::doc.
		// description:
		//		Invoke callback with documentObject as dojo/_base/window::doc. If provided,
		//		callback will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo/_base/window::doc will
		//		be restored to its previous state.

		var oldDoc = ret.doc,
			oldQ = has("quirks"),
			oldIE = has("ie"), isIE, mode, pwin;

		try{
			dojo.doc = ret.doc = documentObject;
			// update dojo.isQuirks and the value of the has feature "quirks".
			// remove setting dojo.isQuirks and dojo.isIE for 2.0
			dojo.isQuirks = has.add("quirks", dojo.doc.compatMode == "BackCompat", true, true); // no need to check for QuirksMode which was Opera 7 only

			if(has("ie")){
				if((pwin = documentObject.parentWindow) && pwin.navigator){
					// re-run IE detection logic and update dojo.isIE / has("ie")
					// (the only time parentWindow/navigator wouldn't exist is if we were not
					// passed an actual legitimate document object)
					isIE = parseFloat(pwin.navigator.appVersion.split("MSIE ")[1]) || undefined;
					mode = documentObject.documentMode;
					if(mode && mode != 5 && Math.floor(isIE) != mode){
						isIE = mode;
					}
					dojo.isIE = has.add("ie", isIE, true, true);
				}
			}

			if(thisObject && typeof callback == "string"){
				callback = thisObject[callback];
			}

			return callback.apply(thisObject, cbArguments || []);
		}finally{
			dojo.doc = ret.doc = oldDoc;
			dojo.isQuirks = has.add("quirks", oldQ, true, true);
			dojo.isIE = has.add("ie", oldIE, true, true);
		}
	}
};

has("extend-dojo") && lang.mixin(dojo, ret);

return ret;

});

/** module:xide/registry **/
define('xide/registry',[
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/window", // win.body
    "xdojo/has"
], function(array, win, has){
	/**
	 * @TODOS:
	 * - add namespaces
	 * - remove window
	 * - augment consumer API
	 * - use std array
	 * - add framework constraint
	 * - move dom api out of here
	 * - define widget.id better
	 * - add search by class
     */
	var _widgetTypeCtr = {}, hash = {};
	var registry =  {
		// summary:
		//		Registry of existing widget on page, plus some utility methods.

		// length: Number
		//		Number of registered widgets
		length: 0,
		add: function(widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(this._hash[widget.id]){
                if(has('xblox')) {
                    this.remove(widget.id);
                    this.add(widget);
                }else{
                    throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
                }
			}
			hash[widget.id] = widget;
			this.length++;
		},
		/**
		 * Remove a widget from the registry. Does not destroy the widget; simply
		 * removes the reference.
		 * @param id
         */
		remove: function(id){
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},
		/**
		 *
		 * @param id {String|Widget}
		 * @returns {String|Widget}
         */
		byId: function( id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
		},
		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
		},

		/**
		 * Convert registry into a true Array
		 * @example:
		 *	Work with the widget .domNodes in a real Array
		 *	array.map(registry.toArray(), function(w){ return w.domNode; });
		 * @returns {obj[]}
         */
		toArray: function(){
			return _.values(_.mapKeys(hash, function(value, key) { value.id = key; return value; }));
		},
		/**
		 * Generates a unique id for a given widgetType
		 * @param widgetType {string}
		 * @returns {string}
         */
		getUniqueId: function(widgetType){
			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return id;
		},
		/**
		 * Search subtree under root returning widgets found.
		 * Doesn't search for nested widgets (ie, widgets inside other widgets).
		 * @param root {HTMLElement} Node to search under.
		 * @param skipNode {HTMLElement} If specified, don't search beneath this node (usually containerNode).
         * @returns {Array}
         */
		findWidgets: function(root, skipNode){
			var outAry = [];
			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else if(node !== skipNode){
							getChildrenHelper(node);
						}
					}
				}
			}
			getChildrenHelper(root);
			return outAry;
		},
		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			// Destroy all the widgets, top down
			_.each(registry.findWidgets(win.body()),function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},
		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.nodeType == 1 && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};
	return registry;
});

define('xide/mixins/ReferenceMixin',[
    'dcl/dcl',
    "dojo/_base/declare",
    'xide/types',
    'xide/utils',
    'xide/registry'
], function (dcl, declare, types, utils, registry) {
    /**
     *
     * @param queryString
     * @param startNode
     * @param single
     * @returns {*}
     */
    utils.find = function (queryString, startNode, single) {
        var nodes = $(startNode).find(queryString);
        if (nodes && nodes.length > 0) {
            return single === false ? nodes : nodes[0];
        }
        return null;
    };

    /**
     *
     * @param scope
     * @param id
     * @returns {*}
     */
    function getElement(scope, id) {
        var dst = scope.document.getElementById(id);
        if (dst) {
            return dst;
        }
        return null;
    }

    var Implementation = {
        _targetReference: null,
        getTarget: function () {
            return this._targetReference || this.inherited(arguments);
        },
        skipWidgetCSSClasses: [
            'dijitButtonHover',
            'dijitHover',
            'dijit',
            'dijitInline',
            'dijitReset',
            'dijitCheckBoxChecked',
            'dijitChecked',
            'dijitLeft'
        ],
        _cssClassesToQuery: function (string) {
            var result = '';
            if (string) {
                var els = string.split(' ');
                for (var i = 0; i < els.length; i++) {

                    if (utils.contains(this.skipWidgetCSSClasses, els[i]) > -1 ||
                        els[i].toLowerCase().indexOf('hover') > -1) {
                        continue;
                    }
                    result += '' + els[i];
                }
            }
            return result.trim();
        },
        /**
         *
         * @param params (object in that format : reference(string) | mode (string))
         */
        resolveReference: function (params) {

            var override = null;
            try{
                override = this.getTarget();
            }catch(e){
                logError(e);
                return null;
            }
            var scope = this.scope;
            var query = params.reference;
            if (!params || !query || !query.length) {
                if (override) {
                    return [override];
                }
            }

            switch (params.mode) {
                //By id, try widget instance first, then try regular HTMLElement
                //
                case types.WIDGET_REFERENCE_MODE.BY_ID:
                {
                    if (this.scope && this.scope.document) {
                        var out = [];
                        if (query.indexOf(' ') !== -1) {

                            var ids = query.split(' ');
                            for (var i = 0; i < ids.length; i++) {
                                var el = getElement(scope, ids[i]);
                                if (el) {
                                    out.push(el);
                                }
                            }
                        } else {
                            return [getElement(scope, query)];
                        }
                        return out;
                    }
                    return [registry.byId(query)] || [dojo.byId(query)];
                }
                //By declared widget class
                //
                case types.WIDGET_REFERENCE_MODE.BY_CLASS:
                {
                    var obj = dojo.getObject(query) || dcl.getObject(query);
                    if (obj) {
                        return [obj];
                    }
                    break;
                }
                // By css class list
                //
                case types.WIDGET_REFERENCE_MODE.BY_CSS:
                {
                    var _query = this._cssClassesToQuery(query);

                    var _$ = null;
                    if (this.scope && this.scope.global && this.scope.global['$']) {
                        _$ = this.scope.global['$'];
                    }else if(typeof $!=='undefined'){
                        _$ = $;
                    }
                    if (_$) {
                        var _elements = _$(query);
                        if (_elements) {
                            return _elements;
                        }
                    }
                    var objects = utils.find(query, null, false);
                    if (objects) {
                        return objects;
                    }
                    break;
                }
            }
            return null;
        }
    };
    var Module = declare('xblox.model.ReferenceMixin', null, Implementation);
    Module.dcl = dcl(null, Implementation);
    return Module;
});
define('xblox/model/Referenced',[
    'dcl/dcl',
    "dojo/_base/declare",
    "xide/mixins/ReferenceMixin"
], function (dcl,declare, ReferenceMixin) {

    var Implementation = {
        /**
         * JSON String in that format : reference(string) | mode (string)
         */
        reference: null,
        /**
         * 'reference' is a JSON structure
         * @param value
         * @returns {*}
         */
        deserialize: function (value) {
            if (!value || value.length == 0) {
                return {}
            }
            try {
                return dojo.fromJson(value);
            } catch (e) {
                return {};
            }
        }
    }

    /**
     * Holds information to locate an object by string or direct reference.
     * This must be used as mixin rather as base class!
     */
    var Module = declare('xblox.model.Referenced', [ReferenceMixin],Implementation);
    Module.dcl = dcl(ReferenceMixin.dcl,Implementation);
    return Module;
});
define('xwire/_Base',[
    'dcl/dcl',
    'xide/mixins/EventedMixin'
],function(dcl,EventedMixin){
    /**
     * @param {object} o An object.
     * @param {string} path The path from object, either dot-concatenated string or an array.
     * @returns The value of the object path.
     */
    function getObjectPath(o, path) {
        for (var comps = getPathComps(path), i = 0, l = comps.length; i < l; ++i) {
            var comp = comps[i];
            o = o == null ? o : o[comp];
        }
        return o;
    }

    /**
     * Utility to split an object path from a dot separated string into an array
     * @param path
     * @param create
     * @returns {Array}
     */
    function getPathComps(path, create) {
        return path === "" ? [] : typeof path.splice !== "function" ? path.split(".") : create ? path.slice() : path;
    }


    /**
     * Sets a value to an object path.
     * @param {object} o An object.
     * @param {string} path The path from object, either dot-concatenated string or an array.
     * @returns The value set. Undefined if value cannot be set.
     */
    function setObjectPath(o, path, value) {
        var comps = getPathComps(path, true),
            prop = comps.pop();
        o = comps.length > 0 ? getObjectPath(o, comps) : o;
        return Object(o) !== o || !path ? undefined : // Bail if the target is not an object
            typeof o.set === "function" ? o.set(prop, value) :
                (o[prop] = value);
    }

    var _base  = dcl([EventedMixin.dcl],{
        declaredClass:'xwire._Base',
        /***
         * Standard constructor for all subclassing bindings
         * @param {array} arguments
         */
        constructor: function(args){

            //simple mixin of constructor arguments
            for (var prop in args) {
                if (args.hasOwnProperty(prop)) {

                    this[prop] = args[prop];
                }
            }
        },
        getValue:function(object,path){
            return getObjectPath(object,path);
        },
        setValue:function(object,path,value){
            return setObjectPath(object,path,value);
        }

    });
    return _base;
});
define('xblox/model/events/OnEvent',[
    'dcl/dcl',
    "dojo/_base/lang",
    "dojo/Deferred",
    "xblox/model/Block",
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xblox/model/Referenced',
    'xide/registry',
    'dojo/on',
    'xwire/_Base'
], function(dcl,lang,Deferred,Block,utils,types,EventedMixin,Referenced,registry,on,_Base){




    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    return dcl([Block,EventedMixin.dcl,Referenced.dcl,_Base],{
        declaredClass:"xblox.model.events.OnEvent",
        //method: (String)
        //  block action name
        name:'On Event',
        event:'',
        reference:'',
        references:null,
        sharable:true,
        _didSubscribe:false,
        filterPath:"item.name",
        filterValue:"",
        valuePath:"item.value",
        _nativeEvents:[
            "onclick",
            "ondblclick",
            "onmousedown",
            "onmouseup",
            "onmouseover",
            "onmousemove",
            "onmouseout",
            "onkeypress",
            "onkeydown",
            "onkeyup",
            "onfocus",
            "onblur",
            "onchange"
        ],

        stop:function(){

            this._destroy();

        },
        /***
         * Returns the block run result
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {Array}
         */
        solve:function(scope,settings,isInterface,error) {

            if(isInterface){
                this._destroy();
            }

            settings = this._lastSettings = settings || this._lastSettings;

            if(!this._didSubscribe){
                this._registerEvent(this.event);
                this.onSuccess(this, settings);
                return false;
            }

            this.onSuccess(this, settings);

            this._currentIndex=0;
            this._return=[];

            var ret=[], items = this[this._getContainer()];
            if(items.length) {
                //console.log('solve ',settings);
                var res = this.runFrom(items,0,settings);
                this.onSuccess(this, settings);
                return res;
            }else{
                this.onSuccess(this, settings);
            }
            return ret;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText:function(){
            var result = this.getBlockIcon() + ' ' + this.name + ' :: ';
            if(this.event){
                result+= this.event;
            }
            return result;
        },

        //  standard call from interface
        canAdd:function(){
            return [];
        },

        //  standard call for editing
        getFields:function(){
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz=this;

            var _ref = this.deserialize(this.reference);
            var isNative = utils.contains(this._nativeEvents,this.event)>-1;
            var options = null;
            if(!isNative){
                options = this.scope.getEventsAsOptions(this.event);
            }else{

                options = [
                    {label:"onclick", value:"onclick"},
                    {label:"ondblclick",value:"ondblclick"},
                    {label:"onmousedown",value:"onmousedown"},
                    {label:"onmouseup",value:"onmouseup"},
                    {label:"onmouseover",value:"onmouseover"},
                    {label:"onmousemove",value:"onmousemove"},
                    {label:"onmouseout",value:"onmouseout"},
                    {label:"onkeypress",value:"onkeypress"},
                    {label:"onkeydown",value:"onkeydown"},
                    {label:"onkeyup",  value:"onkeyup"},
                    {label:"onfocus",  value:"onfocus"},
                    {label:"onblur",  value:"onblur"},
                    {label:"onchange",  value:"onchange"}
                ];

                //select the event we are listening to
                for (var i = 0; i < options.length; i++) {
                    var obj = options[i];
                    if(obj.value===this.event){
                        obj.selected=true;
                        break;
                    }
                }
            }


            fields.push(utils.createCI('Event',types.ECIType.ENUMERATION,this.event,{
                group:'General',
                options:options,
                dst:'event',
                widget:{
                    search:true
                }
            }));

            fields.push(utils.createCI('Filter Path',13,this.filterPath,{
                group:'General',
                dst:'filterPath'
            }));

            fields.push(utils.createCI('Filter Value',13,this.filterValue,{
                group:'General',
                dst:'filterValue'
            }));

            fields.push(utils.createCI('Value Path',13,this.valuePath,{
                group:'General',
                dst:'valuePath'
            }));


            fields.push(utils.createCI('Object/Widget',types.ECIType.WIDGET_REFERENCE,this.reference,{
                group:'Widget',
                dst:'reference',
                value:this.reference
            }));
            return fields;
        },

        getBlockIcon:function(){
            return '<span class="fa-bell"></span>';
        },
        onEvent:function(evt){

            this._lastResult=evt;

            /*
            if(this.scope && evt.scope && evt.scope!==this.scope){
                return;
            }*/

            if(this.filterPath && this.filterValue){
                var value = this.getValue(evt,this.filterPath);
                if(value && this.filterValue !==value){
                    return;
                }
            }

            var eventValue = null;
            if(this.valuePath){

                if(!this._lastSettings){
                    this._lastSettings = {};
                }
                eventValue = this.getValue(evt,this.valuePath);
                if(eventValue!==null){
                    !this._lastSettings.override && (this._lastSettings.override = {});
                    this._lastSettings.override.args = [eventValue];
                }
            }

            //console.log('on event ',this._lastSettings);
            this.solve(this.scope,this._lastSettings);
        },
        _subscribe:function(evt,handler,obj){

            if(!evt){
                return;
            }
            var isNative = utils.contains(this._nativeEvents,evt);
            if(isNative==-1){

                if(this.__events && this.__events[evt]) {
                    var _handles = this.__events[evt];

                    _.each(_handles, function (e) {
                        this.unsubscribe(e.type, e.handler);
                        e.remove();
                    }, this);

                    _.each(_handles, function (e) {
                        this.__events[evt].remove(e);
                    }, this);
                }

                this.subscribe(evt, this.onEvent);
            }else{

                if(obj) {
                    var _event = evt.replace('on', ''),
                        thiz = this;

                    var handle = on(obj, _event, function (e) {
                        thiz.onEvent(e)
                    });
                    console.log('wire native event : ' + _event);
                    this._events.push(handle);
                }

            }

        },
        _registerEvent:function(evt){

            try {
                if (!evt || !evt.length) {
                    return;
                }
                console.log('register event : ' + evt + ' for ' + this.reference);
                var objects = this.resolveReference(this.deserialize(this.reference));
                var thiz = this;
                if (objects && objects.length) {
                    for (var i = 0; i < objects.length; i++) {
                        var obj = objects[i];

                        //try widget
                        if (obj && obj.id) {
                            var _widget = registry.byId(obj.id);
                            if (_widget && _widget.on) {
                                var _event = this.event.replace('on', '');
                                console.log('found widget : ' + obj.id + ' will register event ' + _event);
                                var _handle = _widget.on(_event, lang.hitch(this, function (e) {
                                    console.log('event triggered : ' + thiz.event);
                                    thiz.onEvent(e);
                                }));
                                this._events.push(_handle);
                            } else {

                                this._subscribe(evt, this.onEvent, obj);
                            }
                        } else {

                            this._subscribe(evt, this.onEvent, obj);
                        }
                    }
                    console.log('objects found : ', objects);
                } else {
                    this._subscribe(evt, this.onEvent);
                }
            }catch(e){
                logError(e,'registering event failed');
            }
            this._didSubscribe=evt;
        },
        onLoad:function(){
            this._onLoaded=true;
            if(this.event && this.event.length && this.enabled){
                this._registerEvent(this.event);
            }
        },
        updateEventSelector:function(objects,cis){

            var options = [];

            if(!objects || !objects.length){
                options= this.scope.getEventsAsOptions(this.event);
            }else{

                options = [{label:"onclick", value:"onclick"},
                    {label:"ondblclick",value:"ondblclick"},
                    {label:"onmousedown",value:"onmousedown"},
                    {label:"onmouseup",value:"onmouseup"},
                    {label:"onmouseover",value:"onmouseover"},
                    {label:"onmousemove",value:"onmousemove"},
                    {label:"onmouseout",value:"onmouseout"},
                    {label:"onkeypress",value:"onkeypress"},
                    {label:"onkeydown",value:"onkeydown"},
                    {label:"onkeyup",  value:"onkeyup"},
                    {label:"onfocus",  value:"onfocus"},
                    {label:"onblur",  value:"onblur"},
                    {label:"onchange",  value:"onchange"}];

                //select the event we are listening to
                for (var i = 0; i < options.length; i++) {
                    var obj = options[i];
                    if(obj.value===this.event){
                        obj.selected=true;
                        break;
                    }
                }
            }

            for (var i = 0; i < cis.length; i++) {
                var ci = cis[i];
                if(ci['widget'] && ci['widget'].title==='Event'){
                    //console.log('event!');
                    var widget = ci['_widget'];
                    widget.nativeWidget.set('options',options);
                    widget.nativeWidget.reset();
                    widget.nativeWidget.set('value',this.event);
                    this.publish(types.EVENTS.RESIZE,{});
                    break;
                }
            }
        },
        onReferenceChanged:function(newValue,cis){

            this._destroy();//unregister previous event(s)

            this.reference = newValue;
            var objects = this.resolveReference(this.deserialize(newValue));
            this.updateEventSelector(objects,cis);
            this._registerEvent(this.event);

        },
        onChangeField:function(field,newValue,cis){

            if(field=='event'){
                this._destroy();    //unregister previous event
                if(this._onLoaded){ // we've have been activated at load time, so re-register our event
                    this.event = newValue;
                    this._registerEvent(newValue);
                }
            }
            if(field=='reference'){
                this.onReferenceChanged(newValue,cis);
            }

            this.inherited(arguments);
        },
        activate:function(){
            this._destroy();//you never know
            this._registerEvent(this.event);
        },
        deactivate:function(){
            this._destroy();
        },
        _destroy:function(){

            if(!this._events){this._events=[];}
            _.each(this._events, dojo.unsubscribe);
            this.unsubscribe(this.event,this.onEvent);
            this._lastResult=null;
            this._didSubscribe = false;
        }
    });
});
define('xblox/model/events/OnKey',[
    'dcl/dcl',
    "dojo/_base/lang",
    "dojo/_base/array",
    "dojo/Deferred",
    "xblox/model/Block",
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xblox/model/Referenced',
    'xblox/model/Contains',
    'xblox/model/events/OnEvent',
    'xide/registry',
    'dojo/on'
], function(dcl,lang,array,Deferred,Block,utils,types,EventedMixin,Referenced,Contains,OnEvent,registry,on){

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    return dcl([Block,EventedMixin.dcl,Referenced.dcl,Contains],{
        declaredClass:"xblox.model.events.OnKey",
        //method: (String)
        //  block action name
        name:'On Key',

        event:'',

        reference:'',

        references:null,

        description:'Triggers when a keyboard sequence ' + this.event +' has been entered',

        listeners:null,

        sharable:true,
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText:function(){

            var result = this.getBlockIcon() + ' ' + this.name + ' :: ';
            if(this.event){
                result+= this.event;
            }
            return result;
        },

        //  standard call from interface
        canAdd:function(){
            return [];
        },

        //  standard call for editing
        getFields:function(){
            var fields = this.inherited(arguments) || this.getDefaultFields();

            fields.push(utils.createCI('Keyboard Sequence',types.ECIType.STRING,this.event,{
                group:'General',
                dst:'event',
                value:this.event,
                intermediateChanges:false
            }));

            fields.push(utils.createCI('Object/Widget',types.ECIType.WIDGET_REFERENCE,this.reference,{
                group:'General',
                dst:'reference',
                value:this.reference
            }));
            return fields;
        },
        getBlockIcon:function(){
            return '<span class="fa-keyboard-o"></span>';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Store
        //
        /////////////////////////////////////////////////////////////////////////////////////
        onEvent:function(evt){
            this._lastResult=evt;
            this.solve(this.scope,this._lastRunSettings);

        },
        _addListerner:function(keys,handler,obj){
            if(this.listeners==null){
                this.listeners=[];
            }

            var my_defaults = {
                is_unordered    : true,
                prevent_repeat  : false,
                prevent_default : false,
                on_keyup:function(e){
                    console.log('up');
                },
                on_keydown:function(e){
                    console.log('down');
                },
                on_release:function(e){
                    console.log('release');
                }
            };
            var listener =null;
            listener = new window.keypress.Listener(obj, my_defaults);
            listener.simple_combo(keys, function(e) {
                if(handler){
                    handler(arguments);
                }
            });

            this.listeners.push(listener);
        },
        _subscribe:function(keys,handler,obj){

            if(!keys){
                return;
            }

            if(obj && obj.domNode){
                obj = obj.domNode;
            }

            this._addListerner(keys,handler,obj);

        },
        _registerEvent:function(evt){

            if(!evt || !evt.length){
                return;
            }
            var objects = this.resolveReference(this.deserialize(this.reference));
            var thiz=this;
            if (objects && objects.length) {
                for (var i = 0; i < objects.length; i++) {
                    var obj = objects[i];
                    //try widget
                    if (obj && obj.id) {
                        var _widget = registry.byId(obj.id);
                        _widget=null;
                        if (_widget && _widget.on) {
                            var _event = this.event.replace('on','');
                            var _handle = _widget.on(_event,lang.hitch(this,function(e){
                                thiz.onEvent(e);
                            }));
                            this._events.push( _handle);
                        }else{

                            this._subscribe(evt, function(){thiz.onEvent(arguments)},obj);
                        }
                    }else{

                        this._subscribe(evt, function(){thiz.onEvent(arguments)},obj);
                    }
                }
            }else{
                this._subscribe(evt, function(){thiz.onEvent(arguments)});
            }
        },
        onLoad:function(){

            this._onLoaded=true;

            if(this.event && this.event.length && this.enabled){

                this._registerEvent(this.event);
            }
        },
        destroy:function(){
            this.inherited(arguments);
        },
        updateEventSelector:function(objects,cis){

            var options = [];

            if(!objects || !objects.length){
                options= this.scope.getEventsAsOptions(this.event);
            }else{

                options = [{label:"onclick", value:"onclick"},
                    {label:"ondblclick",value:"ondblclick"},
                    {label:"onmousedown",value:"onmousedown"},
                    {label:"onmouseup",value:"onmouseup"},
                    {label:"onmouseover",value:"onmouseover"},
                    {label:"onmousemove",value:"onmousemove"},
                    {label:"onmouseout",value:"onmouseout"},
                    {label:"onkeypress",value:"onkeypress"},
                    {label:"onkeydown",value:"onkeydown"},
                    {label:"onkeyup",  value:"onkeyup"},
                    {label:"onfocus",  value:"onfocus"},
                    {label:"onblur",  value:"onblur"},
                    {label:"onchange",  value:"onchange"}];

                //select the event we are listening to
                for (var i = 0; i < options.length; i++) {
                    var obj = options[i];
                    if(obj.value===this.event){
                        obj.selected=true;
                        break;
                    }
                }
            }

            for (var i = 0; i < cis.length; i++) {
                var ci = cis[i];
                if(ci['widget'] && ci['widget'].title==='Event'){
                    //console.log('event!');
                    var widget = ci['_widget'];
                    widget.nativeWidget.set('options',options);
                    widget.nativeWidget.reset();
                    widget.nativeWidget.set('value',this.event);
                    this.publish(types.EVENTS.RESIZE,{});
                    break;
                }
            }
        },
        onReferenceChanged:function(newValue,cis){

            this._destroy();//unregister previous event(s)

            this.reference = newValue;
            var objects = this.resolveReference(this.deserialize(newValue));
            this._registerEvent(this.event);

        },
        onChangeField:function(field,newValue,cis){

            if(field=='event'){
                this._destroy();    //unregister previous event
                if(this._onLoaded){ // we've have been activated at load time, so re-register our event
                    this.event = newValue;
                    this._registerEvent(newValue);
                }
            }
            if(field=='reference'){
                this.onReferenceChanged(newValue,cis);
            }

            this.inherited(arguments);
        },
        activate:function(){
            this._destroy();//you never know
            this._registerEvent(this.event);
        },
        deactivate:function(){
            this._destroy();
        },
        _destroy:function(){

            if(this.listeners){

                for (var i = 0; i < this.listeners.length; i++) {
                    var obj = this.listeners[i];
                    obj.stop_listening();
                    var combos = obj.get_registered_combos();
                    if(combos){
                        obj.unregister_many(combos);
                    }
                    obj.reset();

                    console.log('did destroy listener');

                }
            }
            this.listeners=[];
        },
        onFieldsRendered:function(block,cis){}


    });
});
define('xblox/model/logging/Log',[
    'dcl/dcl',
    "dojo/Deferred",
    "xblox/model/Block",
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin'
], function(dcl,Deferred,Block,utils,types,EventedMixin){

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    return dcl([Block,EventedMixin.dcl],{
        declaredClass:"xblox.model.logging.Log",
        //method: (String)
        //  block action name
        name:'Log Message',
        level:'info',
        message:'return "Message: " + arguments[0];',
        _type:'XBlox',
        host:'this host',
        sharable:true,
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText:function(){

            var _cls = 'text-primary';
            switch (this.level){
                case 'info':{
                    _cls = 'text-info';
                    break;
                }
                case 'warn':{
                    _cls = 'text-warning';
                    break;
                }
                case 'error':{
                    _cls = 'text-danger';
                    break;
                }

            }

            var result = this.getBlockIcon() + " " + this.name + " : " + "<span class='" + _cls + " small'> " + ' :: ';
            if(this.message){
                result+= this.message;
            }
            return result +"</span>";
        },
        /***
         * Returns the block run result
         * @param expression
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {string}
         */
        _solveExpression:function(expression,scope,settings,run,error) {

            var _script = '' + expression;
            var thiz=this;

            if(_script && _script.length) {


                //var _function = new Function("{" + _script + "}");
                _script = utils.convertAllEscapes(_script,"none");
                var _args = this.getArgs();
                try {
                    //var _parsed = _function.apply(this, _args || {});
                    var _parsed =  scope.parseExpression(_script,null,null,null,null,this,_args);
                    if(run){
                        run('Expression ' + _script + ' evaluates to ' + _parsed);
                    }
                    return _parsed;
                } catch (e) {
                    if(error){
                        error('invalid expression : \n' + _script + ': ' + e);
                    }
                    this.onFailed(this, settings);
                    return _script;
                }
            }else{
                console.error('have no script');
            }
            return _script;
        },
        /**
         *
         * @param scope
         * @param settings
         * @param run
         * @param error
         */
        solve:function(scope,settings,run,error) {

            console.log('-log');

            var dfd = new Deferred();
            var device = scope.device;
            var _message=this._solveExpression(this.message,scope,settings,run,error);
            var message={
                message:_message,
                level:this.level,
                type:this._type,
                details:this.getArgs(),
                time:new Date().getTime(),
                data:{
                    device : device ? device.info : null
                },
                write:true
            };

            this.onSuccess(this,settings);

            dfd.resolve(_message);

            try {
                this.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, message);
            }catch(e){
                this.onFailed(this,settings);
            }

            return dfd;

        },
        //  standard call from interface
        canAdd:function(){
            return null;
        },
        //  standard call for editing
        getFields:function(){
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz=this;

            var options = [
                {
                    value:'info',
                    label:'Info'
                },
                {
                    value:'warn',
                    label:'Warning'
                },
                {
                    value:'error',
                    label:'Error'
                },
                {
                    value:'debug',
                    label:'Debug'
                },
                {
                    value:'help',
                    label:'Help'
                },
                {
                    value:'verbose',
                    label:'verbose'
                },
                {
                    value:'silly',
                    label:'Silly'
                }
            ];

            fields.push(utils.createCI('Level',3,this.level,{
                group:'General',
                options:options,
                dst:'level'
            }));

            fields.push(
                utils.createCI('message',25,this.message,{
                    group:'General',
                    title:'Message',
                    dst:'message',
                    delegate:{
                        runExpression:function(val,run,error){
                            var _res = thiz._solveExpression(val,thiz.scope,null,run,error);
                        }
                    }
                }));

            fields.push(

                utils.createCI('message',13,this._type,{
                    group:'General',
                    title:'Type',
                    dst:'_type'
                }));

            return fields;
        },
        getBlockIcon:function(){
            return '<span class="fa-bug"></span>';
        }
    });
});
define('dojo/dom',["./sniff", "./_base/window", "./_base/kernel"],
		function(has, win, kernel){
	// module:
	//		dojo/dom

	// FIXME: need to add unit tests for all the semi-public methods

	if(has("ie") <= 7){
		try{
			document.execCommand("BackgroundImageCache", false, true);
		}catch(e){
			// sane browsers don't have cache "issues"
		}
	}

	// =============================
	// DOM Functions
	// =============================

	// the result object
	var dom = {
		// summary:
		//		This module defines the core dojo DOM API.
	};

	if(has("ie")){
		dom.byId = function(id, doc){
			if(typeof id != "string"){
				return id;
			}
			var _d = doc || win.doc, te = id && _d.getElementById(id);
			// attributes.id.value is better than just id in case the
			// user has a name=id inside a form
			if(te && (te.attributes.id.value == id || te.id == id)){
				return te;
			}else{
				var eles = _d.all[id];
				if(!eles || eles.nodeName){
					eles = [eles];
				}
				// if more than 1, choose first with the correct id
				var i = 0;
				while((te = eles[i++])){
					if((te.attributes && te.attributes.id && te.attributes.id.value == id) || te.id == id){
						return te;
					}
				}
			}
		};
	}else{
		dom.byId = function(id, doc){
			// inline'd type check.
			// be sure to return null per documentation, to match IE branch.
			return ((typeof id == "string") ? (doc || win.doc).getElementById(id) : id) || null; // DOMNode
		};
	}
	/*=====
	 dom.byId = function(id, doc){
		// summary:
		//		Returns DOM node with matching `id` attribute or falsy value (ex: null or undefined)
		//		if not found.  If `id` is a DomNode, this function is a no-op.
		//
		// id: String|DOMNode
		//		A string to match an HTML id attribute or a reference to a DOM Node
		//
		// doc: Document?
		//		Document to work in. Defaults to the current value of
		//		dojo/_base/window.doc.  Can be used to retrieve
		//		node references from other documents.
		//
		// example:
		//		Look up a node by ID:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("foo");
		//	|	});
		//
		// example:
		//		Check if a node exists, and use it.
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("bar");
		//	|		if(n){ doStuff() ... }
		//	|	});
		//
		// example:
		//		Allow string or DomNode references to be passed to a custom function:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var foo = function(nodeOrId){
		//	|			nodeOrId = dom.byId(nodeOrId);
		//	|			// ... more stuff
		//	|		}
		//	|	});
	 };
	 =====*/

	// Test for DOMNode.contains() method, available everywhere except FF8-
	// and IE8-, where it's available in general, but not on document itself,
	// and also problems when either ancestor or node are text nodes.

	var doc = kernel.global["document"] || null;
	has.add("dom-contains", !!(doc && doc.contains));
	dom.isDescendant = has("dom-contains") ?
		// FF9+, IE9+, webkit, opera, iOS, Android, Edge, etc.
		function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
			return !!( (ancestor = dom.byId(ancestor)) && ancestor.contains && ancestor.contains(dom.byId(node)));
		} :
		function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
			// summary:
			//		Returns true if node is a descendant of ancestor
			// node: DOMNode|String
			//		string id or node reference to test
			// ancestor: DOMNode|String
			//		string id or node reference of potential parent to test against
			//
			// example:
			//		Test is node id="bar" is a descendant of node id="foo"
			//	|	require(["dojo/dom"], function(dom){
			//	|		if(dom.isDescendant("bar", "foo")){ ... }
			//	|	});

			try{
				node = dom.byId(node);
				ancestor = dom.byId(ancestor);
				while(node){
					if(node == ancestor){
						return true; // Boolean
					}
					node = node.parentNode;
				}
			}catch(e){ /* squelch, return false */ }
			return false; // Boolean
		};

	// TODO: do we need setSelectable in the base?

	// Add feature test for user-select CSS property
	// (currently known to work in all but IE < 10 and Opera)
	// TODO: The user-select CSS property as of May 2014 is no longer part of
	// any CSS specification. In IE, -ms-user-select does not do the same thing
	// as the unselectable attribute on elements; namely, dijit Editor buttons
	// do not properly prevent the content of the editable content frame from
	// unblurring. As a result, the -ms- prefixed version is omitted here.
	has.add("css-user-select", function(global, doc, element){
		// Avoid exception when dom.js is loaded in non-browser environments
		if(!element){ return false; }

		var style = element.style;
		var prefixes = ["Khtml", "O", "Moz", "Webkit"],
			i = prefixes.length,
			name = "userSelect",
			prefix;

		// Iterate prefixes from most to least likely
		do{
			if(typeof style[name] !== "undefined"){
				// Supported; return property name
				return name;
			}
		}while(i-- && (name = prefixes[i] + "UserSelect"));

		// Not supported if we didn't return before now
		return false;
	});

	/*=====
	dom.setSelectable = function(node, selectable){
		// summary:
		//		Enable or disable selection on a node
		// node: DOMNode|String
		//		id or reference to node
		// selectable: Boolean
		//		state to put the node in. false indicates unselectable, true
		//		allows selection.
		// example:
		//		Make the node id="bar" unselectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar");
		//	|	});
		// example:
		//		Make the node id="bar" selectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar", true);
		//	|	});
	};
	=====*/

	var cssUserSelect = has("css-user-select");
	dom.setSelectable = cssUserSelect ? function(node, selectable){
		// css-user-select returns a (possibly vendor-prefixed) CSS property name
		dom.byId(node).style[cssUserSelect] = selectable ? "" : "none";
	} : function(node, selectable){
		node = dom.byId(node);

		// (IE < 10 / Opera) Fall back to setting/removing the
		// unselectable attribute on the element and all its children
		var nodes = node.getElementsByTagName("*"),
			i = nodes.length;

		if(selectable){
			node.removeAttribute("unselectable");
			while(i--){
				nodes[i].removeAttribute("unselectable");
			}
		}else{
			node.setAttribute("unselectable", "on");
			while(i--){
				nodes[i].setAttribute("unselectable", "on");
			}
		}
	};

	return dom;
});

define('dojo/dom-style',["./sniff", "./dom"], function(has, dom){
	// module:
	//		dojo/dom-style

	// =============================
	// Style Functions
	// =============================

	// getComputedStyle drives most of the style code.
	// Wherever possible, reuse the returned object.
	//
	// API functions below that need to access computed styles accept an
	// optional computedStyle parameter.
	// If this parameter is omitted, the functions will call getComputedStyle themselves.
	// This way, calling code can access computedStyle once, and then pass the reference to
	// multiple API functions.

	// Although we normally eschew argument validation at this
	// level, here we test argument 'node' for (duck)type,
	// by testing nodeType, ecause 'document' is the 'parentNode' of 'body'
	// it is frequently sent to this function even
	// though it is not Element.
	var getComputedStyle, style = {
		// summary:
		//		This module defines the core dojo DOM style API.
	};
	if(has("webkit")){
		getComputedStyle = function(/*DomNode*/ node){
			if(!node){
				return {};
			}
			var s;
			if(node.nodeType == 1){
				var dv = node.ownerDocument.defaultView;
				s = dv.getComputedStyle(node, null);
				if(!s && node.style){
					node.style.display = "";
					s = dv.getComputedStyle(node, null);
				}
			}
			return s || {};
		};
	}else if(has("ie") && (has("ie") < 9 || has("quirks"))){
		getComputedStyle = function(node){
			// IE (as of 7) doesn't expose Element like sane browsers
			// currentStyle can be null on IE8!
			return node.nodeType == 1 /* ELEMENT_NODE*/ && node.currentStyle ? node.currentStyle : {};
		};
	}else{
		getComputedStyle = function(node){
            if(!node){
                console.error('getComputedStyle :: invalid node');
                return node;
            }
			return node.nodeType == 1 /* ELEMENT_NODE*/ ?
				node.ownerDocument.defaultView.getComputedStyle(node, null) : {};
		};
	}
	style.getComputedStyle = getComputedStyle;
	/*=====
	style.getComputedStyle = function(node){
		// summary:
		//		Returns a "computed style" object.
		//
		// description:
		//		Gets a "computed style" object which can be used to gather
		//		information about the current state of the rendered node.
		//
		//		Note that this may behave differently on different browsers.
		//		Values may have different formats and value encodings across
		//		browsers.
		//
		//		Note also that this method is expensive.  Wherever possible,
		//		reuse the returned object.
		//
		//		Use the dojo/dom-style.get() method for more consistent (pixelized)
		//		return values.
		//
		// node: DOMNode
		//		A reference to a DOM node. Does NOT support taking an
		//		ID string for speed reasons.
		// example:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.getComputedStyle(dom.byId('foo')).borderWidth;
		//	|	});
		//
		// example:
		//		Reusing the returned object, avoiding multiple lookups:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		var cs = domStyle.getComputedStyle(dom.byId("someNode"));
		//	|		var w = cs.width, h = cs.height;
		//	|	});
		return; // CSS2Properties
	};
	=====*/

	var toPixel;
	if(!has("ie")){
		toPixel = function(element, value){
			// style values can be floats, client code may want
			// to round for integer pixels.
			return parseFloat(value) || 0;
		};
	}else{
		toPixel = function(element, avalue){
			if(!avalue){ return 0; }
			// on IE7, medium is usually 4 pixels
			if(avalue == "medium"){ return 4; }
			// style values can be floats, client code may
			// want to round this value for integer pixels.
			if(avalue.slice && avalue.slice(-2) == 'px'){ return parseFloat(avalue); }
			var s = element.style, rs = element.runtimeStyle, cs = element.currentStyle,
				sLeft = s.left, rsLeft = rs.left;
			rs.left = cs.left;
			try{
				// 'avalue' may be incompatible with style.left, which can cause IE to throw
				// this has been observed for border widths using "thin", "medium", "thick" constants
				// those particular constants could be trapped by a lookup
				// but perhaps there are more
				s.left = avalue;
				avalue = s.pixelLeft;
			}catch(e){
				avalue = 0;
			}
			s.left = sLeft;
			rs.left = rsLeft;
			return avalue;
		};
	}
	style.toPixelValue = toPixel;
	/*=====
	style.toPixelValue = function(node, value){
		// summary:
		//		converts style value to pixels on IE or return a numeric value.
		// node: DOMNode
		// value: String
		// returns: Number
	};
	=====*/

	// FIXME: there opacity quirks on FF that we haven't ported over. Hrm.

	var astr = "DXImageTransform.Microsoft.Alpha";
	var af = function(n, f){
		try{
			return n.filters.item(astr);
		}catch(e){
			return f ? {} : null;
		}
	};

	var _getOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(node){
			try{
				return af(node).Opacity / 100; // Number
			}catch(e){
				return 1; // Number
			}
		} :
		function(node){
			return getComputedStyle(node).opacity;
		};

	var _setOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(/*DomNode*/ node, /*Number*/ opacity){
			if(opacity === ""){ opacity = 1; }
			var ov = opacity * 100, fullyOpaque = opacity === 1;

			// on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),
			// but still update the opacity value so we can get a correct reading if it is read later:
			// af(node, 1).Enabled = !fullyOpaque;

			if(fullyOpaque){
				node.style.zoom = "";
				if(af(node)){
					node.style.filter = node.style.filter.replace(
						new RegExp("\\s*progid:" + astr + "\\([^\\)]+?\\)", "i"), "");
				}
			}else{
				node.style.zoom = 1;
				if(af(node)){
					af(node, 1).Opacity = ov;
				}else{
					node.style.filter += " progid:" + astr + "(Opacity=" + ov + ")";
				}
				af(node, 1).Enabled = true;
			}

			if(node.tagName.toLowerCase() == "tr"){
				for(var td = node.firstChild; td; td = td.nextSibling){
					if(td.tagName.toLowerCase() == "td"){
						_setOpacity(td, opacity);
					}
				}
			}
			return opacity;
		} :
		function(node, opacity){
			return node.style.opacity = opacity;
		};

	var _pixelNamesCache = {
		left: true, top: true
	};
	var _pixelRegExp = /margin|padding|width|height|max|min|offset/; // |border
	function _toStyleValue(node, type, value){
		//TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!
		type = type.toLowerCase();

		// Adjustments for IE and Edge
		if(value == "auto"){
			if(type == "height"){ return node.offsetHeight; }
			if(type == "width"){ return node.offsetWidth; }
		}
		if(type == "fontweight"){
			switch(value){
				case 700: return "bold";
				case 400:
				default: return "normal";
			}
		}

		if(!(type in _pixelNamesCache)){
			_pixelNamesCache[type] = _pixelRegExp.test(type);
		}
		return _pixelNamesCache[type] ? toPixel(node, value) : value;
	}

	var _floatAliases = {cssFloat: 1, styleFloat: 1, "float": 1};

	// public API

	style.get = function getStyle(/*DOMNode|String*/ node, /*String?*/ name){
		// summary:
		//		Accesses styles on a node.
		// description:
		//		Getting the style value uses the computed style for the node, so the value
		//		will be a calculated value, not just the immediate node.style value.
		//		Also when getting values, use specific style names,
		//		like "borderBottomWidth" instead of "border" since compound values like
		//		"border" are not necessarily reflected as expected.
		//		If you want to get node dimensions, use `dojo/dom-geometry.getMarginBox()`,
		//		`dojo/dom-geometry.getContentBox()` or `dojo/dom-geometry.getPosition()`.
		// node: DOMNode|String
		//		id or reference to node to get style for
		// name: String?
		//		the style property to get
		// example:
		//		Passing only an ID or node returns the computed style object of
		//		the node:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger");
		//	|	});
		// example:
		//		Passing a node and a style property returns the current
		//		normalized, computed value for that property:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger", "opacity"); // 1 by default
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		if(l == 2 && op){
			return _getOpacity(n);
		}
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		var s = style.getComputedStyle(n);
		return (l == 1) ? s : _toStyleValue(n, name, s[name] || n.style[name]); /* CSS2Properties||String||Number */
	};

	style.set = function setStyle(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets styles on a node.
		// node: DOMNode|String
		//		id or reference to node to set style for
		// name: String|Object
		//		the style property to set in DOM-accessor format
		//		("borderWidth", not "border-width") or an object with key/value
		//		pairs suitable for setting each property.
		// value: String?
		//		If passed, sets value on the node for style, handling
		//		cross-browser concerns.  When setting a pixel value,
		//		be sure to include "px" in the value. For instance, top: "200px".
		//		Otherwise, in some cases, some browsers will not apply the style.
		//
		// example:
		//		Passing a node, a style property, and a value changes the
		//		current display of the node and returns the new computed value
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", "opacity", 0.5); // == 0.5
		//	|	});
		//
		// example:
		//		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", {
		//	|			"opacity": 0.5,
		//	|			"border": "3px solid black",
		//	|			"height": "300px"
		//	|		});
		//	|	});
		//
		// example:
		//		When the CSS style property is hyphenated, the JavaScript property is camelCased.
		//		font-size becomes fontSize, and so on.
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.set("thinger",{
		//	|			fontSize:"14pt",
		//	|			letterSpacing:"1.2em"
		//	|		});
		//	|	});
		//
		// example:
		//		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
		//		dojo/dom-style.get() on every element of the list. See: `dojo/query` and `dojo/NodeList`
		//	|	require(["dojo/dom-style", "dojo/query", "dojo/NodeList-dom"],
		//	|	function(domStyle, query){
		//	|		query(".someClassName").style("visibility","hidden");
		//	|		// or
		//	|		query("#baz > div").style({
		//	|			opacity:0.75,
		//	|			fontSize:"13pt"
		//	|		});
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		if(l == 3){
			return op ? _setOpacity(n, value) : n.style[name] = value; // Number
		}
		for(var x in name){
			style.set(node, x, name[x]);
		}
		return style.getComputedStyle(n);
	};

	return style;
});

define('dojo/dom-construct',["exports", "./_base/kernel", "./sniff", "./_base/window", "./dom", "./dom-attr"],
		function(exports, dojo, has, win, dom, attr){
	// module:
	//		dojo/dom-construct
	// summary:
	//		This module defines the core dojo DOM construction API.

	// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

	// support stuff for toDom()
	var tagWrap = {
			option: ["select"],
			tbody: ["table"],
			thead: ["table"],
			tfoot: ["table"],
			tr: ["table", "tbody"],
			td: ["table", "tbody", "tr"],
			th: ["table", "thead", "tr"],
			legend: ["fieldset"],
			caption: ["table"],
			colgroup: ["table"],
			col: ["table", "colgroup"],
			li: ["ul"]
		},
		reTag = /<\s*([\w\:]+)/,
		masterNode = {}, masterNum = 0,
		masterName = "__" + dojo._scopeName + "ToDomId";

	// generate start/end tag strings to use
	// for the injection for each special tag wrap case.
	for(var param in tagWrap){
		if(tagWrap.hasOwnProperty(param)){
			var tw = tagWrap[param];
			tw.pre = param == "option" ? '<select multiple="multiple">' : "<" + tw.join("><") + ">";
			tw.post = "</" + tw.reverse().join("></") + ">";
			// the last line is destructive: it reverses the array,
			// but we don't care at this point
		}
	}

	var html5domfix;
	if(has("ie") <= 8){
		html5domfix = function(doc){
			doc.__dojo_html5_tested = "yes";
			var div = create('div', {innerHTML: "<nav>a</nav>", style: {visibility: "hidden"}}, doc.body);
			if(div.childNodes.length !== 1){
				('abbr article aside audio canvas details figcaption figure footer header ' +
				'hgroup mark meter nav output progress section summary time video').replace(
					/\b\w+\b/g, function(n){
						doc.createElement(n);
					}
				);
			}
			destroy(div);
		}
	}

	function _insertBefore(/*DomNode*/ node, /*DomNode*/ ref){
		var parent = ref.parentNode;
		if(parent){
			parent.insertBefore(node, ref);
		}
	}

	function _insertAfter(/*DomNode*/ node, /*DomNode*/ ref){
		// summary:
		//		Try to insert node after ref
		var parent = ref.parentNode;
		if(parent){
			if(parent.lastChild == ref){
				parent.appendChild(node);
			}else{
				parent.insertBefore(node, ref.nextSibling);
			}
		}
	}

	exports.toDom = function toDom(frag, doc){
		// summary:
		//		instantiates an HTML fragment returning the corresponding DOM.
		// frag: String
		//		the HTML fragment
		// doc: DocumentNode?
		//		optional document to use when creating DOM nodes, defaults to
		//		dojo/_base/window.doc if not specified.
		// returns:
		//		Document fragment, unless it's a single node in which case it returns the node itself
		// example:
		//		Create a table row:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var tr = domConstruct.toDom("<tr><td>First!</td></tr>");
		//	|	});

		doc = doc || win.doc;
		var masterId = doc[masterName];
		if(!masterId){
			doc[masterName] = masterId = ++masterNum + "";
			masterNode[masterId] = doc.createElement("div");
		}

		if(has("ie") <= 8){
			if(!doc.__dojo_html5_tested && doc.body){
				html5domfix(doc);
			}
		}

		// make sure the frag is a string.
		frag += "";

		// find the starting tag, and get node wrapper
		var match = frag.match(reTag),
			tag = match ? match[1].toLowerCase() : "",
			master = masterNode[masterId],
			wrap, i, fc, df;
		if(match && tagWrap[tag]){
			wrap = tagWrap[tag];
			master.innerHTML = wrap.pre + frag + wrap.post;
			for(i = wrap.length; i; --i){
				master = master.firstChild;
			}
		}else{
			master.innerHTML = frag;
		}

		// one node shortcut => return the node itself
		if(master.childNodes.length == 1){
			return master.removeChild(master.firstChild); // DOMNode
		}

		// return multiple nodes as a document fragment
		df = doc.createDocumentFragment();
		while((fc = master.firstChild)){ // intentional assignment
			df.appendChild(fc);
		}
		return df; // DocumentFragment
	};

	exports.place = function place(node, refNode, position){
		// summary:
		//		Attempt to insert node into the DOM, choosing from various positioning options.
		//		Returns the first argument resolved to a DOM node.
		// node: DOMNode|DocumentFragment|String
		//		id or node reference, or HTML fragment starting with "<" to place relative to refNode
		// refNode: DOMNode|String
		//		id or node reference to use as basis for placement
		// position: String|Number?
		//		string noting the position of node relative to refNode or a
		//		number indicating the location in the childNodes collection of refNode.
		//		Accepted string values are:
		//
		//		- before
		//		- after
		//		- replace
		//		- only
		//		- first
		//		- last
		//
		//		"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,
		//		"only" replaces all children.  position defaults to "last" if not specified
		// returns: DOMNode
		//		Returned values is the first argument resolved to a DOM node.
		//
		//		.place() is also a method of `dojo/NodeList`, allowing `dojo/query` node lookups.
		// example:
		//		Place a node by string id as the last child of another node by string id:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("someNode", "anotherNode");
		//	|	});
		// example:
		//		Place a node by string id before another node by string id
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("someNode", "anotherNode", "before");
		//	|	});
		// example:
		//		Create a Node, and place it in the body element (last child):
		//	|	require(["dojo/dom-construct", "dojo/_base/window"
		//	|	], function(domConstruct, win){
		//	|		domConstruct.place("<div></div>", win.body());
		//	|	});
		// example:
		//		Put a new LI as the first child of a list by id:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("<li></li>", "someUl", "first");
		//	|	});

		refNode = dom.byId(refNode);
        if(!refNode){
            console.error('have no node in domConstruct');
            console.trace();
            return;
        }
		if(typeof node == "string"){ // inline'd type check
			node = /^\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);
		}
		if(typeof position == "number"){ // inline'd type check
			var cn = refNode.childNodes;
			if(!cn.length || cn.length <= position){
				refNode.appendChild(node);
			}else{
				_insertBefore(node, cn[position < 0 ? 0 : position]);
			}
		}else{
			switch(position){
				case "before":
					_insertBefore(node, refNode);
					break;
				case "after":
					_insertAfter(node, refNode);
					break;
				case "replace":
					refNode.parentNode.replaceChild(node, refNode);
					break;
				case "only":
					exports.empty(refNode);
					refNode.appendChild(node);
					break;
				case "first":
					if(refNode.firstChild){
						_insertBefore(node, refNode.firstChild);
						break;
					}
					// else fallthrough...
				default: // aka: last
                {
                    if(!refNode){
                        console.error('bad');
                        console.trace();
                        return null;
                    }
                    refNode.appendChild(node);
                }
			}
		}
		return node; // DomNode
	};

	var create = exports.create = function create(/*DOMNode|String*/ tag, /*Object*/ attrs, /*DOMNode|String?*/ refNode, /*String?*/ pos){
		// summary:
		//		Create an element, allowing for optional attribute decoration
		//		and placement.
		// description:
		//		A DOM Element creation function. A shorthand method for creating a node or
		//		a fragment, and allowing for a convenient optional attribute setting step,
		//		as well as an optional DOM placement reference.
		//
		//		Attributes are set by passing the optional object through `dojo/dom-attr.set`.
		//		See `dojo/dom-attr.set` for noted caveats and nuances, and API if applicable.
		//
		//		Placement is done via `dojo/dom-construct.place`, assuming the new node to be
		//		the action node, passing along the optional reference node and position.
		// tag: DOMNode|String
		//		A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),
		//		or an existing DOM node to process.
		// attrs: Object
		//		An object-hash of attributes to set on the newly created node.
		//		Can be null, if you don't want to set any attributes/styles.
		//		See: `dojo/dom-attr.set` for a description of available attributes.
		// refNode: DOMNode|String?
		//		Optional reference node. Used by `dojo/dom-construct.place` to place the newly created
		//		node somewhere in the dom relative to refNode. Can be a DomNode reference
		//		or String ID of a node.
		// pos: String?
		//		Optional positional reference. Defaults to "last" by way of `dojo/domConstruct.place`,
		//		though can be set to "first","after","before","last", "replace" or "only"
		//		to further control the placement of the new node relative to the refNode.
		//		'refNode' is required if a 'pos' is specified.
		// example:
		//		Create a DIV:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var n = domConstruct.create("div");
		//	|	});
		//
		// example:
		//		Create a DIV with content:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var n = domConstruct.create("div", { innerHTML:"<p>hi</p>" });
		//	|	});
		//
		// example:
		//		Place a new DIV in the BODY, with no attributes set
		//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
		//	|		var n = domConstruct.create("div", null, win.body());
		//	|	});
		//
		// example:
		//		Create an UL, and populate it with LI's. Place the list as the first-child of a
		//		node with id="someId":
		//	|	require(["dojo/dom-construct", "dojo/_base/array"],
		//	|	function(domConstruct, arrayUtil){
		//	|		var ul = domConstruct.create("ul", null, "someId", "first");
		//	|		var items = ["one", "two", "three", "four"];
		//	|		arrayUtil.forEach(items, function(data){
		//	|			domConstruct.create("li", { innerHTML: data }, ul);
		//	|		});
		//	|	});
		//
		// example:
		//		Create an anchor, with an href. Place in BODY:
		//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
		//	|		domConstruct.create("a", { href:"foo.html", title:"Goto FOO!" }, win.body());
		//	|	});

		var doc = win.doc;
		if(refNode){
			refNode = dom.byId(refNode);
			doc = refNode.ownerDocument;
		}
		if(typeof tag == "string"){ // inline'd type check
			tag = doc.createElement(tag);
		}
		if(attrs){ attr.set(tag, attrs); }
		if(refNode){ exports.place(tag, refNode, pos); }
		return tag; // DomNode
	};

	function _empty(/*DomNode*/ node){
		// TODO: remove this if() block in 2.0 when we no longer have to worry about IE memory leaks,
		// and then uncomment the emptyGrandchildren() test case from html.html.
		// Note that besides fixing #16957, using removeChild() is actually faster than setting node.innerHTML,
		// see http://jsperf.com/clear-dom-node.
		if("innerHTML" in node){
			try{
				// fast path
				node.innerHTML = "";
				return;
			}catch(e){
				// innerHTML is readOnly (e.g. TABLE (sub)elements in quirks mode)
				// Fall through (saves bytes)
			}
		}

		// SVG/strict elements don't support innerHTML
		for(var c; c = node.lastChild;){ // intentional assignment
			node.removeChild(c);
		}
	}

	exports.empty = function empty(/*DOMNode|String*/ node){
		// summary:
		//		safely removes all children of the node.
		// node: DOMNode|String
		//		a reference to a DOM node or an id.
		// example:
		//		Destroy node's children byId:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.empty("someId");
		//	|	});

		_empty(dom.byId(node));
	};


	function _destroy(/*DomNode*/ node, /*DomNode*/ parent){
		// in IE quirks, node.canHaveChildren can be false but firstChild can be non-null (OBJECT/APPLET)
		if(node.firstChild){
			_empty(node);
		}
		if(parent){
			// removeNode(false) doesn't leak in IE 6+, but removeChild() and removeNode(true) are known to leak under IE 8- while 9+ is TBD.
			// In IE quirks mode, PARAM nodes as children of OBJECT/APPLET nodes have a removeNode method that does nothing and
			// the parent node has canHaveChildren=false even though removeChild correctly removes the PARAM children.
			// In IE, SVG/strict nodes don't have a removeNode method nor a canHaveChildren boolean.
			has("ie") && parent.canHaveChildren && "removeNode" in node ? node.removeNode(false) : parent.removeChild(node);
		}
	}
	var destroy = exports.destroy = function destroy(/*DOMNode|String*/ node){
		// summary:
		//		Removes a node from its parent, clobbering it and all of its
		//		children.
		//
		// description:
		//		Removes a node from its parent, clobbering it and all of its
		//		children. Function only works with DomNodes, and returns nothing.
		//
		// node: DOMNode|String
		//		A String ID or DomNode reference of the element to be destroyed
		//
		// example:
		//		Destroy a node byId:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.destroy("someId");
		//	|	});

		node = dom.byId(node);
		if(!node){ return; }
		_destroy(node, node.parentNode);
	};
});

define('dojo/topic',["./Evented"], function(Evented){

	// module:
	//		dojo/topic

	var hub = new Evented;
	return {
		// summary:
		//		Pubsub hub.
		// example:
		//		| 	topic.subscribe("some/topic", function(event){
		//		|	... do something with event
		//		|	});
		//		|	topic.publish("some/topic", {name:"some event", ...});

		publish: function(topic, event){
			// summary:
			//		Publishes a message to a topic on the pub/sub hub. All arguments after
			//		the first will be passed to the subscribers, so any number of arguments
			//		can be provided (not just event).
			// topic: String
			//		The name of the topic to publish to
			// event: Object
			//		An event to distribute to the topic listeners
			return hub.emit.apply(hub, arguments);
		},

		subscribe: function(topic, listener){
			// summary:
			//		Subscribes to a topic on the pub/sub hub
			// topic: String
			//		The topic to subscribe to
			// listener: Function
			//		A function to call when a message is published to the given topic
			return hub.on.apply(hub, arguments);
		}
	};
});

define('dojo/dom-geometry',["./sniff", "./_base/window","./dom", "./dom-style"],
		function(has, win, dom, style){
	// module:
	//		dojo/dom-geometry

	// the result object
	var geom = {
		// summary:
		//		This module defines the core dojo DOM geometry API.
	};

	// Box functions will assume this model.
	// On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.
	// Can be set to change behavior of box setters.

	// can be either:
	//	"border-box"
	//	"content-box" (default)
	geom.boxModel = "content-box";

	// We punt per-node box mode testing completely.
	// If anybody cares, we can provide an additional (optional) unit
	// that overrides existing code to include per-node box sensitivity.

	// Opera documentation claims that Opera 9 uses border-box in BackCompat mode.
	// but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.
	// IIRC, earlier versions of Opera did in fact use border-box.
	// Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.

	if(has("ie") /*|| has("opera")*/){
		// client code may have to adjust if compatMode varies across iframes
		geom.boxModel = document.compatMode == "BackCompat" ? "border-box" : "content-box";
	}

	geom.getPadExtents = function getPadExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		Returns object with special values specifically useful for node
		//		fitting.
		// description:
		//		Returns an object with `w`, `h`, `l`, `t` properties:
		//	|		l/t/r/b = left/top/right/bottom padding (respectively)
		//	|		w = the total of the left and right padding
		//	|		h = the total of the top and bottom padding
		//		If 'node' has position, l/t forms the origin for child nodes.
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
			l = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	var none = "none";

	geom.getBorderExtents = function getBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object with properties useful for noting the border
		//		dimensions.
		// description:
		//		- l/t/r/b = the sum of left/top/right/bottom border (respectively)
		//		- w = the sum of the left and right border
		//		- h = the sum of the top and bottom border
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node),
			l = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0,
			t = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0,
			r = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0,
			b = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	geom.getPadBorderExtents = function getPadBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		Returns object with properties useful for box fitting with
		//		regards to padding.
		// description:
		//		- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
		//		- w = the sum of the left and right padding and border
		//		- h = the sum of the top and bottom padding and border
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node),
			p = geom.getPadExtents(node, s),
			b = geom.getBorderExtents(node, s);
		return {
			l: p.l + b.l,
			t: p.t + b.t,
			r: p.r + b.r,
			b: p.b + b.b,
			w: p.w + b.w,
			h: p.h + b.h
		};
	};

	geom.getMarginExtents = function getMarginExtents(node, computedStyle){
		// summary:
		//		returns object with properties useful for box fitting with
		//		regards to box margins (i.e., the outer-box).
		//
		//		- l/t = marginLeft, marginTop, respectively
		//		- w = total width, margin inclusive
		//		- h = total height, margin inclusive
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
			l = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	// Box getters work in any box context because offsetWidth/clientWidth
	// are invariant wrt box context
	//
	// They do *not* work for display: inline objects that have padding styles
	// because the user agent ignores padding (it's bogus styling in any case)
	//
	// Be careful with IMGs because they are inline or block depending on
	// browser and browser mode.

	// Although it would be easier to read, there are not separate versions of
	// _getMarginBox for each browser because:
	// 1. the branching is not expensive
	// 2. factoring the shared code wastes cycles (function call overhead)
	// 3. duplicating the shared code wastes bytes

	geom.getMarginBox = function getMarginBox(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object that encodes the width, height, left and top
		//		positions of the node's margin box.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		if(!node){
			console.error('have no node');
			return {
				l:0,
				t:0,
				w:0,
				h:0
			};
		}
		var s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s),
			l = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;
		if(has("mozilla")){
			// Mozilla:
			// If offsetParent has a computed overflow != visible, the offsetLeft is decreased
			// by the parent's border.
			// We don't want to compute the parent's style, so instead we examine node's
			// computed left/top which is more stable.
			var sl = parseFloat(s.left), st = parseFloat(s.top);
			if(!isNaN(sl) && !isNaN(st)){
				l = sl;
				t = st;
			}else{
				// If child's computed left/top are not parseable as a number (e.g. "auto"), we
				// have no choice but to examine the parent's computed style.
				if(p && p.style){
					pcs = style.getComputedStyle(p);
					if(pcs.overflow != "visible"){
						l += pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
						t += pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
					}
				}
			}
		}else if(has("opera") || (has("ie") == 8 && !has("quirks"))){
			// On Opera and IE 8, offsetLeft/Top includes the parent's border
			if(p){
				pcs = style.getComputedStyle(p);
				l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
				t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
			}
		}
		return {l: l, t: t, w: node.offsetWidth + me.w, h: node.offsetHeight + me.h};
	};

	geom.getContentBox = function getContentBox(node, computedStyle){
		// summary:
		//		Returns an object that encodes the width, height, left and top
		//		positions of the node's content box, irrespective of the
		//		current box model.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		// clientWidth/Height are important since the automatically account for scrollbars
		// fallback to offsetWidth/Height for special cases (see #3378)
		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h,
			pe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s);
		if(!w){
			w = node.offsetWidth;
			h = node.offsetHeight;
		}else{
			h = node.clientHeight;
			be.w = be.h = 0;
		}
		// On Opera, offsetLeft includes the parent's border
		if(has("opera")){
			pe.l += be.l;
			pe.t += be.t;
		}
		return {l: pe.l, t: pe.t, w: w - pe.w - be.w, h: h - pe.h - be.h};
	};

	// Box setters depend on box context because interpretation of width/height styles
	// vary wrt box context.
	//
	// The value of boxModel is used to determine box context.
	// boxModel can be set directly to change behavior.
	//
	// Beware of display: inline objects that have padding styles
	// because the user agent ignores padding (it's a bogus setup anyway)
	//
	// Be careful with IMGs because they are inline or block depending on
	// browser and browser mode.
	//
	// Elements other than DIV may have special quirks, like built-in
	// margins or padding, or values not detectable via computedStyle.
	// In particular, margins on TABLE do not seems to appear
	// at all in computedStyle on Mozilla.

	function setBox(/*DomNode*/ node, /*Number?*/ l, /*Number?*/ t, /*Number?*/ w, /*Number?*/ h, /*String?*/ u){
		// summary:
		//		sets width/height/left/top in the current (native) box-model
		//		dimensions. Uses the unit passed in u.
		// node:
		//		DOM Node reference. Id string not supported for performance
		//		reasons.
		// l:
		//		left offset from parent.
		// t:
		//		top offset from parent.
		// w:
		//		width in current box model.
		// h:
		//		width in current box model.
		// u:
		//		unit measure to use for other measures. Defaults to "px".
		u = u || "px";
		var s = node.style;
		if(!isNaN(l)){
			s.left = l + u;
		}
		if(!isNaN(t)){
			s.top = t + u;
		}
		if(w >= 0){
			s.width = w + u;
		}
		if(h >= 0){
			s.height = h + u;
		}
	}

	function isButtonTag(/*DomNode*/ node){
		// summary:
		//		True if the node is BUTTON or INPUT.type="button".
		return node.tagName.toLowerCase() == "button" ||
			node.tagName.toLowerCase() == "input" && (node.getAttribute("type") || "").toLowerCase() == "button"; // boolean
	}

	function usesBorderBox(/*DomNode*/ node){
		// summary:
		//		True if the node uses border-box layout.

		// We could test the computed style of node to see if a particular box
		// has been specified, but there are details and we choose not to bother.

		// TABLE and BUTTON (and INPUT type=button) are always border-box by default.
		// If you have assigned a different box to either one via CSS then
		// box functions will break.

        if(!node){
            debugger;
        }

		return geom.boxModel == "border-box" || node.tagName.toLowerCase() == "table" || isButtonTag(node); // boolean
	}

	geom.setContentSize = function setContentSize(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
		// summary:
		//		Sets the size of the node's contents, irrespective of margins,
		//		padding, or borders.
		// node: DOMNode
		// box: Object
		//		hash with optional "w", and "h" properties for "width", and "height"
		//		respectively. All specified properties should have numeric values in whole pixels.
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var w = box.w, h = box.h;
		if(usesBorderBox(node)){
			var pb = geom.getPadBorderExtents(node, computedStyle);
			if(w >= 0){
				w += pb.w;
			}
			if(h >= 0){
				h += pb.h;
			}
		}
		setBox(node, NaN, NaN, w, h);
	};

	var nilExtents = {l: 0, t: 0, w: 0, h: 0};

	geom.setMarginBox = function setMarginBox(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
		// summary:
		//		sets the size of the node's margin box and placement
		//		(left/top), irrespective of box model. Think of it as a
		//		passthrough to setBox that handles box-model vagaries for
		//		you.
		// node: DOMNode
		// box: Object
		//		hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"
		//		respectively. All specified properties should have numeric values in whole pixels.
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		if(!node){
			console.error('have no node');
			return;
		}
		var s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,
		// Some elements have special padding, margin, and box-model settings.
		// To use box functions you may need to set padding, margin explicitly.
		// Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.
			pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),
			mb = geom.getMarginExtents(node, s);
		if(has("webkit")){
			// on Safari (3.1.2), button nodes with no explicit size have a default margin
			// setting an explicit size eliminates the margin.
			// We have to swizzle the width to get correct margin reading.
			if(isButtonTag(node)){
				var ns = node.style;
				if(w >= 0 && !ns.width){
					ns.width = "4px";
				}
				if(h >= 0 && !ns.height){
					ns.height = "4px";
				}
			}
		}
		if(w >= 0){
			w = Math.max(w - pb.w - mb.w, 0);
		}
		if(h >= 0){
			h = Math.max(h - pb.h - mb.h, 0);
		}
		setBox(node, box.l, box.t, w, h);
	};

	// =============================
	// Positioning
	// =============================

	geom.isBodyLtr = function isBodyLtr(/*Document?*/ doc){
		// summary:
		//		Returns true if the current language is left-to-right, and false otherwise.
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Boolean

		doc = doc || win.doc;
		return (win.body(doc).dir || doc.documentElement.dir || "ltr").toLowerCase() == "ltr"; // Boolean
	};

	geom.docScroll = function docScroll(/*Document?*/ doc){
		// summary:
		//		Returns an object with {node, x, y} with corresponding offsets.
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Object

		doc = doc || win.doc;
		var node = win.doc.parentWindow || win.doc.defaultView;   // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem
		return "pageXOffset" in node ? {x: node.pageXOffset, y: node.pageYOffset } :
			(node = has("quirks") ? win.body(doc) : doc.documentElement) &&
				{x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc), y: node.scrollTop || 0 };
	};

	geom.getIeDocumentElementOffset = function(/*Document?*/ doc){
		// summary:
		//		Deprecated method previously used for IE6-IE7.  Now, just returns `{x:0, y:0}`.
		return {
			x: 0,
			y: 0
		};
	};

	geom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(/*Integer*/ scrollLeft, /*Document?*/ doc){
		// summary:
		//		In RTL direction, scrollLeft should be a negative value, but IE
		//		returns a positive one. All codes using documentElement.scrollLeft
		//		must call this function to fix this error, otherwise the position
		//		will offset to right when there is a horizontal scrollbar.
		// scrollLeft: Number
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Number

		// In RTL direction, scrollLeft should be a negative value, but IE
		// returns a positive one. All codes using documentElement.scrollLeft
		// must call this function to fix this error, otherwise the position
		// will offset to right when there is a horizontal scrollbar.

		doc = doc || win.doc;
		var ie = has("ie");
		if(ie && !geom.isBodyLtr(doc)){
			var qk = has("quirks"),
				de = qk ? win.body(doc) : doc.documentElement,
				pwin = win.global;	// TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js
			if(ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight){
				scrollLeft += de.clientLeft; // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels
			}
			return (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft; // Integer
		}
		return scrollLeft; // Integer
	};

	geom.position = function(/*DomNode*/ node, /*Boolean?*/ includeScroll){
		// summary:
		//		Gets the position and size of the passed element relative to
		//		the viewport (if includeScroll==false), or relative to the
		//		document root (if includeScroll==true).
		//
		// description:
		//		Returns an object of the form:
		//		`{ x: 100, y: 300, w: 20, h: 15 }`.
		//		If includeScroll==true, the x and y values will include any
		//		document offsets that may affect the position relative to the
		//		viewport.
		//		Uses the border-box model (inclusive of border and padding but
		//		not margin).  Does not act as a setter.
		// node: DOMNode|String
		// includeScroll: Boolean?
		// returns: Object

		node = dom.byId(node);
		var	db = win.body(node.ownerDocument),
			ret = node.getBoundingClientRect();
		ret = {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};

		if(has("ie") < 9){
			// fixes the position in IE, quirks mode
			ret.x -= (has("quirks") ? db.clientLeft + db.offsetLeft : 0);
			ret.y -= (has("quirks") ? db.clientTop + db.offsetTop : 0);
		}

		// account for document scrolling
		// if offsetParent is used, ret value already includes scroll position
		// so we may have to actually remove that value if !includeScroll
		if(includeScroll){
			var scroll = geom.docScroll(node.ownerDocument);
			ret.x += scroll.x;
			ret.y += scroll.y;
		}

		return ret; // Object
	};

	// random "private" functions wildly used throughout the toolkit

	geom.getMarginSize = function getMarginSize(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object that encodes the width and height of
		//		the node's margin box
		// node: DOMNode|String
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
		var size = node.getBoundingClientRect();
		return {
			w: (size.right - size.left) + me.w,
			h: (size.bottom - size.top) + me.h
		};
	};

	geom.normalizeEvent = function(event){
		// summary:
		//		Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
		//		offsetX, offsetY, layerX, and layerX properties
		// event: Object
		if(!("layerX" in event)){
			event.layerX = event.offsetX;
			event.layerY = event.offsetY;
		}

		if(!("pageX" in event)){
			// FIXME: scroll position query is duped from dojo/_base/html to
			// avoid dependency on that entire module. Now that HTML is in
			// Base, we should convert back to something similar there.
			var se = event.target;
			var doc = (se && se.ownerDocument) || document;
			// DO NOT replace the following to use dojo/_base/window.body(), in IE, document.documentElement should be used
			// here rather than document.body
			var docBody = has("quirks") ? doc.body : doc.documentElement;
			event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc);
			event.pageY = event.clientY + (docBody.scrollTop || 0);
		}
	};

	// TODO: evaluate separate getters/setters for position and sizes?

	return geom;
});

define('dojo/_base/event',["./kernel", "../on", "../has", "../dom-geometry"], function(dojo, on, has, dom){
	// module:
	//		dojo/_base/event

	if(on._fixEvent){
		var fixEvent = on._fixEvent;
		on._fixEvent = function(evt, se){
			// add some additional normalization for back-compat, this isn't in on.js because it is somewhat more expensive
			evt = fixEvent(evt, se);
			if(evt){
				dom.normalizeEvent(evt);
			}
			return evt;
		};		
	}
	
	var ret = {
		// summary:
		//		This module defines dojo DOM event API.   Usually you should use dojo/on, and evt.stopPropagation() +
		//		evt.preventDefault(), rather than this module.

		fix: function(/*Event*/ evt, /*DOMNode*/ sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt: Event
			//		native event object
			// sender: DOMNode
			//		node to treat as "currentTarget"
			if(on._fixEvent){
				return on._fixEvent(evt, sender);
			}
			return evt;	// Event
		},
	
		stop: function(/*Event*/ evt){
			// summary:
			//		prevents propagation and clobbers the default action of the
			//		passed event
			// evt: Event
			//		The event object. If omitted, window.event is used on IE.
			if(has("dom-addeventlistener") || (evt && evt.preventDefault)){
				evt.preventDefault();
				evt.stopPropagation();
			}else{
				evt = evt || window.event;
				evt.cancelBubble = true;
				on._preventDefault.call(evt);
			}
		}
	};

	if(has("extend-dojo")){
		dojo.fixEvent = ret.fix;
		dojo.stopEvent = ret.stop;
	}

	return ret;
});

define('dojo/mouse',["./_base/kernel", "./on", "./has", "./dom", "./_base/window"], function(dojo, on, has, dom, win){

	// module:
	//		dojo/mouse

    has.add("dom-quirks", win.doc && win.doc.compatMode == "BackCompat");
	has.add("events-mouseenter", win.doc && "onmouseenter" in win.doc.createElement("div"));
	has.add("events-mousewheel", win.doc && 'onmousewheel' in win.doc);

	var mouseButtons;
	if((has("dom-quirks") && has("ie")) || !has("dom-addeventlistener")){
		mouseButtons = {
			LEFT:   1,
			MIDDLE: 4,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button & button; },
			isLeft:   function(e){ return e.button & 1; },
			isMiddle: function(e){ return e.button & 4; },
			isRight:  function(e){ return e.button & 2; }
		};
	}else{
		mouseButtons = {
			LEFT:   0,
			MIDDLE: 1,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button == button; },
			isLeft:   function(e){ return e.button == 0; },
			isMiddle: function(e){ return e.button == 1; },
			isRight:  function(e){ return e.button == 2; }
		};
	}
	dojo.mouseButtons = mouseButtons;

/*=====
	dojo.mouseButtons = {
		// LEFT: Number
		//		Numeric value of the left mouse button for the platform.
		LEFT:   0,
		// MIDDLE: Number
		//		Numeric value of the middle mouse button for the platform.
		MIDDLE: 1,
		// RIGHT: Number
		//		Numeric value of the right mouse button for the platform.
		RIGHT:  2,

		isButton: function(e, button){
			// summary:
			//		Checks an event object for a pressed button
			// e: Event
			//		Event object to examine
			// button: Number
			//		The button value (example: dojo.mouseButton.LEFT)
			return e.button == button; // Boolean
		},
		isLeft: function(e){
			// summary:
			//		Checks an event object for the pressed left button
			// e: Event
			//		Event object to examine
			return e.button == 0; // Boolean
		},
		isMiddle: function(e){
			// summary:
			//		Checks an event object for the pressed middle button
			// e: Event
			//		Event object to examine
			return e.button == 1; // Boolean
		},
		isRight: function(e){
			// summary:
			//		Checks an event object for the pressed right button
			// e: Event
			//		Event object to examine
			return e.button == 2; // Boolean
		}
	};
=====*/

	function eventHandler(type, selectHandler){
		// emulation of mouseenter/leave with mouseover/out using descendant checking
		var handler = function(node, listener){
			return on(node, type, function(evt){
				if(selectHandler){
					return selectHandler(evt, listener);
				}
				if(!dom.isDescendant(evt.relatedTarget, node)){
					return listener.call(this, evt);
				}
			});
		};
		handler.bubble = function(select){
			return eventHandler(type, function(evt, listener){
				// using a selector, use the select function to determine if the mouse moved inside the selector and was previously outside the selector
				var target = select(evt.target);
				var relatedTarget = evt.relatedTarget;
				if(target && (target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget)))){
					return listener.call(target, evt);
				} 
			});
		};
		return handler;
	}
	var wheel;
	if(has("events-mousewheel")){
		wheel = 'mousewheel';
	}else{ //firefox
		wheel = function(node, listener){
			return on(node, 'DOMMouseScroll', function(evt){
				evt.wheelDelta = -evt.detail;
				listener.call(this, evt);
			});
		};
	}
	return {
		// summary:
		//		This module provide mouse event handling utility functions and exports
		//		mouseenter and mouseleave event emulation.
		// example:
		//		To use these events, you register a mouseenter like this:
		//		|	define(["dojo/on", "dojo/mouse"], function(on, mouse){
		//		|		on(targetNode, mouse.enter, function(event){
		//		|			dojo.addClass(targetNode, "highlighted");
		//		|		});
		//		|		on(targetNode, mouse.leave, function(event){
		//		|			dojo.removeClass(targetNode, "highlighted");
		//		|		});

		_eventHandler: eventHandler,		// for dojo/touch

		// enter: Synthetic Event
		//		This is an extension event for the mouseenter that IE provides, emulating the
		//		behavior on other browsers.
		enter: eventHandler("mouseover"),

		// leave: Synthetic Event
		//		This is an extension event for the mouseleave that IE provides, emulating the
		//		behavior on other browsers.
		leave: eventHandler("mouseout"),

		// wheel: Normalized Mouse Wheel Event
		//		This is an extension event for the mousewheel that non-Mozilla browsers provide,
		//		emulating the behavior on Mozilla based browsers.
		wheel: wheel,

		isLeft: mouseButtons.isLeft,
		/*=====
		isLeft: function(){
			// summary:
			//		Test an event object (from a mousedown event) to see if the left button was pressed.
		},
		=====*/

		isMiddle: mouseButtons.isMiddle,
		/*=====
		 isMiddle: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the middle button was pressed.
		 },
		 =====*/

		isRight: mouseButtons.isRight
		/*=====
		 , isRight: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the right button was pressed.
		 }
		 =====*/
	};
});

define('dojo/_base/sniff',["./kernel", "./lang", "../sniff"], function(dojo, lang, has){
	// module:
	//		dojo/_base/sniff

	/*=====
	return {
		// summary:
		//		Deprecated.   New code should use dojo/sniff.
		//		This module populates the dojo browser version sniffing properties like dojo.isIE.
	};
	=====*/

	if(!has("host-browser")){
		return has;
	}

	// no idea what this is for, or if it's used
	dojo._name = "browser";

	lang.mixin(dojo, {
		// isBrowser: Boolean
		//		True if the client is a web-browser
		isBrowser: true,

		// isFF: Number|undefined
		//		Version as a Number if client is FireFox. undefined otherwise. Corresponds to
		//		major detected FireFox version (1.5, 2, 3, etc.)
		isFF: has("ff"),

		// isIE: Number|undefined
		//		Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
		//		major detected IE version (6, 7, 8, etc.)
		isIE: has("ie"),

		// isKhtml: Number|undefined
		//		Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
		//		detected version.
		isKhtml: has("khtml"),

		// isWebKit: Number|undefined
		//		Version as a Number if client is a WebKit-derived browser (Konqueror,
		//		Safari, Chrome, etc.). undefined otherwise.
		isWebKit: has("webkit"),

		// isMozilla: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMozilla: has("mozilla"),
		// isMoz: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMoz: has("mozilla"),

		// isOpera: Number|undefined
		//		Version as a Number if client is Opera. undefined otherwise. Corresponds to
		//		major detected version.
		isOpera: has("opera"),

		// isSafari: Number|undefined
		//		Version as a Number if client is Safari or iPhone. undefined otherwise.
		isSafari: has("safari"),

		// isChrome: Number|undefined
		//		Version as a Number if client is Chrome browser. undefined otherwise.
		isChrome: has("chrome"),

		// isMac: Boolean
		//		True if the client runs on Mac
		isMac: has("mac"),

		// isIos: Number|undefined
		//		Version as a Number if client is iPhone, iPod, or iPad. undefined otherwise.
		isIos: has("ios"),

		// isAndroid: Number|undefined
		//		Version as a Number if client is android browser. undefined otherwise.
		isAndroid: has("android"),

		// isWii: Boolean
		//		True if client is Wii
		isWii: has("wii"),

		// isQuirks: Boolean
		//		Page is in quirks mode.
		isQuirks: has("quirks"),

		// isAir: Boolean
		//		True if client is Adobe Air
		isAir: has("air")
	});

	return has;
});

define('dojo/keys',["./_base/kernel", "./sniff"], function(dojo, has){

	// module:
	//		dojo/keys

	return dojo.keys = {
		// summary:
		//		Definitions for common key values.  Client code should test keyCode against these named constants,
		//		as the actual codes can vary by browser.

		BACKSPACE: 8,
		TAB: 9,
		CLEAR: 12,
		ENTER: 13,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		META: has("webkit") ? 91 : 224,		// the apple key on macs
		PAUSE: 19,
		CAPS_LOCK: 20,
		ESCAPE: 27,
		SPACE: 32,
		PAGE_UP: 33,
		PAGE_DOWN: 34,
		END: 35,
		HOME: 36,
		LEFT_ARROW: 37,
		UP_ARROW: 38,
		RIGHT_ARROW: 39,
		DOWN_ARROW: 40,
		INSERT: 45,
		DELETE: 46,
		HELP: 47,
		LEFT_WINDOW: 91,
		RIGHT_WINDOW: 92,
		SELECT: 93,
		NUMPAD_0: 96,
		NUMPAD_1: 97,
		NUMPAD_2: 98,
		NUMPAD_3: 99,
		NUMPAD_4: 100,
		NUMPAD_5: 101,
		NUMPAD_6: 102,
		NUMPAD_7: 103,
		NUMPAD_8: 104,
		NUMPAD_9: 105,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_PLUS: 107,
		NUMPAD_ENTER: 108,
		NUMPAD_MINUS: 109,
		NUMPAD_PERIOD: 110,
		NUMPAD_DIVIDE: 111,
		F1: 112,
		F2: 113,
		F3: 114,
		F4: 115,
		F5: 116,
		F6: 117,
		F7: 118,
		F8: 119,
		F9: 120,
		F10: 121,
		F11: 122,
		F12: 123,
		F13: 124,
		F14: 125,
		F15: 126,
		NUM_LOCK: 144,
		SCROLL_LOCK: 145,
		UP_DPAD: 175,
		DOWN_DPAD: 176,
		LEFT_DPAD: 177,
		RIGHT_DPAD: 178,
		// virtual key mapping
		copyKey: has("mac") && !has("air") ? (has("safari") ? 91 : 224 ) : 17
	};
});

define('dojo/_base/connect',["./kernel", "../on", "../topic", "../aspect", "./event", "../mouse", "./sniff", "./lang", "../keys"], function(dojo, on, hub, aspect, eventModule, mouse, has, lang){
// module:
//		dojo/_base/connect

has.add("events-keypress-typed", function(){ // keypresses should only occur a printable character is hit
	var testKeyEvent = {charCode: 0};
	try{
		testKeyEvent = document.createEvent("KeyboardEvent");
		(testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, "keypress", true, true, null, false, false, false, false, 9, 3);
	}catch(e){}
	return testKeyEvent.charCode == 0 && !has("opera");
});

function connect_(obj, event, context, method, dontFix){
	method = lang.hitch(context, method);
	if(!obj || !(obj.addEventListener || obj.attachEvent)){
		// it is a not a DOM node and we are using the dojo.connect style of treating a
		// method like an event, must go right to aspect
		return aspect.after(obj || dojo.global, event, method, true);
	}
	if(typeof event == "string" && event.substring(0, 2) == "on"){
		event = event.substring(2);
	}
	if(!obj){
		obj = dojo.global;
	}
	if(!dontFix){
		switch(event){
			// dojo.connect has special handling for these event types
			case "keypress":
				event = keypress;
				break;
			case "mouseenter":
				event = mouse.enter;
				break;
			case "mouseleave":
				event = mouse.leave;
				break;
		}
	}
	return on(obj, event, method, dontFix);
}

var _punctMap = {
	106:42,
	111:47,
	186:59,
	187:43,
	188:44,
	189:45,
	190:46,
	191:47,
	192:96,
	219:91,
	220:92,
	221:93,
	222:39,
	229:113
};
var evtCopyKey = has("mac") ? "metaKey" : "ctrlKey";


var _synthesizeEvent = function(evt, props){
	var faux = lang.mixin({}, evt, props);
	setKeyChar(faux);
	// FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);
	// but it throws an error when preventDefault is invoked on Safari
	// does Event.preventDefault not support "apply" on Safari?
	faux.preventDefault = function(){ evt.preventDefault(); };
	faux.stopPropagation = function(){ evt.stopPropagation(); };
	return faux;
};
function setKeyChar(evt){
	evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
	evt.charOrCode = evt.keyChar || evt.keyCode;
}
var keypress;
if(has("events-keypress-typed")){
	// this emulates Firefox's keypress behavior where every keydown can correspond to a keypress
	var _trySetKeyCode = function(e, code){
		try{
			// squelch errors when keyCode is read-only
			// (e.g. if keyCode is ctrl or shift)
			return (e.keyCode = code);
		}catch(e){
			return 0;
		}
	};
	keypress = function(object, listener){
		var keydownSignal = on(object, "keydown", function(evt){
			// munge key/charCode
			var k=evt.keyCode;
			// These are Windows Virtual Key Codes
			// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp
			var unprintable = (k!=13) && k!=32 && (k!=27||!has("ie")) && (k<48||k>90) && (k<96||k>111) && (k<186||k>192) && (k<219||k>222) && k!=229;
			// synthesize keypress for most unprintables and CTRL-keys
			if(unprintable||evt.ctrlKey){
				var c = unprintable ? 0 : k;
				if(evt.ctrlKey){
					if(k==3 || k==13){
						return listener.call(evt.currentTarget, evt); // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively
					}else if(c>95 && c<106){
						c -= 48; // map CTRL-[numpad 0-9] to ASCII
					}else if((!evt.shiftKey)&&(c>=65&&c<=90)){
						c += 32; // map CTRL-[A-Z] to lowercase
					}else{
						c = _punctMap[c] || c; // map other problematic CTRL combinations to ASCII
					}
				}
				// simulate a keypress event
				var faux = _synthesizeEvent(evt, {type: 'keypress', faux: true, charCode: c});
				listener.call(evt.currentTarget, faux);
				if(has("ie")){
					_trySetKeyCode(evt, faux.keyCode);
				}
			}
		});
		var keypressSignal = on(object, "keypress", function(evt){
			var c = evt.charCode;
			c = c>=32 ? c : 0;
			evt = _synthesizeEvent(evt, {charCode: c, faux: true});
			return listener.call(this, evt);
		});
		return {
			remove: function(){
				keydownSignal.remove();
				keypressSignal.remove();
			}
		};
	};
}else{
	if(has("opera")){
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				var c = evt.which;
				if(c==3){
					c=99; // Mozilla maps CTRL-BREAK to CTRL-c
				}
				// can't trap some keys at all, like INSERT and DELETE
				// there is no differentiating info between DELETE and ".", or INSERT and "-"
				c = c<32 && !evt.shiftKey ? 0 : c;
				if(evt.ctrlKey && !evt.shiftKey && c>=65 && c<=90){
					// lowercase CTRL-[A-Z] keys
					c += 32;
				}
				return listener.call(this, _synthesizeEvent(evt, { charCode: c }));
			});
		};
	}else{
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				setKeyChar(evt);
				return listener.call(this, evt);
			});
		};
	}
}

var connect = {
	// summary:
	//		This module defines the dojo.connect API.
	//		This modules also provides keyboard event handling helpers.
	//		This module exports an extension event for emulating Firefox's keypress handling.
	//		However, this extension event exists primarily for backwards compatibility and
	//		is not recommended. WebKit and IE uses an alternate keypress handling (only
	//		firing for printable characters, to distinguish from keydown events), and most
	//		consider the WebKit/IE behavior more desirable.

	_keypress:keypress,

	connect:function(obj, event, context, method, dontFix){
		// summary:
		//		`dojo.connect` is a deprecated event handling and delegation method in
		//		Dojo. It allows one function to "listen in" on the execution of
		//		any other, triggering the second whenever the first is called. Many
		//		listeners may be attached to a function, and source functions may
		//		be either regular function calls or DOM events.
		//
		// description:
		//		Connects listeners to actions, so that after event fires, a
		//		listener is called with the same arguments passed to the original
		//		function.
		//
		//		Since `dojo.connect` allows the source of events to be either a
		//		"regular" JavaScript function or a DOM event, it provides a uniform
		//		interface for listening to all the types of events that an
		//		application is likely to deal with though a single, unified
		//		interface. DOM programmers may want to think of it as
		//		"addEventListener for everything and anything".
		//
		//		When setting up a connection, the `event` parameter must be a
		//		string that is the name of the method/event to be listened for. If
		//		`obj` is null, `kernel.global` is assumed, meaning that connections
		//		to global methods are supported but also that you may inadvertently
		//		connect to a global by passing an incorrect object name or invalid
		//		reference.
		//
		//		`dojo.connect` generally is forgiving. If you pass the name of a
		//		function or method that does not yet exist on `obj`, connect will
		//		not fail, but will instead set up a stub method. Similarly, null
		//		arguments may simply be omitted such that fewer than 4 arguments
		//		may be required to set up a connection See the examples for details.
		//
		//		The return value is a handle that is needed to
		//		remove this connection with `dojo.disconnect`.
		//
		// obj: Object?
		//		The source object for the event function.
		//		Defaults to `kernel.global` if null.
		//		If obj is a DOM node, the connection is delegated
		//		to the DOM event manager (unless dontFix is true).
		//
		// event: String
		//		String name of the event function in obj.
		//		I.e. identifies a property `obj[event]`.
		//
		// context: Object|null
		//		The object that method will receive as "this".
		//
		//		If context is null and method is a function, then method
		//		inherits the context of event.
		//
		//		If method is a string then context must be the source
		//		object object for method (context[method]). If context is null,
		//		kernel.global is used.
		//
		// method: String|Function
		//		A function reference, or name of a function in context.
		//		The function identified by method fires after event does.
		//		method receives the same arguments as the event.
		//		See context argument comments for information on method's scope.
		//
		// dontFix: Boolean?
		//		If obj is a DOM node, set dontFix to true to prevent delegation
		//		of this connection to the DOM event manager.
		//
		// example:
		//		When obj.onchange(), do ui.update():
		//	|	dojo.connect(obj, "onchange", ui, "update");
		//	|	dojo.connect(obj, "onchange", ui, ui.update); // same
		//
		// example:
		//		Using return value for disconnect:
		//	|	var link = dojo.connect(obj, "onchange", ui, "update");
		//	|	...
		//	|	dojo.disconnect(link);
		//
		// example:
		//		When onglobalevent executes, watcher.handler is invoked:
		//	|	dojo.connect(null, "onglobalevent", watcher, "handler");
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked:
		//	|	dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
		//	|	dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(ob, "onCustomEvent", null, customEventHandler);
		//	|	dojo.connect(ob, "onCustomEvent", customEventHandler); // same
		//
		// example:
		//		When globalEvent executes, globalHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(null, "globalEvent", null, globalHandler);
		//	|	dojo.connect("globalEvent", globalHandler); // same

		// normalize arguments
		var a=arguments, args=[], i=0;
		// if a[0] is a String, obj was omitted
		args.push(typeof a[0] == "string" ? null : a[i++], a[i++]);
		// if the arg-after-next is a String or Function, context was NOT omitted
		var a1 = a[i+1];
		args.push(typeof a1 == "string" || typeof a1 == "function" ? a[i++] : null, a[i++]);
		// absorb any additional arguments
		for(var l=a.length; i<l; i++){	args.push(a[i]); }
		return connect_.apply(this, args);
	},

	disconnect:function(handle){
		// summary:
		//		Remove a link created by dojo.connect.
		// description:
		//		Removes the connection between event and the method referenced by handle.
		// handle: Handle
		//		the return value of the dojo.connect call that created the connection.

		if(handle){
            if(handle.remove) {
                handle.remove();
            }else{
                console.error('have no remove!');
            }
		}
	},

	subscribe:function(topic, context, method){
		// summary:
		//		Attach a listener to a named topic. The listener function is invoked whenever the
		//		named topic is published (see: dojo.publish).
		//		Returns a handle which is needed to unsubscribe this listener.
		// topic: String
		//		The topic to which to subscribe.
		// context: Object?
		//		Scope in which method will be invoked, or null for default scope.
		// method: String|Function
		//		The name of a function in context, or a function reference. This is the function that
		//		is invoked when topic is published.
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); });
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.subscribe(topic, lang.hitch(context, method));
	},

	publish:function(topic, args){
		// summary:
		//		Invoke all listener method subscribed to topic.
		// topic: String
		//		The name of the topic to publish.
		// args: Array?
		//		An array of arguments. The arguments will be applied
		//		to each topic subscriber (as first class parameters, via apply).
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.publish.apply(hub, [topic].concat(args));
	},

	connectPublisher:function(topic, obj, event){
		// summary:
		//		Ensure that every time obj.event() is called, a message is published
		//		on the topic. Returns a handle which can be passed to
		//		dojo.disconnect() to disable subsequent automatic publication on
		//		the topic.
		// topic: String
		//		The name of the topic to publish.
		// obj: Object?
		//		The source object for the event function. Defaults to kernel.global
		//		if null.
		// event: String
		//		The name of the event function in obj.
		//		I.e. identifies a property obj[event].
		// example:
		//	|	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");
		var pf = function(){ connect.publish(topic, arguments); };
		return event ? connect.connect(obj, event, pf) : connect.connect(obj, pf); //Handle
	},

	isCopyKey: function(e){
		// summary:
		//		Checks an event for the copy key (meta on Mac, and ctrl anywhere else)
		// e: Event
		//		Event object to examine
		return e[evtCopyKey];	// Boolean
	}
};

connect.unsubscribe = connect.disconnect;
/*=====
 connect.unsubscribe = function(handle){
	 // summary:
	 //		Remove a topic listener.
	 // handle: Handle
	 //		The handle returned from a call to subscribe.
	 // example:
	 //	|	var alerter = dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
	 //	|	...
	 //	|	dojo.unsubscribe(alerter);
 };
 =====*/

has("extend-dojo") && lang.mixin(dojo, connect);
return connect;

});



define('dojo/dom-prop',["exports", "./_base/kernel", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-construct", "./_base/connect"],
		function(exports, dojo, has, lang, dom, style, ctr, conn){
	// module:
	//		dojo/dom-prop
	// summary:
	//		This module defines the core dojo DOM properties API.

	// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

	// =============================
	// Element properties Functions
	// =============================

	// helper to connect events
	var _evtHdlrMap = {}, _ctr = 1, _attrId = dojo._scopeName + "attrid";
	has.add('dom-textContent', function (global, doc, element) { return 'textContent' in element; });

	exports.names = {
		// properties renamed to avoid clashes with reserved words
		"class": "className",
		"for": "htmlFor",
		// properties written as camelCase
		tabindex: "tabIndex",
		readonly: "readOnly",
		colspan: "colSpan",
		frameborder: "frameBorder",
		rowspan: "rowSpan",
		textcontent: "textContent",
		valuetype: "valueType"
	};
	
	function getText(/*DOMNode*/node){
		// summary:
		//		recursion method for get('textContent') to use. Gets text value for a node.
		// description:
		//		Juse uses nodedValue so things like <br/> tags do not end up in
		//		the text as any sort of line return.
		var text = "", ch = node.childNodes;
		for(var i = 0, n; n = ch[i]; i++){
			//Skip comments.
			if(n.nodeType != 8){
				if(n.nodeType == 1){
					text += getText(n);
				}else{
					text += n.nodeValue;
				}
			}
		}
		return text;
	}

	exports.get = function getProp(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Gets a property on an HTML element.
		// description:
		//		Handles normalized getting of properties on DOM nodes.
		//
		// node: DOMNode|String
		//		id or reference to the element to get the property on
		// name: String
		//		the name of the property to get.
		// returns:
		//		the value of the requested property or its default value
		//
		// example:
		//	|	// get the current value of the "foo" property on a node
		//	|	require(["dojo/dom-prop", "dojo/dom"], function(domProp, dom){
		//	|		domProp.get(dom.byId("nodeId"), "foo");
		//	|		// or we can just pass the id:
		//	|		domProp.get("nodeId", "foo");
		//	|	});

		node = dom.byId(node);
		var lc = name.toLowerCase(), propName = exports.names[lc] || name;
		
		if(propName == "textContent" && !has("dom-textContent")){
			return getText(node);
		}
		
		return node[propName];	// Anything
	};

	exports.set = function setProp(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets a property on an HTML element.
		// description:
		//		Handles normalized setting of properties on DOM nodes.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to set the property on
		// name: String|Object
		//		the name of the property to set, or a hash object to set
		//		multiple properties at once.
		// value: String?
		//		The value to set for the property
		// returns:
		//		the DOM node
		//
		// example:
		//	|	// use prop() to set the tab index
		//	|	require(["dojo/dom-prop"], function(domProp){
		//	|		domProp.set("nodeId", "tabIndex", 3);
		//	|	});
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	require(["dojo/dom-prop"], function(domProp){
		//	|		domProp.set("formId", {
		//	|			"foo": "bar",
		//	|			"tabIndex": -1,
		//	|			"method": "POST",
		//	|		});
		//	|	});

		node = dom.byId(node);
		if(!node){
			console.error('invalid node!',node);
			return node;
		}
		var l = arguments.length;
		if(l == 2 && typeof name != "string"){ // inline'd type check
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){
				exports.set(node, x, name[x]);
			}
			return node; // DomNode
		}
		var lc = name.toLowerCase(), propName = exports.names[lc] || name;
		if(propName == "style" && typeof value != "string"){ // inline'd type check
			// special case: setting a style
			style.set(node, value);
			return node; // DomNode
		}
		if(propName == "innerHTML"){
			// special case: assigning HTML
			// the hash lists elements with read-only innerHTML on IE
			if(has("ie") && node.tagName.toLowerCase() in {col: 1, colgroup: 1,
						table: 1, tbody: 1, tfoot: 1, thead: 1, tr: 1, title: 1}){
				ctr.empty(node);
				node.appendChild(ctr.toDom(value, node.ownerDocument));
			}else{
				node[propName] = value;
			}
			return node; // DomNode
		}
		if(propName == "textContent" && !has("dom-textContent")) {
			ctr.empty(node);
			node.appendChild(node.ownerDocument.createTextNode(value));
			return node;
		}
		if(lang.isFunction(value)){
			// special case: assigning an event handler
			// clobber if we can
			var attrId = node[_attrId];
			if(!attrId){
				attrId = _ctr++;
				node[_attrId] = attrId;
			}
			if(!_evtHdlrMap[attrId]){
				_evtHdlrMap[attrId] = {};
			}
			var h = _evtHdlrMap[attrId][propName];
			if(h){
				//h.remove();
				conn.disconnect(h);
			}else{
				try{
					delete node[propName];
				}catch(e){}
			}
			// ensure that event objects are normalized, etc.
			if(value){
				//_evtHdlrMap[attrId][propName] = on(node, propName, value);
				_evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);
			}else{
				node[propName] = null;
			}
			return node; // DomNode
		}
		node[propName] = value;
		return node;	// DomNode
	};
});

define('dojo/dom-attr',["exports", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-prop"],
		function(exports, has, lang, dom, style, prop){
	// module:
	//		dojo/dom-attr
	// summary:
	//		This module defines the core dojo DOM attributes API.

	// TODOC: summary not showing up in output see https://github.com/csnover/js-doc-parse/issues/42

	// =============================
	// Element attribute Functions
	// =============================

	// This module will be obsolete soon. Use dojo/prop instead.

	// dojo/dom-attr.get() should conform to http://www.w3.org/TR/DOM-Level-2-Core/

	// attribute-related functions (to be obsolete soon)
	var forcePropNames = {
			innerHTML:	1,
			textContent:1,
			className:	1,
			htmlFor:	has("ie"),
			value:		1
		},
		attrNames = {
			// original attribute names
			classname: "class",
			htmlfor: "for",
			// for IE
			tabindex: "tabIndex",
			readonly: "readOnly"
		};

	function _hasAttr(node, name){
		var attr = node.getAttributeNode && node.getAttributeNode(name);
		return !!attr && attr.specified; // Boolean
	}
	
	// There is a difference in the presence of certain properties and their default values
	// between browsers. For example, on IE "disabled" is present on all elements,
	// but it is value is "false"; "tabIndex" of <div> returns 0 by default on IE, yet other browsers
	// can return -1.

	exports.has = function hasAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns true if the requested attribute is specified on the
		//		given element, and false otherwise.
		// node: DOMNode|String
		//		id or reference to the element to check
		// name: String
		//		the name of the attribute
		// returns: Boolean
		//		true if the requested attribute is specified on the
		//		given element, and false otherwise

		var lc = name.toLowerCase();
		return forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);	// Boolean
	};

	exports.get = function getAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Gets an attribute on an HTML element.
		// description:
		//		Handles normalized getting of attributes on DOM Nodes.
		// node: DOMNode|String
		//		id or reference to the element to get the attribute on
		// name: String
		//		the name of the attribute to get.
		// returns:
		//		the value of the requested attribute or null if that attribute does not have a specified or
		//		default value;
		//
		// example:
		//	|	// get the current value of the "foo" attribute on a node
		//	|	require(["dojo/dom-attr", "dojo/dom"], function(domAttr, dom){
		//	|		domAttr.get(dom.byId("nodeId"), "foo");
		//	|		// or we can just pass the id:
		//	|		domAttr.get("nodeId", "foo");
		//	|	});	
		//	|	

		node = dom.byId(node);
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName],
			value = node[propName];		// should we access this attribute via a property or via getAttribute()?

		if(forceProp && typeof value != "undefined"){
			// node's property
			return value;	// Anything
		}
		
		if(propName == "textContent"){
			return prop.get(node, propName);
		}
		
		if(propName != "href" && (typeof value == "boolean" || lang.isFunction(value))){
			// node's property
			return value;	// Anything
		}
		// node's attribute
		// we need _hasAttr() here to guard against IE returning a default value
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};

	exports.set = function setAttr(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets an attribute on an HTML element.
		// description:
		//		Handles normalized setting of attributes on DOM Nodes.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to set the attribute on
		// name: String|Object
		//		the name of the attribute to set, or a hash of key-value pairs to set.
		// value: String?
		//		the value to set for the attribute, if the name is a string.
		// returns:
		//		the DOM node
		//
		// example:
		//	|	// use attr() to set the tab index
		//	|	require(["dojo/dom-attr"], function(domAttr){
		//	|		domAttr.set("nodeId", "tabIndex", 3);
		//	|	});
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	require(["dojo/dom-attr"],
		//	|	function(domAttr){
		//	|		domAttr.set("formId", {
		//	|			"foo": "bar",
		//	|			"tabIndex": -1,
		//	|			"method": "POST"
		//	|		}
		//	|	});

		node = dom.byId(node);
		if(arguments.length == 2){ // inline'd type check
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){
				exports.set(node, x, name[x]);
			}
			return node; // DomNode
		}
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName];
		if(propName == "style" && typeof value != "string"){ // inline'd type check
			// special case: setting a style
			style.set(node, value);
			return node; // DomNode
		}
		if(forceProp || typeof value == "boolean" || lang.isFunction(value)){
			return prop.set(node, name, value);
		}
		// node's attribute
		node.setAttribute(attrNames[lc] || name, value);
		return node; // DomNode
	};

	exports.remove = function removeAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Removes an attribute from an HTML element.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute to remove

		dom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);
	};

	exports.getNodeProp = function getNodeProp(/*DomNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns an effective value of a property or an attribute.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute
		// returns:
		//		the value of the attribute

		node = dom.byId(node);
		var lc = name.toLowerCase(), propName = prop.names[lc] || name;
		if((propName in node) && propName != "href"){
			// node's property
			return node[propName];	// Anything
		}
		// node's attribute
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};
});

define('dojo/_base/Color',["./kernel", "./lang", "./array", "./config"], function(dojo, lang, ArrayUtil, config){

	var Color = dojo.Color = function(/*Array|String|Object*/ color){
		// summary:
		//		Takes a named string, hex string, array of rgb or rgba values,
		//		an object with r, g, b, and a properties, or another `Color` object
		//		and creates a new Color instance to work from.
		//
		// example:
		//		Work with a Color instance:
		//	|	require(["dojo/_base/color"], function(Color){
		//	|		var c = new Color();
		//	|		c.setColor([0,0,0]); // black
		//	|		var hex = c.toHex(); // #000000
		//	|	});
		//
		// example:
		//		Work with a node's color:
		//	| 
		//	|	require(["dojo/_base/color", "dojo/dom-style"], function(Color, domStyle){
		//	|		var color = domStyle("someNode", "backgroundColor");
		//	|		var n = new Color(color);
		//	|		// adjust the color some
		//	|		n.r *= .5;
		//	|		console.log(n.toString()); // rgb(128, 255, 255);
		//	|	});
		if(color){ this.setColor(color); }
	};

	// FIXME:
	// there's got to be a more space-efficient way to encode or discover
	// these!! Use hex?
	Color.named = {
		// summary:
		//		Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.
		"black":  [0,0,0],
		"silver": [192,192,192],
		"gray":	  [128,128,128],
		"white":  [255,255,255],
		"maroon": [128,0,0],
		"red":	  [255,0,0],
		"purple": [128,0,128],
		"fuchsia":[255,0,255],
		"green":  [0,128,0],
		"lime":	  [0,255,0],
		"olive":  [128,128,0],
		"yellow": [255,255,0],
		"navy":	  [0,0,128],
		"blue":	  [0,0,255],
		"teal":	  [0,128,128],
		"aqua":	  [0,255,255],
		"transparent": config.transparentColor || [0,0,0,0]
	};

	lang.extend(Color, {
		r: 255, g: 255, b: 255, a: 1,
		_set: function(r, g, b, a){
			var t = this; t.r = r; t.g = g; t.b = b; t.a = a;
		},
		setColor: function(/*Array|String|Object*/ color){
			// summary:
			//		Takes a named string, hex string, array of rgb or rgba values,
			//		an object with r, g, b, and a properties, or another `Color` object
			//		and sets this color instance to that value.
			//
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color(); // no color
			//	|		c.setColor("#ededed"); // greyish
			//	|	});
			if(lang.isString(color)){
				Color.fromString(color, this);
			}else if(lang.isArray(color)){
				Color.fromArray(color, this);
			}else{
				this._set(color.r, color.g, color.b, color.a);
				if(!(color instanceof Color)){ this.sanitize(); }
			}
			return this;	// Color
		},
		sanitize: function(){
			// summary:
			//		Ensures the object has correct attributes
			// description:
			//		the default implementation does nothing, include dojo.colors to
			//		augment it with real checks
			return this;	// Color
		},
		toRgb: function(){
			// summary:
			//		Returns 3 component array of rgb values
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color("#000000");
			//	|		console.log(c.toRgb()); // [0,0,0]
			//	|	});
			var t = this;
			return [t.r, t.g, t.b]; // Array
		},
		toRgba: function(){
			// summary:
			//		Returns a 4 component array of rgba values from the color
			//		represented by this object.
			var t = this;
			return [t.r, t.g, t.b, t.a];	// Array
		},
		toHex: function(){
			// summary:
			//		Returns a CSS color string in hexadecimal representation
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		console.log(new Color([0,0,0]).toHex()); // #000000
			//	|	});
			var arr = ArrayUtil.map(["r", "g", "b"], function(x){
				var s = this[x].toString(16);
				return s.length < 2 ? "0" + s : s;
			}, this);
			return "#" + arr.join("");	// String
		},
		toCss: function(/*Boolean?*/ includeAlpha){
			// summary:
			//		Returns a css color string in rgb(a) representation
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color("#FFF").toCss();
			//	|		console.log(c); // rgb('255','255','255')
			//	|	});
			var t = this, rgb = t.r + ", " + t.g + ", " + t.b;
			return (includeAlpha ? "rgba(" + rgb + ", " + t.a : "rgb(" + rgb) + ")";	// String
		},
		toString: function(){
			// summary:
			//		Returns a visual representation of the color
			return this.toCss(true); // String
		}
	});

	Color.blendColors = dojo.blendColors = function(
		/*Color*/ start,
		/*Color*/ end,
		/*Number*/ weight,
		/*Color?*/ obj
	){
		// summary:
		//		Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
		//		can reuse a previously allocated Color object for the result
		var t = obj || new Color();
		ArrayUtil.forEach(["r", "g", "b", "a"], function(x){
			t[x] = start[x] + (end[x] - start[x]) * weight;
			if(x != "a"){ t[x] = Math.round(t[x]); }
		});
		return t.sanitize();	// Color
	};

	Color.fromRgb = dojo.colorFromRgb = function(/*String*/ color, /*Color?*/ obj){
		// summary:
		//		Returns a `Color` instance from a string of the form
		//		"rgb(...)" or "rgba(...)". Optionally accepts a `Color`
		//		object to update with the parsed value and return instead of
		//		creating a new object.
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var m = color.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);
		return m && Color.fromArray(m[1].split(/\s*,\s*/), obj);	// Color
	};

	Color.fromHex = dojo.colorFromHex = function(/*String*/ color, /*Color?*/ obj){
		// summary:
		//		Converts a hex string with a '#' prefix to a color object.
		//		Supports 12-bit #rgb shorthand. Optionally accepts a
		//		`Color` object to update with the parsed value.
		//
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		//
		// example:
		//	|	require(["dojo/_base/color"], function(Color){
		//	|		var thing = new Color().fromHex("#ededed"); // grey, longhand
		//	|		var thing2 = new Color().fromHex("#000"); // black, shorthand
		//	|	});
		var t = obj || new Color(),
			bits = (color.length == 4) ? 4 : 8,
			mask = (1 << bits) - 1;
		color = Number("0x" + color.substr(1));
		if(isNaN(color)){
			return null; // Color
		}
		ArrayUtil.forEach(["b", "g", "r"], function(x){
			var c = color & mask;
			color >>= bits;
			t[x] = bits == 4 ? 17 * c : c;
		});
		t.a = 1;
		return t;	// Color
	};

	Color.fromArray = dojo.colorFromArray = function(/*Array*/ a, /*Color?*/ obj){
		// summary:
		//		Builds a `Color` from a 3 or 4 element array, mapping each
		//		element in sequence to the rgb(a) values of the color.
		// example:
		//		|	require(["dojo/_base/color"], function(Color){
		//		|		var myColor = new Color().fromArray([237,237,237,0.5]); // grey, 50% alpha
		//		|	});
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var t = obj || new Color();
		t._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));
		if(isNaN(t.a)){ t.a = 1; }
		return t.sanitize();	// Color
	};

	Color.fromString = dojo.colorFromString = function(/*String*/ str, /*Color?*/ obj){
		// summary:
		//		Parses `str` for a color value. Accepts hex, rgb, and rgba
		//		style color values.
		// description:
		//		Acceptable input values for str may include arrays of any form
		//		accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
		//		rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
		//		10, 50)"
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var a = Color.named[str];
		return a && Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj);	// Color
	};

	return Color;
});

define('xblox/model/html/SetStyle',[
    "dcl/dcl",
    "xblox/model/Block",
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xblox/model/Referenced',
    "dojo/dom-attr",
    "dojo/dom-style",
    "dojo/_base/Color"
], function(dcl,Block,utils,types,EventedMixin,Referenced,domAttr,domStyle,Color){

    var debug = false;
    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    //declare("xblox.model.html.SetStyle",[Block,EventedMixin,Referenced]
    var Impl = {
        declaredClass:"xblox.model.html.SetStyle",
        //method: (String)
        //  block name
        name:'Set Style',
        reference:'',
        references:null,
        description:'Sets HTML Node Style Attribute',
        value:'',
        mode:1,
        sharable:true,
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         * Run this block
         * @param scope
         * @param settings
         */
        solve:function(scope,settings) {
            debug && console.log('-set style solve');
            var value = this.value;
            if(this.override && this.override.variables){
                value = utils.replace(value,null,this.override.variables,{
                    begin:'{',
                    end:'}'
                });
            }
            this.updateObjects(null,value,this.mode);
            this.onSuccess(this,settings);
            this.onDidRun();//clear overrides
        },
        /**
         * Get human readable string for the UI
         * @returns {string}
         */
        toText:function(){
            var _ref = this.deserialize(this.reference);
            var result = this.getBlockIcon() + ' ' + this.name + ' :: on ' + _ref.reference + ' to' || ' ' + ' to ';
            if(this.value){
                result+= ' ' + this.value;
            }
            return result;
        },
        /**
         * Standard call when editing this block
         * @returns {*}
         */
        getFields:function(){
            var fields = this.inherited(arguments) || this.getDefaultFields();

            fields.push(utils.createCI('Value',types.ECIType.DOM_PROPERTIES,this.value,{
                group:'General',
                dst:'value',
                value:this.value,
                intermediateChanges:false
            }));

            fields.push(utils.createCI('Mode',types.ECIType.ENUMERATION,this.mode,{
                group:'General',
                options:[
                    utils.createOption('Set',1),
                    utils.createOption('Add',2),
                    utils.createOption('Remove',3),
                    utils.createOption('Increase',4),
                    utils.createOption('Decrease',5)
                ],
                dst:'mode'
            }));


            var referenceArgs = {
                group:'General',
                dst:'reference',
                value:this.reference
            };

            if(this.scope){
                if(this.scope.global) {

                    referenceArgs.window = this.scope.global;
                    referenceArgs.allowHTMLNodes = true;
                    referenceArgs.allowWidgets = false;

                }
                if(this.scope.document) {
                    referenceArgs.document = this.scope.document;
                }
            }

            fields.push(utils.createCI('Target',types.ECIType.WIDGET_REFERENCE,this.reference,referenceArgs));

            return fields;
        },
        getBlockIcon:function(){
            return '<span class="fa-paint-brush"></span>';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Lifecycle
        //
        /////////////////////////////////////////////////////////////////////////////////////
        updateEventSelector:function(objects,cis){
            var options = [];
            if(!objects || !objects.length){
                options= this.scope.getEventsAsOptions(this.event);
            }else{
                options = [{label:"onclick", value:"onclick"},
                    {label:"ondblclick",value:"ondblclick"},
                    {label:"onmousedown",value:"onmousedown"},
                    {label:"onmouseup",value:"onmouseup"},
                    {label:"onmouseover",value:"onmouseover"},
                    {label:"onmousemove",value:"onmousemove"},
                    {label:"onmouseout",value:"onmouseout"},
                    {label:"onkeypress",value:"onkeypress"},
                    {label:"onkeydown",value:"onkeydown"},
                    {label:"onkeyup",  value:"onkeyup"},
                    {label:"onfocus",  value:"onfocus"},
                    {label:"onblur",  value:"onblur"},
                    {label:"onchange",  value:"onchange"}];

                //select the event we are listening to
                for (var i = 0; i < options.length; i++) {
                    var obj = options[i];
                    if(obj.value===this.event){
                        obj.selected=true;
                        break;
                    }
                }
            }

            for (var i = 0; i < cis.length; i++) {
                var ci = cis[i];
                if(ci['widget'] && ci['widget'].title==='Event'){
                    var widget = ci['_widget'];
                    widget.nativeWidget.set('options',options);
                    widget.nativeWidget.reset();
                    widget.nativeWidget.set('value',this.event);
                    this.publish(types.EVENTS.RESIZE,{});
                    break;
                }
            }
        },
        onReferenceChanged:function(newValue,cis){
            this.reference = newValue;
            this.references = this.resolveReference(this.deserialize(newValue));
            this.updateObjects(this.references,this.value);
        },
        getPropValue:function(stylesObject,prop){
            for (var _prop in stylesObject) {
                if(_prop === prop){
                    return stylesObject[_prop];
                }
            }
            return null;
        },
        _getStyle:function(name,obj,jObj){
            switch (name){
                case "height":{
                    return jObj.outerHeight();
                }
                case "width":{
                    return jObj.outerWidth();
                }
                case "color":{
                    return jObj.css("color");
                }
                case "border-color":{
                    return jObj.css("border-color") || "rgba(0,0,0,0)";
                }
            }

            return null;
        },
        updateObject:function(obj,style,mode){
            if(!obj){
                return false;
            }
            mode = mode || 1;
            if(obj.domNode!=null){
                obj = obj.domNode;
            }
            var currentStyle = domAttr.get(obj,'style');
            if(currentStyle===";"){
                currentStyle="";
            }
            if(currentStyle===""){
                if(obj['lastStyle']!=null){
                    currentStyle = obj['lastStyle'];
                }else {
                    currentStyle = style;
                }
            }

            if(currentStyle===";"){
                currentStyle=style;
            }
            switch (mode){
                //set
                case 1:{

                    var currentStyleMap = this._toObject(currentStyle);
                    var props = style.split(';');
                    var css={};
                    for (var i = 0; i < props.length; i++) {
                        var _style = props[i].split(':');
                        if(_style.length==2){
                            currentStyleMap[_style[0]]=_style[1];
                        }
                    }
                    var styles=[];
                    for (var p in currentStyleMap){
                        styles.push(p + ':' +currentStyleMap[p]);
                    }
                    $(obj).attr('style',styles.join(';'));
                    break;
                }
                //add
                case 2:{

                    var _newStyle = currentStyle + ';' + style,
                        _newStyleT = _.uniq(_newStyle.split(';')).join(';');

                    domAttr.set(obj,'style',_newStyleT);
                    break;
                }
                //remove
                case 3:{
                    domAttr.set(obj,'style',utils.replaceAll(style,'',currentStyle));
                    break;
                }
                //increase
                case 4:
                //decrease
                case 5:{

                    var	numbersOnlyRegExp = new RegExp(/(\D*)(-?)(\d+)(\D*)/);

                    /**
                     * compute current style values of the object
                     * @type {{}}
                     */
                    var stylesRequested = this._toObject(style);
                    var stylesComputed = {};
                    var jInstance = $(obj);
                    ///determine from node it self
                    if(stylesRequested) {
                        for (var prop in stylesRequested) {
                            var currentStyle = this._getStyle(prop,obj,jInstance);
                            stylesComputed[prop] = currentStyle;
                            //console.log('style value for ' + prop + ' is now  at ' + currentStyle + ' ' + obj.id);
                        }
                    }

                    var _newStyleObject = {};
                    /**
                     * compute the new style
                     * @type {number}
                     */
                    for (var prop in stylesRequested){

                        var _prop = '' + prop.trim();
                        var multiplicator = 1;
                        if(stylesComputed[_prop]!=null){

                            var _valueRequested = stylesRequested[prop];
                            var _valueComputed = stylesComputed[prop];

                            var _isHex = _valueRequested.indexOf('#')!=-1;
                            var _isRGB = _valueRequested.indexOf('rgb')!=-1;
                            var _isRGBA = _valueRequested.indexOf('rgba')!=-1;

                            if( _isHex || _isRGB || _isRGBA){

                                var dColorMultiplicator = dojo.colorFromString(_valueRequested);
                                //var dColorNow = dojo.colorFromString('rgba(0.1,0.1,0.1,0.1)');
                                var dColorNow = dojo.colorFromString(_valueRequested);
                                var dColorComputed = dojo.colorFromString(_valueComputed);
                                var dColorNew = new Color();

                                _.each(["r", "g", "b", "a"], function(x){
                                    dColorNew[x] = Math.min(dColorComputed[x] + dColorMultiplicator[x], x=="a" ? 1 : 255);
                                });

                                console.log('color computed ' + dColorComputed.toRgba() + ' color requested: ' + dColorNow.toRgba() +   ' | multiplicator color = ' + dColorMultiplicator.toRgba() +  ' is then = ' + dColorNew.toRgba());

                                var _valueOut = '';
                                if(_isHex){
                                    _valueOut = dColorNew.toHex();
                                }else if(_isRGB){
                                    _valueOut = dColorNew.toCss(false);
                                }else if(_isRGBA){
                                    _valueOut = dColorNew.toCss(true);
                                }
                                //var _newValue = this._changeValue(styles[prop],delta * multiplicator);
                                _newStyleObject[prop]=_valueOut;
                                domStyle.set(obj,prop, _valueOut);//update
                                //var dColorNow = dojo.colorFromString(st);
                                //var dColorMultiplicatorRGBA = dColorMultiplicator.toRgba();
                                //console.log('color ' + dColorMultiplicatorRGBA  , dColorMultiplicator);


                            }else{
                                //extract actual number :
                                var numberOnly = numbersOnlyRegExp.exec(stylesComputed[_prop]);
                                if(numberOnly && numberOnly.length>=3){
                                    var _int = parseInt(numberOnly[3]);
                                    if(_int && _int>0){
                                        multiplicator  = _int;
                                    }
                                }
                            }
                        }
                    }
                    var delta = mode == 4 ? 1 : -1;
                    //now get an object array of the styles we'd like to alter
                    var styles = this._toObject(currentStyle);
                    var inStyles = this._toObject(style);
                    if(!styles){
                        return false;
                    }
                    var _skipped = [];
                    for(var prop in styles){
                        var _prop = '' + prop.trim();
                    }

                    var newStyleString = this._toStyleString(_newStyleObject);
                    break;
                }
            }
        },
        onDomStyleChanged:function(objects,newStyle,mode){

            objects = objects || this.resolveReference(this.deserialize(this.reference));
            if(!objects){
                debug && console.warn('have no objects');
                return;
            }
            debug && console.log('change dom style to ' + newStyle + ' on ' + objects.length + ' objects');
            for (var i = 0; i < objects.length; i++) {
                var obj = objects[i];
                if(obj && obj.id && obj.id.indexOf('davinci')!=-1) {
                    continue;
                }
                this.updateObject(obj, newStyle, mode);
            }
        },
        updateObjects:function(objects,domStyleString,mode){
            objects = objects || this.resolveReference(this.deserialize(this.reference));
            this.onDomStyleChanged(objects,domStyleString,mode);
        },
        onChangeField:function(field,newValue,cis){
            this._destroy();
            if(field=='mode' && newValue!==this.mode){
                this.mode = newValue;
            }
            if(field=='value' && newValue!==this.value){
                this.onDomStyleChanged(null,newValue,this.mode);
                this.value = newValue;
            }
            if(field=='reference'){
                this.onReferenceChanged(newValue,cis);
            }
            this.inherited(arguments);
        },
        activate:function(){
            this._destroy();//you never know
        },
        deactivate:function(){
            this._destroy();
        },
        _destroy:function(){

        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Utils
        //
        /////////////////////////////////////////////////////////////////////////////////////
        _changeValue: function(value, delta){
            if(!value){
                return "";
            }
            var split = value.split(" ");
            var result="";
            for(var i=0;i<split.length;i++){
                if(i>0)
                    result+=" ";
                var bits = split[i].match(/([-\d\.]+)([a-zA-Z%]*)/);
                if(!bits){
                    result+=split[i];
                }else{
                    if(bits.length == 1){
                        result+=bits[0];
                    }else{
                        for(var z=1;z<bits.length;z++){
                            if(!isNaN(bits[z]) && bits[z]!=""){
                                result+= parseFloat(bits[z]) + delta;
                            }else{
                                result +=bits[z];
                            }
                        }
                    }
                }
            }
            return result;
        },
        /**
         * Convert Style String to an object array, eg: { color:value,.... }
         * @param styleString
         * @returns {{}}
         * @private
         */
        _toObject:function(styleString){
            if(!styleString){
                return {};
            }
            var _result = {};
            var _values = styleString.split(';');
            for (var i = 0; i < _values.length; i++) {
                var obj = _values[i];
                if(!obj || obj.length==0 || !obj.split){
                    continue;
                }
                var keyVal = obj.split(':');
                if(!keyVal || !keyVal.length){
                    continue;
                }
                _result[keyVal[0]]=keyVal[1];
            }
            return _result;
        },
        _toStyleString:function(values){
            var _values = [];
            for(var prop in values){
                _values.push( prop + ':' + values[prop]);
            }
            return _values.join(';') + ';';
        }

    };

    //package via declare
    var _class = dcl([Block,EventedMixin.dcl,Referenced.dcl],Impl);
    //static access to Impl.
    _class.Impl = Impl;
    return _class;

});
define('xblox/model/Targeted',[
    "dojo/_base/declare",
    "./Referenced"
], function(declare,Referenced){

    /**
     * Targeted provides functions to get an object through various ways
     */
    return declare('xblox.model.Targeted',[Referenced],{

    });
});
define('xblox/model/html/SetCSS',[
    "dojo/_base/declare",
    "dojo/_base/lang",
    "xblox/model/Block",
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xblox/model/Targeted',
    'xide/registry'
], function(declare,lang,Block,utils,types,EventedMixin,Targeted,registry){

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    return declare("xblox.model.html.SetCSS",[Block,EventedMixin,Targeted],{

        //method: (String)
        //  block name
        name:'Set CSS',

        file:'',

        reference:'',

        references:null,

        description:'Sets HTML Node CSS',
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        solve:function(scope,settings) {
            this.onSuccess(this,settings);
        },
        toText:function(){

            var result = this.getBlockIcon() + ' ' + this.name + ' :: ';
            if(this.event){
                result+= this.event;
            }
            return result;
        },

        //  standard call for editing
        getFields:function(){
            try {
                var fields = this.inherited(arguments) || this.getDefaultFields();
                //var _ref = this.deserialize(this.reference);


                fields.push(utils.createCI('File', types.ECIType.FILE, this.file, {
                    group: 'General',
                    dst: 'file',
                    value: this.file,
                    intermediateChanges: false,
                    acceptFolders: false,
                    acceptFiles: true,
                    encodeFilePath: false,
                    buildFullPath: true,
                    filePickerOptions: {
                        dialogTitle: 'Select CSS File',
                        filePickerMixin: {
                            beanContextName: 'CSSFilePicker',
                            persistent: false,
                            globalPanelMixin: {
                                allowLayoutCookies: false
                            }
                        },
                        configMixin: {
                            beanContextName: 'CSSFilePicker',
                            LAYOUT_PRESET: types.LAYOUT_PRESET.SINGLE,
                            PANEL_OPTIONS:{
                                ALLOW_MAIN_MENU:false
                            }
                        },
                        defaultStoreOptions: {
                            "fields": 1663,
                            "includeList": "css",
                            "excludeList": "*"
                        },
                        startPath: this.file
                    }
                }));

                /*
                 fields.push(utils.createCI('Value',types.ECIType.DOM_PROPERTIES,this.value,{
                 group:'General',
                 dst:'value',
                 value:this.value,
                 intermediateChanges:false
                 }));
                 */

                fields.push(utils.createCI('Target', types.ECIType.WIDGET_REFERENCE, this.reference, {
                    group: 'General',
                    dst: 'reference',
                    value: this.reference
                }));

            }catch(e){

            }
            return fields;
        },
        getBlockIcon:function(){
            return '<span class="fa-paint-brush"></span>';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Store
        //
        /////////////////////////////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Lifecycle
        //
        /////////////////////////////////////////////////////////////////////////////////////
        onReferenceChanged:function(newValue,cis){
            this._destroy();//unregister previous event(s)
            this.reference = newValue;
            var objects = this.resolveReference(this.deserialize(newValue));
            //this._registerEvent(this.event);

        },
        onChangeField:function(field,newValue,cis){
            if(field=='file'){
            }

            if(field=='reference'){
                this.onReferenceChanged(newValue,cis);
            }

            this.inherited(arguments);
        },
        activate:function(){
            this._destroy();//you never know
            //this._registerEvent(this.event);
        },
        deactivate:function(){
            this._destroy();
        },
        _destroy:function(){

        }



    });
});
/** @module xblox/model/Expression */
define('xblox/model/Expression',[
    "xdojo/declare",
    "xdojo/has",
    "xide/utils",
    "xblox/model/ModelBase"
    //'xdojo/has!host-node?dojo/node!tracer',
    //'xdojo/has!host-node?nxapp/utils/_console'
], function(declare,has,utils,ModelBase,tracer,_console){

    'use strict';
    var isServer = has('host-node');
    var console = typeof window !== 'undefined' ? window.console : global.console;
    if(isServer && tracer && console && console.error){
        console = _console;
    }
    var _debug = false;
    /**
     * The expression
     * @class module:xblox.model.Expression
     * @extends module:xblox/model/ModelBase
     */
    return declare("xblox.model.Expression",[ModelBase], {
        id:null,
        context:null,
        // Constants
        variableDelimiters : {
            begin : "[",
            end : "]"
        },
        blockCallDelimiters: {
            begin : "{",
            end : "}"
        },
        expressionCache:{},
        variableFuncCache:{},
        reset:function(){
            this.expressionCache ={};
            this.variableFuncCache ={};
        },
        /**
         * Replace variable calls width variable values
         * @param scope
         * @param expression
         * @param _evaluate
         * @param _escape
         * @param variableOverrides
         * @returns {*}
         */
        replaceVariables:function(scope,expression,_evaluate,_escape,variableOverrides,useVariableGetter,variableDelimiters) {
            variableDelimiters = variableDelimiters || this.variableDelimiters;

            var ocurr = this._findOcurrences( expression , variableDelimiters );
            if (ocurr) {
                for(var n = 0; n < ocurr.length; n++ )
                {
                    // Replace each variable call width the variable value
                    var oc = ocurr[n];
                    oc = oc.replace(variableDelimiters.begin,'');
                    oc = oc.replace(variableDelimiters.end,'');
                    var _var = this._getVar(scope,oc);
                    var value = null;
                    if(_var){

                        if(useVariableGetter){

                            expression = expression.replace(ocurr[n],'this.getVariable(\'' +_var.name + '\')');
                            continue;
                        }

                        value = this.getValue(_var.value);

                        if(variableOverrides && _var.name in variableOverrides){
                            value = variableOverrides[_var.name];
                        }

                        if(this.isScript(value) && _evaluate!==false){

                            try{

                                //put other variables on the stack: should be avoided
                                var _otherVariables = scope.variablesToJavascript(_var,true);
                                if(_otherVariables){
                                    value = _otherVariables + value;
                                }

                                var _parsed = (new Function("{\n" + value+ "\n}")).call(scope.context||{});
                                console.log(' parsed variable value to : ' + _parsed);

                                //wasnt a script
                                if(_parsed==='undefined' || typeof _parsed ==='undefined'){
                                    //console.log(' parsed variable to undefined : ' + _var.title + ' with value : ' + value);
                                    value = '' + _var.value;
                                }else{
                                    value = _parsed;
                                    value = "'" + value + "'";
                                }
                            }catch(e){
                                console.log(' parsed variable expression failed \n' + value,e);
                            }
                        }else{
                            if(!this.isNumber(value)){
                                if(_escape!==false) {
                                    value = "'" + value + "'";
                                }
                            }
                        }
                    }else{
                        _debug && console.log('   expression failed, no such variable :' + ocurr[n] + ' ! setting to default ' + '');
                        value = ocurr[n];
                    }

                    expression = expression.replace(ocurr[n],value);
                }
            }

            return expression;
        },
        /**
         *
         * @param scope
         * @param expression
         * @param addVariables
         * @param runCallback
         * @param errorCallback
         * @param context
         * @param variableOverrides
         * @returns {*}
         */
        parse:function(scope,expression,addVariables,runCallback,errorCallback,context,variableOverrides,args) {

            expression = this.replaceAll("''","'",expression);//weird!
            //expression = this.replaceBlockCalls(scope,expression);

            var expressionContext = context || scope.context || scope.getContext() ||{};
            var useVariableGetter  = expressionContext['getVariable'] !=null;

            //expression = utils.replaceHex(expression);

            expression = this.replaceVariables(scope,expression,null,null,variableOverrides,useVariableGetter);

            var isExpression = this.isScript(expression);

            if(!isExpression && (this.isString(expression) || this.isNumber(expression))){

                if(runCallback){
                    runCallback('Expression ' + expression + ' evaluates to ' + expression);
                }
                return expression;
            }


            if(expression.indexOf('return')==-1){
                expression = 'return ' + expression;
            }else{
                /*expression = 'return ' + expression;*/
            }

            addVariables=false;

            if(addVariables===true){
                var _otherVariables = scope.variablesToJavascript(null,expression);
                if(_otherVariables){
                    expression = _otherVariables + expression;
                    expression = this.replaceAll("''","'",expression);//weird!
                }
            }

            var parsed = this;

            try{
                expression = this.replaceAll("''","'",expression);//weird!

                var _function = this.expressionCache[expression];
                if(!_function){
                    _debug && console.log('create function ' + expression);
                    _function = new Function("{" +expression+"; }");
                    this.expressionCache[expression] = _function;
                }
                //parsed = (new Function("{" +expression+"; }")).call(this.context||{});
                parsed = _function.call(expressionContext,args);
            }catch(e){
                console.error('     invalid expression : \n' + expression, e);
                if(errorCallback){
                    errorCallback('invalid expression : \n' + expression + ': ' + e,e);
                }
                parsed='' + expression;
                return parsed;
            }

            if(parsed===true){
                _debug &&  console.log('        expression return true! : ' + expression);
            }

            if(runCallback){
                runCallback('Expression ' + expression + ' evaluates to ' + parsed);
            }
            //console.log(parsed);
            return parsed;
        },
        parseVariableO:function(scope,_var){

            var value = ''+ _var.value;
            if(_var.title==='None'){
                return '';
            }
            try{
                //put other variables on the stack;
                var _otherVariables = scope.variablesToJavascript(_var,false);
                if(_otherVariables){
                    value = _otherVariables + value;
                }
                var _function = new Function("{" + value+ "}");

                var _parsed = _function.call(this.context||{});
                if(_parsed==='undefined' || typeof _parsed ==='undefined'){
                    value = '' + _var.value;
                }else{
                    if(!this.isNumber(_parsed)){
                        value = ''+_parsed;
                        value = "'" + value + "'";
                    }else{
                        value = _parsed;
                    }

                }
            }catch(e){
                console.error('parse variable failed : ' + _var.title + "\n" + value);
            }
            return value;
        },
        parseVariable:function(scope,_var,_prefix,escape,allowCache,context,args){
            var value = ''+ _var.value;
            _prefix = _prefix || '';

                if(allowCache!==false) {
                    var _function = this.variableFuncCache[scope.id + '|' + _var.title];
                    if(!_function){
                        _function = new Function("{" + _prefix + value + "}");
                        this.variableFuncCache[scope.id + '|' + _var.title] = _function;
                    }
                }else{
                    _function = new Function("{" + _prefix + value + "}");
                }
                var _parsed = _function.apply(context || scope.context||{}, args || []);
                if(_parsed==='undefined' || typeof _parsed ==='undefined'){
                    value = '' + _var.value;
                }else{
                    if(!this.isNumber(_parsed) && escape!==false){
                        value = ''+_parsed;
                        value = "'" + value + "'";
                    }else{
                        value = _parsed;
                    }

                }
            return value;
        },
        // Replace block call with block result
        replaceBlockCalls:function(scope,expression) {

            var ocurr = this._findOcurrences( expression, this.blockCallDelimiters );

            if (ocurr) {
                for(var n = 0; n < ocurr.length; n++ )
                {
                    // Replace each block call with block result
                    var blockName = this._removeDelimiters( ocurr[n],this.blockCallDelimiters );
                    var blockResult = scope.solveBlock(blockName).join("\n");
                    expression = expression.replace(ocurr[n],blockResult);
                }
            }

            return expression;
        },


        // gets a variable from the scope using text [variableName]
        _getVar:function(scope,vartext) {

            return scope.getVariable(this._getVarName(vartext));
        },

        _getVarName:function(vartext) {

            return this._removeDelimiters(vartext,this.variableDelimiters);
        },

        _removeDelimiters:function(text,delimiters) {
            return text.replace(delimiters.begin,'')
                .replace(delimiters.end,'');
        },

        // escape regular expressions special chars
        _escapeRegExp:function(string) {

            var special = [ "[" ,"]" , "(" , ")" , "{", "}" , "*" , "+" , "." ];

            for (var n = 0; n < special.length ; n++ )
            {
                string = string.replace(special[n],"\\"+special[n]);
            }
            return string;
        },
        /**
         * Finds a term in an expression by start and end delimiters
         * @param expression
         * @param delimiters
         * @returns {*|Boolean|Array|Route|Collection|SchemaType}
         * @private
         */
        _findOcurrences:function(expression,delimiters) {

            // prepare delimiters for the regular expression
            var d = {
                begin: this._escapeRegExp(delimiters.begin),
                end:   this._escapeRegExp(delimiters.end)
            };

            // regular expression for [<content>]
            var allExceptEnd = "[^" + d.end + "]*";

            // final regular expression = find all [variables]
            var patt = d.begin + "(" + allExceptEnd + ")" + d.end;

            return expression.match( new RegExp(patt,'g') );
        }
    });
});
/** @module xblox/model/Scope **/
define('xblox/model/Scope',[
    'dcl/dcl',
    "./ModelBase",
    "./Expression",
    "xide/factory",
    "xide/utils",
    "xide/types",
    "xide/mixins/EventedMixin",
    'dojo/_base/lang'
    //'xdojo/has!host-node?dojo/node!tracer',
    //'xdojo/has!host-node?nxapp/utils/_console'
], function(dcl,ModelBase,Expression,factory,utils,types,EventedMixin,lang,tracer,_console){

    var console = typeof window !== 'undefined' ? window.console : console;
    if(tracer && tracer.error && console && console.error){
        console = _console;
    }

    function mergeNewModule(block,source) {
        for (var i in source) {
            var o = source[i];
            if (o && _.isFunction(o) /*&& lang.isFunction(target[i])*/) {
                block[i] = o;//swap
            }
        }
    }

    var debug = false;
    /**
     * The scope acts as a real scope as usual. All registered variables and blocks are excecuted in this scope only.
     * @class module:xblox/model/Scope
     */
    var Module = dcl([ModelBase,EventedMixin.dcl],{
        declaredClass: "xblox.model.Scope",
        variableStore:null,
        serviceObject:null,
        context:null,
        blockStore:null,
        /**
         *
         * @param block
         * @param url
         * @returns {*}
         */
        toFriendlyName:function(block,url){

            if(!url || !block){
                return null;
            }

            var blockScope = this,
                ctx = this.ctx,
                driver = this.driver,
                device = this.device,
                deviceManager = ctx.getDeviceManager(),
                driverManager = ctx.getDriverManager();

            if(url.indexOf('://')==-1){
                var _block = blockScope.getBlockById(url);
                if(_block){
                    return _block.name;
                }
                return url;
            }
            var parts = utils.parse_url(url);//strip scheme

            parts = utils.urlArgs(parts.host);//go on with query string
            var _device = deviceManager.getItemById(parts.device.value);
            if(_device){

                var info=deviceManager.toDeviceControlInfo(_device);
                driver = driverManager.getDriverById(info.driverId);
                var driverInstance = _device.driverInstance;
                if(driverInstance || driver) {
                    blockScope = driver.blockScope ? driver.blockScope : driverInstance ? driverInstance.blockScope : blockScope;
                    block = blockScope.getStore().getSync(parts.block.value);
                    if(block){
                        return info.title + '/' + block.name;
                    }else if(driverInstance && driverInstance.blockScope){
                        block = driverInstance.blockScope.getBlock(parts.block.value);
                        if(block){
                            return info.title + '/' + block.name;
                        }
                    }
                }
            }
            return url;
        },
        getContext:function(){
            return this.instance;
        },
        toString:function(){

            var all = {
                blocks: null,
                variables: null
            };

            var blocks = this.blocksToJson();
            try {
                //test integrity
                dojo.fromJson(JSON.stringify(blocks));
            } catch (e) {
                debug && console.error('scope::toString : invalid data in scope');
                return;
            }
            all.blocks = blocks;

            return JSON.stringify(all, null, 2);

        },
        /**
         *
         * @param data
         */
        initWithData:function(data){

            if(data){
                this.blocksFromJson(data);
            }
            this.clearCache();
        },
        /////////////////////////////////////////////////////////
        //
        //  Service uplink related
        //
        /////////////////////////////////////////////////////////
        /** @member {Object} */
        getService:function(){
            return this.serviceObject;
        },
        /////////////////////////////////////////////////////////
        //
        //  Store related
        //
        /////////////////////////////////////////////////////////
        getStore:function(){
            return this.blockStore;
        },
        /**
         *
         */
        empty:function(){

            this.clearCache();

            var store = this.blockStore;

            var allBlocks = this.getBlocks();
            _.each(allBlocks,function(block){
                if(block) {
                    store.removeSync(block.id);
                }else{
                    debug && console.error('have no block');
                }

            });
            store.setData([]);
        },
        fromScope:function(source){
            this.empty();
            //var b0 = source.blockStore.getSync('c4f9df77-c552-72b6-447d-bb45687d473b');

            var _t = source.blocksToJson();

            this.blocksFromJson(_t);

            //var b1 = this.blockStore.getSync('c4f9df77-c552-72b6-447d-bb45687d473b');
            //console.log('merge!',[b0,b1]);
        },

        /**
         *
         */
        clearCache:function(){
            this.expressionModel.expressionCache={};
            this.expressionModel.variableFuncCache={};
        },
        /**
         * @returns {dojo/store/Memory}
         */
        getVariableStore:function(){
            return this.blockStore;
        },
        getBlockStore:function(){
            return this.blockStore;
        },
        getVariables:function(query){
            //no store,
            if(!this.blockStore){
                return [];
            }

            var all = this.blockStore.data;
            var out = [];

            if(query && query.group==='processVariables'){

                for (var i = 0; i < all.length; i++) {

                    if(all[i].group ==='processVariables'){
                        out.push(all[i]);
                    }
                }

                return out;
            }

            //query = query || {id:/\S+/};//all variables
            if(!query){


                for (var i = 0; i < all.length; i++) {

                    var block = all[i],
                        cls = block.declaredClass;

                    if(cls =='xblox.model.variables.Variable'||
                            cls == 'xcf.model.Variable'){
                        out.push(block);
                    }



                }

                /*

                var _vars = this.blockStore.query({
                    declaredClass:'xblox.model.variables.Variable'
                });

                _vars = _vars.concat(this.blockStore.query({
                    declaredClass:'xcf.model.Variable'
                }));
*/
                return out;



            }

            return this.blockStore.query(query);
        },
        loopBlock:function(block,settings){

            if(block && block.interval > 0 && block.enabled){

                var thiz=this;

                if(block._loop){
                    clearTimeout(block._loop);
                }

                block._loop  = setInterval(function(){
                    block.solve(thiz,settings || block._lastSettings);
                    if(!block.enabled){
                        clearTimeout(block._loop);
                        block._loop=null;
                    }
                },block.interval);

            }

        },
        getEventsAsOptions:function(selected){

            var result = [];
            for(var e in types.EVENTS){
                var label = types.EVENTS[e];

                var item = {
                    label:label,
                    value:types.EVENTS[e]
                };

                /*if(selected===types.EVENTS[e]){
                    item.selected=true;
                }*/

                result.push(item);
            }


            result = result.concat([{label:"onclick", value:"onclick"},
                {label:"ondblclick",value:"ondblclick"},
                {label:"onmousedown",value:"onmousedown"},
                {label:"onmouseup",value:"onmouseup"},
                {label:"onmouseover",value:"onmouseover"},
                {label:"onmousemove",value:"onmousemove"},
                {label:"onmouseout",value:"onmouseout"},
                {label:"onkeypress",value:"onkeypress"},
                {label:"onkeydown",value:"onkeydown"},
                {label:"onkeyup",  value:"onkeyup"},
                {label:"onfocus",  value:"onfocus"},
                {label:"onblur",  value:"onblur"},
                {label:"onchange",  value:"onchange"}]);

            //select the event we are listening to
            for (var i = 0; i < result.length; i++) {
                var obj = result[i];
                if(obj.value===selected){
                    obj.selected=true;
                    break;
                }
            }


            return result;

        },
        /**
         *
         * @returns {{}}
         */
        getVariablesAsObject:function() {

            var variables = this.getVariables();
            var result = {};
            for(var i=0; i<variables.length;i++){
                result[variables[i].title] = variables[i].value;
            }
            return result;
        },
        getVariablesAsOptions:function(){

            var variables = this.getVariables();
            var result = [];
            if(variables){

                for(var i=0; i<variables.length;i++){
                    result.push({
                        label:variables[i].label,
                        value:variables[i].variable
                    })
                }
            }

            return result;
        },
        getCommandsAsOptions:function(labelField){

            var items = this.getBlocks({
                declaredClass:'xcf.model.Command'
            });
            var result = [];
            if(items){
                for(var i=0; i<items.length;i++){
                    var item  = {};
                    item[labelField||"label"] =items[i].name;
                    item["value"] =items[i].name;
                    result.push(item);
                }
            }
            return result;
        },
        getBlocks:function(query){
            //no store,
            if(!this.blockStore){
                return [];
            }
            query = query||{id:/\S+/};//all blocks
            return this.blockStore.query(query);

        },
        //declaredClass: String (dcl internals, private!)
        /**
         *
         */
        expressionModel: new Expression(),
        /***
         * Register a variable into the scope
         *
         * The variable title is unique within the scope
         *
         * @param variable  =>  xblox.model.Variable
         */
        registerVariable:function(variable) {
            this.variables[variable.title] = variable;
            if(this.blockStore){
                this.blockStore.putSync(variable);
            }
        },
        /***
         * Returns a variable from the scope
         *
         * @param title => variable title
         * @return variable
         */
        getVariable:function(title) {
            //return this.variables[title];

            var _variables = this.getVariables();
            var _var = null;
            for (var i = 0; i < _variables.length; i++) {
                var obj = _variables[i];
                if(obj.name === title ){
                    return obj;
                }
            }
            //console.error('couldnt find variable with name ' + title,_variables);
            return null;
        },
        /***
         * Returns a variable from the scope
         *
         * @param title => variable title
         * @return variable
         */
        getVariableById:function(id) {

            var parts = id.split('/');
            var scope = this;
            if(parts.length==2){

                var owner = scope.owner;
                if(owner && owner.hasScope){
                    if(owner.hasScope(parts[0])){
                        scope = owner.getScope(parts[0]);
                    }else{
                        console.error('have scope id but cant resolve it',this);
                    }
                }

                id = parts[1];
            }

            var _var = scope.blockStore.getSync(id);
            if(_var){
                return _var;
            }
            /*
            var _var = this.variableStore.query({title:title});
            if(_var){
                return _var[0];
            }
            console.error('couldnt find variable with name ' + title);
            */
            return null;
        },
        /***
         * Register a block into the scope
         *
         * The block name is unique within the scope
         *
         * @param block   =>    xblox.model.Block
         */
        registerBlock:function(block,publish) {
            var store = this.blockStore;
            if(store){
                var added = store.getSync(block.id);
                if(added){
                    debug && console.warn('block already in store! '+block.id,block);
                    return added;
                }



                var result = null;

                //custom add block to store function
                if(block.addToStore){
                    result = block.addToStore(store);
                }else{
                    result = store.putSync(block,publish);
                }

                return result;
            }

        },
        /***
         * Return all blocks
         *
         * @param block   =>    Array(xblox.model.Block)
         */
        allBlocks:function(block) {

            return this.getBlocks();

            var result = [];

            for(var b in this.blocks){
                if(this.blocks[b].id!=null){
                    result.push(this.blocks[b]);
                }
            }
            return result;
        },
        /**
         * Returns whether there is any block belongs to a given group
         * @param group {String}
         * @returns {boolean}
         */
        hasGroup:function(group){

            var all = this.allGroups();
            for (var i = 0; i < all.length; i++) {
                var obj = all[i];
                if (obj === group) {
                    return true;
                }
            }
            return false;
        },
        /**
         * Return all block groups
         */
        allGroups:function(){

            var result = [];
            var all = this.allBlocks();

            var _has = function(what){
                for (var i = 0; i < result.length; i++) {
                    if(result[i]===what){
                        return true;
                    }
                }
                return false;
            };


            for (var i = 0; i < all.length; i++) {
                var obj = all[i];

                if(obj.parentId){
                    continue;
                }

                if(obj.group){
                    if(!_has(obj.group)){
                        result.push(obj.group);
                    }
                }else{
                    if(!_has('No Group')){
                        result.push('No Group');
                    }
                }
            }

            return result;
        },
        /**
         * Serializes all variables
         * @returns {Array}
         */
        variablesToJson:function(){
            var result = [];
            var data = this.variableStore ? this.getVariables() : this.variables;
            for(var e in data){
                var variable = data[e];
                if(variable.serializeMe===false){
                    continue;
                }
                if(variable.keys==null){
                    continue;
                }
                var varOut={
                };
                for(var prop in variable){

                    //copy all serializables over
                    if(
                        this.isString(variable[prop])||
                        this.isNumber(variable[prop])||
                        this.isBoolean(variable[prop])
                        )
                    {
                        varOut[prop]=variable[prop];
                    }
                }

                result.push(varOut);
            }
            //return JSON.stringify(result);
            //console.log('saving all variables  ' + JSON.stringify(result),result);
            return result;
        },
        isScript:function(val){
            return this.isString(val) && (
                    val.indexOf('return')!=-1||
                    val.indexOf(';')!=-1||
                    val.indexOf('[')!=-1||
                    val.indexOf('{')!=-1||
                    val.indexOf('}')!=-1
                );
        },
        /*
        parseVariable:function(_var){

            var value = ''+ _var.value;
            try{
                //put other variables on the stack;
                var _otherVariables = this.variablesToJavascript(_var,false);
                if(_otherVariables){
                    value = _otherVariables + value;
                }
                var _parsed = (new Function("{" + value+ "}")).call(this.expressionModel.context||{});
                //wasnt a script
                if(_parsed==='undefined' || typeof _parsed ==='undefined'){
                    //console.error(' parsed variable to undefined : ' + _var.title + ' with value : ' + value);
                    value = '' + _var.value;
                }else{
                    value = ''+_parsed;
                    value = "'" + value + "'";
                }
            }catch(e){
                console.error('parse variable failed : ' + )
            }
            return value;
        },*/
        /**
         * Serializes all variables
         * @returns {Array}
         */
        variablesToJavascriptEx:function(skipVariable,expression){

            var result=[];
            var data = this.variableStore ? this.getVariables() : this.variables;
            for(var i = 0 ; i  < data.length ; i++){
                var _var = data[i];
                if(_var == skipVariable){
                    continue;
                }
                var _varVal = ''+_var.value;

                //optimization
                if(skipVariable && skipVariable.value && skipVariable.value.indexOf(_var.title)==-1){
                    continue;
                }
                if(expression && expression.indexOf(_var.title)==-1){
                    continue;
                }

                if(_varVal.length==0){
                    continue;
                }
                if(!this.isScript(_varVal) && _varVal.indexOf("'")==-1){
                    _varVal = "'" + _varVal + "'";
                }
                else if(this.isScript(_varVal)){
                    _varVal = this.expressionModel.parseVariable(this,_var);
                }
                if(_varVal==="''"){
                    _varVal="'0'";
                }

                //result+="var " + _var.title + " = " + _varVal + ";";
                //result+="\n";
                result.push(_varVal);
            }

            return result;
        },
        variablesToJavascript:function(skipVariable,expression){

            var result='';
            var data = this.variableStore ? this.getVariables() : this.variables;
            for(var i = 0 ; i  < data.length ; i++){
                var _var = data[i];
                if(_var == skipVariable){
                    continue;
                }
                var _varVal = ''+_var.value;

                //optimization
                if(skipVariable && skipVariable.value && skipVariable.value.indexOf(_var.title)==-1){
                    continue;
                }
                if(expression && expression.indexOf(_var.title)==-1){
                    continue;
                }

                if(_varVal.length==0){
                    continue;
                }
                if(!this.isScript(_varVal)  && _varVal.indexOf("'")==-1){
                    _varVal = "'" + _varVal + "'";
                }
                else if(this.isScript(_varVal)){
                    //_varVal = "''";
                    _varVal = this.expressionModel.parseVariable(this,_var);
                }

                if(_varVal==="''"){
                    _varVal="'0'";
                }

                result+="var " + _var.title + " = " + _varVal + ";";
                result+="\n";
            }

            return result;
        },
        /**
         * Convert from JSON data. Creates all Variables in this scope
         * @param data
         * @returns {Array}
         */
        variablesFromJson:function(data){
            var result = [];
            for(var i = 0; i < data.length ; i++){
                var variable = data[i];
                variable['scope']  = this;
                if(!variable.declaredClass){
                    console.log('   variable has no class ');
                    continue;
                }
                var _class = utils.replaceAll('.','/',variable.declaredClass);
                var variableClassProto = require(_class);
                if(!variableClassProto){
                    console.log('couldnt resolve ' + _class);
                    continue;
                }
                result.push(new variableClassProto(variable));//looks like a leak but the instance is tracked and destroyed in this scope
            }
            return result;
        },
        regenerateIDs:function(blocks){

            var thiz=this;
            var updateChildren=function(block){
                var newId = utils.createUUID();
                var children = thiz.getBlocks({
                    parentId:block.id
                });
                if(children && children.length>0){
                    for(var i = 0 ; i < children.length ; i ++) {
                        var child = children[i];
                        child.parentId=newId;
                        updateChildren(child);
                    }
                }
                block.id=newId;
            };

            for(var i = 0 ; i < blocks.length ; i ++){
                var block=blocks[i];
                updateChildren(block);
            }
        },
        /**
         * Clone blocks
         * @param blocks
         */
        cloneBlocks2:function(blocks,forceGroup){

            var blocksJSON = this.blocksToJson(blocks);
            var tmpScope = this.owner.getScope(utils.createUUID(),null,false);
            var newBlocks = tmpScope.blocksFromJson(blocksJSON,false);
            var store = this.blockStore;
            newBlocks = tmpScope.allBlocks();

            tmpScope.regenerateIDs(newBlocks);
            blocksJSON = tmpScope.blocksToJson(newBlocks);

            if(forceGroup) {
                for (var i = 0; i < blocksJSON.length; i++) {
                    var block = blocksJSON[i];
                    if(block.parentId==null) {//groups are only needed for top level blocks
                        block.group = forceGroup;
                    }
                }
            }
            var result = [];
            newBlocks = this.blocksFromJson(blocksJSON);//add it to our scope

            _.each(newBlocks,function(block){
                result.push(store.getSync(block.id));
            });

            return result;

        },
        /**
         * Clone blocks
         * @param blocks
         */
        cloneBlocks:function(blocks){

            var blocksJSON = this.blocksToJson(blocks);
            var tmpScope = this.owner.getScope(utils.createUUID(),null,false);
            var newBlocks = tmpScope.blocksFromJson(blocksJSON,false);
            newBlocks = tmpScope.allBlocks();

            for(var i = 0 ; i < newBlocks.length ; i ++){
                var block=newBlocks[i];
                block.id = utils.createUUID();
                block.parentId=null;
            }

            blocksJSON = this.blocksToJson(newBlocks);
            this.blocksFromJson(newBlocks);//add it us
            return newBlocks;

        },
        blockToJson:function(block){


                var blockOut={

                    // this property is used to recreate the child blocks in the JSON -> blocks process
                    _containsChildrenIds: []
                };

                for(var prop in block){

                    if (prop == 'ctrArgs') {
                        continue;
                    }

                    if( typeof block[prop] !=='function' && !block.serializeField(prop)){
                        continue;
                    }

                    //copy all strings over
                    if( this.isString(block[prop])||
                        this.isNumber(block[prop])||
                        this.isBoolean(block[prop]))
                    {
                        blockOut[prop]=block[prop];
                    }


                    //flatten children to ids. Skip "parent" field

                    if (prop != 'parent') {

                        if ( this.isBlock(block[prop]) )
                        {
                            // if the field is a single block container, store the child block's id
                            blockOut[prop] = block[prop].id;

                            // register this field name as children ID container
                            blockOut._containsChildrenIds.push(prop);

                        } else if ( this.areBlocks(block[prop]))
                        {
                            // if the field is a multiple blocks container, store all the children blocks' id
                            blockOut[prop] = [];

                            for(var i = 0; i < block[prop].length ; i++){
                                blockOut[prop].push(block[prop][i].id);
                            }

                            // register this field name as children IDs container
                            blockOut._containsChildrenIds.push(prop);
                        }
                    }

                }

            return blockOut;
        },
        /**
         * Serializes all blocks to JSON data.
         * It needs a custom conversation because we're having cyclic
         * object dependencies.
         * @returns {Array}
         */
        blocksToJson:function(data){
            try{
                var result = [];
                data = (data && data.length) ? data :  (this.blockStore ? this.getBlocks() : this.blocks);

                for(var b in data){
                    var block = data[b];
                    if(block.keys==null){
                        continue;
                    }
                    if(block.serializeMe===false){
                        continue;
                    }
                    var blockOut={

                        // this property is used to recreate the child blocks in the JSON -> blocks process
                        _containsChildrenIds: []
                    };

                    for(var prop in block){

                        if (prop == 'ctrArgs') {
                            continue;
                        }

                        if( typeof block[prop] !=='function' && !block.serializeField(prop)){
                            continue;
                        }

                        //copy all strings over
                        if( this.isString(block[prop])||
                            this.isNumber(block[prop])||
                            this.isBoolean(block[prop]))
                        {
                            blockOut[prop]=block[prop];
                        }

                        if( _.isObject(block[prop]) && block.serializeObject){
                            if(block.serializeObject(prop)===true){
                                blockOut[prop]=JSON.stringify(block[prop],null,2);
                            }
                        }


                        //flatten children to ids. Skip "parent" field

                        if (prop != 'parent') {
                            if ( this.isBlock(block[prop]) )
                            {
                                // if the field is a single block container, store the child block's id
                                blockOut[prop] = block[prop].id;

                                // register this field name as children ID container
                                blockOut._containsChildrenIds.push(prop);

                            } else if ( this.areBlocks(block[prop]))
                            {
                                // if the field is a multiple blocks container, store all the children blocks' id
                                blockOut[prop] = [];

                                for(var i = 0; i < block[prop].length ; i++){
                                    blockOut[prop].push(block[prop][i].id);
                                }

                                // register this field name as children IDs container
                                blockOut._containsChildrenIds.push(prop);
                            }
                        }

                    }

                    result.push(blockOut);
                }
            }catch(e){
                console.error('from json failed : ' +e);
            }
            //return JSON.stringify(result);
           // console.log(JSON.stringify(result));
            //console.dir(result);
            return result;
        },
        _createBlockStore:function(){

            /*
            debugger;
            var blockData={
                identifier: "id",
                label: "title",
                items:[]
            };

            var blockStore = new StoreAdapter(Observable(new Memory({
                data: blockData,
                getChildren: function(parent, options){

                    if(parent.getChildren){
                        return parent.getChildren(parent);
                    }

                    // Support persisting the original query via options.originalQuery
                    // so that child levels will filter the same way as the root level
                    var op = lang.mixin({}, options && options.originalQuery || null, { parentId: parent.id });
                    var res = this.query(op, options);


                    return res;
                },
                mayHaveChildren: function(parent){
                    if(parent.mayHaveChildren){
                        return parent.mayHaveChildren(parent);
                    }
                    return parent.items!=null && parent.items.length>0;
                },
                query: function (query, options){
                    query = query || {};
                    options = options || {};

                    if (!query.parentId && !options.deep) {
                        // Default to a single-level query for root items (no parent)
                        query.parentId = undefined;
                    }
                    return this.queryEngine(query, options)(this.data);
                }

            })));

            return blockStore;
            */
        },

        blockFromJson:function(block){


            block['scope']  = this;
            if(block._containsChildrenIds==null){
                block._containsChildrenIds=[];
            }

            // Store all children references into "children"
            var children = {};
            for(var cf = 0 ; cf < block._containsChildrenIds.length ; cf ++)
            {
                var propName = block._containsChildrenIds[cf];
                children[propName] = block[propName];
                block[propName] = null;
            }
            delete block._containsChildrenIds;

            // Create the block
            if(!block.declaredClass){
                console.log('   not a class ');
                return null;
            }
            var blockClassProto=null;
            var _class=null;
            try{
                _class = utils.replaceAll('.','/',block.declaredClass);
                blockClassProto = require(_class);
            }catch(e){

                try {
                    _class = utils.replaceAll('/','.',block.declaredClass);
                    blockClassProto = require(_class);
                }catch(e) {
                    debug && console.error('couldnt resolve class ' + _class);
                }
                debug && console.error('couldnt resolve class ' + _class);

            }
            if(!blockClassProto){
                debug && console.log('couldn`t resolve ' + _class);
                return null;
            }

            var blockOut = null;
            try{
                blockOut = factory.createBlock(blockClassProto,block);
            }catch(e){
                debug && console.error('error in block creation ' , e);
                logError(e);
                return null;
            }

            // assign the children references into block._children
            blockOut._children=children;

            return blockOut;
        },
        /**
         * Convert from JSON data. Creates all blocks in this scope
         * @param data
         * @returns {Array}
         */
        blocksFromJson:function(data,check) {

            var resultSelected = [];
            var childMap = {};
            for(var i = 0; i < data.length ; i++){
                var block = data[i];
                block['scope']  = this;

                if(block._containsChildrenIds==null){
                    block._containsChildrenIds=[];
                }

                // Store all children references into "children"
                var children = {};
                for(var cf = 0 ; cf < block._containsChildrenIds.length ; cf ++)
                {
                    var propName = block._containsChildrenIds[cf];
                    children[propName] = block[propName];
                    block[propName] = null;
                }
                delete block._containsChildrenIds;


                // Create the block
                if(!block.declaredClass){
                    console.log('   not a class ');
                    continue;
                }
                var blockClassProto=null;
                var _class=null;
                try{
                    _class = utils.replaceAll('.','/',block.declaredClass);
                    blockClassProto = require(_class);
                }catch(e){
                    console.error('couldnt resolve class '+_class);

                }
                if(!blockClassProto){
                    console.log('couldnt resolve ' + _class);
                    continue;
                }

                var blockOut = null;
                try{
                    blockOut = factory.createBlock(blockClassProto,block);
                }catch(e){
                    console.error('error in block creation ' , e + ' ' + block.declaredClass);
                    logError(e);
                    continue;
                }

                // assign the children references into block._children
                blockOut._children=children;
                childMap[blockOut.id] = children;
                resultSelected.push(blockOut);


            }


            //2nd pass, update child blocks
            var allBlocks = this.allBlocks();
            for(var i = 0; i < allBlocks.length ; i++){

                var block = allBlocks[i];

                block._children = childMap[block.id];

                if(block._children) {
                    // get all the block container fields
                    for (var propName in block._children)
                    {
                        if (typeof block._children[propName] == "string")
                        {
                            // single block
                            var child = this.getBlockById( block._children[propName] );
                            if (!child) {
                                console.log('   couldnt resolve child: ' + block._children[propName],block);
                                continue;
                            }
                            block[propName] = child;
                            child.parent=block;

                            if(child.postCreate){
                                child.postCreate();
                            }

                        }
                        else if (typeof block._children[propName] == "object")
                        {
                            // multiple blocks
                            block[propName] = [];
                            for(var j = 0; j < block._children[propName].length ; j++){
                                var child = this.getBlockById(block._children[propName][j]);
                                if (!child) {
                                    console.log('   couldnt resolve child: ' + block._children[propName][j]);
                                    continue;
                                }

                                block[propName].push(child);

                                var _parent = this.getBlockById(child.parentId);
                                if(_parent){
                                    child.parent = _parent;
                                }else{
                                    console.error('child has no parent');
                                }
                            }

                        }
                    }
                    delete block._children;
                }

                if(check!==false && block.parentId!=null){
                    var parent = this.getBlockById(block.parentId);
                    if(parent==null){
                        debug && console.error('have orphan block!',block);
                        block.parentId = null;
                    }
                }
              
                    
                block.postCreate();

            }
            var result = this.allBlocks();
            //console.log('after json deserialize ' , result);
            return resultSelected;
        },
        /**
         *
         * @param block
         * @param url
         * @returns {*}
         */
        resolveBlock:function(url){

            var blockScope = this,
                ctx = this.ctx,
                driver = this.driver,
                device = this.device,
                deviceManager = ctx.getDeviceManager(),
                driverManager = ctx.getDriverManager();

            if(url.indexOf('://')==-1){
                var _block = this.getBlockById(url);
                if(_block){
                    return _block;
                }
                return url;
            }
            var parts = utils.parse_url(url);//strip scheme

            parts = utils.urlArgs(parts.host);//go on with query string
            var _device = deviceManager.getItemById(parts.device.value);
            if(_device){
                var info=deviceManager.toDeviceControlInfo(_device);
                driver = driverManager.getDriverById(info.driverId);
                var driverInstance = _device.driverInstance;
                if(driverInstance || driver) {
                    blockScope = driverInstance ? driverInstance.blockScope : driver.blockScope;
                    var block = blockScope ? blockScope.getStore().getSync(parts.block.value) : null;
                    if(block){
                        return block;
                    }
                }
            }
        },
        getBlock:function(id){
            return this.getBlockById(id);
        },
        /***
         * Returns a block from the scope
         *
         * @param name  =>  block name
         * @return block
         */
        getBlockByName:function(name) {

            if(name.indexOf('://')!==-1){
                var block = this.resolveBlock(name);
                if(block){
                    return block;
                }
            }

            var allBlocks = this.getBlocks();

            for (var i = 0; i < allBlocks.length; i++) {
                var block = allBlocks[i];
                if(block.name===name){
                    return block;
                }

            }
            var blocks = this.blockStore.query({
                name:name
            });
            return blocks && blocks.length>0? blocks[0] : null;
            /*
            for(var b in this.blocks){
                if(this.blocks[b].name===name){
                    return this.blocks[b];
                }
            }*/
        },
        /***
         * Returns a block from the scope
         *
         * @param name  =>  block name
         * @return block
         */
        getBlockById:function(id) {
            /*return this.blocks[id];*/
            return this.blockStore.getSync(id) /*|| this.variableStore.getSync(id)*/;
        },
        /**
         * Returns an array of blocks
         * @param blocks
         */
        flatten:function(blocks){

            var result = [];

            for(var b in blocks){

                var block = blocks[b];

                if(block.keys==null){
                    continue;
                }
                result.push(block);

                for(var prop in block){

                    if (prop == 'ctrArgs') {
                        continue;
                    }

                    //flatten children to ids. Skip "parent" field
                    if (prop != 'parent') {
                        if ( this.isBlock(block[prop]) )
                        {
                            // if the field is a single block container, store the child block's id
                            result.push(block[prop]);

                        } else if ( this.areBlocks(block[prop]))
                        {
                            for(var i = 0; i < block[prop].length ; i++){
                                result.push(block[prop][i]);
                            }
                        }
                    }
                }
            }
            return result;
        },
        _getSolve:function(block){

            if(block.prototype){

            }

            return block.prototype ? block.prototype.solve : block.__proto__.solve;
        },
        /***
         * Runs the block
         *
         * @param mixed
         * @returns result
         */
        solveBlock:function(mixed,settings,force,isInterface) {


            settings = settings || {
                highlight:false
            };

            var block = null;
            if(this.isString(mixed)){
                block = this.getBlockByName(mixed);
                if(!block){
                    block = this.getBlockById(mixed);
                }
            }else if(this.isObject(mixed)){
                block = mixed;
            }
            var result = null;
            if(block){
                if(settings.force !==true && block.enabled==false){
                    return null;
                }
                if(settings.force===true){
                    settings.force=false;
                }
                var _class = block.declaredClass;
                var _module = lang.getObject(utils.replaceAll('/', '.', _class)) || lang.getObject(_class);
                if(_module){
                    if(_module.prototype && _module.prototype.solve){
                        result = _module.prototype.solve.apply(block,[this,settings]);
                    }
                }else {
                    result  = block.solve(block.getScope(), settings,force,isInterface);
                    delete block.override;
                    block.override = {};
                }

            }else{
                debug && console.error('solving block failed, have no block! ' , mixed);
            }
            return result;
        },
        /***
         * Solves all the commands into [items]
         *
         * @param manager   =>  BlockManager
         * @return  list of commands to send
         */
        solve:function(scope,settings) {
            var ret='';

            for(var n = 0; n < this.items.length ; n++)
            {
                ret += this.items[n].solve(scope,settings);
            }

            return ret;
        },
        /***
         * Parses an expression
         *
         * @param expression
         * @returns {String} parsed expression
         */
        /**
         * 
         * @param expression
         * @param addVariables
         * @param variableOverrides
         * @param runCallback
         * @param errorCallback
         * @param context
         * @param args
         * @returns {*}
         */
        parseExpression:function(expression,addVariables,variableOverrides,runCallback,errorCallback,context,args) {
            return this.expressionModel.parse(this,expression,addVariables,runCallback,errorCallback,context,variableOverrides,args);
        },
        isString: function (a) {
            return typeof a == "string"
        },
        isNumber: function (a) {
            return typeof a == "number"
        },
        isBoolean: function (a) {
            return typeof a == "boolean"
        },
        isObject:function(a){
            return typeof a === 'object';
        },
        isBlock:function (a) {
            var ret = false;

            if ( ( typeof a == "object" ) && ( a!=null ) && (a.length == undefined) )
            {
                if ( a.serializeMe )
                {
                    ret = true;
                }
            }
            return ret;
        },
        areBlocks:function(a) {
            var ret = false;

            if ( ( typeof a == "object" ) && ( a!=null ) && (a.length > 0) )
            {
                if ( this.isBlock( a[0] )) {
                    ret = true;
                }
            }
            return ret;
        },
        /**
         *
         * @private
         */
        _onVariableChanged:function(evt){
            if(evt.item && this.expressionModel.variableFuncCache[evt.item.title]){
                delete this.expressionModel.variableFuncCache[evt.item.title];
            }
        },

        init:function(){

            this.subscribe(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED,this._onVariableChanged);
            var thiz = this;
            this.subscribe(types.EVENTS.ON_MODULE_RELOADED, function(evt){
                var mid = evt.module,
                    newModule = evt.newModule,
                    blocks = thiz.getBlocks(),
                    instances = blocks.filter(function(block){
                        if(block.declaredClass == mid || block.declaredClass == utils.replaceAll('/', '.', mid)){
                            return block
                        }
                        return null;
                    });

                instances && _.each(instances,function(block){
                    mergeNewModule(block,newModule.prototype);
                });
            });
        },
        /**
         *
         */
        _destroy:function(){

            var allblocks = this.allBlocks();

            for (var i = 0; i < allblocks.length; i++) {

                var obj = allblocks[i];
                if(!obj){
                    continue;
                }


                try {


                    if (obj && obj.stop) {
                        obj.stop();
                    }

                    if (obj && obj.reset) {
                        obj.reset();
                    }
                    if (obj && obj._destroy) {
                        obj._destroy();
                    }
                    if (obj && obj.destroy) {
                        obj.destroy();
                    }

                    if(obj._emit) {
                        obj._emit(types.EVENTS.ON_ITEM_REMOVED, {
                            item: obj
                        });
                    }

                }catch(e){
                    debug && console.error('Scope::_destroy: error destroying block '+e.message, obj ? (obj.id +' ' + obj.name) :'empty');
                    debug && console.trace();
                }
            }

        },
        destroy:function(){
            this._destroy();
        },

        /**
         *
         * @param source
         * @param target
         * @param before
         * @param add
         * @returns {boolean}
         */
        moveTo:function(source,target,before,add){


            /**
             * treat first the special case of adding an item
             */
            if(add){

                //remove it from the source parent and re-parent the source
                if(target.canAdd && target.canAdd()){

                    var sourceParent = this.getBlockById(source.parentId);
                    if(sourceParent){
                        sourceParent.removeBlock(source,false);
                    }
                    target.add(source,null,null);
                    return;
                }else{
                    console.error('cant reparent');
                    return false;
                }
            }


            //for root level move
            if(!target.parentId && add==false){


                //if source is part of something, we remove it
                var sourceParent = this.getBlockById(source.parentId);
                if(sourceParent && sourceParent.removeBlock){
                    sourceParent.removeBlock(source,false);
                    source.parentId=null;
                    source.group=target.group;
                }

                var itemsToBeMoved=[];
                var groupItems = this.getBlocks({
                    group:target.group
                });

                var rootLevelIndex=[];
                var store = this.getBlockStore();

                var sourceIndex = store.storage.index[source.id];
                var targetIndex = store.storage.index[target.id];
                for(var i = 0; i<groupItems.length;i++){

                    var item = groupItems[i];
                    //keep all root-level items

                    if( groupItems[i].parentId==null && //must be root
                        groupItems[i]!=source// cant be source
                        ){

                        var itemIndex = store.storage.index[item.id];
                        var add = before ? itemIndex >= targetIndex : itemIndex <= targetIndex;
                        if(add){
                            itemsToBeMoved.push(groupItems[i]);
                            rootLevelIndex.push(store.storage.index[groupItems[i].id]);
                        }
                    }
                }

                //remove them the store
                for(var j = 0; j<itemsToBeMoved.length;j++){
                    store.remove(itemsToBeMoved[j].id);
                }

                //remove source
                this.getBlockStore().remove(source.id);

                //if before, put source first
                if(before){
                    this.getBlockStore().putSync(source);
                }

                //now place all back
                for(var j = 0; j<itemsToBeMoved.length;j++){
                    store.put(itemsToBeMoved[j]);
                }

                //if after, place source back
                if(!before){
                    this.getBlockStore().putSync(source);
                }

                return true;

            //we move from root to lower item
            }else if( !source.parentId && target.parentId && add==false){
                source.group = target.group;
                if(target){

                }

            //we move from root to into root item
            }else if( !source.parentId && !target.parentId && add){

                console.error('we are adding an item into root root item');
                if(target.canAdd && target.canAdd()){
                    source.group=null;
                    target.add(source,null,null);
                }
                return true;

            // we move within the same parent
            }else if( source.parentId && target.parentId && add==false && source.parentId === target.parentId){
                console.error('we move within the same parents');
                var parent = this.getBlockById(source.parentId);
                if(!parent){
                    console.error('     couldnt find parent ');
                    return false;
                }

                var maxSteps = 20;
                var items = parent[parent._getContainer(source)];

                var cIndexSource = source.indexOf(items,source);
                var cIndexTarget = source.indexOf(items,target);
                var direction = cIndexSource > cIndexTarget ? -1 : 1;
                var distance = Math.abs(cIndexSource - ( cIndexTarget + (before ==true ? -1 : 1)));
                for(var i = 0 ; i < distance -1;  i++){
                    parent.move(source,direction);
                }
                return true;

                // we move within the different parents
            }else if( source.parentId && target.parentId && add==false && source.parentId !== target.parentId){                console.log('same parent!');

                console.error('we move within the different parents');
                //collect data

                var sourceParent = this.getBlockById(source.parentId);
                if(!sourceParent){
                    console.error('     couldnt find source parent ');
                    return false;
                }

                var targetParent = this.getBlockById(target.parentId);
                if(!targetParent){
                    console.error('     couldnt find target parent ');
                    return false;
                }


                //remove it from the source parent and re-parent the source
                if(sourceParent && sourceParent.removeBlock && targetParent.canAdd && targetParent.canAdd()){
                    sourceParent.removeBlock(source,false);
                    targetParent.add(source,null,null);
                }else{
                    console.error('cant reparent');
                    return false;
                }

                //now proceed as in the case above : same parents
                var items = targetParent[targetParent._getContainer(source)];
                if(items==null){
                    console.error('weird : target parent has no item container');
                }
                var cIndexSource = targetParent.indexOf(items,source);
                var cIndexTarget = targetParent.indexOf(items,target);
                if(!cIndexSource || !cIndexTarget){
                    console.error(' weird : invalid drop processing state, have no valid item indicies');
                    return;
                }
                var direction = cIndexSource > cIndexTarget ? -1 : 1;
                var distance = Math.abs(cIndexSource - ( cIndexTarget + (before ==true ? -1 : 1)));
                for(var i = 0 ; i < distance -1;  i++){
                    targetParent.move(source,direction);
                }
                return true;
            }

            return false;
        }

    });
    dcl.chainAfter(Module,'destroy');
    return Module;
});
define('xide/data/Model',[
	'dcl/dcl',
	'dojo/_base/declare',
	'dojo/_base/lang',
	'dojo/Deferred',
	'dojo/aspect',
	'dojo/when'
], function (dcl,declare, lang, Deferred, aspect, when) {

	function getSchemaProperty(object, key) {
		// this function will retrieve the individual property definition
		// from the schema, for the provided object and key
		var definition = object.schema[key];
		if (definition !== undefined && !(definition instanceof Property)) {
			definition = new Property(definition);
			definition._parent = object;
		}
		if (definition) {
			definition.name = key;
		}
		return definition;
	}

	function validate(object, key) {
		// this performs validation, delegating validation, and coercion
		// handling to the property definitions objects.
		var hasOwnPropertyInstance,
			property = object.hasOwnProperty('_properties') && object._properties[key];
		
		hasOwnPropertyInstance = property;

		if (!property) {
			// or, if we don't our own property object, we inherit from the schema
			property = getSchemaProperty(object, key);
			if (property && property.validate) {
				property = lang.delegate(property, {
					_parent: object,
					key: key
				});
			}
		}

		if (property && property.validate) {
			return when(property.validate(), function (isValid) {
				if (!isValid) {
					// errors, so don't perform set
					if (!hasOwnPropertyInstance) {
						// but we do need to store our property
						// instance if we don't have our own
						(object.hasOwnProperty('_properties') ?
							object._properties :
							object._properties = new Hidden())[key] = property;
					}
				}
				return isValid;
			});
		}
		return true;
	}

	function whenEach(iterator) {
		// this is responsible for collecting values from an iterator,
		// and waiting for the results if promises are returned, returning
		// a new promise represents the eventual completion of all the promises
		// this will consistently preserve a sync (non-promise) return value if all
		// sync values are provided
		var deferred;
		var remaining = 1;
		// start the iterator
		iterator(function (value, callback, key) {
			if (value && value.then) {
				// it is a promise, have to wait for it
				remaining++;
				if (!deferred) {
					// make sure we have a deferred
					deferred = new Deferred();
				}
				value.then(function (value) {
					// result received, call callback, and then indicate another item is done
					doneItem(callback(value, key));
				}).then(null, deferred.reject);
			} else {
				// not a promise, just a direct sync callback
				callback(value, key);
			}
		});
		if (deferred) {
			// if we have a deferred, decrement one more time
			doneItem();
			return deferred.promise;
		}
		function doneItem() {
			// called for each promise as it is completed
			remaining--;
			if (!remaining) {
				// all done
				deferred.resolve();
			}
		}
	}
	var slice = [].slice;

	var Model = declare('xide/data/Model',null,{
		//	summary:
		//		A base class for modelled data objects.

		//	schema: Object | dstore/Property
		//		A hash map where the key corresponds to a property definition. 
		//		This can be a string corresponding to a JavaScript
		//		primitive values (string, number, boolean), a constructor, a
		//		null (to allow any type), or a Property object with more advanced
		//		definitions.
		schema: {},

		//	additionalProperties: boolean
		//		This indicates whether properties are allowed that are not 
		//		defined in the schema.
		additionalProperties: true,

		//	_scenario: string
		//		The scenario that is used to determine which validators should
		//		apply to this model. There are two standard values for _scenario,
		//		"insert" and "update", but it can be set to any arbitrary value
		//		for more complex validation scenarios.
		_scenario: 'update',

		constructor: function (options) {
			this.init(options);
		},

		refresh:function(silent){

			var _store = this._store;
			_store && _store.refreshItem(this,silent);

		},
		getStore:function(){
			return this._store;
		},

		init: function (values) {
			// if we are being constructed, we default to the insert scenario
			this._scenario = 'insert';
			// copy in the default values
			values = this._setValues(values);

			// set any defaults
			for (var key in this.schema) {
				var definition = this.schema[key];
				if (definition && typeof definition === 'object' && 'default' in definition &&
						!values.hasOwnProperty(key)) {
					var defaultValue = definition['default'];
					values[key] = typeof defaultValue === 'function' ? defaultValue.call(this) : defaultValue;
				}
			}
			
		},

		_setValues: function (values) {
			return lang.mixin(this, values);
		},

		_getValues: function () {
			return this._values || this;
		},

		save: function (/*Object*/ options) {
			//	summary:
			//		Saves this object, calling put or add on the attached store.
			//	options.skipValidation:
			//		Normally, validation is performed to ensure that the object
			//		is not invalid before being stored. Set `skipValidation` to
			//		true to skip it.
			//	returns: any

			var object = this;
			return when((options && options.skipValidation) ? true : this.validate(), function (isValid) {
				if (!isValid) {
					throw object.createValidationError(object.errors);
				}
				var scenario = object._scenario;
				// suppress any non-date from serialization output
				object.prepareForSerialization();
				return object._store && when(object._store[scenario === 'insert' ? 'add' : 'put'](object),
						function (returned) {
					// receive any updates from the server
					object.set(returned);
					object._scenario = 'update';
					return object;
				});
			});
		},

		remove: function () {
			var store = this._store;
			return store.remove(store.getIdentity(this));
		},

		prepareForSerialization: function () {
			//	summary:
			//		This method is responsible for cleaing up any properties on the instance
			//		object to ensure it can easily be serialized (by JSON.stringify at least)
			this._scenario = undefined;
			if (this._inherited) {
				this._inherited.toJSON = toJSONHidden;
			}
		},

		createValidationError: function (errors) {
			//	summary:
			//		This is called when a save is attempted and a validation error was found.
			//		This can be overriden with locale-specific messages
			//	errors:
			//		Errors that were found in validation
			return new Error('Validation error');
		},

		property: function (/*String...*/ key, nextKey) {
			//	summary:
			//		Gets a new reactive property object, representing the present and future states
			//		of the provided property. The returned property object gives access to methods for changing,
			//		retrieving, and observing the property value, any validation errors, and property metadata.
			//	key: String...
			//		The name of the property to retrieve. Multiple key arguments can be provided
			//		nested property access.

			// create the properties object, if it doesn't exist yet
			var properties = this.hasOwnProperty('_properties') ? this._properties :
				(this._properties = new Hidden());
			var property = properties[key];
			// if it doesn't exist, create one, delegated from the schema's property definition
			// (this gives an property instance, owning the current property value and listeners,
			// while inheriting metadata from the schema's property definitions)
			if (!property) {
				property = getSchemaProperty(this, key);
				// delegate, or just create a new instance if no schema definition exists
				property = properties[key] = property ? lang.delegate(property) : new Property();
				property.name = key;
				// give it the correct initial value
				property._parent = this;
			}
			if (nextKey) {
				// go to the next property, if there are multiple
				return property.property.apply(property, slice.call(arguments, 1));
			}
			return property;
		},

		get: function (/*string*/ key) {
			// TODO: add listener parameter back in
			//	summary:
			//		Standard get() function to retrieve the current value
			//		of a property, augmented with the ability to listen
			//		for future changes

			var property, definition = this.schema[key];
			// now we need to see if there is a custom get involved, or if we can just
			// shortcut to retrieving the property value
			definition = property || this.schema[key];
			if (definition && definition.valueOf &&
					(definition.valueOf !== simplePropertyValueOf || definition.hasCustomGet)) {
				// we have custom get functionality, need to create at least a temporary property
				// instance
				property = property || (this.hasOwnProperty('_properties') && this._properties[key]);
				if (!property) {
					// no property instance, so we create a temporary one
					property = lang.delegate(getSchemaProperty(this, key), {
						name: key,
						_parent: this
					});
				}
				// let the property instance handle retrieving the value
				return property.valueOf();
			}
			// default action of just retrieving the property value
			return this._getValues()[key];
		},

		set: function (/*string*/ key, /*any?*/ value) {
            //	summary:
			//		Only allows setting keys that are defined in the schema,
			//		and remove any error conditions for the given key when
			//		its value is set.
			if (typeof key === 'object') {
				startOperation();
				try {
					for (var i in key) {
						value = key[i];
						if (key.hasOwnProperty(i) && !(value && value.toJSON === toJSONHidden)) {
							this.set(i, value);
						}
					}
				} finally {
					endOperation();
				}
				return;
			}
			var definition = this.schema[key];
			if (!definition && !this.additionalProperties) {
				// TODO: Shouldn't this throw an error instead of just giving a warning?
				return console.warn('Schema does not contain a definition for', key);
			}
			var property = this.hasOwnProperty('_properties') && this._properties[key];
			if (!property &&
					// we need a real property instance if it is an object or if we have a custom put method
					((value && typeof value === 'object') ||
						(definition && definition.put !== simplePropertyPut))) {
				property = this.property(key);
			}
			if (property) {
				// if the property instance exists, use this to do the set
				property.put(value);
			} else {
				if (definition && definition.coerce) {
					// if a schema definition exists, and has a coerce method,
					// we can use without creating a new instance
					value = definition.coerce(value);
				}
				// we can shortcut right to just setting the object property
				this._getValues()[key] = value;
				// check to see if we should do validation
				if (definition && definition.validateOnSet !== false) {
					validate(this, key);
				}
			}

			return value;
		},

		observe: function (/*string*/ key, /*function*/ listener, /*object*/ options) {
			//	summary:
			//		Registers a listener for any changes in the specified property
			//	key:
			//		The name of the property to listen to
			//	listener:
			//		Function to be called for each change
			//	options.onlyFutureUpdates
			//		If this is true, it won't call the listener for the current value,
			//		just future updates. If this is true, it also won't return
			//		a new reactive object
			return this.property(key).observe(listener, options);
		},

		validate: function (/*string[]?*/ fields) {
			//	summary:
			//		Validates the current object.
			//	fields:
			//		If provided, only the fields listed in the array will be
			//		validated.
			//	returns: boolean | dojo/promise/Promise
			//		A boolean or a promise that resolves to a boolean indicating whether
			//		or not the model is in a valid state.

			var object = this,
				isValid = true,
				errors = [],
				fieldMap;

			if (fields) {
				fieldMap = {};
				for (var i = 0; i < fields.length; i++) {
					fieldMap[i] = true;
				}
			}
			return when(whenEach(function (whenItem) {
				// iterate through the keys in the schema.
				// note that we will always validate every property, regardless of when it fails,
				// and we will execute all the validators immediately (async validators will
				// run in parallel)
				for (var key in object.schema) {
					// check to see if we are allowed to validate this key
					if (!fieldMap || (fieldMap.hasOwnProperty(key))) {
						// run validation
						whenItem(validate(object, key), function (isValid, key) {
							if (!isValid) {
								notValid(key);
							}
						}, key);
					}
				}
			}), function () {
				object.set('errors', isValid ? undefined : errors);
				// it wasn't async, so we just return the synchronous result
				return isValid;
			});
			function notValid(key) {
				// found an error, mark valid state and record the errors
				isValid = false;
				errors.push.apply(errors, object.property(key).errors);
			}
		},

		isValid: function () {
			//	summary:
			//		Returns whether or not there are currently any errors on
			//		this model due to validation failures. Note that this does
			//		not run validation but merely returns the result of any
			//		prior validation.
			//	returns: boolean

			var isValid = true,
				key;

			for (key in this.schema) {
				var property = this.hasOwnProperty('_properties') && this._properties[key];
				if (property && property.errors && property.errors.length) {
					isValid = false;
				}
			}
			return isValid;
		}
	});

	// define the start and end markers of an operation, so we can
	// fire notifications at the end of the operation, by default
	function startOperation() {
		setCallDepth++;
	}
	function endOperation() {
		// if we are ending this operation, start executing the queue
		if (setCallDepth < 2 && onEnd) {
			onEnd();
			onEnd = null;
		}
		setCallDepth--;
	}
	var setCallDepth = 0;
	var callbackQueue;
	var onEnd;
	// the default nextTurn executes at the end of the current operation
	// The intent with this function is that it could easily be replaced
	// with something like setImmediate, setTimeout, or nextTick to provide
	// next turn handling
	(Model.nextTurn = function (callback) {
		// set the callback for the end of the current operation
		onEnd = callback;
	}).atEnd = true;

	var Reactive = declare([Model], {
		//	summary:
		//		A reactive object is a data model that can contain a value,
		//		and notify listeners of changes to that value, in the future.
		observe: function (/*function*/ listener, /*object*/ options) {
			//	summary:
			//		Registers a listener for any changes in the current value
			//	listener:
			//		Function to be called for each change
			//	options.onlyFutureUpdates
			//		If this is true, it won't call the listener for the current value,
			//		just future updates. If this is true, it also won't return
			//		a new reactive object
			
			var reactive;
			if (typeof listener === 'string') {
				// a property key was provided, use the Model's method
				return this.inherited(arguments);
			}
			if (!options || !options.onlyFutureUpdates) {
				// create a new reactive to contain the results of the execution
				// of the provided function
				reactive = new Reactive();
				if (this._has()) {
					// we need to notify of the value of the present (as well as future)
					reactive.value = listener(this.valueOf());
				}
			}
			// add to the listeners
			var handle = this._addListener(function (value) {
				var result = listener(value);
				if (reactive) {
					// TODO: once we have a real notification API again, call that, instead 
					// of requesting a change
					reactive.put(result);
				}
			});
			if (reactive) {
				reactive.remove = handle.remove;
				return reactive;
			} else {
				return handle;
			}
		},

		//	validateOnSet: boolean
		//		Indicates whether or not to perform validation when properties
		//		are modified.
		//		This can provided immediate feedback and on the success
		//		or failure of a property modification. And Invalid property 
		//		values will be rejected. However, if you are
		//		using asynchronous validation, invalid property values will still
		//		be set.
		validateOnSet: false,

		//	validators: Array
		//		An array of additional validators to apply to this property
		validators: null,

		_addListener: function (listener) {
			// add a listener for the property change event
			return aspect.after(this, 'onchange', listener, true);
		},

		valueOf: function () {
			return this._get();
		},

		_get: function () {
			return this.value;
		},

		_has: function () {
			return this.hasOwnProperty('value');
		},
		setValue: function (value) {
			//	summary:
			//		This method is responsible for storing the value. This can
			//		be overriden to define a custom setter
			//	value: any
			//		The value to be stored
			//	parent: Object
			//		The parent object of this propery
			this.value = value;
		},

		put: function (/*any*/ value) {
			//	summary:
			//		Indicates a new value for this reactive object

			// notify all the listeners of this object, that the value has changed
			var oldValue = this._get();
			value = this.coerce(value);
			if (this.errors) {
				// clear any errors
				this.set('errors', undefined);
			}
			var property = this;
			// call the setter and wait for it
			startOperation();
			return when(this.setValue(value, this._parent), function (result) {
				if (result !== undefined) {
					// allow the setter to change the value
					value = result;
				}
				// notify listeners
				if (property.onchange) {
					// queue the callback
					property._queueChange(property.onchange, oldValue);
				}
				// if this was set to an object (or was an object), we need to notify.
				// update all the sub-property objects, so they can possibly notify their
				// listeners
				var key,
					hasOldObject = oldValue && typeof oldValue === 'object' && !(oldValue instanceof Array),
					hasNewObject = value && typeof value === 'object' && !(value instanceof Array);
				if (hasOldObject || hasNewObject) {
					// we will iterate through the properties recording the changes
					var changes = {};
					if (hasOldObject) {
						oldValue = oldValue._getValues ? oldValue._getValues() : oldValue;
						for (key in oldValue) {
							changes[key] = {old: oldValue[key]};
						}
					}
					if (hasNewObject) {
						value = value._getValues ? value._getValues() : value;
						for (key in value) {
							(changes[key] = changes[key] || {}).value = value[key];
						}
					}
					property._values = hasNewObject && value;
					for (key in changes) {
						// now for each change, we can notify the property object
						var change = changes[key];
						var subProperty = property._properties && property._properties[key];
						if (subProperty && subProperty.onchange) {
							// queue the callback
							subProperty._queueChange(subProperty.onchange, change.old);
						}
					}
				}
				if (property.validateOnSet) {
					property.validate();
				}
				endOperation();
			});
		},

		coerce: function (value) {
			//	summary:
			//		Given an input value, this method is responsible
			//		for converting it to the appropriate type for storing on the object.

			var type = this.type;
			if (type) {
				if (type === 'string') {
					value = '' + value;
				}
				else if (type === 'number') {
					value = +value;
				}
				else if (type === 'boolean') {
					// value && value.length check is because dijit/_FormMixin
					// returns an array for checkboxes; an array coerces to true,
					// but an empty array should be set as false
					value = (value === 'false' || value === '0' || value instanceof Array && !value.length) ?
						false : !!value;
				}
				else if (typeof type === 'function' && !(value instanceof type)) {
					/* jshint newcap: false */
					value = new type(value);
				}
			}
			return value;
		},

		addError: function (error) {
			//	summary:
			//		Add an error to the current list of validation errors
			//	error: String
			//		Error to add
			this.set('errors', (this.errors || []).concat([error]));
		},

		checkForErrors: function (value) {
			//	summary:
			//		This method can be implemented to simplify validation.
			//		This is called with the value, and this method can return
			//		an array of any errors that were found. It is recommended
			//		that you call this.inherited(arguments) to permit any
			//		other validators to perform validation
			//	value:
			//		This is the value to validate.
			var errors = [];
			if (this.type && !(typeof this.type === 'function' ? (value instanceof this.type) :
				(this.type === typeof value))) {
				errors.push(value + ' is not a ' + this.type);
			}
			
			if (this.required && !(value != null && value !== '')) {
				errors.push('required, and it was not present');
			}
			return errors;
		},

		validate: function () {
			//	summary:
			//		This method is responsible for validating this particular
			//		property instance.
			var property = this;
			var model = this._parent;
			var validators = this.validators;
			var value = this.valueOf();
			var totalErrors = [];

			return when(whenEach(function (whenItem) {
				// iterator through any validators (if we have any)
				if (validators) {
					for (var i = 0; i < validators.length; i++) {
						whenItem(validators[i].checkForErrors(value, property, model), addErrors);
					}
				}
				// check our own validation
				whenItem(property.checkForErrors(value, property, model), addErrors);
				function addErrors(errors) {
					if (errors) {
						// if we have an array of errors, add it to the total of all errors
						totalErrors.push.apply(totalErrors, errors);
					}
				}
			}), function () {
				if (totalErrors.length) {
					// errors exist
					property.set('errors', totalErrors);
					return false;
				}
				// no errors, valid value, if there were errors before, remove them
				if(property.get('errors') !== undefined){
					property.set('errors', undefined);
				}
				return true;
			});
		},
		_queueChange: function (callback, oldValue) {
			// queue up a notification callback
			if (!callback._queued) {
				// make sure we only queue up once before it is called by flagging it
				callback._queued = true;
				var reactive = this;
				// define a function for when it is called that will clear the flag
				// and provide the correct args
				var dispatch = function () {
					callback._queued = false;
					callback.call(reactive, reactive._get(), oldValue);
				};

				if (callbackQueue) {
					// we already have a waiting queue of callbacks, add our callback
					callbackQueue.push(dispatch);
				}
				if (!callbackQueue) {
					// no waiting queue, check to see if we have a custom nextTurn
					// or we are in an operation
					if (!Model.nextTurn.atEnd || setCallDepth > 0) {
						// create the queue (starting with this callback)
						callbackQueue = [dispatch];
						// define the callback executor for the next turn
						Model.nextTurn(function () {
							// pull out all the callbacks
							for (var i = 0; i < callbackQueue.length; i++) {
								// call each one
								callbackQueue[i]();
							}
							// clear it
							callbackQueue = null;
						});
					} else {
						// no set call depth, so just immediately execute
						dispatch();
					}
				}
			}
		},
		toJSON: function () {
			return this._values || this;
		}
	});
	// a function that returns a function, to stop JSON serialization of an
	// object
	function toJSONHidden() {
		return toJSONHidden;
	}
	// An object that will be hidden from JSON serialization
	var Hidden = function () {
	};
	Hidden.prototype.toJSON = toJSONHidden;

	var Property = Model.Property = declare(Reactive, {
		//	summary:
		//		A Property represents a time-varying property value on an object,
		//		along with meta-data. One can listen to changes in this value (through
		//		receive), as well as access and monitor metadata, like default values,
		//		validation information, required status, and any validation errors.

		//	value: any
		//		This represents the value of this property, which can be
		//		monitored for changes and validated

		init: function (options) {
			// handle simple definitions
			if (typeof options === 'string' || typeof options === 'function') {
				options = {type: options};
			}
			// and/or mixin any provided properties
			if (options) {
				declare.safeMixin(this, options);
			}
		},

		_get: function () {
			return this._parent._getValues()[this.name];
		},
		_has: function () {
			return this.name in this._parent._getValues();
		},
		setValue: function (value, parent) {
			parent._getValues()[this.name] = value;
		}
	});

	var simplePropertyValueOf = Property.prototype.valueOf;
	var simplePropertyPut = Property.prototype.put;

	return Model;
});
/** @module xide/data/Source **/
define('xide/data/Source',[
    'dcl/dcl',
    "dojo/_base/declare",
    'xide/utils'
], function (dcl, declare, utils) {

    var _debug = false;
    /**
     * @class module:xide/data/Source
     */
    var Implementation = {
        _references: null,
        _originReference: null,
        onReferenceUpdate: function () {
        },
        onReferenceRemoved: function () {
        },
        onReferenceDelete: function () {
        },
        updateReference: function () {
        },
        getReferences: function () {
            return this._references ? utils.pluck(this._references, 'item') : [];
        },
        addReference: function (item, settings, addSource) {

            if (!this._references) {
                this._references = [];
            }

            this._references.push({
                item: item,
                settings: settings
            });

            var thiz = this;

            if (settings && settings.onDelete) {
                if (item._store) {
                    item._store.on('delete', function (evt) {
                        if (evt.target == item) {
                            thiz._store.removeSync(thiz[thiz._store['idProperty']]);
                        }
                    })
                }
            }

            if (addSource) {
                if (item.addSource) {
                    item.addSource(this, settings);
                } else {
                    _debug && console.log('empty: ', item.command);
                }
            }
        },
        removeReference: function (Reference) {
            _debug && console.log('remove reference ' + Reference.label, Reference);
            this._references && _.each(this._references, function (ref) {
                if (ref && ref.item == Reference) {
                    this._references && this._references.remove(ref);
                }
            }, this);
        },
        updateReferences: function (args) {


            var property = args.property,
                value = args.value;

            if (!this._references) {
                this._references = [];
            }

            for (var i = 0; i < this._references.length; i++) {

                var link = this._references[i],
                    item = link.item,
                    settings = link.settings,
                    store = item._store;

                if (this._originReference == item) {
                    continue;
                }

                if (args.property && settings.properties && settings.properties[args.property]) {

                    if (store) {
                        store._ignoreChangeEvents = true;
                    }
                    try {
                        if (item.onSourceChanged) {
                            item.onSourceChanged(property, value);
                        } else {
                            item.set(property, value);
                        }

                    } catch (e) {
                        _debug && console.error('error updating reference! ' + e, e);
                    }
                    if (store) {
                        store._ignoreChangeEvents = false;
                        store.emit('update', {target: item});
                    }
                }
            }
        },
        constructor: function (properties) {
            this._references = [];
            utils.mixin(this, properties);
        },
        onItemChanged: function (args) {
            this.updateReferences(args);
        }
    };
    //package via declare
    var Module = declare('xgrid.data.Source', null, Implementation);
    Module.dcl = dcl(null, Implementation);
    Module.Implementation = Implementation;
    return Module;
});

define('xblox/model/BlockModel',[
    'dcl/dcl',
    'xdojo/declare',
    'xide/data/Model',
    'xide/data/Source'
], function(dcl,declare,Model,Source){
    /**
     * Contains provides implements functions to deal with sub blocks.
     */
    return declare('xblox.model.BlockModel',[Model,Source],{
        declaredClass:'xblox.model.BlockModel',
        icon:'fa-play',
        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren: function (parent) {
            return this.items != null && this.items.length > 0;
        },

        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren: function (parent) {
            return this.items;
        },
        getBlockIcon:function(){
            return '<span class="' +this.icon + '"></span>';
        }

    });
});
define('dojo/io-query',["./_base/lang"], function(lang){

	// module:
	//		dojo/io-query

	var backstop = {};

	return {
		// summary:
		//		This module defines query string processing functions.

		objectToQuery: function objectToQuery(/*Object*/ map){
			// summary:
			//		takes a name/value mapping object and returns a string representing
			//		a URL-encoded version of that object.
			// example:
			//		this object:
			//
			//	|	{
			//	|		blah: "blah",
			//	|		multi: [
			//	|			"thud",
			//	|			"thonk"
			//	|		]
			//	|	};
			//
			//		yields the following query string:
			//
			//	|	"blah=blah&multi=thud&multi=thonk"

			// FIXME: need to implement encodeAscii!!
			var enc = encodeURIComponent, pairs = [];
			for(var name in map){
				var value = map[name];
				if(value != backstop[name]){
					var assign = enc(name) + "=";
					if(lang.isArray(value)){
						for(var i = 0, l = value.length; i < l; ++i){
							pairs.push(assign + enc(value[i]));
						}
					}else{
						pairs.push(assign + enc(value));
					}
				}
			}
			return pairs.join("&"); // String
		},

		queryToObject: function queryToObject(/*String*/ str){
			// summary:
			//		Create an object representing a de-serialized query section of a
			//		URL. Query keys with multiple values are returned in an array.
			//
			// example:
			//		This string:
			//
			//	|		"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&"
			//
			//		results in this object structure:
			//
			//	|		{
			//	|			foo: [ "bar", "baz" ],
			//	|			thinger: " spaces =blah",
			//	|			zonk: "blarg"
			//	|		}
			//
			//		Note that spaces and other urlencoded entities are correctly
			//		handled.

        	var dec = decodeURIComponent, qp = str.split("&"), ret = {}, name, val;
			for(var i = 0, l = qp.length, item; i < l; ++i){
				item = qp[i];
				if(item.length){
					var s = item.indexOf("=");
					if(s < 0){
						name = dec(item);
						val = "";
					}else{
						name = dec(item.slice(0, s));
						val = dec(item.slice(s + 1));
					}
					if(typeof ret[name] == "string"){ // inline'd type check
						ret[name] = [ret[name]];
					}

					if(lang.isArray(ret[name])){
						ret[name].push(val);
					}else{
						ret[name] = val;
					}
				}
			}
			return ret; // Object
		}
	};
});
define('dojo/dom-form',["./_base/lang", "./dom", "./io-query", "./json"], function(lang, dom, ioq, json){
	// module:
	//		dojo/dom-form

    function setValue(/*Object*/ obj, /*String*/ name, /*String*/ value){
        // summary:
        //		For the named property in object, set the value. If a value
        //		already exists and it is a string, convert the value to be an
        //		array of values.

        // Skip it if there is no value
        if(value === null){
            return;
        }

        var val = obj[name];
        if(typeof val == "string"){ // inline'd type check
            obj[name] = [val, value];
        }else if(lang.isArray(val)){
            val.push(value);
        }else{
            obj[name] = value;
        }
    }

	var exclude = "file|submit|image|reset|button";

	var form = {
		// summary:
		//		This module defines form-processing functions.

		fieldToObject: function fieldToObject(/*DOMNode|String*/ inputNode){
			// summary:
			//		Serialize a form field to a JavaScript object.
			// description:
			//		Returns the value encoded in a form field as
			//		as a string or an array of strings. Disabled form elements
			//		and unchecked radio and checkboxes are skipped.	Multi-select
			//		elements are returned as an array of string values.
			// inputNode: DOMNode|String
			// returns: Object

			var ret = null;
			inputNode = dom.byId(inputNode);
			if(inputNode){
				var _in = inputNode.name, type = (inputNode.type || "").toLowerCase();
				if(_in && type && !inputNode.disabled){
					if(type == "radio" || type == "checkbox"){
						if(inputNode.checked){
							ret = inputNode.value;
						}
					}else if(inputNode.multiple){
						ret = [];
						var nodes = [inputNode.firstChild];
						while(nodes.length){
							for(var node = nodes.pop(); node; node = node.nextSibling){
								if(node.nodeType == 1 && node.tagName.toLowerCase() == "option"){
									if(node.selected){
										ret.push(node.value);
									}
								}else{
									if(node.nextSibling){
										nodes.push(node.nextSibling);
									}
									if(node.firstChild){
										nodes.push(node.firstChild);
									}
									break;
								}
							}
						}
					}else{
						ret = inputNode.value;
					}
				}
			}
			return ret; // Object
		},

		toObject: function formToObject(/*DOMNode|String*/ formNode){
			// summary:
			//		Serialize a form node to a JavaScript object.
			// description:
			//		Returns the values encoded in an HTML form as
			//		string properties in an object which it then returns. Disabled form
			//		elements, buttons, and other non-value form elements are skipped.
			//		Multi-select elements are returned as an array of string values.
			// formNode: DOMNode|String
			// example:
			//		This form:
			//		|	<form id="test_form">
			//		|		<input type="text" name="blah" value="blah">
			//		|		<input type="text" name="no_value" value="blah" disabled>
			//		|		<input type="button" name="no_value2" value="blah">
			//		|		<select type="select" multiple name="multi" size="5">
			//		|			<option value="blah">blah</option>
			//		|			<option value="thud" selected>thud</option>
			//		|			<option value="thonk" selected>thonk</option>
			//		|		</select>
			//		|	</form>
			//
			//		yields this object structure as the result of a call to
			//		formToObject():
			//
			//		|	{
			//		|		blah: "blah",
			//		|		multi: [
			//		|			"thud",
			//		|			"thonk"
			//		|		]
			//		|	};

			var ret = {}, elems = dom.byId(formNode).elements;
			for(var i = 0, l = elems.length; i < l; ++i){
				var item = elems[i], _in = item.name, type = (item.type || "").toLowerCase();
				if(_in && type && exclude.indexOf(type) < 0 && !item.disabled){
					setValue(ret, _in, form.fieldToObject(item));
					if(type == "image"){
						ret[_in + ".x"] = ret[_in + ".y"] = ret[_in].x = ret[_in].y = 0;
					}
				}
			}
			return ret; // Object
		},

		toQuery: function formToQuery(/*DOMNode|String*/ formNode){
			// summary:
			//		Returns a URL-encoded string representing the form passed as either a
			//		node or string ID identifying the form to serialize
			// formNode: DOMNode|String
			// returns: String

			return ioq.objectToQuery(form.toObject(formNode)); // String
		},

		toJson: function formToJson(/*DOMNode|String*/ formNode, /*Boolean?*/ prettyPrint){
			// summary:
			//		Create a serialized JSON string from a form node or string
			//		ID identifying the form to serialize
			// formNode: DOMNode|String
			// prettyPrint: Boolean?
			// returns: String

			return json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0); // String
		}
	};

    return form;
});

define('dojo/_base/Deferred',[
	"./kernel",
	"../Deferred",
	"../promise/Promise",
	"../errors/CancelError",
	"../has",
	"./lang",
	"../when"
], function(dojo, NewDeferred, Promise, CancelError, has, lang, when){
	// module:
	//		dojo/_base/Deferred

	var mutator = function(){};
	var freeze = Object.freeze || function(){};
	// A deferred provides an API for creating and resolving a promise.
	var Deferred = dojo.Deferred = function(/*Function?*/ canceller){
		// summary:
		//		Deprecated.   This module defines the legacy dojo/_base/Deferred API.
		//		New code should use dojo/Deferred instead.
		// description:
		//		The Deferred API is based on the concept of promises that provide a
		//		generic interface into the eventual completion of an asynchronous action.
		//		The motivation for promises fundamentally is about creating a
		//		separation of concerns that allows one to achieve the same type of
		//		call patterns and logical data flow in asynchronous code as can be
		//		achieved in synchronous code. Promises allows one
		//		to be able to call a function purely with arguments needed for
		//		execution, without conflating the call with concerns of whether it is
		//		sync or async. One shouldn't need to alter a call's arguments if the
		//		implementation switches from sync to async (or vice versa). By having
		//		async functions return promises, the concerns of making the call are
		//		separated from the concerns of asynchronous interaction (which are
		//		handled by the promise).
		//
		//		The Deferred is a type of promise that provides methods for fulfilling the
		//		promise with a successful result or an error. The most important method for
		//		working with Dojo's promises is the then() method, which follows the
		//		CommonJS proposed promise API. An example of using a Dojo promise:
		//
		//		|	var resultingPromise = someAsyncOperation.then(function(result){
		//		|		... handle result ...
		//		|	},
		//		|	function(error){
		//		|		... handle error ...
		//		|	});
		//
		//		The .then() call returns a new promise that represents the result of the
		//		execution of the callback. The callbacks will never affect the original promises value.
		//
		//		The Deferred instances also provide the following functions for backwards compatibility:
		//
		//		- addCallback(handler)
		//		- addErrback(handler)
		//		- callback(result)
		//		- errback(result)
		//
		//		Callbacks are allowed to return promises themselves, so
		//		you can build complicated sequences of events with ease.
		//
		//		The creator of the Deferred may specify a canceller.  The canceller
		//		is a function that will be called if Deferred.cancel is called
		//		before the Deferred fires. You can use this to implement clean
		//		aborting of an XMLHttpRequest, etc. Note that cancel will fire the
		//		deferred with a CancelledError (unless your canceller returns
		//		another kind of error), so the errbacks should be prepared to
		//		handle that error for cancellable Deferreds.
		// example:
		//	|	var deferred = new Deferred();
		//	|	setTimeout(function(){ deferred.callback({success: true}); }, 1000);
		//	|	return deferred;
		// example:
		//		Deferred objects are often used when making code asynchronous. It
		//		may be easiest to write functions in a synchronous manner and then
		//		split code using a deferred to trigger a response to a long-lived
		//		operation. For example, instead of register a callback function to
		//		denote when a rendering operation completes, the function can
		//		simply return a deferred:
		//
		//		|	// callback style:
		//		|	function renderLotsOfData(data, callback){
		//		|		var success = false
		//		|		try{
		//		|			for(var x in data){
		//		|				renderDataitem(data[x]);
		//		|			}
		//		|			success = true;
		//		|		}catch(e){ }
		//		|		if(callback){
		//		|			callback(success);
		//		|		}
		//		|	}
		//
		//		|	// using callback style
		//		|	renderLotsOfData(someDataObj, function(success){
		//		|		// handles success or failure
		//		|		if(!success){
		//		|			promptUserToRecover();
		//		|		}
		//		|	});
		//		|	// NOTE: no way to add another callback here!!
		// example:
		//		Using a Deferred doesn't simplify the sending code any, but it
		//		provides a standard interface for callers and senders alike,
		//		providing both with a simple way to service multiple callbacks for
		//		an operation and freeing both sides from worrying about details
		//		such as "did this get called already?". With Deferreds, new
		//		callbacks can be added at any time.
		//
		//		|	// Deferred style:
		//		|	function renderLotsOfData(data){
		//		|		var d = new Deferred();
		//		|		try{
		//		|			for(var x in data){
		//		|				renderDataitem(data[x]);
		//		|			}
		//		|			d.callback(true);
		//		|		}catch(e){
		//		|			d.errback(new Error("rendering failed"));
		//		|		}
		//		|		return d;
		//		|	}
		//
		//		|	// using Deferred style
		//		|	renderLotsOfData(someDataObj).then(null, function(){
		//		|		promptUserToRecover();
		//		|	});
		//		|	// NOTE: addErrback and addCallback both return the Deferred
		//		|	// again, so we could chain adding callbacks or save the
		//		|	// deferred for later should we need to be notified again.
		// example:
		//		In this example, renderLotsOfData is synchronous and so both
		//		versions are pretty artificial. Putting the data display on a
		//		timeout helps show why Deferreds rock:
		//
		//		|	// Deferred style and async func
		//		|	function renderLotsOfData(data){
		//		|		var d = new Deferred();
		//		|		setTimeout(function(){
		//		|			try{
		//		|				for(var x in data){
		//		|					renderDataitem(data[x]);
		//		|				}
		//		|				d.callback(true);
		//		|			}catch(e){
		//		|				d.errback(new Error("rendering failed"));
		//		|			}
		//		|		}, 100);
		//		|		return d;
		//		|	}
		//
		//		|	// using Deferred style
		//		|	renderLotsOfData(someDataObj).then(null, function(){
		//		|		promptUserToRecover();
		//		|	});
		//
		//		Note that the caller doesn't have to change his code at all to
		//		handle the asynchronous case.

		var result, finished, canceled, fired, isError, head, nextListener;
		var promise = (this.promise = new Promise());

		function complete(value){
			if(finished){
				throw new Error("This deferred has already been resolved");
			}
			result = value;
			finished = true;
			notify();
		}
		function notify(){
			var mutated;
			while(!mutated && nextListener){
				var listener = nextListener;
				nextListener = nextListener.next;
				if((mutated = (listener.progress == mutator))){ // assignment and check
					finished = false;
				}

				var func = (isError ? listener.error : listener.resolved);
				if(has("config-useDeferredInstrumentation")){
					if(isError && NewDeferred.instrumentRejected){
						NewDeferred.instrumentRejected(result, !!func);
					}
				}
				if(func){
					try{
						var newResult = func(result);
						if (newResult && typeof newResult.then === "function"){
							newResult.then(lang.hitch(listener.deferred, "resolve"), lang.hitch(listener.deferred, "reject"), lang.hitch(listener.deferred, "progress"));
							continue;
						}
						var unchanged = mutated && newResult === undefined;
						if(mutated && !unchanged){
							isError = newResult instanceof Error;
						}
						listener.deferred[unchanged && isError ? "reject" : "resolve"](unchanged ? result : newResult);
					}catch(e){
						listener.deferred.reject(e);
					}
				}else{
					if(isError){
						listener.deferred.reject(result);
					}else{
						listener.deferred.resolve(result);
					}
				}
			}
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fired == 0;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fired == 1;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return fired >= 0;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		// calling resolve will resolve the promise
		this.resolve = this.callback = function(value){
			// summary:
			//		Fulfills the Deferred instance successfully with the provide value
			this.fired = fired = 0;
			this.results = [value, null];
			complete(value);
		};


		// calling error will indicate that the promise failed
		this.reject = this.errback = function(error){
			// summary:
			//		Fulfills the Deferred instance as an error with the provided error
			isError = true;
			this.fired = fired = 1;
			if(has("config-useDeferredInstrumentation")){
				if(NewDeferred.instrumentRejected){
					NewDeferred.instrumentRejected(error, !!nextListener);
				}
			}
			complete(error);
			this.results = [null, error];
		};
		// call progress to provide updates on the progress on the completion of the promise
		this.progress = function(update){
			// summary:
			//		Send progress events to all listeners
			var listener = nextListener;
			while(listener){
				var progress = listener.progress;
				progress && progress(update);
				listener = listener.next;
			}
		};
		this.addCallbacks = function(callback, errback){
			// summary:
			//		Adds callback and error callback for this deferred instance.
			// callback: Function?
			//		The callback attached to this deferred object.
			// errback: Function?
			//		The error callback attached to this deferred object.
			// returns:
			//		Returns this deferred object.
			this.then(callback, errback, mutator);
			return this;	// Deferred
		};
		// provide the implementation of the promise
		promise.then = this.then = function(/*Function?*/resolvedCallback, /*Function?*/errorCallback, /*Function?*/progressCallback){
			// summary:
			//		Adds a fulfilledHandler, errorHandler, and progressHandler to be called for
			//		completion of a promise. The fulfilledHandler is called when the promise
			//		is fulfilled. The errorHandler is called when a promise fails. The
			//		progressHandler is called for progress events. All arguments are optional
			//		and non-function values are ignored. The progressHandler is not only an
			//		optional argument, but progress events are purely optional. Promise
			//		providers are not required to ever create progress events.
			//
			//		This function will return a new promise that is fulfilled when the given
			//		fulfilledHandler or errorHandler callback is finished. This allows promise
			//		operations to be chained together. The value returned from the callback
			//		handler is the fulfillment value for the returned promise. If the callback
			//		throws an error, the returned promise will be moved to failed state.
			//
			// returns:
			//		Returns a new promise that represents the result of the
			//		execution of the callback. The callbacks will never affect the original promises value.
			// example:
			//		An example of using a CommonJS compliant promise:
			//		|	asyncComputeTheAnswerToEverything().
			//		|		then(addTwo).
			//		|		then(printResult, onError);
			//		|	>44
			//
			var returnDeferred = progressCallback == mutator ? this : new Deferred(promise.cancel);
			var listener = {
				resolved: resolvedCallback,
				error: errorCallback,
				progress: progressCallback,
				deferred: returnDeferred
			};
			if(nextListener){
				head = head.next = listener;
			}
			else{
				nextListener = head = listener;
			}
			if(finished){
				notify();
			}
			return returnDeferred.promise; // Promise
		};
		var deferred = this;
		promise.cancel = this.cancel = function(){
			// summary:
			//		Cancels the asynchronous operation
			if(!finished){
				var error = canceller && canceller(deferred);
				if(!finished){
					if (!(error instanceof Error)){
						error = new CancelError(error);
					}
					error.log = false;
					deferred.reject(error);
				}
			}
			canceled = true;
		};
		freeze(promise);
	};
	lang.extend(Deferred, {
		addCallback: function(/*Function*/ callback){
			// summary:
			//		Adds successful callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			return this.addCallbacks(lang.hitch.apply(dojo, arguments));	// Deferred
		},

		addErrback: function(/*Function*/ errback){
			// summary:
			//		Adds error callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			return this.addCallbacks(null, lang.hitch.apply(dojo, arguments));	// Deferred
		},

		addBoth: function(/*Function*/ callback){
			// summary:
			//		Add handler as both successful callback and error callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			var enclosed = lang.hitch.apply(dojo, arguments);
			return this.addCallbacks(enclosed, enclosed);	// Deferred
		},
		fired: -1
	});

	Deferred.when = dojo.when = when;

	return Deferred;
});

define('dojo/errors/RequestError',['./create'], function(create){
	// module:
	//		dojo/errors/RequestError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestError", function(message, response){
		this.response = response;
	});
});

define('dojo/request/util',[
	'exports',
	'../errors/RequestError',
	'../errors/CancelError',
	'../Deferred',
	'../io-query',
	'../_base/array',
	'../_base/lang',
	'../promise/Promise'
], function(exports, RequestError, CancelError, Deferred, ioQuery, array, lang, Promise){
	exports.deepCopy = function deepCopy(target, source){
		for(var name in source){
			var tval = target[name],
				sval = source[name];
			if(tval !== sval){
				if(tval && typeof tval === 'object' && sval && typeof sval === 'object'){
					exports.deepCopy(tval, sval);
				}else{
					target[name] = sval;
				}
			}
		}
		return target;
	};

	exports.deepCreate = function deepCreate(source, properties){
		properties = properties || {};
		var target = lang.delegate(source),
			name, value;

		for(name in source){
			value = source[name];

			if(value && typeof value === 'object'){
				target[name] = exports.deepCreate(value, properties[name]);
			}
		}
		return exports.deepCopy(target, properties);
	};

	var freeze = Object.freeze || function(obj){ return obj; };
	function okHandler(response){
		return freeze(response);
	}
	function dataHandler (response) {
		return response.data !== undefined ? response.data : response.text;
	}

	exports.deferred = function deferred(response, cancel, isValid, isReady, handleResponse, last){
		var def = new Deferred(function(reason){
			cancel && cancel(def, response);

			if(!reason || !(reason instanceof RequestError) && !(reason instanceof CancelError)){
				return new CancelError('Request canceled', response);
			}
			return reason;
		});

		def.response = response;
		def.isValid = isValid;
		def.isReady = isReady;
		def.handleResponse = handleResponse;

		function errHandler(error){
			error.response = response;
			throw error;
		}
		var responsePromise = def.then(okHandler).otherwise(errHandler);

		if(exports.notify){
			responsePromise.then(
				lang.hitch(exports.notify, 'emit', 'load'),
				lang.hitch(exports.notify, 'emit', 'error')
			);
		}

		var dataPromise = responsePromise.then(dataHandler);

		// http://bugs.dojotoolkit.org/ticket/16794
		// The following works around a leak in IE9 through the
		// prototype using lang.delegate on dataPromise and
		// assigning the result a property with a reference to
		// responsePromise.
		var promise = new Promise();
		for (var prop in dataPromise) {
			if (dataPromise.hasOwnProperty(prop)) {
				promise[prop] = dataPromise[prop];
			}
		}
		promise.response = responsePromise;
		freeze(promise);
		// End leak fix


		if(last){
			def.then(function(response){
				last.call(def, response);
			}, function(error){
				last.call(def, response, error);
			});
		}

		def.promise = promise;
		def.then = promise.then;

		return def;
	};

	exports.addCommonMethods = function addCommonMethods(provider, methods){
		array.forEach(methods||['GET', 'POST', 'PUT', 'DELETE'], function(method){
			provider[(method === 'DELETE' ? 'DEL' : method).toLowerCase()] = function(url, options){
				options = lang.delegate(options||{});
				options.method = method;
				return provider(url, options);
			};
		});
	};

	exports.parseArgs = function parseArgs(url, options, skipData){
		var data = options.data,
			query = options.query;
		
		if(data && !skipData){
			if(typeof data === 'object'){
				options.data = ioQuery.objectToQuery(data);
			}
		}

		if(query){
			if(typeof query === 'object'){
				query = ioQuery.objectToQuery(query);
			}
			if(options.preventCache){
				query += (query ? '&' : '') + 'request.preventCache=' + (+(new Date));
			}
		}else if(options.preventCache){
			query = 'request.preventCache=' + (+(new Date));
		}

		if(url && query){
			url += (~url.indexOf('?') ? '&' : '?') + query;
		}

		return {
			url: url,
			options: options,
			getHeader: function(headerName){ return null; }
		};
	};

	exports.checkStatus = function(stat){
		stat = stat || 0;
		return (stat >= 200 && stat < 300) || // allow any 2XX response code
			stat === 304 ||                 // or, get it out of the cache
			stat === 1223 ||                // or, Internet Explorer mangled the status code
			!stat;                         // or, we're Titanium/browser chrome/chrome extension requesting a local file
	};
});

define('dojo/errors/RequestTimeoutError',['./create', './RequestError'], function(create, RequestError){
	// module:
	//		dojo/errors/RequestTimeoutError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestTimeoutError", null, RequestError, {
		dojoType: "timeout"
	});
});


define('dojo/request/watch',[
	'./util',
	'../errors/RequestTimeoutError',
	'../errors/CancelError',
	'../_base/array',
	'../has!host-browser?../_base/window:',
	'../has!host-browser?dom-addeventlistener?:../on:'
], function(util, RequestTimeoutError, CancelError, array, win, on){
	// avoid setting a timer per request. It degrades performance on IE
	// something fierece if we don't use unified loops.
	var _inFlightIntvl = null,
		_inFlight = [];

	function watchInFlight(){
		// summary:
		//		internal method that checks each inflight XMLHttpRequest to see
		//		if it has completed or if the timeout situation applies.

		var now = +(new Date);

		// we need manual loop because we often modify _inFlight (and therefore 'i') while iterating
		for(var i = 0, dfd; i < _inFlight.length && (dfd = _inFlight[i]); i++){
			var response = dfd.response,
				options = response.options;
			if((dfd.isCanceled && dfd.isCanceled()) || (dfd.isValid && !dfd.isValid(response))){
				_inFlight.splice(i--, 1);
				watch._onAction && watch._onAction();
			}else if(dfd.isReady && dfd.isReady(response)){
				_inFlight.splice(i--, 1);
				dfd.handleResponse(response);
				watch._onAction && watch._onAction();
			}else if(dfd.startTime){
				// did we timeout?
				if(dfd.startTime + (options.timeout || 0) < now){
					_inFlight.splice(i--, 1);
					// Cancel the request so the io module can do appropriate cleanup.
					dfd.cancel(new RequestTimeoutError('Timeout exceeded', response));
					watch._onAction && watch._onAction();
				}
			}
		}

		watch._onInFlight && watch._onInFlight(dfd);

		if(!_inFlight.length){
			clearInterval(_inFlightIntvl);
			_inFlightIntvl = null;
		}
	}

	function watch(dfd){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// response: Object
		//		The object used as the value of the request promise.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.
		if(dfd.response.options.timeout){
			dfd.startTime = +(new Date);
		}

		if(dfd.isFulfilled()){
			// bail out if the deferred is already fulfilled
			return;
		}

		_inFlight.push(dfd);
		if(!_inFlightIntvl){
			_inFlightIntvl = setInterval(watchInFlight, 50);
		}

		// handle sync requests separately from async:
		// http://bugs.dojotoolkit.org/ticket/8467
		if(dfd.response.options.sync){
			watchInFlight();
		}
	}

	watch.cancelAll = function cancelAll(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		try{
			array.forEach(_inFlight, function(dfd){
				try{
					dfd.cancel(new CancelError('All requests canceled.'));
				}catch(e){}
			});
		}catch(e){}
	};

	if(win && on && win.doc.attachEvent){
		// Automatically call cancel all io calls on unload in IE
		// http://bugs.dojotoolkit.org/ticket/2357
		on(win.global, 'unload', function(){
			watch.cancelAll();
		});
	}

	return watch;
});

define('dojo/request/handlers',[
	'../json',
	'../_base/kernel',
	'../_base/array',
	'../has',
	'../has!dom?../selector/_loader' // only included for has() qsa tests
], function(JSON, kernel, array, has){
	has.add('activex', typeof ActiveXObject !== 'undefined');
	has.add('dom-parser', function(global){
		return 'DOMParser' in global;
	});

	var handleXML;
	if(has('activex')){
		// GUIDs obtained from http://msdn.microsoft.com/en-us/library/ms757837(VS.85).aspx
		var dp = [
			'Msxml2.DOMDocument.6.0',
			'Msxml2.DOMDocument.4.0',
			'MSXML2.DOMDocument.3.0',
			'MSXML.DOMDocument' // 2.0
		];
		var lastParser;

		handleXML = function(response){
			var result = response.data;
			var text = response.text;

			if(result && has('dom-qsa2.1') && !result.querySelectorAll && has('dom-parser')){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(text, 'application/xml');
			}

			function createDocument(p) {
					try{
						var dom = new ActiveXObject(p);
						dom.async = false;
						dom.loadXML(text);
						result = dom;
						lastParser = p;
					}catch(e){ return false; }
					return true;
			}

			if(!result || !result.documentElement){
				// The creation of an ActiveX object is expensive, so we cache the
				// parser type to avoid trying all parser types each time we handle a
				// document. There is some concern that some parser types might fail
				// depending on the document being parsed. If parsing using the cached
				// parser type fails, we do the more expensive operation of finding one
				// that works for the given document.
				// https://bugs.dojotoolkit.org/ticket/15246
				if(!lastParser || !createDocument(lastParser)) {
					array.some(dp, createDocument);
				}
			}

			return result;
		};
	}

	var handleNativeResponse = function(response) {
		if(!has('native-xhr2-blob') && response.options.handleAs === 'blob' && typeof Blob !== 'undefined'){
			return new Blob([ response.xhr.response ], { type: response.xhr.getResponseHeader('Content-Type') });
		}

		return response.xhr.response;
	}

	var handlers = {
		'javascript': function(response){
			return kernel.eval(response.text || '');
		},
		'json': function(response){
			return JSON.parse(response.text || null);
		},
		'xml': handleXML,
		'blob': handleNativeResponse,
		'arraybuffer': handleNativeResponse,
		'document': handleNativeResponse
	};

	function handle(response){
		var handler = handlers[response.options.handleAs];

		response.data = handler ? handler(response) : (response.data || response.text);

		return response;
	}

	handle.register = function(name, handler){
		handlers[name] = handler;
	};

	return handle;
});

define('dojo/request/xhr',[
	'../errors/RequestError',
	'./watch',
	'./handlers',
	'./util',
	'../has'/*=====,
	'../request',
	'../_base/declare' =====*/
], function(RequestError, watch, handlers, util, has/*=====, request, declare =====*/){
	has.add('native-xhr', function(){
		// if true, the environment has a native XHR implementation
		return typeof XMLHttpRequest !== 'undefined';
	});
	has.add('dojo-force-activex-xhr', function(){
		return has('activex') && window.location.protocol === 'file:';
	});

	has.add('native-xhr2', function(){
		if(!has('native-xhr') || has('dojo-force-activex-xhr')){ return; }
		var x = new XMLHttpRequest();
		return typeof x['addEventListener'] !== 'undefined' &&
			(typeof opera === 'undefined' || typeof x['upload'] !== 'undefined');
	});

	has.add('native-formdata', function(){
		// if true, the environment has a native FormData implementation
		return typeof FormData !== 'undefined';
	});

	has.add('native-response-type', function(){
		return has('native-xhr') && typeof new XMLHttpRequest().responseType !== 'undefined';
	});

	has.add('native-xhr2-blob', function(){
		if(!has('native-response-type')){ return; }
		var x = new XMLHttpRequest();
		x.open('GET', '/', true);
		x.responseType = 'blob';
		// will not be set if unsupported
		var responseType = x.responseType;
		x.abort();
		return responseType === 'blob';
	});

	// Google Chrome doesn't support "json" response type
	// up to version 30, so it's intentionally not included here
	var nativeResponseTypes = {
		'blob': has('native-xhr2-blob') ? 'blob' : 'arraybuffer',
		'document': 'document',
		'arraybuffer': 'arraybuffer'
	};

	function handleResponse(response, error){
		var _xhr = response.xhr;
		response.status = response.xhr.status;

		try {
			// Firefox throws an error when trying to access
			// xhr.responseText if response isn't text
			response.text = _xhr.responseText;
		} catch (e) {}

		if(response.options.handleAs === 'xml'){
			response.data = _xhr.responseXML;
		}

		if(!error){
			try{
				handlers(response);
			}catch(e){
				error = e;
			}
		}
		var handleError;
		if(error){
			this.reject(error);
		}else{
			try{
				handlers(response);
			}catch(e){
				handleError = e;
			}
			if(util.checkStatus(_xhr.status)){
				if(!handleError){
					this.resolve(response);
				}else{
					this.reject(handleError);
				}
			}else{
				if(!handleError){
					error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
					this.reject(error);
				}else{
					error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status +
						' and an error in handleAs: transformation of response', response);
    				this.reject(error);
				}
			}
		}
	}

	var isValid, isReady, addListeners, cancel;
	if(has('native-xhr2')){
		// Any platform with XHR2 will only use the watch mechanism for timeout.

		isValid = function(response){
			// summary:
			//		Check to see if the request should be taken out of the watch queue
			return !this.isFulfilled();
		};
		cancel = function(dfd, response){
			// summary:
			//		Canceler for deferred
			response.xhr.abort();
		};
		addListeners = function(_xhr, dfd, response){
			// summary:
			//		Adds event listeners to the XMLHttpRequest object
			function onLoad(evt){
				dfd.handleResponse(response);
			}
			function onError(evt){
				var _xhr = evt.target;
				var error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
				dfd.handleResponse(response, error);
			}

			function onProgress(evt){
				if(evt.lengthComputable){
					response.loaded = evt.loaded;
					response.total = evt.total;
					dfd.progress(response);
				} else if(response.xhr.readyState === 3){
					response.loaded = ('loaded' in evt) ? evt.loaded : evt.position;
					dfd.progress(response);
				}
			}

			_xhr.addEventListener('load', onLoad, false);
			_xhr.addEventListener('error', onError, false);
			_xhr.addEventListener('progress', onProgress, false);

			return function(){
				_xhr.removeEventListener('load', onLoad, false);
				_xhr.removeEventListener('error', onError, false);
				_xhr.removeEventListener('progress', onProgress, false);
				_xhr = null;
			};
		};
	}else{
		isValid = function(response){
			return response.xhr.readyState; //boolean
		};
		isReady = function(response){
			return 4 === response.xhr.readyState; //boolean
		};
		cancel = function(dfd, response){
			// summary:
			//		canceller function for util.deferred call.
			var xhr = response.xhr;
			var _at = typeof xhr.abort;
			if(_at === 'function' || _at === 'object' || _at === 'unknown'){
				xhr.abort();
			}
		};
	}

	function getHeader(headerName){
		return this.xhr.getResponseHeader(headerName);
	}

	var undefined,
		defaultOptions = {
			data: null,
			query: null,
			sync: false,
			method: 'GET'
		};
	function xhr(url, options, returnDeferred){
		var isFormData = has('native-formdata') && options && options.data && options.data instanceof FormData;
		var response = util.parseArgs(
			url,
			util.deepCreate(defaultOptions, options),
			isFormData
		);
		url = response.url;
		options = response.options;

		var remover,
			last = function(){
				remover && remover();
			};

		//Make the Deferred object for this xhr request.
		var dfd = util.deferred(
			response,
			cancel,
			isValid,
			isReady,
			handleResponse,
			last
		);
		var _xhr = response.xhr = xhr._create();

		if(!_xhr){
			// If XHR factory somehow returns nothings,
			// cancel the deferred.
			dfd.cancel(new RequestError('XHR was not created'));
			return returnDeferred ? dfd : dfd.promise;
		}

		response.getHeader = getHeader;

		if(addListeners){
			remover = addListeners(_xhr, dfd, response);
		}

		var data = options.data,
			async = !options.sync,
			method = options.method;

		try{
			// IE6 won't let you call apply() on the native function.
			_xhr.open(method, url, async, options.user || undefined, options.password || undefined);

			if(options.withCredentials){
				_xhr.withCredentials = options.withCredentials;
			}

			if(has('native-response-type') && options.handleAs in nativeResponseTypes) {
				_xhr.responseType = nativeResponseTypes[options.handleAs];
			}

			var headers = options.headers,
				contentType = isFormData ? false : 'application/x-www-form-urlencoded';
			if(headers){
				for(var hdr in headers){
					if(hdr.toLowerCase() === 'content-type'){
						contentType = headers[hdr];
					}else if(headers[hdr]){
						//Only add header if it has a value. This allows for instance, skipping
						//insertion of X-Requested-With by specifying empty value.
						_xhr.setRequestHeader(hdr, headers[hdr]);
					}
				}
			}

			if(contentType && contentType !== false){
				_xhr.setRequestHeader('Content-Type', contentType);
			}
			if(!headers || !('X-Requested-With' in headers)){
				_xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
			}

			if(util.notify){
				util.notify.emit('send', response, dfd.promise.cancel);
			}
			_xhr.send(data);
		}catch(e){
			dfd.reject(e);
		}

		watch(dfd);
		_xhr = null;

		return returnDeferred ? dfd : dfd.promise;
	}

	/*=====
	xhr = function(url, options){
		// summary:
		//		Sends a request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.__BaseOptions = declare(request.__BaseOptions, {
		// sync: Boolean?
		//		Whether to make a synchronous request or not. Default
		//		is `false` (asynchronous).
		// data: String|Object|FormData?
		//		Data to transfer. This is ignored for GET and DELETE
		//		requests.
		// headers: Object?
		//		Headers to use for the request.
		// user: String?
		//		Username to use during the request.
		// password: String?
		//		Password to use during the request.
		// withCredentials: Boolean?
		//		For cross-site requests, whether to send credentials
		//		or not.
	});
	xhr.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request. Must be
		//		uppercase. Default is `"GET"`.
	});
	xhr.__Options = declare([xhr.__BaseOptions, xhr.__MethodOptions]);

	xhr.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.put = function(url, options){
		// summary:
		//		Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	xhr._create = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
		throw new Error('XMLHTTP not available');
	};
	if(has('native-xhr') && !has('dojo-force-activex-xhr')){
		xhr._create = function(){
			return new XMLHttpRequest();
		};
	}else if(has('activex')){
		try{
			new ActiveXObject('Msxml2.XMLHTTP');
			xhr._create = function(){
				return new ActiveXObject('Msxml2.XMLHTTP');
			};
		}catch(e){
			try{
				new ActiveXObject('Microsoft.XMLHTTP');
				xhr._create = function(){
					return new ActiveXObject('Microsoft.XMLHTTP');
				};
			}catch(e){}
		}
	}

	util.addCommonMethods(xhr);

	return xhr;
});

define('dojo/_base/xhr',[
	"./kernel",
	"./sniff",
	"require",
	"../io-query",
	/*===== "./declare", =====*/
	"../dom",
	"../dom-form",
	"./Deferred",
	"./config",
	"./json",
	"./lang",
	"./array",
	"../on",
	"../aspect",
	"../request/watch",
	"../request/xhr",
	"../request/util"
], function(dojo, has, require, ioq, /*===== declare, =====*/ dom, domForm, Deferred, config, json, lang, array, on, aspect, watch, _xhr, util){
	// module:
	//		dojo/_base/xhr

	/*=====
	dojo._xhrObj = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
	};
	=====*/
	dojo._xhrObj = _xhr._create;

	var cfg = dojo.config;

	// mix in io-query and dom-form
	dojo.objectToQuery = ioq.objectToQuery;
	dojo.queryToObject = ioq.queryToObject;
	dojo.fieldToObject = domForm.fieldToObject;
	dojo.formToObject = domForm.toObject;
	dojo.formToQuery = domForm.toQuery;
	dojo.formToJson = domForm.toJson;

	// need to block async callbacks from snatching this thread as the result
	// of an async callback might call another sync XHR, this hangs khtml forever
	// must checked by watchInFlight()

	dojo._blockAsync = false;

	// MOW: remove dojo._contentHandlers alias in 2.0
	var handlers = dojo._contentHandlers = dojo.contentHandlers = {
		// summary:
		//		A map of available XHR transport handle types. Name matches the
		//		`handleAs` attribute passed to XHR calls.
		// description:
		//		A map of available XHR transport handle types. Name matches the
		//		`handleAs` attribute passed to XHR calls. Each contentHandler is
		//		called, passing the xhr object for manipulation. The return value
		//		from the contentHandler will be passed to the `load` or `handle`
		//		functions defined in the original xhr call.
		// example:
		//		Creating a custom content-handler:
		//	|	xhr.contentHandlers.makeCaps = function(xhr){
		//	|		return xhr.responseText.toUpperCase();
		//	|	}
		//	|	// and later:
		//	|	dojo.xhrGet({
		//	|		url:"foo.txt",
		//	|		handleAs:"makeCaps",
		//	|		load: function(data){ /* data is a toUpper version of foo.txt */ }
		//	|	});

		"text": function(xhr){
			// summary:
			//		A contentHandler which simply returns the plaintext response data
			return xhr.responseText;
		},
		"json": function(xhr){
			// summary:
			//		A contentHandler which returns a JavaScript object created from the response data
			return json.fromJson(xhr.responseText || null);
		},
		"json-comment-filtered": function(xhr){
			// summary:
			//		A contentHandler which expects comment-filtered JSON.
			// description:
			//		A contentHandler which expects comment-filtered JSON.
			//		the json-comment-filtered option was implemented to prevent
			//		"JavaScript Hijacking", but it is less secure than standard JSON. Use
			//		standard JSON instead. JSON prefixing can be used to subvert hijacking.
			//
			//		Will throw a notice suggesting to use application/json mimetype, as
			//		json-commenting can introduce security issues. To decrease the chances of hijacking,
			//		use the standard `json` contentHandler, and prefix your "JSON" with: {}&&
			//
			//		use djConfig.useCommentedJson = true to turn off the notice
			if(!config.useCommentedJson){
				console.warn("Consider using the standard mimetype:application/json."
					+ " json-commenting can introduce security issues. To"
					+ " decrease the chances of hijacking, use the standard the 'json' handler and"
					+ " prefix your json with: {}&&\n"
					+ "Use djConfig.useCommentedJson=true to turn off this message.");
			}

			var value = xhr.responseText;
			var cStartIdx = value.indexOf("\/*");
			var cEndIdx = value.lastIndexOf("*\/");
			if(cStartIdx == -1 || cEndIdx == -1){
				throw new Error("JSON was not comment filtered");
			}
			return json.fromJson(value.substring(cStartIdx+2, cEndIdx));
		},
		"javascript": function(xhr){
			// summary:
			//		A contentHandler which evaluates the response data, expecting it to be valid JavaScript

			// FIXME: try Moz and IE specific eval variants?
			return dojo.eval(xhr.responseText);
		},
		"xml": function(xhr){
			// summary:
			//		A contentHandler returning an XML Document parsed from the response data
			var result = xhr.responseXML;

			if(result && has("dom-qsa2.1") && !result.querySelectorAll && has("dom-parser")){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation 
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain 
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(xhr.responseText, "application/xml");
			}

			if(has("ie")){
				if((!result || !result.documentElement)){
					//WARNING: this branch used by the xml handling in dojo.io.iframe,
					//so be sure to test dojo.io.iframe if making changes below.
					var ms = function(n){ return "MSXML" + n + ".DOMDocument"; };
					var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
					array.some(dp, function(p){
						try{
							var dom = new ActiveXObject(p);
							dom.async = false;
							dom.loadXML(xhr.responseText);
							result = dom;
						}catch(e){ return false; }
						return true;
					});
				}
			}
			return result; // DOMDocument
		},
		"json-comment-optional": function(xhr){
			// summary:
			//		A contentHandler which checks the presence of comment-filtered JSON and
			//		alternates between the `json` and `json-comment-filtered` contentHandlers.
			if(xhr.responseText && /^[^{\[]*\/\*/.test(xhr.responseText)){
				return handlers["json-comment-filtered"](xhr);
			}else{
				return handlers["json"](xhr);
			}
		}
	};

	/*=====

	// kwargs function parameter definitions.   Assigning to dojo namespace rather than making them local variables
	// because they are used by dojo/io modules too

	dojo.__IoArgs = declare(null, {
		// url: String
		//		URL to server endpoint.
		// content: Object?
		//		Contains properties with string values. These
		//		properties will be serialized as name1=value2 and
		//		passed in the request.
		// timeout: Integer?
		//		Milliseconds to wait for the response. If this time
		//		passes, the then error callbacks are called.
		// form: DOMNode?
		//		DOM node for a form. Used to extract the form values
		//		and send to the server.
		// preventCache: Boolean?
		//		Default is false. If true, then a
		//		"dojo.preventCache" parameter is sent in the request
		//		with a value that changes with each request
		//		(timestamp). Useful only with GET-type requests.
		// handleAs: String?
		//		Acceptable values depend on the type of IO
		//		transport (see specific IO calls for more information).
		// rawBody: String?
		//		Sets the raw body for an HTTP request. If this is used, then the content
		//		property is ignored. This is mostly useful for HTTP methods that have
		//		a body to their requests, like PUT or POST. This property can be used instead
		//		of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.
		// ioPublish: Boolean?
		//		Set this explicitly to false to prevent publishing of topics related to
		//		IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
		//		will be published via dojo/topic.publish() for different phases of an IO operation.
		//		See dojo/main.__IoPublish for a list of topics that are published.

		load: function(response, ioArgs){
			// summary:
			//		This function will be
			//		called on a successful HTTP response code.
	 		// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
			// response: Object
			//		The response in the format as defined with handleAs.
		},

		error: function(response, ioArgs){
			// summary:
			//		This function will
			//		be called when the request fails due to a network or server error, the url
			//		is invalid, etc. It will also be called if the load or handle callback throws an
			//		exception, unless djConfig.debugAtAllCosts is true.	 This allows deployed applications
			//		to continue to run even when a logic error happens in the callback, while making
			//		it easier to troubleshoot while in debug mode.
			// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
			// response: Object
			//		The response in the format as defined with handleAs.
		},

		handle: function(loadOrError, response, ioArgs){
			// summary:
	 		//		This function will
	 		//		be called at the end of every request, whether or not an error occurs.
			// loadOrError: String
			//		Provides a string that tells you whether this function
			//		was called because of success (load) or failure (error).
			// response: Object
			//		The response in the format as defined with handleAs.
			// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
		}
	});

	dojo.__IoCallbackArgs = declare(null, {
		// args: Object
		//		the original object argument to the IO call.
		// xhr: XMLHttpRequest
		//		For XMLHttpRequest calls only, the
		//		XMLHttpRequest object that was used for the
		//		request.
		// url: String
		//		The final URL used for the call. Many times it
		//		will be different than the original args.url
		//		value.
		// query: String
		//		For non-GET requests, the
		//		name1=value1&name2=value2 parameters sent up in
		//		the request.
		// handleAs: String
		//		The final indicator on how the response will be
		//		handled.
		// id: String
		//		For dojo/io/script calls only, the internal
		//		script ID used for the request.
		// canDelete: Boolean
		//		For dojo/io/script calls only, indicates
		//		whether the script tag that represents the
		//		request can be deleted after callbacks have
		//		been called. Used internally to know when
		//		cleanup can happen on JSONP-type requests.
		// json: Object
		//		For dojo/io/script calls only: holds the JSON
		//		response for JSONP-type requests. Used
		//		internally to hold on to the JSON responses.
		//		You should not need to access it directly --
		//		the same object should be passed to the success
		//		callbacks directly.
	});

	dojo.__IoPublish = declare(null, {
		// summary:
		//		This is a list of IO topics that can be published
		//		if djConfig.ioPublish is set to true. IO topics can be
		//		published for any Input/Output, network operation. So,
		//		dojo.xhr, dojo.io.script and dojo.io.iframe can all
		//		trigger these topics to be published.
		// start: String
		//		"/dojo/io/start" is sent when there are no outstanding IO
		//		requests, and a new IO request is started. No arguments
		//		are passed with this topic.
		// send: String
		//		"/dojo/io/send" is sent whenever a new IO request is started.
		//		It passes the dojo.Deferred for the request with the topic.
		// load: String
		//		"/dojo/io/load" is sent whenever an IO request has loaded
		//		successfully. It passes the response and the dojo.Deferred
		//		for the request with the topic.
		// error: String
		//		"/dojo/io/error" is sent whenever an IO request has errored.
		//		It passes the error and the dojo.Deferred
		//		for the request with the topic.
		// done: String
		//		"/dojo/io/done" is sent whenever an IO request has completed,
		//		either by loading or by erroring. It passes the error and
		//		the dojo.Deferred for the request with the topic.
		// stop: String
		//		"/dojo/io/stop" is sent when all outstanding IO requests have
		//		finished. No arguments are passed with this topic.
	});
	=====*/


	dojo._ioSetArgs = function(/*dojo/main.__IoArgs*/args,
			/*Function*/canceller,
			/*Function*/okHandler,
			/*Function*/errHandler){
		// summary:
		//		sets up the Deferred and ioArgs property on the Deferred so it
		//		can be used in an io call.
		// args:
		//		The args object passed into the public io call. Recognized properties on
		//		the args object are:
		// canceller:
		//		The canceller function used for the Deferred object. The function
		//		will receive one argument, the Deferred object that is related to the
		//		canceller.
		// okHandler:
		//		The first OK callback to be registered with Deferred. It has the opportunity
		//		to transform the OK response. It will receive one argument -- the Deferred
		//		object returned from this function.
		// errHandler:
		//		The first error callback to be registered with Deferred. It has the opportunity
		//		to do cleanup on an error. It will receive two arguments: error (the
		//		Error object) and dfd, the Deferred object returned from this function.

		var ioArgs = {args: args, url: args.url};

		//Get values from form if requested.
		var formObject = null;
		if(args.form){
			var form = dom.byId(args.form);
			//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
			//so use it for all. See #2844
			var actnNode = form.getAttributeNode("action");
			ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : null);
			formObject = domForm.toObject(form);
		}

		// set up the query params
		var miArgs = [{}];

		if(formObject){
			// potentially over-ride url-provided params w/ form values
			miArgs.push(formObject);
		}
		if(args.content){
			// stuff in content over-rides what's set by form
			miArgs.push(args.content);
		}
		if(args.preventCache){
			miArgs.push({"dojo.preventCache": new Date().valueOf()});
		}
		ioArgs.query = ioq.objectToQuery(lang.mixin.apply(null, miArgs));

		// .. and the real work of getting the deferred in order, etc.
		ioArgs.handleAs = args.handleAs || "text";
		var d = new Deferred(function(dfd){
			dfd.canceled = true;
			canceller && canceller(dfd);

			var err = dfd.ioArgs.error;
			if(!err){
				err = new Error("request cancelled");
				err.dojoType="cancel";
				dfd.ioArgs.error = err;
			}
			return err;
		});
		d.addCallback(okHandler);

		//Support specifying load, error and handle callback functions from the args.
		//For those callbacks, the "this" object will be the args object.
		//The callbacks will get the deferred result value as the
		//first argument and the ioArgs object as the second argument.
		var ld = args.load;
		if(ld && lang.isFunction(ld)){
			d.addCallback(function(value){
				return ld.call(args, value, ioArgs);
			});
		}
		var err = args.error;
		if(err && lang.isFunction(err)){
			d.addErrback(function(value){
				return err.call(args, value, ioArgs);
			});
		}
		var handle = args.handle;
		if(handle && lang.isFunction(handle)){
			d.addBoth(function(value){
				return handle.call(args, value, ioArgs);
			});
		}

		// Attach error handler last (not including topic publishing)
		// to catch any errors that may have been generated from load
		// or handle functions.
		d.addErrback(function(error){
			return errHandler(error, d);
		});

		//Plug in topic publishing, if dojo.publish is loaded.
		if(cfg.ioPublish && dojo.publish && ioArgs.args.ioPublish !== false){
			d.addCallbacks(
				function(res){
					dojo.publish("/dojo/io/load", [d, res]);
					return res;
				},
				function(res){
					dojo.publish("/dojo/io/error", [d, res]);
					return res;
				}
			);
			d.addBoth(function(res){
				dojo.publish("/dojo/io/done", [d, res]);
				return res;
			});
		}

		d.ioArgs = ioArgs;

		// FIXME: need to wire up the xhr object's abort method to something
		// analogous in the Deferred
		return d;
	};

	var _deferredOk = function(/*Deferred*/dfd){
		// summary:
		//		okHandler function for dojo._ioSetArgs call.

		var ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
		return ret === undefined ? null : ret;
	};
	var _deferError = function(/*Error*/error, /*Deferred*/dfd){
		// summary:
		//		errHandler function for dojo._ioSetArgs call.

		if(!dfd.ioArgs.args.failOk){
			console.error(error);
		}
		return error;
	};

	//Use a separate count for knowing if we are starting/stopping io calls.
	var _checkPubCount = function(dfd){
		if(_pubCount <= 0){
			_pubCount = 0;
			if(cfg.ioPublish && dojo.publish && (!dfd || dfd && dfd.ioArgs.args.ioPublish !== false)){
				dojo.publish("/dojo/io/stop");
			}
		}
	};

	var _pubCount = 0;
	aspect.after(watch, "_onAction", function(){
		_pubCount -= 1;
	});
	aspect.after(watch, "_onInFlight", _checkPubCount);

	dojo._ioCancelAll = watch.cancelAll;
	/*=====
	dojo._ioCancelAll = function(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		//		(xhr, script, iframe).
	};
	=====*/

	dojo._ioNotifyStart = function(/*Deferred*/dfd){
		// summary:
		//		If dojo.publish is available, publish topics
		//		about the start of a request queue and/or the
		//		the beginning of request.
		//
		//		Used by IO transports. An IO transport should
		//		call this method before making the network connection.
		if(cfg.ioPublish && dojo.publish && dfd.ioArgs.args.ioPublish !== false){
			if(!_pubCount){
				dojo.publish("/dojo/io/start");
			}
			_pubCount += 1;
			dojo.publish("/dojo/io/send", [dfd]);
		}
	};

	dojo._ioWatch = function(dfd, validCheck, ioCheck, resHandle){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.

		var args = dfd.ioArgs.options = dfd.ioArgs.args;
		lang.mixin(dfd, {
			response: dfd.ioArgs,
			isValid: function(response){
				return validCheck(dfd);
			},
			isReady: function(response){
				return ioCheck(dfd);
			},
			handleResponse: function(response){
				return resHandle(dfd);
			}
		});
		watch(dfd);

		_checkPubCount(dfd);
	};

	var _defaultContentType = "application/x-www-form-urlencoded";

	dojo._ioAddQueryToUrl = function(/*dojo.__IoCallbackArgs*/ioArgs){
		// summary:
		//		Adds query params discovered by the io deferred construction to the URL.
		//		Only use this for operations which are fundamentally GET-type operations.
		if(ioArgs.query.length){
			ioArgs.url += (ioArgs.url.indexOf("?") == -1 ? "?" : "&") + ioArgs.query;
			ioArgs.query = null;
		}
	};

	/*=====
	dojo.__XhrArgs = declare(dojo.__IoArgs, {
		// summary:
		//		In addition to the properties listed for the dojo._IoArgs type,
		//		the following properties are allowed for dojo.xhr* methods.
		// handleAs: String?
		//		Acceptable values are: text (default), json, json-comment-optional,
		//		json-comment-filtered, javascript, xml. See `dojo/_base/xhr.contentHandlers`
	 	// sync: Boolean?
		//		false is default. Indicates whether the request should
		//		be a synchronous (blocking) request.
		// headers: Object?
		//		Additional HTTP headers to send in the request.
		// failOk: Boolean?
		//		false is default. Indicates whether a request should be
		//		allowed to fail (and therefore no console error message in
		//		the event of a failure)
		// contentType: String|Boolean
		//		"application/x-www-form-urlencoded" is default. Set to false to
		//		prevent a Content-Type header from being sent, or to a string
		//		to send a different Content-Type.
	 });
	=====*/

	dojo.xhr = function(/*String*/ method, /*dojo.__XhrArgs*/ args, /*Boolean?*/ hasBody){
		// summary:
		//		Deprecated.   Use dojo/request instead.
		// description:
		//		Sends an HTTP request with the given method.
		//		See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
		//		for those HTTP methods. There are also methods for "raw" PUT and POST methods
		//		via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.
		// method:
		//		HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.
		// hasBody:
		//		If the request has an HTTP body, then pass true for hasBody.

		var rDfd;
		//Make the Deferred object for this xhr request.
		var dfd = dojo._ioSetArgs(args, function(dfd){
			rDfd && rDfd.cancel();
		}, _deferredOk, _deferError);
		var ioArgs = dfd.ioArgs;

		//Allow for specifying the HTTP body completely.
		if("postData" in args){
			ioArgs.query = args.postData;
		}else if("putData" in args){
			ioArgs.query = args.putData;
		}else if("rawBody" in args){
			ioArgs.query = args.rawBody;
		}else if((arguments.length > 2 && !hasBody) || "POST|PUT".indexOf(method.toUpperCase()) === -1){
			//Check for hasBody being passed. If no hasBody,
			//then only append query string if not a POST or PUT request.
			dojo._ioAddQueryToUrl(ioArgs);
		}

		var options = {
			method: method,
			handleAs: "text",
			timeout: args.timeout,
			withCredentials: args.withCredentials,
			ioArgs: ioArgs
		};

		if(typeof args.headers !== 'undefined'){
			options.headers = args.headers;
		}
		if(typeof args.contentType !== 'undefined'){
			if(!options.headers){
				options.headers = {};
			}
			options.headers['Content-Type'] = args.contentType;
		}
		if(typeof ioArgs.query !== 'undefined'){
			options.data = ioArgs.query;
		}
		if(typeof args.sync !== 'undefined'){
			options.sync = args.sync;
		}

		dojo._ioNotifyStart(dfd);
		try{
			rDfd = _xhr(ioArgs.url, options, true);
		}catch(e){
			// If XHR creation fails, dojo/request/xhr throws
			// When this happens, cancel the deferred
			dfd.cancel();
			return dfd;
		}

		// sync ioArgs
		dfd.ioArgs.xhr = rDfd.response.xhr;

		rDfd.then(function(){

			if(has('debug')) {
				var debugData = rDfd.response.getHeader('xapp_debug_data');
				if (debugData && typeof xappServerDebug !== 'undefined') {
					xappServerDebug(debugData, rDfd, dfd);
				}
			}
			dfd.resolve(dfd);
		}).otherwise(function(error){
			ioArgs.error = error;
			if(error.response){
				error.status = error.response.status;
				error.responseText = error.response.text;
				error.xhr = error.response.xhr;
			}
			dfd.reject(error);
		});
		return dfd; // dojo/_base/Deferred
	};

	dojo.xhrGet = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP GET request to the server.
		return dojo.xhr("GET", args); // dojo/_base/Deferred
	};

	dojo.rawXhrPost = dojo.xhrPost = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP POST request to the server. In addition to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		// postData:
		//		String. Send raw data in the body of the POST request.
		return dojo.xhr("POST", args, true); // dojo/_base/Deferred
	};

	dojo.rawXhrPut = dojo.xhrPut = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP PUT request to the server. In addition to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		// putData:
		//		String. Send raw data in the body of the PUT request.
		return dojo.xhr("PUT", args, true); // dojo/_base/Deferred
	};

	dojo.xhrDelete = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP DELETE request to the server.
		return dojo.xhr("DELETE", args); // dojo/_base/Deferred
	};

	/*
	dojo.wrapForm = function(formNode){
		// summary:
		//		A replacement for FormBind, but not implemented yet.

		// FIXME: need to think harder about what extensions to this we might
		// want. What should we allow folks to do w/ this? What events to
		// set/send?
		throw new Error("dojo.wrapForm not yet implemented");
	}
	*/

	dojo._isDocumentOk = function(x){
		return util.checkStatus(x.status);
	};

	dojo._getText = function(url){
		var result;
		dojo.xhrGet({
			url:url,
			sync:true,
			headers:{
				"X-Requested-With": null
			},
			load:function(text){
			result = text;
		}});
		return result;
	};

	// Add aliases for static functions to dojo.xhr since dojo.xhr is what's returned from this module
	lang.mixin(dojo.xhr, {
		_xhrObj: dojo._xhrObj,
		fieldToObject: domForm.fieldToObject,
		formToObject: domForm.toObject,
		objectToQuery: ioq.objectToQuery,
		formToQuery: domForm.toQuery,
		formToJson: domForm.toJson,
		queryToObject: ioq.queryToObject,
		contentHandlers: handlers,
		_ioSetArgs: dojo._ioSetArgs,
		_ioCancelAll: dojo._ioCancelAll,
		_ioNotifyStart: dojo._ioNotifyStart,
		_ioWatch: dojo._ioWatch,
		_ioAddQueryToUrl: dojo._ioAddQueryToUrl,
		_isDocumentOk: dojo._isDocumentOk,
		_getText: dojo._getText,
		get: dojo.xhrGet,
		post: dojo.xhrPost,
		put: dojo.xhrPut,
		del: dojo.xhrDelete	// because "delete" is a reserved word
	});

	return dojo.xhr;
});

/** @module xide/manager/ManagerBase **/
define('xide/manager/ManagerBase',[
    'dcl/dcl',
    'xide/mixins/EventedMixin',
    'xide/model/Base',
    'xide/utils',
    "dojo/_base/xhr",
    "dojo/_base/kernel"
], function (dcl,EventedMixin,Base,utils,xhr,dojo) {
    /**
     * @class module:xide/manager/ManagerBase
     * @augments module:dojo/Stateful
     * @augments module:xide/mixins/EventedMixin
     * @interface
     */
    var Module =dcl([Base.dcl,EventedMixin.dcl],{
        declaredClass:"xide.manager.ManagerBase",
        /**
         * @type module:xide/manager/ContextBase
         * @member ctx A pointer to a xide context
         */
        ctx: null,
        init: function () {
            this.initReload && this.initReload();
        },
        /**
         *
         * @param title
         * @param scope
         * @param parent
         * @returns {*|{name, isDir, parentId, path, beanType, scope}|{name: *, isDir: *, parentId: *, path: *, beanType: *, scope: *}}
         */
        _getText: function (url,options) {
            var result;
            options = utils.mixin({
                url: url,
                sync: true,
                handleAs: 'text',
                load: function (text) {
                    result = text;
                }
            },options);

            var def = xhr.get(options);
            if(!options.sync){
                return def;
            }
            return '' + result + '';
        }
    });

    dcl.chainAfter(Module,'init');
    return Module;
});
define('xide/data/_Base',[
    "dojo/_base/declare",
    'dstore/Memory',
    'dstore/Tree',
    'dstore/QueryResults',
    'xide/mixins/EventedMixin'
], function (declare, Memory, Tree, QueryResults,EventedMixin) {

    return declare("xide/data/_Base",EventedMixin, {
        __all:null,
        allowCache:false,
        constructor: function () {

            var store = this;
            if (store._getQuerierFactory('filter') || store._getQuerierFactory('sort')) {

                this.queryEngine = function (query, options) {
                    options = options || {};

                    var filterQuerierFactory = store._getQuerierFactory('filter');
                    var filter = filterQuerierFactory ? filterQuerierFactory(query) : passthrough;

                    var sortQuerierFactory = store._getQuerierFactory('sort');
                    var sort = passthrough;
                    if (sortQuerierFactory) {
                        sort = sortQuerierFactory(arrayUtil.map(options.sort, function (criteria) {
                            return {
                                property: criteria.attribute,
                                descending: criteria.descending
                            };
                        }));
                    }

                    var range = passthrough;
                    if (!isNaN(options.start) || !isNaN(options.count)) {
                        range = function (data) {
                            var start = options.start || 0,
                                count = options.count || Infinity;

                            var results = data.slice(start, start + count);
                            results.total = data.length;
                            return results;
                        };
                    }

                    return function (data) {
                        return range(sort(filter(data)));
                    };
                };
            }
            var objectStore = this;
            // we call notify on events to mimic the old dojo/store/Trackable
            store.on('add,update,delete', function (event) {
                var type = event.type;
                var target = event.target;
                objectStore.notify(
                    (type === 'add' || type === 'update') ? target : undefined,
                    (type === 'delete' || type === 'update') ?
                        ('id' in event ? event.id : store.getIdentity(target)) : undefined);
            });
        },
        destroy:function(){
            //this.inherited();
            this._emit('destroy',this);
        },
        notify: function () {

        },
        refreshItem:function(item){
            this.emit('update', {
                target: item
            });
        },
        query: function (query, options,allowCache) {
            /*
            if(!query && !options && this.__all && allowCache!==false && this.allowCache){
                return this.__all;
            }
            */

            // summary:
            //		Queries the store for objects. This does not alter the store, but returns a
            //		set of data from the store.
            // query: String|Object|Function
            //		The query to use for retrieving objects from the store.
            // options: dstore/api/Store.QueryOptions
            //		The optional arguments to apply to the resultset.
            // returns: dstore/api/Store.QueryResults
            //		The results of the query, extended with iterative methods.
            //
            // example:
            //		Given the following store:
            //
            //	...find all items where "prime" is true:
            //
            //	|	store.query({ prime: true }).forEach(function(object){
            //	|		// handle each object
            //	|	});
            options = options || {};
            query = query || {};

            var results = this.filter(query);
            var queryResults;

            // Apply sorting
            var sort = options.sort;
            if (sort) {
                if (Object.prototype.toString.call(sort) === '[object Array]') {
                    var sortOptions;
                    while ((sortOptions = sort.pop())) {
                        results = results.sort(sortOptions.attribute, sortOptions.descending);
                    }
                } else {
                    results = results.sort(sort);
                }
            }

            var tracked;
            var _track = false;
            if (_track && results.track && !results.tracking) {
                // if it is trackable, always track, so that observe can
                // work properly.
                results = results.track();
                tracked = true;
            }
            if ('start' in options) {
                // Apply a range
                var start = options.start || 0;
                // object stores support sync results, so try that if available
                queryResults = results[results.fetchRangeSync ? 'fetchRangeSync' : 'fetchRange']({
                    start: start,
                    end: options.count ? (start + options.count) : Infinity
                });
                queryResults.total = queryResults.totalLength;
            }
            queryResults = queryResults || new QueryResults(results[results.fetchSync ? 'fetchSync' : 'fetch']());
            queryResults.observe = function (callback, includeObjectUpdates) {
                // translate observe to event listeners
                function convertUndefined(value) {
                    if (value === undefined && tracked) {
                        return -1;
                    }
                    return value;
                }

                var addHandle = results.on('add', function (event) {
                    callback(event.target, -1, convertUndefined(event.index));
                });
                var updateHandle = results.on('update', function (event) {
                    if (includeObjectUpdates || event.previousIndex !== event.index || !isFinite(event.index)) {
                        callback(event.target, convertUndefined(event.previousIndex), convertUndefined(event.index));
                    }
                });
                var removeHandle = results.on('delete', function (event) {
                    callback(event.target, convertUndefined(event.previousIndex), -1);
                });
                var handle = {
                    remove: function () {
                        addHandle.remove();
                        updateHandle.remove();
                        removeHandle.remove();
                    }
                };
                handle.cancel = handle.remove;
                return handle;
            };
            //this.__all = queryResults;
            return queryResults;
        }
    });
});
define('xide/data/Memory',[
    "dojo/_base/declare",
	'dstore/Memory',
    'xide/data/_Base'
], function (declare, Memory,_Base) {
    return declare('xide.data.Memory',[Memory, _Base], {});
});

/** @module xide/data/TreeMemory **/
define('xide/data/TreeMemory',[
    "dojo/_base/declare",
    'xide/data/Memory',
    'dstore/Tree',
    'dojo/Deferred',
    'dstore/QueryResults'
], function (declare, Memory, Tree, Deferred, QueryResults) {

    return declare('xide.data.TreeMemory', [Memory, Tree], {
        _state: {
            filter: null
        },
        parentField: 'parentId',
        reset: function () {
            this._state.filter = null;
            this.resetQueryLog();
        },
        resetQueryLog: function () {
            this.queryLog = [];
        },
        fetchRange: function () {
            // dstore/Memory#fetchRange always uses fetchSync, which we aren't extending,
            // so we need to extend this as well.
            var results = this._fetchRange(arguments);
            return new QueryResults(results.then(function (data) {
                return data;
            }), {
                totalLength: results.then(function (data) {
                    return data.length;
                })
            });
        },
        filter: function (data) {

            try {
                var _res = this.inherited(arguments);
                this._state.filter = data;
            }catch(e){
                console.error('-error filter store ',e);
                logError(e);
            }
            return _res;
        },
        _fetchRange: function (kwArgs) {

            var deferred = new Deferred();

            var _res = this.fetchRangeSync(kwArgs);
            var thiz = this;

            if (this._state.filter) {
                //the parent query
                if (this._state && this._state.filter && this._state.filter['parent']) {

                    var _item = this.getSync(this._state.filter.parent);
                    if (_item) {
                        this.reset();
                        var _query = {};
                        if (this.getChildrenSync) {
                            _res = this.getChildrenSync(_item);
                        } else {
                            _query[this.parentField] = _item[this.idProperty];
                            _res = this.root.query(_query);
                        }
                    }
                }

                //the group query
                if (this._state && this._state.filter && this._state.filter['group']) {
                    var _items = this.getSync(this._state.filter.parent);
                    if (_item) {
                        this.reset();
                        _res = _item.items;
                    }
                }
            }
            deferred.resolve(_res);
            return deferred;
        },
        children: function (parent) {
            var filter = {};
            var all = this.root.data, out = [];
            for (var i = 0; i < all.length; i++) {
                var obj = all[i];
                if (obj[this.parentField] == parent[this.idProperty]) {
                    out.push(obj);
                }
            }
            return all;
        },
        mayHaveChildren: function (parent) {
            if (parent._mayHaveChildren === false) {
                return false;
            }
            return true;
        }
    });
});

/** @module xide/data/ObservableStore **/
define('xide/data/ObservableStore',[
    "dojo/_base/declare",
    "xide/types",
    "xide/mixins/EventedMixin"
], function (declare, types,EventedMixin) {

    var _debug = false;
    var _debugChange = false;
    /**
     * @class module:xide/data/ObservableStore
     */
    return declare('xide/data/Observable', EventedMixin, {
        _ignoreChangeEvents: true,
        observedProperties: [],
        putSync: function (item,publish) {
            this._ignoreChangeEvents = true;
            var res = this.inherited(arguments);
            this._ignoreChangeEvents = false;
            publish!==false && this.emit('added', res);
            return res;
        },
        removeSync: function (id) {
            var _item = this.getSync(id);
            _item && _item.onRemove && _item.onRemove();
            var res = this.inherited(arguments);
            return res;
        },
        postscript: function () {

            var thiz = this;
            thiz.inherited(arguments);
            if (!thiz.on) {
                return;
            }
            thiz.on('add', function (evt) {
                var _item = evt.target;
                thiz._observe(_item);
                if (!_item._store) {
                    _item._store = thiz;
                }
                _item._onCreated();
                _item.onAdd && _item.onAdd(_item);
            });
        },
        /**
         *
         * @param item
         * @param property
         * @param value
         * @param source
         * @private
         */
        _onItemChanged: function (item, property, value, source) {
            if (this._ignoreChangeEvents) {
                return;
            }

            _debug && console.log('item changed', arguments);

            var args = {
                target: item,
                property: property,
                value: value,
                source: source
            };
            this.emit('update', args);
            item.onItemChanged && item.onItemChanged(args);
        },
        _observe: function (item) {
            var thiz = this,
                props = thiz.observedProperties;

            if (item && item.observed) {
                props = props.concat(item.observed);
            }
            props && props.forEach(function (property) {
                //_debug && console.log('observe item : ' + item.command + ' for ' + property);
                item.property(property).observe(function (value) {
                    if (!thiz._ignoreChangeEvents) {
                        _debugChange && console.log('property changed: ' + property);
                        thiz._onItemChanged(item, property, value, thiz);
                    }
                });
            });
        },
        setData: function (data) {
            this.inherited(arguments);
            this._ignoreChangeEvents = true;
            data && _.each(data,this._observe, this);
            this._ignoreChangeEvents = false;
        }
    });
});
/** @module xblox/data/Store **/
define('xblox/data/Store',[
    "dojo/_base/declare",
    'xide/data/TreeMemory',
    'xide/data/ObservableStore',
    'xide/data/Model',
    'dstore/Trackable',
    'dojo/Deferred'

], function (declare, TreeMemory,ObservableStore,Model,Trackable, Deferred) {

    return declare("xblox.data.Store", [TreeMemory,Trackable,ObservableStore], {
        idProperty:'id',
        parentField:'parentId',
        filter: function (data) {

            var _res = this.inherited(arguments);
            this._state.filter= data;
            //console.log('filter ',data);
            return _res;
        },
        getChildren: function (object) {

            //console.log('getChildren ' , object);
            // summary:
            // Get a collection of the children of the provided parent object
            // object:
            // The parent object
            // returns: dstore/Store.Collection
            return this.root.filter({ parentId:this.getIdentity(object) });
        },
        __getChildren:function(parent){
            /*
            if(parent.getChildren){
                return parent.getChildren();
            }*/

            return this.inherited(arguments);
        },
        _fetchRange: function (kwArgs) {

            var deferred = new Deferred();

            var _res = this.fetchRangeSync(kwArgs);

            if(this._state.filter){

                //the parent query
                if(this._state && this._state.filter && this._state.filter['parentId']) {
                    var _item = this.getSync(this._state.filter.parentId);
                    if (_item) {
                        this.reset();
                        var _items = _item.items;

                        if(_item.getChildren){
                            _items = _item.getChildren();
                        }

                        deferred.resolve(_items);
                        _res = _items;
                    }
                }

                //the group query
                if(this._state && this._state.filter && this._state.filter['group']) {
                    var _items = this.getSync(this._state.filter.parent);
                    if (_item) {
                        this.reset();
                        _res=_item.items;
                    }
                }
            }
            deferred.resolve(_res);

            //return _res;
            return deferred;
        },
        mayHaveChildren: function(parent){
            if(parent.mayHaveChildren){
                return parent.mayHaveChildren(parent);
            }
            return parent.items!=null && parent.items.length>0;
        }
    });
});



define('xblox/manager/BlockManager',[
    'dcl/dcl',
    "dojo/_base/lang",
    'dojo/has',
    'dojo/Deferred',
    'dojo/promise/all',
    'xide/types',
    'xide/utils',
    'xide/factory',
    'xblox/model/ModelBase',
    'xblox/model/Scope',
    'xblox/model/BlockModel',
    'xide/mixins/ReloadMixin',
    'xide/manager/ManagerBase',
    'xblox/data/Store',
    "xdojo/has!xblox-ui?xblox/manager/BlockManagerUI"
],function (dcl,lang,has,Deferred,all,types,utils,factory,ModelBase,Scope,BlockModel,ReloadMixin,ManagerBase,Store,BlockManagerUI){
    var bases = has('host-browser') && has("xblox-ui") ? [BlockManagerUI,ManagerBase,ReloadMixin.dcl] : [ManagerBase,ReloadMixin.dcl];
    var debug = false;
    var blockManager = dcl(bases,{
        declaredClass:"xblox/manager/BlockManager",
        serviceObject:null,
        loaded:{},
        /***
         *  scope: storage for all registered variables / commands
         */
        scope:null,
        scopes:null,
        //track original create block function
        _createBlock:null,
        _registerActions:function(){},
        toScope:function(data){
            try {
                data = utils.getJson(data);
            } catch (e) {
                console.error('BlockManager::toScope: failed,err='+e);
                return null;
            }

            if(!data){
                console.error('correct data');
                data = {
                    "blocks": [
                    ],
                    "variables": []
                }
            }

            var scopeId = utils.createUUID();
            var blockInData = data;
            var variableInData = data;

            //check structure
            if (lang.isArray(data)) {// a flat list of blocks

            } else if (lang.isObject(data)) {
                scopeId = data.scopeId || scopeId;
                blockInData = data.blocks || [];
                variableInData = data.variables || [];
            }

            var blockManager = this;

            var scopeUserData = {
                owner:this
            };

            var blockScope = this.getScope(scopeId, scopeUserData, true);
            var allBlocks = blockScope.blocksFromJson(blockInData);
            for (var i = 0; i < allBlocks.length; i++) {
                var obj = allBlocks[i];
                obj._lastRunSettings = {
                    force: false,
                    highlight: true
                }
            }
            blockScope.serviceObject = this.serviceObject;
            return blockScope;
        },
        /**
         *
         * @param files{Object[]} array of items to load in this format
         * @example:
         * @returns {Deferred.promise}
         */
        loadFiles:function(files){

            var thiz=this,
                _createDfd = function(mount,path,force,publish)
                {
                    return thiz.load(mount,path,force);
                },
                _promises = [],
                dfd = new Deferred();

            //build promise chain for 'all'
            for (var i = 0; i < files.length; i++) {
                var item = files[i];
                _promises.push(_createDfd(item.mount, item.path, item.force, item.publish));
            }

            //run and resolve head
            all(_promises).then(function(results){
                debug && console.log('got all block files ',results);
                dfd.resolve(results);
            });

            return dfd.promise;
        },
        load:function(mount,path,forceReload){
            var dfd = new Deferred(),
                thiz = this,
                _mount = utils.replaceAll('/','',mount),
                _path = utils.replaceAll('./','',path);

            var full = _mount + _path;
            full = full.trim();

            if(this.loaded[full] && forceReload===true){
                this.removeScope(this.loaded[full].id);
                this.loaded[full]=null;
            }

            if(forceReload !==true && this.loaded[full]){
                dfd.resolve(this.loaded[full]);
                return dfd.promise;
            }
            var _ready = function(data){
                var scope = thiz.toScope(data);
                if(scope){
                    thiz.loaded[full] = scope;

                    scope.mount = mount;//track file info
                    scope.path = path;
                }
                dfd.resolve(scope);
            };
            this.ctx.getFileManager().getContent(_mount,_path,_ready,false);
            return dfd.promise;
        },
        onBlocksReady:function(scope){
            var blocks = scope.allBlocks();
            for (var i = 0; i < blocks.length; i++) {
                var obj = blocks[i];
                this.setScriptFunctions(obj,scope,this);
            }
            /**
             * pick 'On Load' blocks
             */

            var loadBlocks = scope.getBlocks({
                group:'On Load'
            });
            if(loadBlocks && loadBlocks.length>0){
                for (var i = 0; i < loadBlocks.length; i++) {
                    var loadBlock  = loadBlocks[i];
                    if(loadBlock.onLoad){
                        loadBlock.onLoad();
                    }
                }
            }
        },
        getBlock:function(){

        },
        setScriptFunctions:function(obj,scope,owner){

            var thiz=owner;
            //scope.context = obj;//set the context of the blox scope
            if(!obj.blockScope) {
                obj.blockScope = scope;
            }
            debug && console.log('set script functions ' + scope.id,obj);
            scope.serviceObject = this.serviceObject;
            ///////////////////////////////////////////////////////////////////////////////
            //
            //  Variables
            //
            ///////////////////////////////////////////////////////////////////////////////
            /**
             * Add 'setVariable'
             * @param title
             * @param value
             */
            if(!obj.setVariable) {
                obj.setVariable = function (title, value, save, publish, source) {
                    var _scope = this.blockScope;
                    var _variable = _scope.getVariable(title);
                    if (_variable) {
                        _variable.value = value;
                        debug && console.log('setting variable '+title + ' to ' + value);
                    } else {
                        debug && console.log('no such variable : ' + title);
                        return;
                    }
                    if (publish !== false) {

                        thiz.publish(types.EVENTS.ON_VARIABLE_CHANGED, {
                            item: _variable,
                            scope: scope,
                            driver: obj,
                            owner: thiz,
                            save: save === true,
                            source: source || types.MESSAGE_SOURCE.BLOX  //for prioritizing
                        });
                    }
                };
            }
            /**
             * Add getVariable
             * @param title
             */
            if(!obj.getVariable) {
                obj.getVariable = function (title) {
                    var _scope = this.blockScope;
                    var _variable = _scope.getVariable(title);
                    if (_variable) {
                        return _variable.value;
                    }
                    return '';
                };
            }

        },
        hasScope:function(id) {
            if (!this.scopes) {
                this.scopes = {};
            }
            if (this.scopes[id]) {
                return this.scopes[id];
            }
            return null;
        },
        getScope:function(id,userData,publish){
            if(!this.scopes){
              this.scopes={};
            }
            if(!this.scopes[id]){
                this.scopes[id]=this.createScope({
                    id:id,
                    ctx:this.ctx
                });
                this.scopes[id].userData=userData;
                if(publish!==false){
                    try{
                        factory.publish(types.EVENTS.ON_SCOPE_CREATED,this.scopes[id]);
                    }catch(e){
                        console.error('bad, scope creation failed ' +e ,e);
                    }
                }
            }
            return this.scopes[id];
        },
        /**
         *
         * @param id
         * @returns {null}
         */
        removeScope:function(id){
            if(!this.scopes){
                this.scopes={};
            }
            for (var scopeId in this.loaded){
                if(this.loaded[scopeId].id==id){
                    delete this.loaded[scopeId];
                }
            }
            try {
                if (this.scopes[id]) {
                    this.scopes[id]._destroy();
                    delete this.scopes[id];
                }
            }catch(e){
                debugger;
            }
            return null;
        },
        /**
         *
         * @param mixed
         * @param data
         * @returns {*}
         */
        createScope:function(mixed,data){
            //console.error('create scope');
            data = data || [];
            var blockStore = new Store({
                data: [],
                Model:BlockModel,
                id:utils.createUUID(),
                __events:{

                },
                observedProperties:[
                    "name",
                    "enabled",
                    "value"
                ],
                getLabel:function(item){
                    return item.name;
                },
                labelAttr:'name'
            });
            blockStore.reset();
            blockStore.setData([]);
            var args = {
                owner:this,
                blockStore:blockStore,
                serviceObject:this.serviceObject,
                config:this.config
            };
            utils.mixin(args,mixed);
            try {
                var scope = new Scope(args);
                data && scope.initWithData(data);
                scope.init();
            }catch(e){
                logError(e,'error creating scope');
            }

            return scope;
        },
        onReloaded:function(){
            debug && console.log('on reloaded');
        },
        init:function() {
            this.scope = {
                variables:[],
                blocks: []
            };
            ModelBase.prototype.types=types;
            ModelBase.prototype.factory=factory;
            if(this.onReady){
                this.onReady();
            }
        }
    });
    return blockManager;
});
define('xblox/model/functions/SetProperties',[
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'dojo/Deferred',
    "xblox/model/Block"
], function(dcl,utils,types,Deferred,Block){

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.functions.CallBlock
    /**
     * @augments module:xide/mixins/EventedMixin
     * @extends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    return dcl(Block,{
        declaredClass:"xblox.model.functions.SetProperties",
        //command: (String)
        //  block action name
        command:'Select block',
        icon:'',
        args:null,
        _timeout:100,
        /***
         * Returns the block run result
         * @param scope
         */
        solve:function(scope,settings) {
            var dfd = new Deferred();
            if (this.command){
                var block = scope.resolveBlock(this.command);
                if(block && this.props){

                    for(var prop in this.props){

                        block.set(prop,this.props[prop]);
                        block[prop] = this.props[prop];
                        block.onChangeField && block.onChangeField(prop,this.props[prop]);
                    }

                    this.onSuccess(this,settings);
                }else{
                    this.onFailed(this,settings);
                }

                dfd.resolve([]);
                return dfd;
            }
            return dfd;
        },
        hasInlineEdits:false,
        /**
         *
         * @param field
         * @param pos
         * @param type
         * @param title
         * @param mode: inline | popup
         * @returns {string}
         */
        makeEditable:function(field,pos,type,title,mode,options,value){

            var optionsString = "";
            if(options){

            }

            return "<a " + optionsString + "  tabIndex=\"-1\" pos='" + pos +"' display-mode='" + (mode||'popup') + "' display-type='" + (type || 'text') +"' data-prop='" + field + "' data-title='" + title + "' class='editable editable-click'  href='#'>" + this[field] +"</a>";
        },
        getFieldOptions:function(field){

            if(field ==="command"){
                return this.scope.getCommandsAsOptions("text");
            }
        },
        toText:function(){

            var text = 'Unknown';
            var block = this.scope.getBlock(this.command);
            if(block){
                text = block.name;
            }
            if(this.command.indexOf('://')!==-1) {
                text = '<span class="text-info">' +this.scope.toFriendlyName(this,this.command) + '</span>';
            }
            //var _out = this.getBlockIcon('D') + 'Call Command : ' + this.makeEditable('command','bottom','select','Enter a unique name','inline');
            var _out = this.getBlockIcon('D') + 'Set Properties : ' + text;
            return _out;
        },
        serializeObject:function(field){

            if(field ==='props'){
                return true;
            }
            return false;
        },
        onChangeField:function(field,newValue,cis){

            if(field==='command'){
                delete this.props;
                this.props = {};
            }
        },
        init:function(){
            if(this.props && _.isString(this.props)){
                this.props = utils.fromJson(this.props);
            }

        },
        //  standard call for editing
        getFields:function(){

            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz=this;

            var title = 'Command';
            if(this.command.indexOf('://')){
                title = this.scope.toFriendlyName(this,this.command);
            }

            fields.push(utils.createCI('value','xcf.widgets.CommandPicker',this.command,{
                    group:'General',
                    title:'Command',
                    dst:'command',
                    options:this.scope.getCommandsAsOptions(),
                    block:this,
                    pickerType:'command',
                    value:this.command
            }));

            var block = this.scope.resolveBlock(this.command);
            if(block && block.getFields){
                if(!this.props){
                    this.props = {};
                }
                var _fields = block.getFields();
                var descr = _.find(_fields,{
                    dst:"description"
                });
                _fields.remove(descr);
                _.each(_fields,function(_field){
                    _field.group = "Properties";
                    _field.value = utils.getAt(this.props,_field.dst,_field.value);
                    _field.dst = "props." + _field.dst;

                },this);
                fields = fields.concat(_fields);
            }
            return fields;
        }
    });
});
define('xblox/model/server/ServerBlock',[
    'dcl/dcl',
    "xblox/model/Block",
    "xide/utils"
], function (dcl,Block,utils) {
    /**
     * Runs a JSON-RPC-2.0 method on the server. This assumes that this block's scope has
     * a 'service object'
     */
    return dcl(Block, {
        
        declaredClass:"xblox.model.server.ServerBlock",
        /**
         * The name of the block, used in the UI
         * @member {string}
         */
        name: 'Run Server Block',
        /**
         * The full string of the service class method, ie: MyPHPServerClass::method
         * @member {string}
         */
        method: 'XShell::run',
        /**
         * Arguments for the server call
         * @member {string}
         */
        args: '',
        /**
         * Override in super class, this block runs async by default
         * @member {boolean}
         */
        deferred: true,
        /**
         * The default for the server RPC class
         * @member {string}
         */
        defaultServiceClass: 'XShell',
        /**
         * The default for the server RPC class method
         * @member {string}
         */
        defaultServiceMethod: 'run',
        /**
         * Debugging
         * @member {function}
         */
        sharable:true,

        onReloaded: function () {


            console.log('1');


            return;


            /*console.log('is valid  ' + this.isInValidState());
             console.log('current service class ' + this.getServiceClass());
             console.log('current service class method ' + this.getServiceMethod());*/
            var service = this.getService();
            //var params = this.utils.byString(service,'_smd.services.'+ this.method.replace('::','.'));

            var params = service.getParameterMap(this.getServiceClass(), this.getServiceMethod());
            console.log('params', params);
            var cwd = 'root://test';
            var cmd = 'ls';
            var fun = this.getServerFunction(),
                thiz = this;

            if (fun) {
                var _cb = function (response) {
                    console.log('hello from server', response);
                };
                var _value = service.base64_encode(cmd);
                service.callMethodEx(this.getServiceClass(), 'run', ['sh', _value, cwd], _cb);
            }


        },
        /***
         * Returns the block run result
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {Array}
         */
        solve: function (scope, settings, run, error) {

            this._currentIndex = 0;
            this._return = [];

            var _script = '' + this.method;
            var thiz = this;

            if (_script && _script.length) {

                var _function = new Function("{" + _script + "}");
                var _args = this.getArgs();
                try {
                    var _parsed = _function.apply(this, _args || {});
                    this._lastResult = _parsed;

                    if (run) {
                        run('Expression ' + _script + ' evaluates to ' + _parsed);
                    }
                    if (_parsed !== 'false' && _parsed !== false) {
                        this.onSuccess(this, settings);
                    } else {
                        this.onFailed(this, settings);
                        return [];
                    }
                } catch (e) {
                    if (error) {
                        error('invalid expression : \n' + _script + ': ' + e);
                    }
                    this.onFailed(this, settings);
                    return [];
                }
            } else {
                console.error('have no script');
            }
            var ret = [], items = this[this._getContainer()];
            if (items.length) {
                this.runFrom(items, 0, settings);
            } else {
                this.onSuccess(this, settings);
            }

            return ret;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText: function () {

            var result = this.getBlockIcon() + ' ' + this.name + ' :: ';
            if (this.method) {
                result += this.method.substr(0, 50);
            }
            return result;
        },

        //  standard call from interface
        canAdd: function () {
            return [];
        },
        getServerDefaultFields:function(target){

            var fields = target || [];

            fields.push(utils.createCI('args', 27, this.args, {
                group: 'General',
                title: 'Arguments',
                dst: 'args'
            }));

            return fields;
        },
        //  standard call for editing
        getFields: function () {
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz = this;
/*
            fields.push(this.utils.createCI('args', 27, this.args, {
                group: 'General',
                title: 'Arguments',
                dst: 'args'
            }));
            */

            return fields;
        },
        getBlockIcon: function () {
            return '<span class="fa-plug"></span>';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Store
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren: function (parent) {
            return this.items != null && this.items.length > 0;
        },

        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren: function (parent) {
            return this.items;
        },

        /**
         * Check our scope has a service object
         * @returns {boolean}
         */
        isInValidState: function () {
            return this.getService() != null;
        },
        getService: function () {
            return this.scope.getService();
        },
        getServiceClass: function () {
            return this.method.split('::')[0] || this.defaultServiceClass;
        },
        getServiceMethod: function () {
            return this.method.split('::')[1] || this.defaultServiceMethod;
        },
        hasMethod: function (method) {
            return this.isInValidState() &&
            this.getService()[this.getServiceClass()] != null &&
            this.getService()[this.getServiceClass()][this.getServiceMethod()] != null
        },
        hasServerClass: function (_class) {
            return this.isInValidState() &&
            this.getService()[this.getServiceClass()] != null;
        },
        getServerFunction: function () {
            if (this.isInValidState() && this.getServiceClass() && this.getServiceMethod()) {
                return this.getService()[this.getServiceClass()][this.getServiceMethod()];
            }
            return null;
        }
    });
});
define('xblox/model/server/RunServerMethod',[
    "dcl/dcl",
    "xblox/model/server/ServerBlock",
    'xide/utils'
], function (dcl, ServerBlock, utils) {
    /**
     * Runs a JSON-RPC-2.0 method on the server. This assumes that this block's scope has
     * a 'service object'
     */
    return dcl(ServerBlock, {

        declaredClass:"xblox.model.server.RunServerMethod",

        description: 'Runs a JSON-RPC-2.0 method on the server',

        /**
         * The name of the block, used in the UI
         * @member {string}
         */
        name: 'Run Server Method',

        /**
         * The full string of the service class method, ie: MyPHPServerClass::method
         * @member {string}
         */
        method: 'XShell::run',
        /**
         * Arguments for the server call
         * @member {string}
         */
        args: '',
        /**
         * Override in super class, this block runs async by default
         * @member {boolean}
         */
        deferred: true,
        /**
         * The default for the server RPC class
         * @member {string}
         */
        defaultServiceClass: 'XShell',
        /**
         * The default for the server RPC class method
         * @member {string}
         */
        defaultServiceMethod: 'run',

        sharable:true,
        /**
         * Callback when user edited the 'method' field. This will pre-populate the arguments field when empty
         * with the known SMD parameters : if possible.
         * @param newMethod
         * @param cis
         */
        onMethodChanged: function (newMethod, cis) {
            
            this.method = newMethod;

            //we auto populate the arguments field
            if (!utils.isValidString(this.args)) {

                var newServerParams = this.getServerParams();
                if (newServerParams) {
                    this._updateArgs(newServerParams, cis);
                }

            }
        },
        _getArgs: function () {


            /*
            var test = [
                {
                    "name": "shellType",
                    "default": "sh", "optional": false, "value": "notset"
                },
                {
                    "name": "cmd",
                    "optional": false,
                    "value": "[CurrentDirectory]"
                },
                {
                    "name": "cwd",
                    "default": null,
                    "optional": true,
                    "value": "[CurrentDirectory]"
                }
            ];*/


            var _args = utils.getJson(this.args || '[]');
            var result = [];
            if (_args) {
                var isSMD = false;
                //now check this is still in 'SMD' format
                if (_args && _args[0] && _args[0]['optional'] != null) {
                    isSMD = true;
                }
                //if SMD true, evaluate the value field
                if (isSMD) {
                    for (var i = 0; i < _args.length; i++) {
                        var _arg = _args[i];
                        var _variableValue = _arg.value;
                        var isBase64 = _arg.name.indexOf('Base64') != -1;
                        if(isBase64){
                            _variableValue = this.getService().base64_encode(_variableValue);
                        }

                        if (_arg.value !== 'notset') {
                            if (_arg.value.indexOf('[') != -1 && _arg.value.indexOf(']') != -1) {
                                _variableValue = this.scope.expressionModel.replaceVariables(this.scope, _arg.value, false, false);
                                if (_arg.name.indexOf('Base64') != -1) {
                                    _variableValue = this.getService().base64_encode(_variableValue);
                                }
                                result.push(_variableValue);
                            } else {
                                result.push(_variableValue || _arg['default']);
                            }

                        } else {
                            result.push(_arg['default'] || _variableValue);
                        }
                    }
                } else {

                }
            } else {
                return [this.args];
            }

            return result;

        },
        /**
         * Update this.args (string) with a SMD parameter set
         * @param params
         * @param cis
         * @private
         */
        _updateArgs: function (params, cis) {

            var argumentWidget = this.utils.getCIWidgetByName(cis, 'args');
            if (argumentWidget) {
                var _string = JSON.stringify(params);
                argumentWidget.editBox.set('value', _string);
                this.args = _string;

            }
        },
        /**
         * Find SMD for the current method
         * @returns {*}
         */
        getServerParams: function () {
            var service = this.getService();
            var params = service.getParameterMap(this.getServiceClass(), this.getServiceMethod());
            if (params) {
                for (var i = 0; i < params.length; i++) {
                    var param = params[i];
                    param.value = 'notset';
                }
            }
            return params;
        },
        onReloaded: function (evt) {

            console.log('sdfsd');
            this._solve()
        },
        _solve:function(scope,settings,run,error){

            console.log('solve223');

        },
        /***
         * Returns the block run result
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {Array}
         */
        solve: function (scope, settings, run, error) {



            this._return = [];
            this._lastResult=null;
            var thiz = this;
            var ret = [];

            //this._solve();



            //console.dir(this.scope);


            if(!this.isInValidState()){
                this.onFailed(this, settings);
                return ret;
            }

            var _args = this._getArgs();//returns SMD ready array of values
            var _cbSuccess = function (response) {
                thiz._lastResult = thiz.utils.getJson(response) || [response];
                thiz.resolved(thiz._lastResult);
                thiz.onSuccess(thiz, settings);
            };
            var _cbError = function (response) {
                //console.error('   server method ' + thiz.method + ' with params ' + JSON.stringify(_args)  + 'failed ' + response);
                thiz._lastResult = thiz.utils.getJson(response) || [response];
                thiz.resolved(thiz._lastResult);
                thiz.onFailed(thiz, settings);
            };

            this.onRun(this, settings);

            var service = this.getService();
            var serviceObject = this.scope.serviceObject;
            //service.callMethodEx(this.getServiceClass(), this.getServiceMethod(), _args, _cbSuccess,_cbError);

            console.error('run deferred');

            var dfd = serviceObject.runDeferred(this.getServiceClass(),this.getServiceMethod(),_args);
            if(dfd){
                dfd.then(function(data){
                    console.error('returned ',data);
                });
            }

            return dfd;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText: function () {

            var result = this.getBlockIcon() + ' ' + this.name + ' :: ';
            if (this.method) {
                result += this.method.substr(0, 50);
            }
            return result;
        },

        //  standard call from interface
        canAdd: function () {
            return [];
        },
        //  standard call for editing
        getFields: function () {
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz = this;

            fields.push(utils.createCI('value', 25, this.method, {
                group: 'General',
                title: 'Method',
                dst: 'method',
                description: 'This should be in the format : MyServerClass::myMethod',
                delegate: {
                    runExpression: function (val, run, error) {
                        var old = thiz.method;
                        thiz.method = val;
                        var _res = thiz.solve(thiz.scope, null, run, error);
                    }
                }
            }));
            fields = fields.concat(this.getServerDefaultFields());
            return fields;
        },
        getBlockIcon: function () {
            return '<span class="fa-plug"></span>';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Store
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren: function (parent) {
            return this.items != null && this.items.length > 0;
        },

        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren: function (parent) {
            return this.items;
        },

        onChangeField: function (field, newValue, cis) {
            if (field === 'method') {
                this.onMethodChanged(newValue, cis);
            }
        },

        /**
         * Check our scope has a service object
         * @returns {boolean}
         */
        isInValidState: function () {

            return this.getService() != null;
        },
        getService: function () {

            var service = this.scope.getService();

            if(!service){
                console.error('have no service object');
            }
            return service;
        },
        getServiceClass: function () {
            return this.method.split('::')[0] || this.defaultServiceClass;
        },
        getServiceMethod: function () {
            return this.method.split('::')[1] || this.defaultServiceMethod;
        },
        hasMethod: function (method) {
            return this.isInValidState() &&
            this.getService()[this.getServiceClass()] != null &&
            this.getService()[this.getServiceClass()][this.getServiceMethod()] != null
        },
        hasServerClass: function (_class) {
            return this.isInValidState() &&
            this.getService()[this.getServiceClass()] != null;
        },
        getServerFunction: function () {
            if (this.isInValidState() && this.getServiceClass() && this.getServiceMethod()) {
                return this.getService()[this.getServiceClass()][this.getServiceMethod()];
            }
            return null;
        }


    });
});
define('xblox/model/server/Shell',[
    "dcl/dcl",
    "xblox/model/server/ServerBlock",
    'xide/utils'
], function (dcl, ServerBlock, utils) {
    /**
     * Runs a JSON-RPC-2.0 method on the server. This assumes that this block's scope has
     * a 'service object'
     */
    return dcl(ServerBlock, {

        declaredClass:"xblox.model.server.Shell",

        description: 'Runs a JSON-RPC-2.0 method on the server',

        /**
         * The name of the block, used in the UI
         * @member {string}
         */
        name: 'Run Shell',

        /**
         * The full string of the service class method, ie: MyPHPServerClass::method
         * @member {string}
         */
        method: '',
        /**
         * Arguments for the server call
         * @member {string}
         */
        args: '',
        /**
         * Override in super class, this block runs async by default
         * @member {boolean}
         */
        deferred: true,
        /**
         * The default for the server RPC class
         * @member {string}
         */
        defaultServiceClass: 'XShell',
        /**
         * The default for the server RPC class method
         * @member {string}
         */
        defaultServiceMethod: 'run',

        sharable:true,
        /**
         * onCommandFinish will be excecuted which a driver did run a command
         * @param msg {object}
         * @param msg.id {string} the command job id
         * @param msg.src {string} the source id, which is this block id
         * @param msg.cmd {string} the command string being sent
         */
        onCommandFinish:function(msg){
            var scope = this.getScope();
            var context = scope.getContext();//driver instance
            debug && console.log('onCommandFinish ' + this.send);
            if(this.waitForResponse){
                this._emit('cmd:'+msg.cmd + '_' + msg.id,{
                    msg:msg
                });
            }
        },
        onCommandError:function(msg){
            var scope = this.getScope();
            var context = scope.getContext();//driver instance
            debug && console.log('onCommandError',msg);
            if(this.waitForResponse){
                this._emit('cmd:'+msg.cmd + '_' + msg.id,msg);
            }

        },
        /**
         * Callback when user edited the 'method' field. This will pre-populate the arguments field when empty
         * with the known SMD parameters : if possible.
         * @param newMethod
         * @param cis
         */
        onMethodChanged: function (newMethod, cis) {
            
            this.method = newMethod;

            //we auto populate the arguments field
            if (!utils.isValidString(this.args)) {

                var newServerParams = this.getServerParams();
                if (newServerParams) {
                    this._updateArgs(newServerParams, cis);
                }

            }
        },
        _getArgs: function () {


            /*
            var test = [
                {
                    "name": "shellType",
                    "default": "sh", "optional": false, "value": "notset"
                },
                {
                    "name": "cmd",
                    "optional": false,
                    "value": "[CurrentDirectory]"
                },
                {
                    "name": "cwd",
                    "default": null,
                    "optional": true,
                    "value": "[CurrentDirectory]"
                }
            ];*/


            var _args = utils.getJson(this.args || '[]');
            var result = [];
            if (_args) {
                var isSMD = false;
                //now check this is still in 'SMD' format
                if (_args && _args[0] && _args[0]['optional'] != null) {
                    isSMD = true;
                }
                //if SMD true, evaluate the value field
                if (isSMD) {
                    for (var i = 0; i < _args.length; i++) {
                        var _arg = _args[i];
                        var _variableValue = _arg.value;
                        var isBase64 = _arg.name.indexOf('Base64') != -1;
                        if(isBase64){
                            _variableValue = this.getService().base64_encode(_variableValue);
                        }

                        if (_arg.value !== 'notset') {
                            if (_arg.value.indexOf('[') != -1 && _arg.value.indexOf(']') != -1) {
                                _variableValue = this.scope.expressionModel.replaceVariables(this.scope, _arg.value, false, false);
                                if (_arg.name.indexOf('Base64') != -1) {
                                    _variableValue = this.getService().base64_encode(_variableValue);
                                }
                                result.push(_variableValue);
                            } else {
                                result.push(_variableValue || _arg['default']);
                            }

                        } else {
                            result.push(_arg['default'] || _variableValue);
                        }
                    }
                } else {

                }
            } else {
                return [this.args];
            }

            return result;

        },
        /**
         * Update this.args (string) with a SMD parameter set
         * @param params
         * @param cis
         * @private
         */
        _updateArgs: function (params, cis) {

            var argumentWidget = this.utils.getCIWidgetByName(cis, 'args');
            if (argumentWidget) {
                var _string = JSON.stringify(params);
                argumentWidget.editBox.set('value', _string);
                this.args = _string;

            }
        },
        /**
         * Find SMD for the current method
         * @returns {*}
         */
        getServerParams: function () {
            var service = this.getService();
            var params = service.getParameterMap(this.getServiceClass(), this.getServiceMethod());
            if (params) {
                for (var i = 0; i < params.length; i++) {
                    var param = params[i];
                    param.value = 'notset';
                }
            }
            return params;
        },
        onReloaded: function (evt) {

            console.log('sdfsd');
            this._solve()
        },
        _solve:function(scope,settings,run,error){

            console.log('solve223');

        },
        /***
         * Returns the block run result
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {Array}
         */
        solve: function (scope, settings, isInterface,send,run,error) {
            
            this._return = [];
            this._lastResult=null;
            var thiz = this;
            var ret = [];

            settings = this._lastSettings = settings || this._lastSettings;

            var instance = this.getInstance();

            console.log('run');



            /*
            var value =utils.getJson(args,true,false);
            if(value === null || value === 0 || value === true || value === false || !_.isObject(value)){
                value = {
                    payload:this.args
                }
            }*/

            var code = scope.expressionModel.replaceVariables(scope,this.method,false,false);
            instance.runShell(code,utils.mixin({
            },{}),this.id,this.id,this);


            return;

            if(!this.isInValidState()){
                this.onFailed(this, settings);
                return ret;
            }

            var _args = this._getArgs();//returns SMD ready array of values
            var _cbSuccess = function (response) {
                thiz._lastResult = thiz.utils.getJson(response) || [response];
                thiz.resolved(thiz._lastResult);
                thiz.onSuccess(thiz, settings);
            };
            var _cbError = function (response) {
                //console.error('   server method ' + thiz.method + ' with params ' + JSON.stringify(_args)  + 'failed ' + response);
                thiz._lastResult = thiz.utils.getJson(response) || [response];
                thiz.resolved(thiz._lastResult);
                thiz.onFailed(thiz, settings);
            };

            this.onRun(this, settings);

            var service = this.getService();
            var serviceObject = this.scope.serviceObject;
            //service.callMethodEx(this.getServiceClass(), this.getServiceMethod(), _args, _cbSuccess,_cbError);

            console.error('run deferred');

            var dfd = serviceObject.runDeferred(this.getServiceClass(),this.getServiceMethod(),_args);
            if(dfd){
                dfd.then(function(data){
                    console.error('returned ',data);
                });
            }

            return dfd;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText: function () {

            var result = this.getBlockIcon() + ' ' + this.name + ' :: ';
            if (this.method) {
                result += this.method.substr(0, 50);
            }
            return result;
        },

        //  standard call from interface
        canAdd: function () {
            return [];
        },
        //  standard call for editing
        getFields: function () {
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz = this;

            fields.push(utils.createCI('value', 25, this.method, {
                group: 'General',
                title: 'Method',
                dst: 'method',
                description: 'This should be in the format : MyServerClass::myMethod',
                delegate: {
                    runExpression: function (val, run, error) {
                        var old = thiz.method;
                        thiz.method = val;
                        var _res = thiz.solve(thiz.scope, null, run, error);
                    }
                }
            }));
            //fields = fields.concat(this.getServerDefaultFields());
            return fields;
        },
        getBlockIcon: function () {
            return '<span class="fa-plug"></span>';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Store
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren: function (parent) {
            return this.items != null && this.items.length > 0;
        },

        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren: function (parent) {
            return this.items;
        },

        onChangeField: function (field, newValue, cis) {
            if (field === 'method') {
                this.onMethodChanged(newValue, cis);
            }
        },

        /**
         * Check our scope has a service object
         * @returns {boolean}
         */
        isInValidState: function () {

            return this.getService() != null;
        },
        getService: function () {

            var service = this.scope.getService();

            if(!service){
                console.error('have no service object');
            }
            return service;
        },
        getServiceClass: function () {
            return this.method.split('::')[0] || this.defaultServiceClass;
        },
        getServiceMethod: function () {
            return this.method.split('::')[1] || this.defaultServiceMethod;
        },
        hasMethod: function (method) {
            return this.isInValidState() &&
            this.getService()[this.getServiceClass()] != null &&
            this.getService()[this.getServiceClass()][this.getServiceMethod()] != null
        },
        hasServerClass: function (_class) {
            return this.isInValidState() &&
            this.getService()[this.getServiceClass()] != null;
        },
        getServerFunction: function () {
            if (this.isInValidState() && this.getServiceClass() && this.getServiceMethod()) {
                return this.getService()[this.getServiceClass()][this.getServiceMethod()];
            }
            return null;
        }


    });
});
/** @module xblox/model/mqtt/Subscribe **/
define('xblox/model/mqtt/Subscribe',[
    'dcl/dcl',
    'xdojo/has',
    "dojo/Deferred",
    "xblox/model/Block",
    'xide/utils',
    'xblox/model/Contains',
    'xide/types'
    //'dojo/has!host-node?dojo/node!tracer',
    //'dojo/has!host-node?nxapp/utils/_console'
], function(dcl,has,Deferred,Block,utils,Contains,types,tracer,_console){


    var isServer = has('host-node');

    var console = typeof window !== 'undefined' ? window.console : global.console;
    if(isServer && tracer && console && console.error){
        console = _console;
    }else{
        //console.error('have no tracer ' + (tracer!=null && tracer.error!=null ? 'tracer ok ' : 'no ') + ' | ' + (console.error!=null ? 'errir ok ' : 'no error') );
        //console.dir(tracer);
    }

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    /**
     * Base block class.
     *
     * @class module:xblox/model/mqtt/Subscribe
     * @extends module:xblox/model/Block
     */
    return dcl([Block,Contains],{
        declaredClass:"xblox.model.mqtt.Subscribe",
        //method: (String)
        //  block action name
        name:'Subscribe',
        //method: (String)
        //  block action name
        topic:'Topic',
        args:'',
        deferred:false,
        sharable:true,
        context:null,
        icon:'fa-bell',
        /**
         * @type {string|null}
         */
        path:'',
        qos:0,
        stop:function(){
            var instance = this.getInstance();
            if(instance){
                instance.callMethod('unSubscribeTopic',utils.mixin({
                    topic:this.topic
                },utils.getJson(this.args)),this.id,this.id);
            }
        },
        onData:function(message){

            //console.error('-data ' + message.topic,message);
            if(message && message.topic && message.topic==this.topic){

                delete message['src'];
                delete message['id'];


                var thiz=this,
                    ctx = this.getContext(),
                    items = this[this._getContainer()];

                var settings = this._lastSettings;
                var ret=[];
                if(items.length>0){
                    var value = message;
                    var path = this.path && this.path.length ? this.path : (message.payload!==null) ? 'payload' : null;
                    if(path && _.isObject(message)){
                        value = utils.getAt(message,path,message);
                    }

                    console.error('path=' + path + ' @ ' + message.topic,value);


                    for(var n = 0; n < this.items.length ; n++)
                    {
                        var block = this.items[n];
                        if(block.enabled) {



                            block.override ={
                                args: [value]
                            };
                            ret.push(block.solve(this.scope,settings));
                            //console.log('run block '+block.name);
                        }
                    }
                }
                this.onSuccess(this, this._lastSettings);
                return ret;
            }
        },
        observed:[
            'topic'
        ],
        getContext:function(){
            return this.context || (this.scope.getContext ?  this.scope.getContext() : this);
        },
        /**
         *
         * @param scope
         * @param settings
         * @param run
         * @param error
         */
        solve:function(scope,settings,isInterface,send,run,error){

            this._currentIndex = 0;
            this._return=[];
            this._lastSettings = settings;
            var instance = this.getInstance();

            if(instance){
                instance.callMethod('subscribeTopic',utils.mixin({
                    topic:this.topic,
                    qos:this.qos
                },utils.getJson(this.args ||"{}")),this.id,this.id);
            }
            settings = settings || {};
            this.onRunThis(settings);
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText:function(){

            var result = '<span style="">' +
                this.getBlockIcon() + '' + this.makeEditable('topic','bottom','text','Enter a topic','inline') + ' :: '+'</span>';

            if(this.topic){
                result+= this.topic.substr(0,30);
            }
            return result;
        },
        //  standard call from interface
        canAdd:function(){
            return [];
        },
        //  standard call for editing
        getFields:function(){

            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz=this;

            fields.push(
                utils.createCI('name',13,this.name,{
                    group:'General',
                    title:'Name',
                    dst:'name'
                })
            );

            fields.push(utils.createCI('arguments',27,this.args,{
                    group:'Arguments',
                    title:'Arguments',
                    dst:'args'
                }));

            fields.push(utils.createCI('topic',types.ECIType.STRING,this.topic,{
                    group:'General',
                    title:'Topic',
                    dst:'topic',
                    select:true
                }));

            fields.push(utils.createCI('name',types.ECIType.ENUMERATION,this.qos,{
                    group:'General',
                    title:'QOS',
                    dst:'qos',
                    widget: {
                        options: [
                            {
                                label:"0 - at most once",
                                value:0
                            },
                            {
                                label:"1 - at least once",
                                value:1
                            },
                            {
                                label:"2 - exactly once",
                                value:2
                            }
                        ]
                    }
                })
            );

            fields.push(utils.createCI('path',types.ECIType.STRING,this.path,{
                group:'General',
                title:'Value Path',
                dst:'path'
            }));
            return fields;
        }
    });
});
/** @module xcf/model/Command */
define('xcf/model/Command',[
    'dcl/dcl',
    "xblox/model/Block",
    "xblox/model/Contains",
    'xide/utils',
    'xide/types',
    'dojo/Deferred',
    'module',
    'require'
], function(dcl,Block,Contains,utils,types,Deferred,module,require){
    var debug = false;
    /**
     * The command model. A 'command' consists out of a few parameters and a series of
     *  XCF - Command - Block expresssions. Those expressions need to be evaluated before send them to the device
     * @class module:xcf/model/Command
     * @augments module:xide/mixins/EventedMixin
     * @extends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    return dcl([Block,Contains],{
        //declaredClass: String (dcl internals, private!)
        declaredClass: "xcf.model.Command",
        //startup: Boolean
        //  3.12.10.3. The “Startup” checkbox indicates whether or not the associated command
        //  should be automatically sent at startup once communications have been established
        //  with the device.
        startup:false,
        //auto: Float
        //  3.12.10.3. The “Auto” field is used to set a time interval at which the command is
        //  automatically continually sent when necessary for applications such as polling.
        auto:null,
        //send: xcf.model.Expression
        //  3.12.10.3. “Send” field containing the actual string or hexadecimal sequence used to communicate with the device.
        send:'',

        name:'No Title',
        observed:[
            'send'
        ],

        interval:0,

        flags:0x00000800,

        waitForResponse:false,

        _runningDfd:null,

        /**
         * onCommandFinish will be excecuted which a driver did run a command
         * @param msg {object}
         * @param msg.id {string} the command job id
         * @param msg.src {string} the source id, which is this block id
         * @param msg.cmd {string} the command string being sent
         */
        onCommandFinish:function(msg){
            var scope = this.getScope();
            var context = scope.getContext();//driver instance
            debug && console.log('onCommandFinish ' + this.send);
            if(this.waitForResponse && msg.params && msg.params.id){
                this._emit('cmd:'+msg.cmd + '_' + msg.params.id,{
                    msg:msg
                });
            }
        },
        onCommandError:function(msg){
            var scope = this.getScope();
            var context = scope.getContext();//driver instance
            debug && console.log('onCommandError',msg);
            if(this.waitForResponse && msg.params && msg.params.id){
                this._emit('cmd:'+msg.cmd + '_' + msg.params.id,msg);
            }
            this.onFailed(this, this._settings);

        },
        sendToDevice:function(msg,settings){

            msg=this.replaceAll("'",'',msg);
            var id = utils.createUUID(),
                self = this;

            if(this.scope.instance){
                if(this.waitForResponse){
                    this._on('cmd:'+msg + '_' + id,function(msg){
                        if(msg.error){
                            self.onFailed(self, settings);
                        }else {
                            self.onSuccess(self, settings);
                        }
                    });
                }
                this.scope.instance.sendMessage(msg,null,this.id,id);
            }else{
                debug && console.warn('have no device!');
                this.publish(types.EVENTS.ON_STATUS_MESSAGE,{
                    text:'Command ' + this.name + ' : have no device',
                    type:'error',
                    delay:1000
                });
                return false;
            }
            return id;
        },
        reset:function(){
            this._lastSettings = {};
            if(this._loop){
                clearTimeout(this._loop);
                this._loop = null;
            }
        },
        /***
         * Solves the command
         *
         * @param scope
         * @returns formatted send string
         */
        solve:function(scope,settings,isInterface,send) {
            var dfd = null;
            scope = scope || this.scope;

            settings = this._lastSettings = settings || this._lastSettings;

            if(settings && settings.override && settings.override.mixin){
                utils.mixin(this.override,settings.override.mixin);
            }

            var value = send || this._get('send');

            var parse = !(this.flags & types.CIFLAG.DONT_PARSE);

            var isExpression = (this.flags & types.CIFLAG.EXPRESSION);

            if(this.flags & types.CIFLAG.TO_HEX){
                value = utils.to_hex(value);
            }

            if(this.flags & types.CIFLAG.REPLACE_HEX){
                //value = utils.replaceHex(value);
            }

            if(parse!==false){
                value = utils.convertAllEscapes(value,"none");
            }

            if(!this.enabled && isInterface!==true){
                this.reset();
                return;
            }
            //we're already running
            if(isInterface ==true && this._loop){
                this.reset();
            }
            if(this.waitForResponse!==true) {
                this.onRun(this,settings);
            }else{

                this.onRun(this,settings,{
                    timeout:false
                });

                dfd = new Deferred();
                this._runningDfd = dfd;
            }
            if(this.items && this.items.length>0){

                if(value && value.length>0){
                    var res =  parse ? scope.parseExpression(value) : value;
                    if(res && res.length>0){
                        if(!this.sendToDevice(res,settings)){
                            this.onFailed(this, settings);
                        }else{
                            this.onSuccess(this, settings);
                        }
                    }
                }

                var ret=[];

                for(var n = 0; n < this.items.length ; n++)
                {
                    var block = this.items[n];
                    if(block.enabled) {
                        ret.push(block.solve(scope, settings));
                    }
                }

                return ret;

            }else if(value.length>0){
                var _overrides = (this.override && this.override.variables) ? this.override.variables : null;
                if(_overrides){
                    for(var prop in _overrides){
                        if(_.isNumber(_overrides[prop])){
                            _overrides[prop] = Math.round(_overrides[prop]);
                        }
                    }
                }

                var res='';

                if(/*(this.isScript(value) && parse!==false) || */isExpression && parse!==false){
                    res = scope.parseExpression(value,null,_overrides);
                }else{
                    res = '' + value;
                }
                if(res && res.length>0){
                    if(!this.sendToDevice(res,settings)) {
                        this.onFailed(this, settings);
                    }
                }
                //console.log('sending ' + res);
                if(this.waitForResponse!==true) {
                    this.onSuccess(this, settings);

                }else{
                    this._settings = settings;
                    //this.onRun(this, settings);
                }

                if(isInterface){
                    if(this.auto && this.getInterval()>0) {
                        this.scope.loopBlock(this, settings);
                    }
                }

                return [res];
            }
            return false;
        },
        canAdd:function(){
            return [];
        },
        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren:function(parent){
            return this.items!=null && this.items.length>0;
        },

        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren:function(parent){
            return this.items;
        },
        hasInlineEdits:true,

        toText:function(icon,label,detail,breakDetail){
            var out = "";
            if(icon!==false){
                out +="<span class='text-primary inline-icon'>" + this.getBlockIcon() + "</span>";
            }
            label!==false && (out +=""+ this.makeEditable('name','bottom','text','Enter a unique name','inline') + "");
            breakDetail == true && (out +="<br/>");
            detail !==false && (out +=("<span class='text-muted small'> Send:<kbd class='text-warning'>" + this.makeEditable('send','bottom','text','Enter the string to send','inline')) + "</kbd></span>");
            if(icon!==false){
                this.startup && (out +=this.getIcon('fa-bell inline-icon text-warning','text-align:right;float:right;',''));
                this.auto && this.getInterval() > 0 && (out +=this.getIcon('fa-clock-o inline-icon text-warning','text-align:right;float:right',''));
            }
            return out;
        },
        getInterval:function(){
            return parseInt(this.interval);
        },
        start:function(){
            if(this.startup && !this.auto){
                this.solve(this.scope);
            }else if(this.auto && this.getInterval()>0){
                this.scope.loopBlock(this);
            }

        },
        getFields:function(){

            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz=this;

            fields.push(this.utils.createCI('name',13,this.name,{
                group:'General',
                title:'Name',
                dst:'name',
                order:200
            }));

            fields.push(this.utils.createCI('startup',0,this.startup,{
                group:'General',
                title:'Send on Startup',
                dst:'startup',
                order:199
            }));


            fields.push(this.utils.createCI('auto',0,this.auto,{
                group:'General',
                title:'Auto Send',
                dst:'auto',
                order:198
            }));

            fields.push(this.utils.createCI('interval',13,this.interval,{
                group:'General',
                title:'Interval',
                dst:'interval',
                order:197
            }));

            fields.push(this.utils.createCI('waitForResponse',0,this.waitForResponse,{
                group:'General',
                title:'%%Has Response',
                dst:'waitForResponse',
                order:195
            }));

            fields.push(this.utils.createCI('send',types.ECIType.EXPRESSION_EDITOR,this.send,{
                group:'Send',
                title:'Send',
                dst:'send',
                widget:{
                    instantChanges:false,
                    allowACECache:true,
                    showBrowser:false,
                    showSaveButton:true,
                    style:'height:inherit;',
                    editorOptions:{
                        showGutter:false,
                        autoFocus:false
                    },
                    aceOptions:{
                        hasEmmet:false,
                        hasLinking:false,
                        hasMultiDocs:false
                    },
                    item:this
                },
                delegate:{
                    runExpression:function(val,run,error){
                        return thiz.scope.expressionModel.parse(thiz.scope,val,false,run,error);
                    }
                }
            }));



            fields.push(this.utils.createCI('flags',5,this.flags,{
                group:'General',
                title:'Flags',
                dst:'flags',
                data:[
                    {
                        value: 0x000001000,
                        label: 'Dont parse',
                        title:"Do not parse the string and use it as is"
                    },
                    {
                        value: 0x00000800,//2048
                        label: 'Expression',
                        title: 'Parse it as Javascript'
                    }/*,
                    {
                        value: 0x000004000,//8096
                        label: '%%Replace Hex',
                        title: "Replace string with the hex designator,ie x0d will be replaced by \\r"
                    }*/
                ],
                widget:{
                    hex:true
                }

            }));
            
            return fields;
        },
        icon:'fa-exclamation',
        getIconClass:function(){
            return 'el-icon-play-circle';
        },
        getBlockIcon:function(){
            return '<span class="'+this.icon+'"></span> ';
        },
        canEdit:function(){
            return true;
        },
        onChangeField:function(field,newValue,cis){
            if(field=='auto'){
                if(newValue==true){
                    this.getInterval()>0 && this.scope.loopBlock(this);
                }else{
                    if(this._loop){
                        this.reset();
                    }
                }
            }
            if(field=='enabled'){
                if(newValue==false){
                    this.reset();
                }else{
                    if(this.getInterval()){
                        this.scope.loopBlock(this);
                    }
                }
            }
            if(field=='interval'){
                if(this.getInterval()>0 && this.auto){
                    this.scope.loopBlock(this);
                }else{
                    this.reset();
                }
            }
            this.inherited(arguments);
        },
        destroy:function () {
            console.error('-destroy');
            this.reset();
        }
    });
});

/** @module xblox/model/mqtt/Publish **/
define('xblox/model/mqtt/Publish',[
    'dcl/dcl',
    'xdojo/has',
    "dojo/Deferred",
    "xblox/model/Block",
    'xide/utils',
    'xblox/model/Contains',
    'xide/types',
    'xcf/model/Command'
    //'xdojo/has!host-node?dojo/node!tracer',
    //'xdojo/has!host-node?nxapp/utils/_console'
], function(dcl,has,Deferred,Block,utils,Contains,types,Command,tracer,_console){
    var isServer = has('host-node');
    var console = typeof window !== 'undefined' ? window.console : global.console;
    if(isServer && tracer && console && console.error){
        console = _console;
    }else{
        //console.error('have no tracer ' + (tracer!=null && tracer.error!=null ? 'tracer ok ' : 'no ') + ' | ' + (console.error!=null ? 'errir ok ' : 'no error') );
        //console.dir(tracer);
    }

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    /**
     * Base block class.
     *
     * @class module:xblox/model/mqtt/Publish
     * @extends module:xblox/model/Block
     */
    return dcl(Command,{
        declaredClass:"xblox.model.mqtt.Publish",
        //method: (String)
        //  block action name
        name:'Publish',
        //method: (String)
        //  block action name
        topic:'',
        args:'',
        deferred:false,
        sharable:true,
        context:null,
        icon:'fa-send',
        isCommand:true,
        qos:0,
        retain:false,
        /**
         * @type {string|null}
         */
        path:null,
        onData:function(message){
            if(message && message.topic && message.topic==this.topic){
                var thiz=this,
                    ctx = this.getContext(),
                    items = this[this._getContainer()];

                var settings = this._lastSettings;
                var ret=[];
                if(items.length>0){

                    var value = message;
                    this.path = 'value';
                    if(this.path && _.isObject(message)){
                        value = utils.getAt(message,this.path,message);
                    }

                    for(var n = 0; n < this.items.length ; n++)
                    {
                        var block = this.items[n];
                        if(block.enabled) {
                            block.override ={
                                args: [value]
                            };
                            ret.push(block.solve(this.scope,settings));
                        }
                    }
                }
                this.onSuccess(this, this._lastSettings);
                return ret;
            }
        },
        observed:[
            'topic'
        ],
        getContext:function(){
            return this.context || (this.scope.getContext ?  this.scope.getContext() : this);
        },
        /**
         *
         * @param scope
         * @param settings
         * @param isInterface
         * @param send
         * @param run
         * @param error
         */
        solve:function(scope,settings,isInterface,send,run,error){

            this._currentIndex = 0;
            this._return=[];

            settings = this._lastSettings = settings || this._lastSettings;

            var instance = this.getInstance();
            if(isInterface ==true && this._loop){
                this.reset();
            }

            var args = this.args;
            var inArgs = this.getArgs(settings);
            if(inArgs[0]){
                args = inArgs[0];
            }

            if(instance){
                var value =utils.getJson(args,true,false);
                if(value === null || value === 0 || value === true || value === false || !_.isObject(value)){
                    value = {
                        payload:this.args
                    }
                }
                var topic = scope.expressionModel.replaceVariables(scope,this.topic,false,false);

                instance.callMethod('publishTopic',utils.mixin({
                    topic:topic,
                    qos:this.qos,
                    retain:this.retain
                },value),this.id,this.id);
            }

            settings = settings || {};

            this.onDidRun();

            this.onSuccess(this, settings);
            return true;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText:function(icon,label,detail,breakDetail){
            var out = '<span style="">' + this.getBlockIcon() + ' ' + this.makeEditable('name','top','text','Enter a name','inline') + ' :: '+'</span>';
            if(this.topic){
                out+= this.makeEditable('topic','bottom','text','Enter a topic','inline');
                this.startup && (out +=this.getIcon('fa-bell inline-icon text-warning','text-align:right;float:right;',''));
                this.interval > 0 && (out +=this.getIcon('fa-clock-o inline-icon text-warning','text-align:right;float:right',''));
            }
            return out;
        },
        //  standard call from interface
        canAdd:function(){
            return [];
        },
        //  standard call for editing
        getFields:function(){

            var fields = this.inherited(arguments) || this.getDefaultFields();

            fields.push(utils.createCI('qos',types.ECIType.ENUMERATION,this.qos,{
                    group:'General',
                    title:'QOS',
                    dst:'qos',
                    widget: {
                        options: [
                            {
                                label:"0 - at most once",
                                value:0
                            },
                            {
                                label:"1 - at least once",
                                value:1
                            },
                            {
                                label:"2 - exactly once",
                                value:2
                            }
                        ]
                    }
                })
            );



            //
            //var type = 'xide/widgets/JSONDualEditorWidget';//27
            fields.push(utils.createCI('arguments',27,this.args,{
                    group:'Arguments',
                    title:'Arguments',
                    dst:'args'
                }));

            fields.push(utils.createCI('topic',types.ECIType.STRING,this.topic,{
                group:'General',
                title:'Topic',
                dst:'topic',
                select:true
            }));

            fields.push(utils.createCI('retain',types.ECIType.BOOL,this.retain,{
                group:'General',
                title:'Retain',
                dst:'retain'
            }));

            fields.remove(_.find(fields,{
                name:"send"
            }));

            fields.remove(_.find(fields,{
                name:"waitForResponse"
            }));

            return fields;
        }
    });
});
define('xcf/factory/Blocks',[
    'dojo/_base/lang',
    'xblox/factory/Blocks',
    "xcf/model/Command",
    "xblox/model/functions/CallBlock",
    "xide/factory"

], function (lang,Blocks,Command,CallBlock,factory)
{
    if(Blocks) {
        Blocks._getCommandBlocks = function (scope, owner, target, group) {

            var items = [];
            items.push({
                name: 'Commands',
                iconClass: 'el-icon-random',
                /*dstItem:dstItem,*/
                items: [
                    {
                        name: 'Call Command',
                        owner: owner,
                        iconClass: 'el-icon-video',
                        proto: CallBlock,
                        target: target,
                        ctrArgs: {
                            scope: scope,
                            group: group,
                            condition: ""
                        }
                    },
                    {
                        name: 'New Command',
                        owner: owner,
                        iconClass: 'el-icon-video',
                        proto: Command,
                        target: target,
                        ctrArgs: {
                            scope: scope,
                            group: group,
                            condition: "",
                            name: 'No-Title'
                        }
                    }
                ]
            });
            return items;
        };


        return Blocks;
    }else{
        return factory;
    }

});
define('xblox/factory/Blocks',[
    'dojo/_base/lang',
    'xide/factory',
    'xide/utils',
    'xide/types',
    'xide/mixins/ReloadMixin',
    'xide/mixins/EventedMixin',
    "xblox/model/logic/CaseBlock",
    "xblox/model/Block",
    "xblox/model/functions/CallBlock",
    "xblox/model/functions/SetProperties",
    "xblox/model/code/CallMethod",
    "xblox/model/code/RunScript",
    "xblox/model/loops/ForBlock",
    "xblox/model/loops/WhileBlock",
    "xblox/model/variables/VariableAssignmentBlock",
    "xblox/model/logic/IfBlock",
    "xblox/model/logic/ElseIfBlock",
    "xblox/model/logic/SwitchBlock",
    "xblox/model/variables/VariableSwitch",
    "xblox/model/logging/Log",
    "xblox/model/server/RunServerMethod",
    "xblox/model/server/Shell",
    "xblox/model/code/RunBlock",
    "xblox/model/events/OnEvent",
    "xblox/model/events/OnKey",
    //"xblox/model/html/SetStyle",
    //"xblox/model/html/SetCSS",
    "xblox/model/mqtt/Subscribe",
    "xblox/model/mqtt/Publish",
    "xcf/factory/Blocks"

], function (lang,
             factory,
             utils,
             types,
             ReloadMixin,EventedMixin,
             CaseBlock,
             Block,
             CallBlock,
             SetProperties,
             CallMethod,
             RunScript,
             ForBlock,
             WhileBlock,
             VariableAssignmentBlock,
             IfBlock,
             ElseIfBlock,
             SwitchBlock,
             VariableSwitch,
             Log,
             RunServerMethod,
             Shell,
             RunBlock,
             OnEvent,

             OnKey,
             //SetStyle,
             //SetCSS,
             Subscribe,
             Publish

    )
{



    factory.prepareBlockContructorArgs=function(ctorArgs){
        if(!ctorArgs){
            ctorArgs={};
        }

        //prepare items
        if(!ctorArgs['id']){
            ctorArgs['id']=utils.createUUID();
        }
        if(!ctorArgs['items']){
            ctorArgs['items']=[];
        }
    };
    /***
     *
     * @param mixed String|Prototype
     * @param ctorArgs
     * @param baseClasses
     */
    factory.createBlock=function(mixed,ctorArgs,baseClasses,publish){

        //complete missing arguments:
        factory.prepareBlockContructorArgs(ctorArgs);

        var block= factory.createInstance(mixed,ctorArgs,baseClasses);
        block.ctrArgs=null;
        var newBlock;
        try{
            if(block && block.init){
                block.init();
            }
            ReloadMixin.prototype.mergeFunctions(block,EventedMixin.prototype);
            //ReloadMixin.prototype.mergeFunctions(block,ReloadMixin.prototype);

            //add to scope
            if (block.scope) {
                newBlock = block.scope.registerBlock(block,publish);
            }
            try{
                if(block.initReload){
                    block.initReload();
                }
            }catch(e){
                debugger;
            }
        }catch(e){
            logError(e,'create block');
        }
        if(!block){
            //logError(e,'create block');
        }
        return newBlock || block;

    };
    
    var cachedAll = null;
    
    
    

    factory.clearVariables=function(){};
    factory.getAllBlocks=function(scope,owner,target,group,allowCache){
        if(allowCache!==false && cachedAll !=null){
            /**
             * remove dynamic blocks like 'Set Variable'
             */
            for (var i = 0; i < cachedAll.length; i++) {
                var obj = cachedAll[i];
                if(obj.name==='Set Variable'){
                    cachedAll.remove(obj);
                    break;
                }
            }
            return cachedAll;
        }else if(allowCache==false){
            cachedAll=null;
        }


        var items = factory._getFlowBlocks(scope,owner,target,group);
        items = items.concat(factory._getLoopBlocks(scope,owner,target,group));
        items = items.concat(factory._getCommandBlocks(scope,owner,target,group));

        items = items.concat(factory._getCodeBlocks(scope,owner,target,group));
        items = items.concat(factory._getEventBlocks(scope,owner,target,group));
        items = items.concat(factory._getLoggingBlocks(scope,owner,target,group));
        //items = items.concat(factory._getHTMLBlocks(scope,owner,target,group));
        items = items.concat(factory._getServerBlocks(scope,owner,target,group));
        //items = items.concat(factory._getServerBlocks(scope,owner,target,group));
        items = items.concat(factory._getMQTTBlocks(scope,owner,target,group));
        cachedAll = items;
        return items;
    };
    /*
    factory._getCommandBlocks=function(scope,owner,target,group){
        var items = [];
        return items;
    };
    */
    factory._getMQTTBlocks=function(scope,owner,target,group){

        var items = [];
        items.push({
            name:'MQTT',
            iconClass: 'fa-cloud',
            items:[
                {
                    name:'Subscribe',
                    owner:owner,
                    iconClass:'fa-bell',
                    proto:Subscribe,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                },
                {
                    name:'Publish',
                    owner:owner,
                    iconClass:'fa-send',
                    proto:Publish,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                }
            ]
        });



        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST,{
            items:items,
            group:'MQTT'
        });
        return items;

    };
    factory._getServerBlocks=function(scope,owner,target,group){

        var items = [];
        items.push({
            name:'Server',
            iconClass: 'el-icon-repeat',
            items:[
                {
                    name:'Run Server Method',
                    owner:owner,
                    iconClass:'fa-plug',
                    proto:RunServerMethod,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                },
                {
                    name:'Shell',
                    owner:owner,
                    iconClass:'fa-code',
                    proto:Shell,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                }
            ]
        });

        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST,{
            items:items,
            group:'Server'
        });
        return items;
    };
    /*
    factory._getHTMLBlocks=function(scope,owner,target,group){
        var items = [];
        items.push({
            name:'HTML',
            iconClass:'fa-paint-brush',
            items:[
                {
                    name:'Set Style',
                    owner:owner,
                    iconClass:'fa-paint-brush',
                    proto:SetStyle,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                },
                {
                    name:'Set CSS',
                    owner:owner,
                    iconClass:'fa-paint-brush',
                    proto:SetCSS,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                }
            ]
        });
        return items;
    };
    */
    factory._getVariableBlocks=function(scope,owner,target,group){

        var items = [];
        items.push({
            name:'Flow',
            iconClass:'el-icon-random',
            items:[
                {
                    name:'If...Else',
                    owner:owner,
                    iconClass:'el-icon-fork',
                    proto:IfBlock,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group,
                        condition:"[value]=='PW'"
                    }
                }/*,
                {
                    name:'Switch',
                    owner:owner,
                    iconClass:'el-icon-fork',
                    proto:SwitchBlock,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                }
                */
            ]
        });

        return items;
    };
    factory._getEventBlocks=function(scope,owner,target,group){

        var items = [];
        items.push({
            name:'Events',
            iconClass:'fa-bell',
            items:[
                {
                    name:'On Event',
                    owner:owner,
                    iconClass:'fa-bell',
                    proto:OnEvent,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                },
                {
                    name:'On Key',
                    owner:owner,
                    iconClass:'fa-keyboard-o',
                    proto:OnKey,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                }
            ]
        });



        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST,{
            items:items,
            group:'Events'
        });

        return items;
    };
    factory._getLoggingBlocks=function(scope,owner,target,group){

        var items = [];
        items.push({
            name:'Logging',
            iconClass:'fa-bug',
            items:[
                {
                    name:'Log',
                    owner:owner,
                    iconClass:'fa-bug',
                    proto:Log,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                }
            ]
        });

        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST,{
            items:items,
            group:'Logging'
        });

        return items;
    };
    factory._getCodeBlocks=function(scope,owner,target,group){

        var items = [];
        items.push({
            name:'Code',
            iconClass:'fa-code',
            items:[
                {
                    name:'Call Method',
                    owner:owner,
                    iconClass:'el-icon-video',
                    proto:CallMethod,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                },
                {
                    name:'Run Script',
                    owner:owner,
                    iconClass:'fa-code',
                    proto:RunScript,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                },
                {
                    name:'Run Block',
                    owner:owner,
                    iconClass:'fa-code',
                    proto:RunBlock,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                },
                {
                    name:'Set Properties',
                    owner:owner,
                    iconClass:'fa-code',
                    proto:SetProperties,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                }
            ]
        });
        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST,{
            items:items,
            group:'Code'
        });
        return items;
    };
    factory._getFlowBlocks=function(scope,owner,target,group){

        var items = [];
        items.push({
            name:'Flow',
            iconClass:'el-icon-random',
            items:[
                {
                    name:'If...Else',
                    owner:owner,
                    iconClass:'el-icon-fork',
                    proto:IfBlock,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group,
                        condition:"[value]=='PW'"
                    }
                },
                /*
                {
                    name:'Switch',
                    owner:owner,
                    iconClass:'el-icon-fork',
                    proto:SwitchBlock,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                },
                */
                {
                    name:'Variable Switch',
                    owner:owner,
                    iconClass:'el-icon-fork',
                    proto:VariableSwitch,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                }
            ]
        });

        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST,{
            items:items,
            group:'Flow'
        });

        return items;
    };
    factory._getLoopBlocks=function(scope,owner,target,group){

        var items = [];
        items.push({
            name:'Loops',
            iconClass: 'el-icon-repeat',
            items:[
                {
                    name:'While',
                    owner:owner,
                    iconClass:'el-icon-repeat',
                    proto:WhileBlock,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group,
                        condition:"[Volume]<=100"
                    }
                },
                {
                    name:'For',
                    owner:owner,
                    iconClass:'el-icon-repeat',
                    proto:ForBlock,
                    target:target,
                    ctrArgs:{
                        scope:scope,
                        group:group,
                        initial: '1',
                        comparator: "<=",
                        "final": '5',
                        modifier: '+1',
                        counterName: 'value'
                    }
                }
            ]
        });

        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST,{
            items:items,
            group:'Loops'
        });
        return items;
    };
    factory._getMathBlocks=function(scope,owner,dstItem,group){

        var items = [];
        items.push({
            name:'Math',
            owner:this,
            iconClass:'el-icon-qrcode',
            dstItem:dstItem,
            items:[
                {
                    name:'If...Else',
                    owner:dstItem,
                    iconClass:'el-icon-compass',
                    proto:IfBlock,
                    item:dstItem,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                }
            ]
        });
        return items;
    };
    factory._getTimeBlocks=function(scope,owner,dstItem,group){

        var items = [];
        items.push({
            name:'Time',
            owner:this,
            iconClass:'el-icon-qrcode',
            dstItem:dstItem,
            items:[
                {
                    name:'If...Else',
                    owner:dstItem,
                    iconClass:'el-icon-time',
                    proto:IfBlock,
                    item:dstItem,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                }

            ]
        });
        return items;
    };
    factory._getTransformBlocks=function(scope,owner,dstItem,group){

        var items = [];
        items.push({
            name:'Time',
            owner:this,
            iconClass:'el-icon-magic',
            dstItem:dstItem,
            items:[
                {
                    name:'If...Else',
                    owner:dstItem,
                    iconClass:'el-icon-time',
                    proto:IfBlock,
                    item:dstItem,
                    ctrArgs:{
                        scope:scope,
                        group:group
                    }
                }
            ]
        });



        return items;


    };
    
    

    return factory;
});
define('xblox/embedded',[
    'dojo/_base/declare',
    'xide/types',
    'xblox/types/Types',
    'xide/factory',
    'xide/utils',
    'xide/mixins/ReloadMixin',
    'xide/mixins/EventedMixin',
    "xblox/model/logic/CaseBlock",
    "xblox/model/Block",
    "xblox/model/functions/CallBlock",
    "xblox/model/code/CallMethod",
    "xblox/model/code/RunScript",
    "xblox/model/code/RunBlock",
    "xblox/model/loops/ForBlock",
    "xblox/model/loops/WhileBlock",
    "xblox/model/variables/VariableAssignmentBlock",
    "xblox/model/logic/IfBlock",
    "xblox/model/logic/ElseIfBlock",
    "xblox/model/logic/SwitchBlock",
    "xblox/model/variables/VariableSwitch",
    "xblox/model/events/OnEvent",
    "xblox/model/events/OnKey",
    "xblox/model/logging/Log",
    "xblox/model/html/SetStyle",
    "xblox/model/html/SetCSS",
    "xblox/manager/BlockManager",
    "xblox/factory/Blocks",

    "xdojo/has!xblox-ui?xblox/model/Block_UI"
], function () {


    if(!Array.prototype.remove){
        Array.prototype.remove= function(){
            var what, a= arguments, L= a.length, ax;
            while(L && this.length){
                what= a[--L];
                if(this.indexOf==null){
                    break;
                }
                while((ax= this.indexOf(what))!= -1){
                    this.splice(ax, 1);
                }
            }
            return this;
        };
    }
    if(!Array.prototype.swap){

        Array.prototype.swap = function (x,y) {
            var b = this[x];
            this[x] = this[y];
            this[y] = b;
            return this;
        };
    }

    if ( typeof String.prototype.startsWith != 'function' ) {
        String.prototype.startsWith = function( str ) {
            return this.substring( 0, str.length ) === str;
        }
    }

    if ( typeof String.prototype.endsWith != 'function' ) {
        String.prototype.endsWith = function( str ) {
            return this.substring( this.length - str.length, this.length ) === str;
        }
    }

    if(!Function.prototype.bind) {
        // Cheap polyfill to approximate bind(), make Safari happy
        Function.prototype.bind = Function.prototype.bind || function (that) {
            return dojo.hitch(that, this);
        };
    }
    /*
     cycle.js
     2013-02-19

     Public Domain.

     NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

     This code should be minified before deployment.
     See http://javascript.crockford.com/jsmin.html

     USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
     NOT CONTROL.
     */

    /*jslint evil: true, regexp: true */

    /*members $ref, apply, call, decycle, hasOwnProperty, length, prototype, push,
     retrocycle, stringify, test, toString
     */

    /*
    if (typeof JSON.decycle !== 'function') {
        JSON.decycle = function decycle(object) {
            'use strict';

// Make a deep copy of an object or array, assuring that there is at most
// one instance of each object or array in the resulting structure. The
// duplicate references (which might be forming cycles) are replaced with
// an object of the form
//      {$ref: PATH}
// where the PATH is a JSONPath string that locates the first occurance.
// So,
//      var a = [];
//      a[0] = a;
//      return JSON.stringify(JSON.decycle(a));
// produces the string '[{"$ref":"$"}]'.

// JSONPath is used to locate the unique object. $ indicates the top level of
// the object or array. [NUMBER] or [STRING] indicates a child member or
// property.

            var objects = [],   // Keep a reference to each unique object or array
                paths = [];     // Keep the path to each unique object or array

            return (function derez(value, path) {

// The derez recurses through the object, producing the deep copy.

                var i,          // The loop counter
                    name,       // Property name
                    nu;         // The new object or array

// typeof null === 'object', so go on if this value is really an object but not
// one of the weird builtin objects.

                if (typeof value === 'object' && value !== null &&
                    !(value instanceof Boolean) &&
                    !(value instanceof Date)    &&
                    !(value instanceof Number)  &&
                    !(value instanceof RegExp)  &&
                    !(value instanceof String)) {

// If the value is an object or array, look to see if we have already
// encountered it. If so, return a $ref/path object. This is a hard way,
// linear search that will get slower as the number of unique objects grows.

                    for (i = 0; i < objects.length; i += 1) {
                        if (objects[i] === value) {
                            return {$ref: paths[i]};
                        }
                    }

// Otherwise, accumulate the unique value and its path.

                    objects.push(value);
                    paths.push(path);

// If it is an array, replicate the array.

                    if (Object.prototype.toString.apply(value) === '[object Array]') {
                        nu = [];
                        for (i = 0; i < value.length; i += 1) {
                            nu[i] = derez(value[i], path + '[' + i + ']');
                        }
                    } else {

// If it is an object, replicate the object.

                        nu = {};
                        for (name in value) {
                            if (Object.prototype.hasOwnProperty.call(value, name)) {
                                nu[name] = derez(value[name],
                                    path + '[' + JSON.stringify(name) + ']');
                            }
                        }
                    }
                    return nu;
                }
                return value;
            }(object, '$'));
        };
    }


    if (typeof JSON.retrocycle !== 'function') {
        JSON.retrocycle = function retrocycle($) {
            'use strict';

// Restore an object that was reduced by decycle. Members whose values are
// objects of the form
//      {$ref: PATH}
// are replaced with references to the value found by the PATH. This will
// restore cycles. The object will be mutated.

// The eval function is used to locate the values described by a PATH. The
// root object is kept in a $ variable. A regular expression is used to
// assure that the PATH is extremely well formed. The regexp contains nested
// * quantifiers. That has been known to have extremely bad performance
// problems on some browsers for very long strings. A PATH is expected to be
// reasonably short. A PATH is allowed to belong to a very restricted subset of
// Goessner's JSONPath.

// So,
//      var s = '[{"$ref":"$"}]';
//      return JSON.retrocycle(JSON.parse(s));
// produces an array containing a single element which is the array itself.

            var px =
                /^\$(?:\[(?:\d+|\"(?:[^\\\"\u0000-\u001f]|\\([\\\"\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\])*$/;

            (function rez(value) {

// The rez function walks recursively through the object looking for $ref
// properties. When it finds one that has a value that is a path, then it
// replaces the $ref object with a reference to the value that is found by
// the path.

                var i, item, name, path;

                if (value && typeof value === 'object') {
                    if (Object.prototype.toString.apply(value) === '[object Array]') {
                        for (i = 0; i < value.length; i += 1) {
                            item = value[i];
                            if (item && typeof item === 'object') {
                                path = item.$ref;
                                if (typeof path === 'string' && px.test(path)) {
                                    value[i] = eval(path);
                                } else {
                                    rez(item);
                                }
                            }
                        }
                    } else {
                        for (name in value) {
                            if (typeof value[name] === 'object') {
                                item = value[name];
                                if (item) {
                                    path = item.$ref;
                                    if (typeof path === 'string' && px.test(path)) {
                                        value[name] = eval(path);
                                    } else {
                                        rez(item);
                                    }
                                }
                            }
                        }
                    }
                }
            }($));
            return $;
        };

    }
    */
});
define('decor/features',["requirejs-dplugins/has"], function (has) {
	/* global Platform */
	has.add("console-api", typeof console !== "undefined");
	has.add("host-browser", typeof window !== "undefined");
	has.add("object-observe-api", typeof Object.observe === "function" && typeof Array.observe === "function");
	has.add("object-is-api", !!Object.is);
	has.add("setimmediate-api", typeof setImmediate === "function");
	has.add("mutation-observer-api",
		typeof MutationObserver !== "undefined"
			&& (/\[\s*native\s+code\s*\]/i.test(MutationObserver) // Avoid polyfill version of MutationObserver
				|| !/^\s*function/.test(MutationObserver)));
	has.add("polymer-platform", typeof Platform !== "undefined");
	return has;
});

/** @module decor/schedule */
define('decor/schedule',["./features"], function (has) {
	"use strict";

	/**
	 * Calls a function at the end of microtask.
	 * @function module:decor/schedule
	 * @param {Function} callback The function to call at the end of microtask.
	 */

	/* global setImmediate */
	var inFlight,
		SCHEDULEID_PREFIX = "_schedule",
		seq = 0,
		uniqueId = Math.random() + "",
		callbacks = {},
		pseudoDiv = has("mutation-observer-api") && document.createElement("div");
	function runCallbacks() {
		for (var anyWorkDone = true; anyWorkDone;) {
			anyWorkDone = false;
			for (var id in callbacks) {
				var callback = callbacks[id];
				delete callbacks[id];
				callback();
				anyWorkDone = true;
			}
		}
		inFlight = false;
	}
	if (has("mutation-observer-api")) {
		pseudoDiv.id = 0;
		new MutationObserver(runCallbacks).observe(pseudoDiv, {attributes: true});
	} else if (!has("setimmediate-api") && has("host-browser")) {
		window.addEventListener("message", function (event) {
			if (event.data === uniqueId) {
				runCallbacks();
			}
		});
	}
	return function (callback) {
		var id = SCHEDULEID_PREFIX + seq++;
		callbacks[id] = callback;
		if (!inFlight) {
			has("mutation-observer-api") ? ++pseudoDiv.id :
				has("setimmediate-api") ? setImmediate(runCallbacks) :
				window.postMessage(uniqueId, "*");
			inFlight = true;
		}
		return {
			remove: function () {
				delete callbacks[id];
			}
		};
	};
});

/**
 * @license domReady 2.0.1 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/domReady/LICENSE
 */
/*jslint */
/*global require: false, define: false, requirejs: false,
  window: false, clearInterval: false, document: false,
  self: false, setInterval: false */


define('requirejs-domready/domReady',[],function () {
    'use strict';

    var isTop, testDiv, scrollIntervalId,
        isBrowser = typeof window !== "undefined" && window.document,
        isPageLoaded = !isBrowser,
        doc = isBrowser ? document : null,
        readyCalls = [];

    function runCallbacks(callbacks) {
        var i;
        for (i = 0; i < callbacks.length; i += 1) {
            callbacks[i](doc);
        }
    }

    function callReady() {
        var callbacks = readyCalls;

        if (isPageLoaded) {
            //Call the DOM ready callbacks
            if (callbacks.length) {
                readyCalls = [];
                runCallbacks(callbacks);
            }
        }
    }

    /**
     * Sets the page as loaded.
     */
    function pageLoaded() {
        if (!isPageLoaded) {
            isPageLoaded = true;
            if (scrollIntervalId) {
                clearInterval(scrollIntervalId);
            }

            callReady();
        }
    }

    if (isBrowser) {
        if (document.addEventListener) {
            //Standards. Hooray! Assumption here that if standards based,
            //it knows about DOMContentLoaded.
            document.addEventListener("DOMContentLoaded", pageLoaded, false);
            window.addEventListener("load", pageLoaded, false);
        } else if (window.attachEvent) {
            window.attachEvent("onload", pageLoaded);

            testDiv = document.createElement('div');
            try {
                isTop = window.frameElement === null;
            } catch (e) {}

            //DOMContentLoaded approximation that uses a doScroll, as found by
            //Diego Perini: http://javascript.nwbox.com/IEContentLoaded/,
            //but modified by other contributors, including jdalton
            if (testDiv.doScroll && isTop && window.external) {
                scrollIntervalId = setInterval(function () {
                    try {
                        testDiv.doScroll();
                        pageLoaded();
                    } catch (e) {}
                }, 30);
            }
        }

        //Check if document already complete, and if so, just trigger page load
        //listeners. Latest webkit browsers also use "interactive", and
        //will fire the onDOMContentLoaded before "interactive" but not after
        //entering "interactive" or "complete". More details:
        //http://dev.w3.org/html5/spec/the-end.html#the-end
        //http://stackoverflow.com/questions/3665561/document-readystate-of-interactive-vs-ondomcontentloaded
        //Hmm, this is more complicated on further use, see "firing too early"
        //bug: https://github.com/requirejs/domReady/issues/1
        //so removing the || document.readyState === "interactive" test.
        //There is still a window.onload binding that should get fired if
        //DOMContentLoaded is missed.
        if (document.readyState === "complete") {
            pageLoaded();
        }
    }

    /** START OF PUBLIC API **/

    /**
     * Registers a callback for DOM ready. If DOM is already ready, the
     * callback is called immediately.
     * @param {Function} callback
     */
    function domReady(callback) {
        if (isPageLoaded) {
            callback(doc);
        } else {
            readyCalls.push(callback);
        }
        return domReady;
    }

    domReady.version = '2.0.1';

    /**
     * Loader Plugin API method
     */
    domReady.load = function (name, req, onLoad, config) {
        if (config.isBuild) {
            onLoad(null);
        } else {
            domReady(onLoad);
        }
    };

    /** END OF PUBLIC API **/

    return domReady;
});

define('delite/features',["requirejs-dplugins/has"], function (has) {
	// Flag for whether to create background iframe behind popups like Menus and Dialog.
	// A background iframe is useful to prevent problems with popups appearing behind applets/pdf files.
	has.add("config-bgIframe", false);

	// Flag to enable advanced bidi support
	has.add("bidi", false);

	// Flag to enable inheritance direction from any ancestor
	has.add("inherited-dir", false);

	if (typeof window !== "undefined") {
		// Returns the name of the method to test if an element matches a CSS selector.
		has.add("dom-matches", function () {
			var node = document.body;
			if (node.matches) {
				return "matches";
			}
			if (node.webkitMatchesSelector) {
				return "webkitMatchesSelector";
			}
			if (node.mozMatchesSelector) {
				return "mozMatchesSelector";
			}
			if (node.msMatchesSelector) {
				return "msMatchesSelector";
			}
		});

		// Does platform have native support for document.registerElement() or a polyfill to simulate it?
		has.add("document-register-element", !!document.registerElement);

		// Test for how to monitor DOM nodes being inserted and removed from the document.
		// For DOMNodeInserted events, there are two variations:
		//		"root" - just notified about the root of each tree added to the document
		//		"all" - notified about all nodes added to the document
		has.add("MutationObserver", window.MutationObserver ? "MutationObserver" : window.WebKitMutationObserver ?
			"WebKitMutationObserver" : "");
		has.add("DOMNodeInserted", function () {
			var root = document.createElement("div"),
				child = document.createElement("div"),
				sawRoot, sawChild;
			root.id = "root";
			child.id = "child";
			root.appendChild(child);

			function listener(event) {
				if (event.target.id === "root") {
					sawRoot = true;
				}
				if (event.target.id === "child") {
					sawChild = true;
				}
			}

			document.body.addEventListener("DOMNodeInserted", listener);
			document.body.appendChild(root);
			document.body.removeChild(root);
			document.body.removeEventListener("DOMNodeInserted", listener);
			return sawChild ? "all" : sawRoot ? "root" : "";
		});

		// Can we use __proto__ to reset the prototype of DOMNodes?
		// It's not available on IE<11, and even on IE11 it makes the node's attributes
		// (ex: node.attributes, node.textContent) disappear, so disabling it on IE11 too.
		has.add("dom-proto-set", function () {
			var node = document.createElement("div");
			/* jshint camelcase: false */
			/* jshint proto: true */
			return !!node.__proto__;
			/* jshint camelcase: true */
			/* jshint proto: false */
		});

		// Support for <template> elements (specifically, that their content is available via templateNode.content
		// rather than templateNode.children[] etc.
		has.add("dom-template", !!document.createElement("template").content);
	}

	return has;
});
/** @module delite/register */
define('delite/register',[
	"module",
	"dcl/advise",
	"dcl/dcl",
	"decor/schedule",
	"requirejs-domready/domReady",	// loading as a function, not as a plugin
	"./features"
], function (module, advise, dcl, schedule, domReady, has) {
	"use strict";

	var doc = has("builder") ? require.nodeRequire(require.getNodePath(require.toUrl(module.id).replace(/[^\/]*$/,
		"node_modules/jsdom"))).jsdom("") : typeof document !=='undefined' ? document :null ;

	// Set to true after the page finishes loading and the parser runs.  Any widgets declared after initialParseComplete
	// instantiated in a separate code path.
	var initialParseComplete;

	// Workaround problem using dcl() on native DOMNodes on FF and IE,
	// see https://github.com/uhop/dcl/issues/9.
	// Fixes case where tabIndex is declared in a mixin that's passed to register().
	dcl.mix = function (a, b) {
		for (var n in b) {
			try {
				a[n] = b[n];
			} catch (e) {
				Object.defineProperty(a, n, {
					configurable: true,
					writable: true,
					enumerable: true,
					value: b[n]
				});
			}
		}
	};

	/**
	 * List of selectors that the parser needs to search for as possible upgrade targets.  Mainly contains
	 * the widget custom tags like d-accordion, but also selectors like button[is='d-button'] to find <button is="...">
	 * @type {string[]}
	 */
	var selectors = [];

	/**
	 * Internal registry of widget class metadata.
	 * Key is custom widget tag name, used as Element tag name like <d-accordion> or "is" attribute like
	 * <button is="d-accordion">).
	 * Value is metadata about the widget, including its prototype, ex: {prototype: object, extends: "button", ... }
	 * @type {Object}
	 */
	var registry = {};

	/**
	 * Create an Element.  Similar to document.createElement(), but if tag is the name of a widget defined by
	 * register(), then it upgrades the Element to be a widget.
	 * @function module:delite/register.createElement
	 * @param {string} tag
	 * @returns {Element} The DOMNode
	 */
	function createElement(tag) {
		if (/-/.test(tag) && !(tag in registry) && !has("builder")) {
			// Try to help people that have templates with custom elements but they forgot to do requires="..."
			console.warn("register.createElement(): undefined tag '" + tag +
				"', did you forget requires='...' in your template?");
		}

		var base = registry[tag] ? registry[tag].extends : null;
		if (has("document-register-element")) {
			return base ? doc.createElement(base, tag) : doc.createElement(tag);
		} else {
			var element = doc.createElement(base || tag);
			if (base) {
				element.setAttribute("is", tag);
			}
			upgrade(element);
			return element;
		}
	}

	/**
	 * Generate metadata about all the properties in proto, both direct and inherited.
	 * On IE<=10, these properties will be applied to a DOMNode via Object.defineProperties().
	 * Skips properties in the base element (HTMLElement, HTMLButtonElement, etc.)
	 * @param {Object} proto - The prototype.
	 * @returns {Object} Hash from property name to return value from `Object.getOwnPropertyDescriptor()`.
	 */
	function getPropDescriptors(proto) {
		var props = {};

		do {
			var keys = Object.getOwnPropertyNames(proto);	// better than Object.keys() because finds hidden props too
			for (var i = 0, k; (k = keys[i]); i++) {
				if (!props[k]) {
					props[k] = Object.getOwnPropertyDescriptor(proto, k);
				}
			}
			proto = Object.getPrototypeOf(proto);
		} while (!/HTML[a-zA-Z]*Element/.test(proto.constructor.toString()));

		return props;
	}

	/**
	 * Converts plain Element of custom type into "custom element", by adding the widget's custom methods, etc.
	 * Does nothing if the Element has already been converted or if it doesn't correspond to a registered custom tag.
	 * After the upgrade, calls `createdCallback()`.
	 *
	 * Usually the application will not need to call this method directly, because it's called automatically
	 * on page load and as elements are added to the document.
	 *
	 * @function module:delite/register.upgrade
	 * @param {Element} element - The DOM node.
	 * @param {boolean} [attach] - If `element`'s tag has been registered, but `attachedCallback()` hasn't yet been
	 * called [since the last call to `detachedCallback()`], then call `attachedCallback()`.  Call even if the element
	 * has already been upgraded.
	 */
	function upgrade(element, attach) {
		if (!has("document-register-element")) {
			var widget = registry[element.getAttribute("is") || element.nodeName.toLowerCase()];
			if (widget) {
				if (!element._upgraded) {
					if (has("dom-proto-set")) {
						// Redefine Element's prototype to point to widget's methods etc.
						/*jshint camelcase: false*/
						/*jshint proto: true*/
						element.__proto__ = widget.prototype;
						/*jshint camelcase: true*/
						/*jshint proto: false*/
					} else {
						// Mixin all the widget's methods etc. into Element
						Object.defineProperties(element, widget.props);
					}
					element._upgraded = true;
					if (element.createdCallback) {
						element.createdCallback();
					}
				}
				if (attach && !element._attached) {
					element.attachedCallback();
				}
			}
		}
	}

	/**
	 * Call detachedCallback() on specified Element if it's a custom element that was upgraded by us.
	 * @param {Element} node
	 */
	function detach(node) {
		if (node._upgraded) {
			node.detachedCallback();
		}
	}

	/**
	 * Mapping of tag names to HTMLElement interfaces.
	 * Doesn't include newer elements not available on all browsers.
	 * @type {Object}
	 */
	var tagMap = typeof HTMLElement !== "undefined" && {	// "typeof HTMLElement" check so module loads in NodeJS
		a: HTMLAnchorElement,
		// applet: HTMLAppletElement,
		// area: HTMLAreaElement,
		// audio: HTMLAudioElement,
		base: HTMLBaseElement,
		br: HTMLBRElement,
		button: HTMLButtonElement,
		canvas: HTMLCanvasElement,
		// data: HTMLDataElement,
		// datalist: HTMLDataListElement,
		div: HTMLDivElement,
		dl: HTMLDListElement,
		directory: HTMLDirectoryElement,
		// embed: HTMLEmbedElement,
		fieldset: HTMLFieldSetElement,
		font: HTMLFontElement,
		form: HTMLFormElement,
		head: HTMLHeadElement,
		h1: HTMLHeadingElement,
		html: HTMLHtmlElement,
		hr: HTMLHRElement,
		iframe: HTMLIFrameElement,
		img: HTMLImageElement,
		input: HTMLInputElement,
		// keygen: HTMLKeygenElement,
		label: HTMLLabelElement,
		legend: HTMLLegendElement,
		li: HTMLLIElement,
		link: HTMLLinkElement,
		map: HTMLMapElement,
		// media: HTMLMediaElement,
		menu: HTMLMenuElement,
		meta: HTMLMetaElement,
		// meter: HTMLMeterElement,
		ins: HTMLModElement,
		object: HTMLObjectElement,
		ol: HTMLOListElement,
		optgroup: HTMLOptGroupElement,
		option: HTMLOptionElement,
		// output: HTMLOutputElement,
		p: HTMLParagraphElement,
		param: HTMLParamElement,
		pre: HTMLPreElement,
		// progress: HTMLProgressElement,
		quote: HTMLQuoteElement,
		script: HTMLScriptElement,
		select: HTMLSelectElement,
		// source: HTMLSourceElement,
		// span: HTMLSpanElement,
		style: HTMLStyleElement,
		table: HTMLTableElement,
		caption: HTMLTableCaptionElement,
		// td: HTMLTableDataCellElement,
		// th: HTMLTableHeaderCellElement,
		col: HTMLTableColElement,
		tr: HTMLTableRowElement,
		tbody: HTMLTableSectionElement,
		textarea: HTMLTextAreaElement,
		// time: HTMLTimeElement,
		title: HTMLTitleElement,
		// track: HTMLTrackElement,
		ul: HTMLUListElement,
		// blink: HTMLUnknownElement,
		video: HTMLVideoElement
	};
	var tags = tagMap && Object.keys(tagMap);

	/**
	 * Registers the tag with the current document, and save tag information in registry.
	 * Handles situations where the base constructor inherits from
	 * HTMLElement but is not HTMLElement.
	 * @param  {string}   tag         The custom tag name for the element, or the "is" attribute value.
	 * @param  {string}	  _extends    The name of the tag this element extends, ex: "button" for <button is="...">
	 * @param  {string}   baseElement The native HTML*Element "class" that this custom element is extending.
	 * @param  {Function} baseCtor    The constructor function.
	 * @return {Function}             The "new" constructor function that can create instances of the custom element.
	 */
	function getTagConstructor(tag, _extends, baseElement, baseCtor) {
		var proto = baseCtor.prototype,
			config = registry[tag] = {
				constructor: baseCtor,
				prototype: proto
			};

		if (_extends) {
			config.extends = _extends;
		}

		if (has("document-register-element")) {
			doc.registerElement(tag, config);
		} else {
			if (!has("dom-proto-set")) {
				// Get descriptors for all the properties in the prototype.  This is needed on IE<=10 in upgrade().
				config.props = getPropDescriptors(proto);
			}
		}

		// Note: if we wanted to support registering new types after the parser was called, then here we should
		// scan the document for the new type (selectors[length-1]) and upgrade any nodes found.

		// Create a constructor method to return a DOMNode representing this widget.
		var tagConstructor = function (params) {
			// Create new widget node or upgrade existing node to widget
			var node = createElement(tag);

			// Set parameters on node
			for (var name in params || {}) {
				if (name === "style") {
					node.style.cssText = params.style;
				} else if ((name === "class" || name === "className") && node.setClassComponent) {
					node.setClassComponent("user", params[name]);
				} else {
					node[name] = params[name];
				}
			}
			if (node.deliver) {
				node.deliver();
			}

			return node;
		};

		// Add some flags for debugging and return the new constructor
		tagConstructor.tag = tag;
		tagConstructor._ctor = baseCtor;

		// Register the selector to find this custom element
		var selector = _extends ? _extends + "[is='" + tag + "']" : tag;
		selectors.push(selector);

		// If the document has already been parsed then do a supplementary sweep for this new custom element.
		if (initialParseComplete && !has("document-register-element")) {
			unobserve();	// pause listening for added/deleted nodes
			parse(doc, selector);
			observe();	// resume listening for added/deleted nodes
		}

		return tagConstructor;
	}

	/**
	 * Restore the "true" constructor when trying to recombine custom elements
	 * @param  {Function} extension A constructor function that might have a shadow property that contains the
	 *                              original constructor
	 * @return {Function}           The original construction function or the existing function/object
	 */
	function restore(extension) {
		return (extension && extension._ctor) || extension;
	}

	/**
	 * Declare a widget and register it as a custom element.
	 *
	 * props{} can provide custom setters/getters for widget properties, which are called automatically when
	 * the widget properties are set.
	 * For a property XXX, define methods _setXXXAttr() and/or _getXXXAttr().
	 *
	 * @param  {string}               tag             The custom element's tag name.
	 * @param  {Object[]}             superclasses    Any number of superclasses to be built into the custom element
	 *                                                constructor. But first one must be [descendant] of HTMLElement.
	 * @param  {Object}               props           Properties of this widget class.
	 * @return {Function}                             A constructor function that will create an instance of the custom
	 *                                                element.
	 * @function module:delite/register
	 */
	function register(tag, superclasses, props) {
		// Create the widget class by extending specified superclasses and adding specified properties.

		// Make sure all the bases have their proper constructors for being composited.
		// I.E. remove the wrapper added by getTagConstructor().
		var bases = (superclasses instanceof Array ? superclasses : superclasses ? [superclasses] : []).map(restore);


		// Check to see if the custom tag is already registered
		if (tag in registry) {
			throw new TypeError("A widget is already registered with tag '" + tag + "'.");
		}

		// Get root (aka native) class: HTMLElement, HTMLInputElement, etc.
		var baseElement = bases[0];
		if (baseElement.prototype && baseElement.prototype._baseElement) {
			// The first superclass is a widget created by another call to register, so get that widget's root class
			baseElement = baseElement.prototype._baseElement;
		}

		// Get name of tag that this widget extends, for example <button is="..."> --> "button"
		var _extends;
		if (baseElement !== HTMLElement) {
			_extends = tags.filter(function (tag) {
				return tagMap[tag] === baseElement;
			})[0];
			if (!_extends) {
				throw new TypeError(tag + ": must have HTMLElement in prototype chain");
			}
		}

		// Get a composited constructor
		var ctor = dcl(bases, props || {}),
			proto = ctor.prototype;
		proto._ctor = ctor;
		proto._baseElement = baseElement;
		proto._tag = tag;
		proto._extends = _extends;

		// Monkey-patch attachedCallback() and detachedCallback() to avoid double executions.
		// Generally this isn't an issue, but it could happen if the app manually called the functions
		// and then they were called automatically too.
		advise.around(proto, "attachedCallback", function (sup) {
			return function () {
				if (this._attached) { return; }
				if (sup) { sup.apply(this, arguments); }
				this._attached = true;
			};
		});
		advise.around(proto, "detachedCallback", function (sup) {
			return function () {
				if (!this._attached) { return; }
				if (sup) { sup.apply(this, arguments); }
				this._attached = false;
			};
		});

		// Run introspection to add ES5 getters/setters.
		// Doesn't happen automatically because Stateful's constructor isn't called.
		// Also, on IE this needs to happen before the getTagConstructor() call,
		// since getTagConstructor() scans all the properties on the widget prototype.
		if (proto.introspect) {
			ctor._propsToObserve = proto.getProps();
			proto.introspect(ctor._propsToObserve);
			ctor.introspected = true;
		}

		// Save widget metadata to the registry and return constructor that creates an upgraded DOMNode for the widget
		/* jshint boss:true */
		return getTagConstructor(tag, _extends, baseElement, ctor);
	}

	/**
	 * Parse the given DOM tree for any Elements that need to be upgraded to widgets.
	 * Searches all descendants of the specified node, but does not upgrade the node itself.
	 *
	 * Usually the application will not need to call this method directly, because it's called automatically
	 * on page load and as elements are added to the document.
	 *
	 * @function module:delite/register.parse
	 * @param {Element} [root] DOM node to parse from.
	 * @param {String} [selector] The selector to use to detect custom elements.  Defaults to selector
	 * for all registered custom elements.
	 */
	function parse(root, selector) {
		if (has("document-register-element")) { return; }
		selector = selector || selectors.join(", ");
		if (selector) {
			var node, idx = 0, nodes = (root || doc).querySelectorAll(selector);
			while ((node = nodes[idx++])) {
				upgrade(node, true);
			}
		}
	}

	// ------------------------
	// Code to listen for nodes being added/deleted from the document, to automatically call parse()/detachedCallback()
	var observer;

	/**
	 * Start listening for added/deleted nodes.
	 */
	function observe() {
		if (!has("document-register-element")) {
			if (!observer) {
				if (has("MutationObserver")) {
					observer = new MutationObserver(processMutations);
				} else {
					// Fallback for Android < 4.2 and IE < 11.  Partial shim of MutationObserver, except sometimes
					// addedNodes lists all nodes not just the root of each added tree.
					observer = {
						takeRecords: function () {
							var ret = this._mutations;
							this._mutations = [];
							if (this._timer) {
								this._timer.remove();
								this._timer = null;
							}
							return ret;
						},
						observe: function () {
							this._mutations = [];
							this._listener = function (event) {
								if (event.target.nodeType === 1) {
									var mutation = {};
									mutation[event.type === "DOMNodeInserted" ? "addedNodes" : "removedNodes"] =
										[event.target];
									this._mutations.push(mutation);
								}
								if (!this._timer) {
									this._timer = schedule(function () {
										this._timer = null;
										processMutations(this.takeRecords());
									}.bind(this));
								}
							}.bind(this);
							doc.body.addEventListener("DOMNodeInserted", this._listener);
							doc.body.addEventListener("DOMNodeRemoved", this._listener);
						},
						disconnect: function () {
							doc.body.removeEventListener("DOMNodeInserted", this._listener);
							doc.body.removeEventListener("DOMNodeRemoved", this._listener);
						}
					};
				}
			}
			observer.observe(doc.body, {childList: true, subtree: true});
		}
	}

	/**
	 * Stop (aka pause) listening for added/deleted nodes.
	 */
	function unobserve() {
		if (observer) {
			// TODO: This method is supposed to pause listening for DOM updates,
			// but I suspect disconnect() also throws away records
			// for any mutations that have already occurred.   Those records need to be saved or processed.
			observer.disconnect();
		}
	}

	/**
	 * Process the added/deleted nodes.  Called for incremental updates after initial parse.
	 * @param mutations
	 */
	function processMutations(mutations) {
		if (!has("document-register-element") && selectors.length) {
			unobserve();	// pause listening for added/deleted nodes
			var parseDescendants = has("MutationObserver") || has("DOMNodeInserted") === "root";
			mutations.forEach(function (mutation) {
				var added, idx1 = 0;
				while ((added = mutation.addedNodes && mutation.addedNodes[idx1++])) {
					// contains() checks avoid calling attachedCallback() on nodes not attached to document because:
					//		1. node was added then removed before processMutations() was called
					//		2. node was added and then its ancestor was removed before processMutations() was called
					if (added.nodeType === 1 && added.ownerDocument.body.contains(added)) {
						// upgrade the node itself (if it's a custom widget and it hasn't been upgraded yet),
						// and then call attachedCallback() on it
						upgrade(added, true);

						// upgrade any descendants that are custom widgets (if they aren't already upgraded),
						// and then call attachedCallback() on them
						if (parseDescendants) {
							parse(added);
						}
					}
				}

				var removedRoot, idx2 = 0;
				while ((removedRoot = mutation.removedNodes && mutation.removedNodes[idx2++])) {
					if (removedRoot.nodeType === 1) {
						detach(removedRoot);
						var removed, idx3 = 0, removedDescendants = removedRoot.querySelectorAll(selectors.join(", "));
						while ((removed = removedDescendants[idx3++])) {
							detach(removed);
						}
					}
				}
			});
			observe();	// resume listening for added/deleted nodes
		}
	}

	/**
	 * Upgrade any custom tags in the document that have not yet been upgraded.
	 * Nodes are automatically updated asynchronously, but applications can synchronously update them by calling
	 * this method.  Should not be called before domReady event.
	 */
	function deliver() {
		if (!has("document-register-element")) {
			if (!initialParseComplete) {
				parse();
				initialParseComplete = true;
				observe();
			} else {
				processMutations(observer.takeRecords());
			}
		}
	}

	// Setup initial parse of document and also listeners for future document modifications.
	if (!has("document-register-element") && doc) {
		domReady(function () {
			if (!has("dom-template")) {
				// Move <template> child nodes to .content property, so that we don't parse custom elements in
				// <template> nodes.  Could be done on dynamically created nodes too, but currently there's no need.
				var template, idx = 0, nodes = doc.querySelectorAll("template");
				while ((template = nodes[idx++])) {
					if (!template.content) {
						var child, content = template.content = doc.createDocumentFragment();
						while ((child = template.firstChild)) {
							content.appendChild(child);
						}
					}
				}
			}

			// Upgrade all custom element nodes, and setup listeners for future changes.
			deliver();
		});
	}

	// Setup return value as register() method, with other methods hung off it.
	register.upgrade = upgrade;
	register.createElement = createElement;
	register.parse = parse;
	register.deliver = deliver;

	// Add helpers from dcl for declaring classes.

	/**
	 * Convenience shortcut to [dcl()](http://www.dcljs.org/docs/mini_js/dcl/).
	 * @function module:delite/register.dcl
	 */
	register.dcl = dcl;

	/**
	 * Convenience shortcut to [dcl.after()](http://www.dcljs.org/docs/dcl_js/after/).
	 * @function module:delite/register.after
	 */
	register.after = dcl.after;

	/**
	 * Convenience shortcut to [dcl.before()](http://www.dcljs.org/docs/dcl_js/before/).
	 * @function module:delite/register.before
	 */
	register.before = dcl.before;

	/**
	 * Convenience shortcut to [dcl.around()](http://www.dcljs.org/docs/dcl_js/around/).
	 * @function module:delite/register.around
	 */
	register.around = dcl.around;

	/**
	 * Convenience shortcut to [dcl.superCall()](http://www.dcljs.org/docs/mini_js/supercall/).
	 * @function module:delite/register.superCall
	 */
	register.superCall = dcl.superCall;

	return register;
});


/** @module decor/Observable */
define('decor/Observable',[
	"./features",
	"./features!object-observe-api?:./schedule"
], function (has, schedule) {
	"use strict";

	/**
	 * An observable object, working as a shim
	 * of {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Object.observe()}.
	 * @class
	 * @alias module:decor/Observable
	 * @param {Object} o The object to mix-into the new Observable.
	 * @example
	 *     var observable = new Observable({foo: "Foo0"});
	 *     Observable.observe(observable, function (changeRecords) {
	 *         // Called at the end of microtask with:
	 *         //     [
	 *         //         {
	 *         //             type: "update",
	 *         //             object: observable,
	 *         //             name: "foo",
	 *         //             oldValue: "Foo0"
	 *         //         },
	 *         //         {
	 *         //             type: "add",
	 *         //             object: observable,
	 *         //             name: "bar"
	 *         //         }
	 *         //     ]
	 *     });
	 *     observable.set("foo", "Foo1");
	 *     observable.set("bar", "Bar0");
	 */
	var Observable,
		defineProperty = Object.defineProperty,
		getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	/**
	 * The default list of change record types, which is:
	 * [
	 *     "add",
	 *     "update",
	 *     "delete",
	 *     "reconfigure",
	 *     "setPrototype",
	 *     "preventExtensions"
	 * ]
	 * @constant {Array.<module:decor/Observable~ChangeType>}
	 *     module:decor/Observable~DEFAULT_CHANGETYPES
	 */
	var DEFAULT_ACCEPT_CHANGETYPES = {
		"add": 1,
		"update": 1,
		"delete": 1,
		"reconfigure": 1,
		"setPrototype": 1,
		"preventExtensions": 1
	}; // Observable#set() only supports the first two

	/**
	 * Change record type.
	 * One of:
	 * * "add"
	 * * "update"
	 * * "delete"
	 * * "reconfigure"
	 * * "setPrototype"
	 * * "preventExtensions"
	 * * "splice"
	 * @typedef {string} module:decor/Observable~ChangeType
	 */

	/**
	 * Change record seen in Observable.observe().
	 * @typedef {Object} module:decor/Observable~ChangeRecord
	 * @property {module:decor/Observable~ChangeType} type The type of change record.
	 * @property {Object} object The changed object.
	 * @property {string} [name] The changed property name. Set only for non-splice type of change records.
	 * @property {number} [index] The array index of splice. Set only for splice type of change records.
	 * @property {Array} [removed] The removed array elements. Set only for splice type of change records.
	 * @property {number} [addedCount] The count of added array elements. Set only for splice type of change records.
	 */

	/**
	 * Change callback.
	 * @callback module:decor/Observable~ChangeCallback
	 * @param {Array.<module:decor/Observable~ChangeRecord>} changeRecords The change records.
	 */

	Observable = function (o) {
		// Make Observable marker not enumerable, configurable or writable
		if (!this._observable) { // In case this constructor is called manually
			defineProperty(this, "_observable", {value: 1});
		}
		o && Observable.assign(this, o);
	};

	/**
	 * @method module:decor/Observable.test
	 * @param {Object} o The object to test.
	 * @returns {boolean} true if o is an instance of Observable.
	 */
	Observable.test = function (o) {
		return o && o._observable;
	};

	/**
	 * @method module:decor/Observable.is
	 * @returns {boolean} true if the given two values are the same, considering NaN as well as +0 vs. -0.
	 */
	Observable.is = has("object-is-api") ? Object.is : function (lhs, rhs) {
		return lhs === rhs && (lhs !== 0 || 1 / lhs === 1 / rhs) || lhs !== lhs && rhs !== rhs;
	};

	/**
	 * Copy properties of given source objects to given target object.
	 * If target object has {@link module:decor/Observable#set set()} function for the property, uses it.
	 * @function module:decor/Observable.assign
	 * @param {Object} dst The target object.
	 * @param {...Object} var_args The source objects.
	 * @returns {Object} The target object.
	 */
	Observable.assign = function (dst) {
		if (dst == null) {
			throw new TypeError("Can't convert " + dst + " to object.");
		}
		dst = Object(dst);
		for (var i = 1, l = arguments.length; i < l; ++i) {
			var src = Object(arguments[i]),
				props = Object.getOwnPropertyNames(src);
			for (var j = 0, m = props.length; j < m; ++j) {
				var prop = props[j];
				Observable.prototype.set.call(dst, prop, src[prop]);
			}
		}
		return dst;
	};

	/**
	 * @method module:decor/Observable.canObserve
	 * @param {Object} o The object to test.
	 * @returns {boolean} true if o can be observed with {@link module:decor/Observable.observe Observable.observe()}.
	 */
	if (has("object-observe-api")) {
		Observable.canObserve = function (o) {
			return typeof o === "object" && o != null;
		};
	} else {
		Observable.canObserve = Observable.test;
	}

	if (has("object-observe-api")) {
		defineProperty(Observable.prototype, "set", { // Make set() not enumerable
			value: function (name, value) {
				this[name] = value;
				return value;
			},
			configurable: true,
			writable: true
		});

		Observable.observe = function (object, callback, accept) {
			Object.observe.call(this, object, callback, accept);
			return {
				remove: function () {
					Object.unobserve(object, callback);
				}
			};
		};

		Observable.getNotifier = Object.getNotifier;
		Observable.deliverChangeRecords = Object.deliverChangeRecords;
	} else {
		defineProperty(Observable.prototype, "set", { // Make set() not enumerable
			/**
			 * Sets a value.
			 * Automatically emits change record(s)
			 * compatible with {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe Object.observe()}
			 * if no ECMAScript setter is defined for the given property.
			 * If ECMAScript setter is defined for the given property, use
			 * {@link module:decor/Observable~Notifier#notify Observable.getNotifier(observable).notify(changeRecord)}
			 * to manually emit a change record.
			 * @method module:decor/Observable#set
			 * @param {string} name The property name.
			 * @param value The property value.
			 * @returns The value set.
			 */
			value: function (name, value) {
				var type = name in this ? "update" : "add",
					oldValue = this[name],
					// For defining setter, ECMAScript setter should be used
					setter = (getOwnPropertyDescriptor(this, name) || {}).set;
				this[name] = value;
				if (!Observable.is(value, oldValue) && setter === undefined) {
					// Auto-notify if there is no setter defined for the property.
					// Application should manually call Observable.getNotifier(observable).notify(changeRecord)
					// if a setter is defined.
					var changeRecord = {
						type: type,
						object: this,
						name: name + ""
					};
					if (type === "update") {
						changeRecord.oldValue = oldValue;
					}
					Observable.getNotifier(this).notify(changeRecord);
				}
				return value;
			},
			configurable: true,
			writable: true
		});

		var seq = 0,
			hotCallbacks = {},
			deliverHandle = null,
			deliverAllByTimeout = function () {
				/* global Platform */
				has("polymer-platform") && Platform.performMicrotaskCheckpoint(); // For Polymer watching for Observable
				for (var anyWorkDone = true; anyWorkDone;) {
					anyWorkDone = false;
					// Observation may stop during observer callback
					var callbacks = [];
					for (var s in hotCallbacks) {
						callbacks.push(hotCallbacks[s]);
					}
					hotCallbacks = {};
					callbacks = callbacks.sort(function (lhs, rhs) {
						return lhs._seq - rhs._seq;
					});
					for (var i = 0, l = callbacks.length; i < l; ++i) {
						if (callbacks[i]._changeRecords.length > 0) {
							Observable.deliverChangeRecords(callbacks[i]);
							anyWorkDone = true;
						}
					}
				}
				deliverHandle = null;
			},
			removeGarbageCallback = function (callback) {
				if (callback._changeRecords.length === 0 && callback._refCountOfNotifier === 0) {
					callback._seq = undefined;
				}
			};

		/**
		 * Notifier object for Observable.
		 * This is an internal function and cannot be used directly.
		 * @class module:decor/Observable~Notifier
		 */
		var Notifier = function (target) {
			this.target = target;
			this.observers = {};
			this._activeChanges = {};
		};

		Notifier.prototype = /** @lends module:decor/Observable~Notifier */ {
			/**
			 * Queue up a change record.
			 * It will be notified at the end of microtask,
			 * or when {@link module:decor/Observable.deliverChangeRecords Observable.deliverChangeRecords()}
			 * is called.
			 * @method module:decor/Observable~Notifier#notify
			 * @param {module:decor/Observable~ChangeRecord} changeRecord
			 *     The change record to queue up for notification.
			 */
			notify: function (changeRecord) {
				function shouldDeliver(activeChanges, acceptTable, changeType) {
					if (changeType in acceptTable) {
						for (var s in acceptTable) {
							if (activeChanges[s] > 0) {
								return false;
							}
						}
						return true;
					}
				}
				for (var s in this.observers) {
					if (shouldDeliver(this._activeChanges, this.observers[s].acceptTable, changeRecord.type)) {
						var callback = this.observers[s].callback;
						callback._changeRecords.push(changeRecord);
						hotCallbacks[callback._seq] = callback;
						if (!deliverHandle) {
							deliverHandle = schedule(deliverAllByTimeout);
						}
					}
				}
			},
			/**
			 * Let the series of changes made in the given callback be represented
			 * by a synthetic change of the given change type.
			 * The callback may return the synthetic change record,
			 * which will be of the `type` and automatically emitted.
			 * Otherwise, the caller can emit the synthetic record manually
			 * via {@link module:decor/Observable~Notifier#notify notify()}.
			 * @param {string} type The change type of synthetic change record.
			 * @param {Function} callback The callback function.
			 */
			performChange: function (type, callback) {
				this._activeChanges[type] = (this._activeChanges[type] || 0) + 1;
				var source = callback.call(undefined);
				--this._activeChanges[type];
				if (source) {
					var target = {
						type: type,
						object: this.target
					};
					for (var s in source) {
						if (!(s in target)) {
							target[s] = source[s];
						}
					}
					this.notify(target);
				}
			}
		};

		/**
		 * Obtains a notifier object for the given {@link module:decor/Observable Observable}.
		 * @method module:decor/Observable.getNotifier
		 * @param {Object} observable The {@link module:decor/Observable Observable} to get a notifier object of.
		 * @returns {module:decor/Observable~Notifier}
		 */
		Observable.getNotifier = function (observable) {
			if (!getOwnPropertyDescriptor(observable, "_notifier")) {
				// Make the notifier reference not enumerable, configurable or writable
				defineProperty(observable, "_notifier", {
					value: new Notifier(observable)
				});
			}
			return observable._notifier;
		};

		/**
		 * Observes an {@link module:decor/Observable Observable} for changes.
		 * @method module:decor/Observable.observe
		 * @param {Object} observable The {@link module:decor/Observable Observable} to observe.
		 * @param {module:decor/Observable~ChangeCallback} callback The change callback.
		 * @param {Array.<module:decor/Observable~ChangeType>}
		 *     [accept={@link module:decor/Observable~DEFAULT_CHANGETYPES}]
		 *     The list of change record types to observe.
		 * @returns {Handle} The handle to stop observing.
		 * @throws {TypeError} If the 1st argument is non-object or null.
		 */
		Observable.observe = function (observable, callback, accept) {
			if (Object(observable) !== observable) {
				throw new TypeError("Observable.observe() cannot be called on non-object.");
			}
			if (!("_seq" in callback)) {
				callback._seq = seq++;
				callback._changeRecords = [];
				callback._refCountOfNotifier = 0;
			}
			var acceptTable = accept ? accept.reduce(function (types, type) {
					types[type] = 1;
					return types;
				}, {}) : DEFAULT_ACCEPT_CHANGETYPES,
				notifier = Observable.getNotifier(observable);
			if (!(callback._seq in notifier.observers)) {
				notifier.observers[callback._seq] = {
					acceptTable: acceptTable,
					callback: callback
				};
				++callback._refCountOfNotifier;
			} else {
				notifier.observers[callback._seq].acceptTable = acceptTable;
			}
			return {
				remove: function () {
					if (callback._seq in notifier.observers) {
						delete notifier.observers[callback._seq];
						--callback._refCountOfNotifier;
					}
				}
			};
		};

		/**
		 * Delivers change records immediately.
		 * @method module:decor/Observable.deliverChangeRecords
		 * @param {Function} callback The change callback to deliver change records of.
		 */
		Observable.deliverChangeRecords = function (callback) {
			var length = callback._changeRecords.length;
			try {
				callback(callback._changeRecords.splice(0, length));
			} catch (e) {
				has("console-api") && console.error("Error occured in observer callback: " + (e.stack || e));
			}
			removeGarbageCallback(callback);
		};
	}

	return Observable;
});

/** @module decor/Destroyable */
define('decor/Destroyable',[
	"dcl/advise",
	"dcl/dcl"
], function (advise, dcl) {
	/**
	 * Mixin to track handles and release them when instance is destroyed.
	 *
	 * Call `this.own(...)` on list of handles (returned from dcl/advise, dojo/on,
	 * decor/Stateful#observe, or any class (including widgets) with a destroy() or remove() method.
	 * Then call `destroy()` later to destroy this instance and release the resources.
	 * @mixin module:decor/Destroyable
	 */
	var Destroyable = dcl(null, /** @lends module:decor/Destroyable# */ {
		/**
		 * Destroy this class, releasing any resources registered via `own()`.
		 * @method
		 */
		destroy: dcl.advise({
			before: function () {
				this._beingDestroyed = true;
				this._releaseHandles();
			},
			after: function () {
				this._destroyed = true;
			}
		}),

		_releaseHandles: function () {
		},

		/**
		 * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
		 * already removed/destroyed manually.
		 * @returns {Object[]} The array of specified handles, so you can do for example:
		 * `var handle = this.own(on(...))[0];`
		 * @protected
		 */
		own: function () {
			var cleanupMethods = [
				"destroy",
				"remove",
				"cancel"
			];

			// transform arguments into an Array
			var ary = Array.prototype.slice.call(arguments);
			ary.forEach(function (handle) {
				// When this.destroy() is called, destroy handle.  Since I'm using advise.before(),
				// the handle will be destroyed before a subclass's destroy() method starts running, before it calls
				// this.inherited() or even if it doesn't call this.inherited() at all.  If that's an issue, make an
				// onDestroy() method and connect to that instead.
				var destroyMethodName;
				var odh = advise.after(this, "_releaseHandles", function () {
					handle[destroyMethodName]();
				});

				// Callback for when handle is manually destroyed.
				var hdhs = [];

				function onManualDestroy() {
					odh.destroy();
					hdhs.forEach(function (hdh) {
						hdh.destroy();
					});
				}

				// Setup listeners for manual destroy of handle.
				// Also compute destroyMethodName, used in listener above.
				if (handle.then) {
					// Special path for Promises.  Detect when Promise is settled.
					handle.then(onManualDestroy, onManualDestroy);
				}
				cleanupMethods.forEach(function (cleanupMethod) {
					if (typeof handle[cleanupMethod] === "function") {
						if (!destroyMethodName) {
							// Use first matching method name in above listener.
							destroyMethodName = cleanupMethod;
						}
						if (!handle.then) {
							// Path for non-promises.  Use AOP to detect when handle is manually destroyed.
							hdhs.push(advise.after(handle, cleanupMethod, onManualDestroy));
						}
					}
				});
			}, this);

			return ary;
		},

		/**
		 * Wrapper to setTimeout to avoid deferred functions executing
		 * after the originating widget has been destroyed.
		 * @param {Function} fcn - Function to be executed after specified delay (or 0ms if no delay specified).
		 * @param {number} delay - Delay in ms, defaults to 0.
		 * @returns {Object} Handle with a remove method that deschedules the callback from being called.
		 * @protected
		 */
		defer: function (fcn, delay) {
			// TODO: if delay unspecified, use schedule?
			var timer = setTimeout(
				function () {
					if (!timer) {
						return;
					}
					timer = null;
					if (!this._destroyed) {
						fcn.call(this);
					}
				}.bind(this),
					delay || 0
			);
			return {
				remove: function () {
					if (timer) {
						clearTimeout(timer);
						timer = null;
					}
					return null; // so this works well: handle = handle.remove();
				}
			};
		}
	});

	dcl.chainBefore(Destroyable, "destroy");

	return Destroyable;
});

/** @module decor/Stateful */
define('decor/Stateful',[
	"dcl/advise",
	"dcl/dcl",
	"./features",
	"./Observable"
], function (advise, dcl, has, Observable) {
	var apn = {};

	/**
	 * Helper function to map "foo" --> "_setFooAttr" with caching to avoid recomputing strings.
	 */
	function propNames(name) {
		if (apn[name]) {
			return apn[name];
		}
		var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function (c) {
			return c.charAt(c.length - 1).toUpperCase();
		});
		var ret = apn[name] = {
			p: "_shadow" + uc + "Attr",	// shadow property, since real property hidden by setter/getter
			s: "_set" + uc + "Attr",	// converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
			g: "_get" + uc + "Attr"
		};
		return ret;
	}

	/**
	 * Utility function for notification.
	 */
	function notify(stateful, name, oldValue) {
		Observable.getNotifier(stateful).notify({
			// Property is never new because setting up shadow property defines the property
			type: "update",
			object: stateful,
			name: name + "",
			oldValue: oldValue
		});
	}

	var REGEXP_IGNORE_PROPS = /^constructor$|^_set$|^_get$|^deliver$|^discardChanges$|^_(.+)Attr$/;

	/**
	 * Base class for objects that provide named properties with optional getter/setter
	 * control and the ability to observe for property changes.
	 *
	 * The class also provides the functionality to auto-magically manage getters
	 * and setters for class attributes/properties.  Note though that expando properties
	 * (i.e. properties added to an instance but not in the prototype) are not supported.
	 *
	 * Getters and Setters should follow the format of `_setXxxAttr` or `_getXxxAttr` where
	 * the xxx is a name of the attribute to handle.  So an attribute of `foo`
	 * would have a custom getter of `_getFooAttr` and a custom setter of `_setFooAttr`.
	 * Setters must save and announce the new property value by calling `this._set("foo", val)`,
	 * and getters should access the property value as `this._get("foo")`.
	 *
	 * @example <caption>Example 1</caption>
	 * var MyClass = dcl(Stateful, { foo: "initial" });
	 * var obj = new MyClass();
	 * obj.observe(function(oldValues){
	 *    if ("foo" in oldValues) {
	 *      console.log("foo changed to " + this.foo);
	 *    }
	 * });
	 * obj.foo = bar;
	 * // Stateful by default interprets the first parameter passed to
	 * // the constructor as a set of properties to set on the widget 
	 * // immediately after it is created.
	 *
	 * @example <caption>Example 2</caption>
	 * var MyClass = dcl(Stateful, { foo: "initial" });
	 * var obj = new MyClass({ foo: "special"});
	 *
	 * @mixin module:decor/Stateful
	 */
	var Stateful = dcl(null, /** @lends module:decor/Stateful# */ {
		/**
		 * Returns a hash of properties that should be observed.
		 * @returns {Object} Hash of properties.
		 * @protected
		 */
		getProps: function () {
			var hash = {};
			for (var prop in this) {
				if (!REGEXP_IGNORE_PROPS.test(prop)) {
					hash[prop] = true;
				}
			}
			return hash;
		},

		/**
		 * Sets up ES5 getters/setters for each class property.
		 * Inside introspect(), "this" is a reference to the prototype rather than any individual instance.
		 * @param {Object} props - Hash of properties.
		 * @protected
		 */
		introspect: function (props) {
			Object.keys(props).forEach(function (prop) {
				var names = propNames(prop),
					shadowProp = names.p,
					getter = names.g,
					setter = names.s;

				// Setup ES5 getter and setter for this property, if not already setup.
				// For a property named foo, saves raw value in _fooAttr.
				// ES5 setter intentionally does late checking for this[names.s] in case a subclass sets up a
				// _setFooAttr method.
				if (!(shadowProp in this)) {
					this[shadowProp] = this[prop];
					delete this[prop]; // make sure custom setters fire
					Object.defineProperty(this, prop, {
						enumerable: true,
						set: function (x) {
							setter in this ? this[setter](x) : this._set(prop, x);
						},
						get: function () {
							return getter in this ? this[getter]() : this[shadowProp];
						}
					});
				}
			}, this);
		},

		constructor: dcl.advise({
			before: function () {
				// First time this class is instantiated, introspect it.
				// Use _introspected flag on constructor, rather than prototype, to avoid hits when superclass
				// was already inspected but this class wasn't.
				var ctor = this.constructor;
				if (!ctor._introspected) {
					// note: inside getProps() and introspect(), this refs prototype
					ctor._props = ctor.prototype.getProps();
					ctor.prototype.introspect(ctor._props);
					ctor._introspected = true;
				}
				Observable.call(this);
			},

			after: function (args) {
				// Automatic setting of params during construction.
				// In after() advice so that it runs after all the subclass constructor methods.
				this.processConstructorParameters(args);
			}
		}),

		/**
		 * Called after Object is created to process parameters passed to constructor.
		 * @protected
		 */
		processConstructorParameters: function (args) {
			if (args.length) {
				this.mix(args[0]);
			}
		},

		/**
		 * Set a hash of properties on a Stateful instance.
		 * @param {Object} hash - Hash of properties.
		 * @example
		 * myObj.mix({
		 *     foo: "Howdy",
		 *     bar: 3
		 * });
		 */
		mix: function (hash) {
			for (var x in hash) {
				if (hash.hasOwnProperty(x)) {
					this[x] = hash[x];
				}
			}
		},

		/**
		 * Internal helper for directly setting a property value without calling the custom setter.
		 *
		 * Directly changes the value of an attribute on an object, bypassing any
		 * accessor setter.  Also notifies callbacks registered via observe().
		 * Custom setters should call `_set` to actually record the new value.
		 * @param {string} name - The property to set.
		 * @param {*} value - Value to set the property to.
		 * @protected
		 */
		_set: function (name, value) {
			var shadowPropName = propNames(name).p,
				oldValue = this[shadowPropName];
			this[shadowPropName] = value;
			// Even if Object.observe() is natively available,
			// automatic change record emission won't happen if there is a ECMAScript setter
			!Observable.is(value, oldValue) && notify(this, name, oldValue);
		},

		/**
		 * Internal helper for directly accessing an attribute value.
		 *
		 * Directly gets the value of an attribute on an object, bypassing any accessor getter.
		 * It is designed to be used by descendant class if they want
		 * to access the value in their custom getter before returning it.
		 * @param {string} name - Name of property.
		 * @returns {*} Value of property.
		 * @protected
		 */
		_get: function (name) {
			return this[propNames(name).p];
		},

		/**
		 * Notifies current values to observers for specified property name(s).
		 * Handy to manually schedule invocation of observer callbacks when there is no change in value.
		 * @method module:decor/Stateful#notifyCurrentValue
		 * @param {...string} name The property name.
		 */
		notifyCurrentValue: function () {
			Array.prototype.forEach.call(arguments, function (name) {
				notify(this, name, this[propNames(name).p]);
			}, this);
		},

		/**
		 * Get list of properties that Stateful#observe() should observe.
		 * @returns {string[]} list of properties
		 * @protected
		 */
		getPropsToObserve: function () {
			return this.constructor._props;
		},

		/**
		 * Observes for change in properties.
		 * Callback is called at the end of micro-task of changes with a hash table of
		 * old values keyed by changed property.
		 * Multiple changes to a property in a micro-task are squashed.
		 * @method module:decor/Stateful#observe
		 * @param {function} callback The callback.
		 * @returns {module:decor/Stateful.PropertyListObserver}
		 *     The observer that can be used to stop observation
		 *     or synchronously deliver/discard pending change records.
		 * @example
		 *     var stateful = new (dcl(Stateful, {
		 *             foo: undefined,
		 *             bar: undefined,
		 *             baz: undefined
		 *         }))({
		 *             foo: 3,
		 *             bar: 5,
		 *             baz: 7
		 *         });
		 *     stateful.observe(function (oldValues) {
		 *         // oldValues is {foo: 3, bar: 5, baz: 7}
		 *     });
		 *     stateful.foo = 4;
		 *     stateful.bar = 6;
		 *     stateful.baz = 8;
		 *     stateful.foo = 6;
		 *     stateful.bar = 8;
		 *     stateful.baz = 10;
		 */
		observe: function (callback) {
			// create new listener
			var h = new Stateful.PropertyListObserver(this, this.getPropsToObserve());
			h.open(callback, this);

			// make this.deliver() and this.discardComputing() call deliver() and discardComputing() on new listener
			var a1 = advise.after(this, "deliver", h.deliver.bind(h)),
				a2 = advise.after(this, "discardChanges", h.discardChanges.bind(h));
			advise.before(h, "close", function () {
				a1.unadvise();
				a2.unadvise();
			});

			return h;
		},

		/**
		 * Synchronously deliver change records to all listeners registered via `observe()`.
		 */
		deliver: function () {
		},

		/**
		 * Discard change records for all listeners registered via `observe()`.
		 */
		discardChanges: function () {
		}
	});

	dcl.chainAfter(Stateful, "introspect");

	/**
	 * An observer to observe a set of {@link module:decor/Stateful Stateful} properties at once.
	 * This class is what {@link module:decor/Stateful#observe} returns.
	 * @class module:decor/Stateful.PropertyListObserver
	 * @param {Object} o - The {@link module:decor/Stateful Stateful} being observed.
	 * @param {Object} props - Hash of properties to observe.
	 */
	Stateful.PropertyListObserver = function (o, props) {
		this.o = o;
		this.props = props;
	};

	Stateful.PropertyListObserver.prototype = {
		/**
		 * Starts the observation.
		 * {@link module:decor/Stateful#observe `Stateful#observe()`} calls this method automatically.
		 * @method module:decor/Stateful.PropertyListObserver#open
		 * @param {function} callback The change callback.
		 * @param {Object} thisObject The object that should work as "this" object for callback.
		 */
		open: function (callback, thisObject) {
			var props = this.props;
			this._boundCallback = function (records) {
				if (!this._closed && !this._beingDiscarded) {
					var oldValues = {};
					records.forEach(function (record) {
						// for consistency with platforms w/out native Object.observe() support,
						// only notify about updates to properties in prototype (see getProps())
						if (record.name in props && !(record.name in oldValues)) {
							oldValues[record.name] = record.oldValue;
						}
					});
					/* jshint unused: false */
					for (var s in oldValues) {
						callback.call(thisObject, oldValues);
						break;
					}
				}
			}.bind(this);
			this._h = Observable.observe(this.o, this._boundCallback);
			return this.o;
		},

		/**
		 * Synchronously delivers pending change records.
		 * @method module:decor/Stateful.PropertyListObserver#deliver
		 */
		deliver: function () {
			this._boundCallback && Observable.deliverChangeRecords(this._boundCallback);
		},

		/**
		 * Discards pending change records.
		 * @method module:decor/Stateful.PropertyListObserver#discardChanges
		 */
		discardChanges: function () {
			this._beingDiscarded = true;
			this._boundCallback && Observable.deliverChangeRecords(this._boundCallback);
			this._beingDiscarded = false;
			return this.o;
		},

		/**
		 * Does nothing, just exists for API compatibility with liaison and other data binding libraries.
		 * @method module:decor/Stateful.PropertyListObserver#setValue
		 */
		setValue: function () {},

		/**
		 * Stops the observation.
		 * @method module:decor/Stateful.PropertyListObserver#close
		 */
		close: function () {
			if (this._h) {
				this._h.remove();
				this._h = null;
			}
			this._closed = true;
		}
	};

	/**
	 * Synonym for {@link module:decor/Stateful.PropertyListObserver#close `close()`}.
	 * @method module:decor/Stateful.PropertyListObserver#remove
	 */
	Stateful.PropertyListObserver.prototype.remove = Stateful.PropertyListObserver.prototype.close;

	return Stateful;
});

/** @module delite/on */
define('delite/on',[],function () {
	/**
	 * Call specified function when event occurs.
	 * @param {Element} [node] - Element to attach handler to.
	 * @param {string} type - Name of event (ex: "click").
	 * @param {Function} callback - Callback function.
	 * @returns {Object} Handle with `remove()` method to cancel the listener.
	 */
	return function (node, type, callback) {
		var capture = false;

		// Shim support for focusin/focusout.
		var captures = { focusin: "focus", focusout: "blur" };
		if (type in captures) {
			type = captures[type];
			capture = true;
		}

		// Shim support for Event.key, and fix some wrong/outdated Event.key values
		if (/^key(down|press|up)$/.test(type)) {
			var origFunc = callback;
			callback = function (event) {
				var key = event.key || event.keyIdentifier || String.fromCharCode(event.charCode);

				var fixedKey = {
					// mappings for event.keyIdentifier differences from event.key for special keys
					"U+0020": "Spacebar",
					"U+0008": "Backspace",
					"U+0009": "Tab",
					"U+001B": "Escape",

					// fix for FF 34
					" ": "Spacebar",

					// fix for old key names, see https://www.w3.org/Bugs/Public/show_bug.cgi?id=22084
					"Apps": "ContextMenu",
					"Left": "ArrowLeft",
					"Down": "ArrowDown",
					"Right": "ArrowRight",
					"Up": "ArrowUp",
					"Del": "Delete",
					"Esc": "Escape",

					// fix for Android 4.2
					"U+00007F": "Backspace"
				}[key] || key.replace(/^U\+0*(.*)$/, function (all, hexString) {
					// fix event.keyIdentifier for normal printable characters, ex: "U+0041" --> "A" or "a"
					var code = parseInt(hexString, 16);
					if (code >= 65 && code <= 90 && !event.shiftKey) {
						code += 32;	// uppercase --> lowercase
					}
					return String.fromCharCode(code);
				});

				if (event.key !== fixedKey) {
					// A simple "event.key = fixedKey" doesn't work on FF31 (for " " --> "Spacebar" conversion).
					// And Object.defineProperty(event, "key", {value: fixedKey}); (for "Down" --> "ArrowDown")
					// doesn't work on IE.
					Object.defineProperty(event, "key", {get: function () { return fixedKey; }});
				}

				origFunc(event);
			};
		}

		node.addEventListener(type, callback, capture);

		return {
			remove: function () {
				node.removeEventListener(type, callback, capture);
			}
		};
	};
});
/** @module delite/CustomElement */
define('delite/CustomElement',[
	"dcl/advise",
	"dcl/dcl",
	"decor/Observable",
	"decor/Destroyable",
	"decor/Stateful",
	"requirejs-dplugins/has",
	"./on",
	"./register"
], function (advise, dcl, Observable, Destroyable, Stateful, has, on, register) {

	/**
	 * Dispatched after the CustomElement has been attached.
	 * This is useful to be notified when an HTMLElement has been upgraded to a
	 * CustomElement and attached to the DOM, in particular on browsers supporting native Custom Element.
	 * @example
	 * element.addEventListener("customelement-attached", function (evt) {
	 *      console.log("custom element: "+evt.target.id+" has been attached");
	 * });
	 * @event module:delite/CustomElement#customelement-attached
	 */

	// Test if custom setters work for native properties like dir, or if they are ignored.
	// They don't work on some versions of webkit (Chrome, Safari 7, iOS 7), but do work on Safari 8 and iOS 8.
	// If needed, this test could probably be reduced to just use Object.defineProperty() and dcl(),
	// skipping use of register().
	has.add("setter-on-native-prop", function () {
		var works = false,
			Mixin = dcl(Stateful, {	// mixin to workaround https://github.com/uhop/dcl/issues/9
				getProps: function () { return {dir: true}; },
				dir: "",
				_setDirAttr: function () { works = true; }
			}),
			TestWidget = register("test-setter-on-native-prop", [HTMLElement, Mixin], {}),
			tw = new TestWidget();
		tw.dir = "rtl";
		return works;
	});


	/**
	 * Get a property from a dot-separated string, such as "A.B.C".
	 */
	function getObject(name) {
		try {
			return name.split(".").reduce(function (context, part) {
				return context[part];
			}, this);	// "this" is the global object (i.e. window on browsers)
		} catch (e) {
			// Return undefined to indicate that object doesn't exist.
		}
	}

	// Properties not to monitor for changes.
	var REGEXP_IGNORE_PROPS = /^constructor$|^_set$|^_get$|^deliver$|^discardChanges$|^_(.+)Attr$/;

	/**
	 * Base class for all custom elements.
	 *
	 * Use this class rather that delite/Widget for non-visual custom elements.
	 * Custom elements can provide custom setters/getters for properties, which are called automatically
	 * when the value is set.  For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
	 *
	 * @mixin module:delite/CustomElement
	 * @augments module:decor/Stateful
	 * @augments module:decor/Destroyable
	 */
	var CustomElement = dcl([Stateful, Destroyable], /** @lends module:delite/CustomElement# */{
		introspect: function () {
			if (!has("setter-on-native-prop")) {
				// Generate map from native attributes of HTMLElement to custom setters for those attributes.
				// Necessary because webkit masks all custom setters for native properties on the prototype.
				// For details see:
				//		https://bugs.webkit.org/show_bug.cgi?id=36423
				//		https://bugs.webkit.org/show_bug.cgi?id=49739
				//		https://bugs.webkit.org/show_bug.cgi?id=75297
				var proto = this,
					nativeProps = document.createElement(this._extends || "div"),
					setterMap = this._nativePropSetterMap = {};

				this._nativeAttrs = [];
				do {
					Object.keys(proto).forEach(function (prop) {
						var lcProp = prop.toLowerCase();

						if (prop in nativeProps && !setterMap[lcProp]) {
							var desc = Object.getOwnPropertyDescriptor(proto, prop);
							if (desc && desc.set) {
								this._nativeAttrs.push(lcProp);
								setterMap[lcProp] = desc.set;
							}
						}
					}, this);

					proto = Object.getPrototypeOf(proto);
				} while (proto && proto !== this._baseElement.prototype);
			}
		},

		getProps: function () {
			// Override _Stateful.getProps() to ignore properties from the HTML*Element superclasses, like "style".
			// You would need to explicitly declare style: "" in your widget to get it here.
			//
			// Also sets up this._propCaseMap, a mapping from lowercase property name to actual name,
			// ex: iconclass --> iconClass, which does include the methods, but again doesn't
			// include props like "style" that are merely inherited from HTMLElement.

			var hash = {}, proto = this,
				pcm = this._propCaseMap = {};

			do {
				Object.keys(proto).forEach(function (prop) {
					if (!REGEXP_IGNORE_PROPS.test(prop)) {
						hash[prop] = true;
						pcm[prop.toLowerCase()] = prop;
					}
				});

				proto = Object.getPrototypeOf(proto);
			} while (proto && proto !== this._baseElement.prototype);

			return hash;
		},

		/**
		 * This method will detect and process any properties that the application has set, but the custom setter
		 * didn't run because `has("setter-on-native-prop") === false`.
		 * Used during initialization and also by `deliver()`.
		 * @private
		 */
		_processNativeProps: function () {
			if (!has("setter-on-native-prop")) {
				this._nativeAttrs.forEach(function (attrName) {
					if (this.hasAttribute(attrName)) { // value was specified
						var value = this.getAttribute(attrName);
						this.removeAttribute(attrName);
						if (value !== null) {
							this._nativePropSetterMap[attrName].call(this, value); // call custom setter
						}
					}
				}, this);
			}
		},

		/**
		 * Set to true when `createdCallback()` has completed.
		 * @member {boolean}
		 * @protected
		 */
		created: false,

		/**
		 * Called when the custom element is created, or when `register.parse()` parses a custom tag.
		 *
		 * This method is automatically chained, so subclasses generally do not need to use `dcl.superCall()`,
		 * `dcl.advise()`, etc.
		 * @method
		 * @protected
		 */
		createdCallback: dcl.advise({
			before: function () {
				// Mark this object as observable with Object.observe() shim
				if (!this._observable) {
					Observable.call(this);
				}

				// Get parameters that were specified declaratively on the widget DOMNode.
				this._parsedAttributes = this._mapAttributes();
			},

			after: function () {
				this.created = true;

				// Now that creation has finished, apply parameters that were specified declaratively.
				// This is consistent with the timing that parameters are applied for programmatic creation.
				this._parsedAttributes.forEach(function (pa) {
					if (pa.event) {
						this.on(pa.event, pa.callback);
					} else {
						this[pa.prop] = pa.value;
					}
				}, this);

				if (!has("setter-on-native-prop")) {
					// Call custom setters for initial values of attributes with shadow properties (dir, tabIndex, etc)
					this._processNativeProps();

					// Begin watching for changes to those DOM attributes.
					// Note that (at least on Chrome) I could use attributeChangedCallback() instead, which is
					// synchronous, so Widget#deliver() will work as expected, but OTOH gets lots of notifications
					// that I don't care about.
					// If Polymer is loaded, use MutationObserver rather than WebKitMutationObserver
					// to avoid error about "referencing a Node in a context where it does not exist".
					/* global WebKitMutationObserver */
					var MO = window.MutationObserver || WebKitMutationObserver;	// for jshint
					var observer = new MO(function (records) {
						records.forEach(function (mr) {
							var attrName = mr.attributeName,
								setter = this._nativePropSetterMap[attrName],
								newValue = this.getAttribute(attrName);
							if (newValue !== null) {
								this.removeAttribute(attrName);
								setter.call(this, newValue);
							}
						}, this);
					}.bind(this));
					observer.observe(this, {
						subtree: false,
						attributeFilter: this._nativeAttrs,
						attributes: true
					});
				}
			}
		}),

		/**
		 * Set to true when `attachedCallback()` has completed, and false when `detachedCallback()` called.
		 * @member {boolean}
		 * @protected
		 */
		attached: false,

		/**
		 * Called automatically when the element is added to the document, after `createdCallback()` completes.
		 * This method is automatically chained, so subclasses generally do not need to use `dcl.superCall()`,
		 * `dcl.advise()`, etc.
		 * @method
		 * @fires module:delite/CustomElement#customelement-attached
		 */
		attachedCallback: dcl.advise({
			before: function () {
				// Call computeProperties() and refreshRendering() for declaratively set properties.
				// Do this in attachedCallback() rather than createdCallback() to avoid calling refreshRendering() etc.
				// prematurely in the programmatic case (i.e. calling it before user parameters have been applied).
				this.deliver();
			},

			after: function () {
				this.attached = true;

				this.emit("customelement-attached", {
					bubbles: false,
					cancelable: false
				});
			}
		}),

		/**
		 * Called when the element is removed the document.
		 * This method is automatically chained, so subclasses generally do not need to use `dcl.superCall()`,
		 * `dcl.advise()`, etc.
		 */
		detachedCallback: function () {
			this.attached = false;
		},

		/**
		 * Returns value for widget property based on attribute value in markup.
		 * @param {string} name - Name of widget property.
		 * @param {string} value - Value of attribute in markup.
		 * @private
		 */
		_parsePrototypeAttr: function (name, value) {
			// inner function useful to reduce cyclomatic complexity when using jshint
			function stringToObject(value) {
				var obj;

				try {
					// TODO: remove this code if it isn't being used, so we don't scare people that are afraid of eval.
					/* jshint evil:true */
					// This will only be executed when complex parameters are used in markup
					// <my-tag constraints="max: 3, min: 2"></my-tag>
					// This can be avoided by using such complex parameters only programmatically or by not using
					// them at all.
					// This is harmless if you make sure the JavaScript code that is passed to the attribute
					// is harmless.
					obj = eval("(" + (value[0] === "{" ? "" : "{") + value + (value[0] === "{" ? "" : "}") + ")");
				}
				catch (e) {
					throw new SyntaxError("Error in attribute conversion to object: " + e.message +
						"\nAttribute Value: '" + value + "'");
				}
				return obj;
			}

			switch (typeof this[name]) {
			case "string":
				return value;
			case "number":
				return value - 0;
			case "boolean":
				return value !== "false";
			case "object":
				// Try to interpret value as global variable, ex: store="myStore", array of strings
				// ex: "1, 2, 3", or expression, ex: constraints="min: 10, max: 100"
				return getObject(value) ||
					(this[name] instanceof Array ? (value ? value.split(/\s+/) : []) : stringToObject(value));
			case "function":
				return this.parseFunctionAttribute(value, []);
			}
		},

		/**
		 * Helper to parse function attribute in markup.  Unlike `_parsePrototypeAttr()`, does not require a
		 * corresponding widget property.  Functions can be specified as global variables or as inline javascript:
		 *
		 * ```html
		 * <my-widget funcAttr="globalFunction" on-click="console.log(event.pageX);">
		 * ```
		 *
		 * @param {string} value - Value of the attribute.
		 * @param {string[]} params - When generating a function from inline javascript, give it these parameter names.
		 * @protected
		 */
		parseFunctionAttribute: function (value, params) {
			/* jshint evil:true */
			// new Function() will only be executed if you have properties that are of function type in your widget
			// and that you use them in your tag attributes as follows:
			// <my-tag whatever="console.log(param)"></my-tag>
			// This can be avoided by setting the function programmatically or by not setting it at all.
			// This is harmless if you make sure the JavaScript code that is passed to the attribute is harmless.
			// Use Function.bind to get a partial on Function constructor (trick to call it with an array
			// of args instead list of args).
			return getObject(value) ||
				new (Function.bind.apply(Function, [undefined].concat(params).concat([value])))();
		},

		/**
		 * Helper for parsing declarative widgets.  Interpret a given attribute specified in markup, returning either:
		 *
		 * - `undefined`: ignore
		 * - `{prop: prop, value: value}`: set `this[prop] = value`
		 * - `{event: event, callback: callback}`: call `this.on(event, callback)`
		 *
		 * @param {string} name - Attribute name.
		 * @param {string} value - Attribute value.
		 * @protected
		 */
		parseAttribute: function (name, value) {
			var pcm = this._propCaseMap;
			if (name in pcm) {
				name =  pcm[name]; // convert to correct case for widget
				return {
					prop: name,
					value: this._parsePrototypeAttr(name, value)
				};
			} else if (/^on-/.test(name)) {
				return {
					event: name.substring(3),
					callback: this.parseFunctionAttribute(value, ["event"])
				};
			}
		},

		/**
		 * Parse declaratively specified attributes for widget properties and connects.
		 * @returns {Array} Info about the attributes and their values as returned by `parseAttribute()`.
		 * @private
		 */
		_mapAttributes: function () {
			var attr,
				idx = 0,
				parsedAttrs = [],
				attrsToRemove = [];

			while ((attr = this.attributes[idx++])) {
				var name = attr.name.toLowerCase();	// note: will be lower case already except for IE9
				var parsedAttr = this.parseAttribute(name, attr.value);
				if (parsedAttr) {
					parsedAttrs.push(parsedAttr);
					attrsToRemove.push(attr.name);
				}
			}

			// Remove attributes that were processed, but do it in a separate loop so we don't modify this.attributes
			// while we are looping through it.   (See CustomElement-attr.html test failure on IE10.)
			attrsToRemove.forEach(this.removeAttribute, this);

			return parsedAttrs;
		},

		/**
		 * Release resources used by this custom element and its descendants.
		 * After calling this method, the element can no longer be used,
		 * and should be removed from the document.
		 */
		destroy: function () {
			// Destroy descendants
			this.findCustomElements().forEach(function (w) {
				if (w.destroy) {
					w.destroy();
				}
			});

			if (this.parentNode) {
				this.parentNode.removeChild(this);
				this.detachedCallback();
			}
		},

		/**
		 * Emits a synthetic event of specified type, based on eventObj.
		 * @param {string} type - Name of event.
		 * @param {Object} [eventObj] - Properties to mix in to emitted event.  Can also contain
		 * `bubbles` and `cancelable` properties to control how the event is emitted.
		 * @returns {boolean} True if the event was *not* canceled, false if it was canceled.
		 * @example
		 * myWidget.emit("query-success", {});
		 * @protected
		 */
		emit: function (type, eventObj) {
			eventObj = eventObj || {};
			var bubbles = "bubbles" in eventObj ? eventObj.bubbles : true;
			var cancelable = "cancelable" in eventObj ? eventObj.cancelable : true;

			// Note: can't use jQuery.trigger() because it doesn't work with addEventListener(),
			// see http://bugs.jquery.com/ticket/11047
			var nativeEvent = this.ownerDocument.createEvent("HTMLEvents");
			nativeEvent.initEvent(type, bubbles, cancelable);
			for (var i in eventObj) {
				if (!(i in nativeEvent)) {
					nativeEvent[i] = eventObj[i];
				}
			}
			return this.dispatchEvent(nativeEvent);
		},

		/**
		 * Call specified function when event occurs.
		 *
		 * Note that the function is not run in any particular scope, so if (for example) you want it to run
		 * in the element's scope you must do `myCustomElement.on("click", myCustomElement.func.bind(myCustomElement))`.
		 *
		 * Note that `delite/Widget` overrides `on()` so that `on("focus", ...)` and `on("blur", ...) will trigger the
		 * listener when focus moves into or out of the widget, rather than just when the widget's root node is
		 * focused/blurred.  In other words, the listener is called when the widget is conceptually focused or blurred.
		 *
		 * @param {string} type - Name of event (ex: "click").
		 * @param {Function} func - Callback function.
		 * @param {Element} [node] - Element to attach handler to, defaults to `this`.
		 * @returns {Object} Handle with `remove()` method to cancel the event.
		 */
		on: function (type, func, node) {
			return on(node || this, type, func);
		},

		// Override Stateful#getPropsToObserve() because the way to get the list of properties to watch is different
		// than for a plain Stateful.  Especially since IE doesn't support prototype swizzling.
		getPropsToObserve: function () {
			return this._ctor._propsToObserve;
		},

		// Before deliver() runs, process any native properties (tabIndex, dir) etc. that may have been
		// set without the custom setter getting called.
		deliver: dcl.before(function () {
			this._processNativeProps();
		}),

		/**
		 * Search subtree under root returning custom elements found.
		 * @param {Element} [root] - Node to search under.
		 */
		findCustomElements: function (root) {
			var outAry = [];

			function getChildrenHelper(root) {
				for (var node = root.firstChild; node; node = node.nextSibling) {
					if (node.nodeType === 1 && node.createdCallback) {
						outAry.push(node);
					} else {
						getChildrenHelper(node);
					}
				}
			}

			getChildrenHelper(root || this);
			return outAry;
		}
	});

	// Setup automatic chaining for lifecycle methods.
	// destroy() is chained in Destroyable.js.
	dcl.chainAfter(CustomElement, "createdCallback");
	dcl.chainAfter(CustomElement, "attachedCallback");
	dcl.chainBefore(CustomElement, "detachedCallback");

	return CustomElement;
});

define('xide/factory/Events',[
    'xide/factory',
    'dojo/_base/connect',
    'dojo/_base/lang',
    "dojo/on",
    'dojo/has'
], function (factory, connect, lang, on,has) {

    var _debug = false,         //print publish messages in console
        _tryEvents = false,     //put publish in try/catch block
        _foo=null,              //noop
        _nativeEvents = {
            "click": _foo,
            "dblclick":_foo,
            "mousedown":_foo,
            "mouseup":_foo,
            "mouseover":_foo,
            "mousemove":_foo,
            "mouseout":_foo,
            "keypress":_foo,
            "keydown":_foo,
            "keyup":_foo,
            "focus":_foo,
            "blur":_foo,
            "change":_foo
        },
        _debugGroup=false;


    /**
     * Returns true if it is a DOM element, might be not needed anymore
     * @param o
     * @returns {*}
     * @private
     */
    function _isElement(o){
        return (
            typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
            o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName==="string"
        );
    }
    /**
     * Event debouncer/throttler
     * @param eventHandler
     * @param waitForMirror
     * @returns {Function}
     */
    function applyEventOnce(eventHandler, waitForMirror) {
        var timer;
        var mirror = this;
        return function() {
            var _arguments = arguments;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {
                if (waitForMirror && mirror.isPending())
                    return setTimeout(function() { applyEventOnce(eventHandler, true) }, 0);
                eventHandler.apply(eventHandler, _arguments);
            }, 0);
        };
    }

    /**
     * asyncForEach does runs a chain of promises, needed this specialized for event callbacks
     * @param array
     * @param fn
     * @param test
     * @param callback
     */
    function asyncForEach(array, fn, test, callback) {
        if (!callback) {
            callback = test;
            test = null;
        }

        array = array.slice(); // copy before use

        var nested = false, callNext = true;
        loop();

        function loop() {
            while (callNext && !nested) {
                callNext = false;
                while (array.length > 0 && test && !test(array[0]))
                    array.shift();

                var item = array.shift();
                // TODO: implement proper err argument?
                if (!item)
                    return callback && callback();

                nested = true;
                fn(item, loop);
                nested = false;
            }
            callNext = true;
        }
    }

    /***
     * @param keys
     * @param data
     * @param callee
     * @extends module:xide/factory
     * @memberOf xide/factory
     */
    factory.publish = function (keys, data, callee,filter) {

        var msgStruct   = data ? _.isString(data) ? {message: data} : data : {},
            eventKeys   = keys,
            _publish    = connect.publish,
            result      = [];//lookup cache

        //normalize to array
        if (!_.isArray(keys)) {
            eventKeys = [keys];
        }
        for (var i = 0,l=eventKeys.length; i < l; i++) {

            var eventKey = eventKeys[i];

            if(filter && !filter(eventKey)){
                continue;
            }

            if (_debug && !_debugGroup) {
                console.group("Events");
                _debugGroup = true;
                console.log('publish ' + eventKey + ' from : ' + (callee ? callee.id : ''), msgStruct);
            }

            if(_tryEvents) {
                try {
                    result = _publish(eventKey, msgStruct);
                } catch (e) {
                    logError(e,'error whilst publishing event ' + eventKey);
                }
            }else{
                result = _publish(eventKey, msgStruct);
            }
        }

        return result;
    };

    /***
     *
     * Subscribes to multiple events
     * @param keys {String[]}
     * @param _cb {function|null} When null, it expects the owner having a function matching the event key!
     * @param owner {Object}
     * @extends module:xide/factory
     * @memberOf xide/factory
     * @returns {Object[]|null} Returns an array of regular Dojo-subscribe/on handles
     */
    factory.subscribe = function (keys, cb, owner,filter) {

        if(has('debug')){
            if(!keys){
                _debug && console.error('subscribe failed, event key is empty!');
                return null;
            }
        }

        //some vars
        var eventKeys  = keys,
            _subscribe = connect.subscribe,     //cache
            events = [];                        //resulting subscribe handles
            //_isDom = _isElement(owner),       //dom element?

        //-- not good for use-strict
        //owner = owner || arguments.callee;

        //normalize to array
        if (!_.isArray(keys)) {
            eventKeys = [keys];
        }

        for (var i = 0,l=eventKeys.length; i < l; i++) {

            if(!eventKeys[i] || filter && !filter(eventKey)){
                continue;
            }

            var _item =
                    //the raw item
                    eventKeys[i],
                    //is string?
                    _isString = _.isString(_item),
                    //if string: use it, otherwise assume struct
                    eventKey =  _isString ? _item : _item.key,
                    //pick handler from arguments or struct
                    _handler = _isString ? cb : _item.handler,
                    //is native event?
                    _isNative = eventKey in _nativeEvents,
                    //the final handle
                    _handle;


            //owner specified, hitch the callback into owner's scope
            if (owner != null) {
                //try cb first, then owner.onEVENT_KEY, that enables similar effect as in Dojo2/Evented
                var _cb = _handler !=null ? _handler : owner[eventKey];
                if(_isNative){
                    _handle = on(owner, eventKey, lang.hitch(owner, _cb));
                }else{
                    _handle = _subscribe(eventKey, lang.hitch(owner, _cb));
                }
                _handle.handler = lang.hitch(owner, _cb);
            } else {
                _handle =  connect.subscribe(eventKey, _handler);
                _handle.handler = _handler;
            }
            //track the actual event type
            _handle.type = eventKey;
            events.push(_handle);
        }
        return events;
    };
    return factory;
});
/** @module xide/lodash **/
define('xide/lodash',[],function(){
    /**
     * temp. wanna be shim for lodash til dojo-2/loader lands here
     */
    if(typeof _ !=="undefined"){
        return _;
    }
});

define('xide/utils/StringUtils',[
    'dojo/_base/lang',
    'xide/utils',
    'xide/types',
    'dojo/json',
    'xide/lodash'
], function (lang, utils, types, json,_) {

    "use strict";

    function getParameters (node) {
        var par = ''
        var checkboxes = node.querySelectorAll('input[type=checkbox]')
        for (var c=0;c<checkboxes.length;c++) {
            if (c>0) par += ';'
            if (checkboxes[c].checked) par += checkboxes[c].dataset.fn
            else par += ''
        }

        return par
    }
    function hex2char ( hex ) {
        // converts a single hex number to a character
        // note that no checking is performed to ensure that this is just a hex number, eg. no spaces etc
        // hex: string, the hex codepoint to be converted
        var result = '';
        var n = parseInt(hex, 16);
        if (n <= 0xFFFF) { result += String.fromCharCode(n); }
        else if (n <= 0x10FFFF) {
            n -= 0x10000
            result += String.fromCharCode(0xD800 | (n >> 10)) + String.fromCharCode(0xDC00 | (n & 0x3FF));
        }
        else { result += 'hex2Char error: Code point out of range: '+dec2hex(n); }
        return result;
    }
    function dec2char ( n ) {
        // converts a single string representing a decimal number to a character
        // note that no checking is performed to ensure that this is just a hex number, eg. no spaces etc
        // dec: string, the dec codepoint to be converted
        var result = '';
        if (n <= 0xFFFF) { result += String.fromCharCode(n); }
        else if (n <= 0x10FFFF) {
            n -= 0x10000
            result += String.fromCharCode(0xD800 | (n >> 10)) + String.fromCharCode(0xDC00 | (n & 0x3FF));
        }
        else { result += 'dec2char error: Code point out of range: '+dec2hex(n); }
        return result;
    }
    function dec2hex ( textString ) {
        return (textString+0).toString(16).toUpperCase();
    }
    function dec2hex2 ( textString ) {
        var hexequiv = new Array ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F");
        return hexequiv[(textString >> 4) & 0xF] + hexequiv[textString & 0xF];
    }
    function dec2hex4 ( textString ) {
        var hexequiv = new Array ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F");
        return hexequiv[(textString >> 12) & 0xF] + hexequiv[(textString >> 8) & 0xF]
            + hexequiv[(textString >> 4) & 0xF] + hexequiv[textString & 0xF];
    }
    function convertChar2CP ( textString ) {
        var haut = 0;
        var n = 0;
        var CPstring = '';
        for (var i = 0; i < textString.length; i++) {
            var b = textString.charCodeAt(i);
            if (b < 0 || b > 0xFFFF) {
                CPstring += 'Error in convertChar2CP: byte out of range ' + dec2hex(b) + '!';
            }
            if (haut != 0) {
                if (0xDC00 <= b && b <= 0xDFFF) {
                    CPstring += dec2hex(0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00)) + ' ';
                    haut = 0;
                    continue;
                }
                else {
                    CPstring += 'Error in convertChar2CP: surrogate out of range ' + dec2hex(haut) + '!';
                    haut = 0;
                }
            }
            if (0xD800 <= b && b <= 0xDBFF) {
                haut = b;
            }
            else {
                CPstring += dec2hex(b) + ' ';
            }
        }
        return CPstring.substring(0, CPstring.length-1);
    }

    var text =  "ESC/VP.net 0x10 0x03 0x00 0x00 0x00 0x00";

    //var text =  "0x20 0x20";


    function removeWhitespacesFromHexSequence( str ) {
        // converts a string containing &#x...; escapes to a string of characters
        // str: string, the input

        // convert up to 6 digit escapes to characters

        str = str.replace(/0x([A-Fa-f0-9]{1,4})(\s)?/g,
            function(matchstr, parens) {
                var result = hex2char(parens);
                //console.log('match : ' + matchstr + ' _ ' + parens + ' = ' + result);
                return hex2char(parens);
            }
        );
        /*
        str = str.replace(/&#x([A-Fa-f0-9]{1,6});/g,
            function(matchstr, parens) {
                return hex2char(parens);
            }
        );
        */
        return str;
    }


// ========================== Converting to characters ==============================================
    function convertAllEscapes (str, numbers) {
        // converts all escapes in the text str to characters, and can interpret numbers as escapes too
        // str: string, the text to be converted
        // numbers: string enum [none, hex, dec, utf8, utf16], what to treat numbers as

        var sle = false;
        str = convertUnicode2Char(str);
        str = removeWhitespacesFromHexSequence(str);

        str = convertZeroX2Char(str);
        str = convertHexNCR2Char(str); 
        str = convertDecNCR2Char(str); 
        if (sle) { 
            str = convertjEsc2Char(str, true); 
        }
        else { 
            str = convertjEsc2Char(str, false); 
            str = convertCSS2Char(str, false); 
        } 
        str = convertpEnc2Char(str);  
        str = convertEntities2Char(str); 
        str = convertNumbers2Char(str, numbers); 

        return str;
    }



    /*
    console.clear();
    var result = removeWhitespacesFromHexSequence(text);
    var result2 = convertAllEscapes(text,'none');
    console.log('test '+result + ' - l=' + result.length);
    console.log('test '+result2 + ' - l=' + result2.length);
    //debugger;
    */


    function convertUnicode2Char ( str ) {
        // converts a string containing U+... escapes to a string of characters
        // str: string, the input

        // first convert the 6 digit escapes to characters
        str = str.replace(/[Uu]\+10([A-Fa-f0-9]{4})/g,
            function(matchstr, parens) {
                return hex2char('10'+parens);
            }
        );
        // next convert up to 5 digit escapes to characters
        str = str.replace(/[Uu]\+([A-Fa-f0-9]{1,5})/g,
            function(matchstr, parens) {
                return hex2char(parens);
            }
        );
        return str;
    }

    utils.convertUnicode2Char = convertUnicode2Char;
    
    function oldconvertUnicode2Char ( str ) {
        // converts a string containing U+... escapes to a string of characters
        // str: string, the input

        // first convert the 6 digit escapes to characters
        str = str.replace(/U\+10([A-Fa-f0-9]{4})/g,
            function(matchstr, parens) {
                return hex2char('10'+parens);
            }
        );
        // next convert up to 5 digit escapes to characters
        str = str.replace(/U\+([A-Fa-f0-9]{1,5})/g,
            function(matchstr, parens) {
                return hex2char(parens);
            }
        );
        return str;
    }
    function convertHexNCR2Char ( str ) {
        // converts a string containing &#x...; escapes to a string of characters
        // str: string, the input

        // convert up to 6 digit escapes to characters
        str = str.replace(/&#x([A-Fa-f0-9]{1,6});/g,
            function(matchstr, parens) {
                return hex2char(parens);
            }
        );
        return str;
    }
    function convertDecNCR2Char ( str ) {
        // converts a string containing &#...; escapes to a string of characters
        // str: string, the input

        // convert up to 6 digit escapes to characters
        str = str.replace(/&#([0-9]{1,7});/g,
            function(matchstr, parens) {
                return dec2char(parens);
            }
        );
        return str;
    }
    function convertZeroX2Char ( str ) {
        // converts a string containing 0x... escapes to a string of characters
        // str: string, the input

        // convert up to 6 digit escapes to characters
        str = str.replace(/0x([A-Fa-f0-9]{1,6})/g,
            function(matchstr, parens) {
                return hex2char(parens);
            }
        );
        return str;
    }
    function convertCSS2Char ( str, convertbackslash ) {
        // converts a string containing CSS escapes to a string of characters
        // str: string, the input
        // convertbackslash: boolean, true if you want \x etc to become x or \a to be treated as 0xA

        // convert up to 6 digit escapes to characters & throw away any following whitespace
        if (convertbackslash) {
            str = str.replace(/\\([A-Fa-f0-9]{1,6})(\s)?/g,
                function(matchstr, parens) {
                    return hex2char(parens);
                }
            );
            str = str.replace(/\\/g, '');
        }
        else {
            str = str.replace(/\\([A-Fa-f0-9]{2,6})(\s)?/g,
                function(matchstr, parens) {
                    return hex2char(parens);
                }
            );
        }
        return str;
    }
    function convertjEsc2Char ( str, shortEscapes ) {
        // converts a string containing JavaScript or Java escapes to a string of characters
        // str: string, the input
        // shortEscapes: boolean, if true the function will convert \b etc to characters

        // convert ES6 escapes to characters
        str = str.replace(/\\u\{([A-Fa-f0-9]{1,})\}/g,
            function(matchstr, parens) {
                return hex2char(parens);
            }
        );
        // convert \U and 6 digit escapes to characters
        str = str.replace(/\\U([A-Fa-f0-9]{8})/g,
            function(matchstr, parens) {
                return hex2char(parens);
            }
        );
        // convert \u and 6 digit escapes to characters
        str = str.replace(/\\u([A-Fa-f0-9]{4})/g,
            function(matchstr, parens) {
                return hex2char(parens);
            }
        );
        // convert \b etc to characters, if flag set
        if (shortEscapes) {
            //str = str.replace(/\\0/g, '\0');
            str = str.replace(/\\b/g, '\b');
            str = str.replace(/\\t/g, '\t');
            str = str.replace(/\\n/g, '\n');
            str = str.replace(/\\v/g, '\v');
            str = str.replace(/\\f/g, '\f');
            str = str.replace(/\\r/g, '\r');
            str = str.replace(/\\\'/g, '\'');
            str = str.replace(/\\\"/g, '\"');
            str = str.replace(/\\\\/g, '\\');
        }
        return str;
    }
    function convertpEnc2Char ( str ) {
        // converts a string containing precent encoded escapes to a string of characters
        // str: string, the input

        // find runs of hex numbers separated by % and send them for conversion
        str = str.replace(/((%[A-Fa-f0-9]{2})+)/g,
            function(matchstr, parens) {
                //return convertpEsc2Char(parens.replace(/%/g,' '));
                return convertpEsc2Char(parens);
            }
        );
        return str;
    }
    function convertEntities2Char ( str ) {
        // converts a string containing HTML/XML character entities to a string of characters
        // str: string, the input

        str = str.replace(/&([A-Za-z0-9]+);/g,
            function(matchstr, parens) { //alert(parens);
                if (parens in entities) { //alert(entities[parens]);
                    return entities[parens];
                }
                else { return matchstr; }						}
        );
        return str;
    }
    function convertNumbers2Char ( str, type ) {
        // converts a string containing HTML/XML character entities to a string of characters
        // str: string, the input
        // type: string enum [none, hex, dec, utf8, utf16], what to treat numbers as

        if (type == 'hex') {
            str = str.replace(/(\b[A-Fa-f0-9]{2,6}\b)/g,
                function(matchstr, parens) {
                    return hex2char(parens);
                }
            );
        }
        else if (type == 'dec') {
            str = str.replace(/(\b[0-9]+\b)/g,
                function(matchstr, parens) {
                    return dec2char(parens);
                }
            );
        }
        else if (type == 'utf8') {
            str = str.replace(/(( [A-Fa-f0-9]{2})+)/g,
                //str = str.replace(/((\b[A-Fa-f0-9]{2}\b)+)/g,
                function(matchstr, parens) {
                    return convertUTF82Char(parens);
                }
            );
        }
        else if (type == 'utf16') {
            str = str.replace(/(( [A-Fa-f0-9]{1,6})+)/g,
                function(matchstr, parens) {
                    return convertUTF162Char(parens);
                }
            );
        }
        return str;
    }
    function convertUTF82Char ( str ) {
        // converts to characters a sequence of space-separated hex numbers representing bytes in utf8
        // str: string, the sequence to be converted
        var outputString = "";
        var counter = 0;
        var n = 0;

        // remove leading and trailing spaces
        str = str.replace(/^\s+/, '');
        str = str.replace(/\s+$/,'');
        if (str.length == 0) { return ""; }
        str = str.replace(/\s+/g, ' ');

        var listArray = str.split(' ');
        for ( var i = 0; i < listArray.length; i++ ) {
            var b = parseInt(listArray[i], 16);  // alert('b:'+dec2hex(b));
            switch (counter) {
                case 0:
                    if (0 <= b && b <= 0x7F) {  // 0xxxxxxx
                        outputString += dec2char(b); }
                    else if (0xC0 <= b && b <= 0xDF) {  // 110xxxxx
                        counter = 1;
                        n = b & 0x1F; }
                    else if (0xE0 <= b && b <= 0xEF) {  // 1110xxxx
                        counter = 2;
                        n = b & 0xF; }
                    else if (0xF0 <= b && b <= 0xF7) {  // 11110xxx
                        counter = 3;
                        n = b & 0x7; }
                    else {
                        outputString += 'convertUTF82Char: error1 ' + dec2hex(b) + '! ';
                    }
                    break;
                case 1:
                    if (b < 0x80 || b > 0xBF) {
                        outputString += 'convertUTF82Char: error2 ' + dec2hex(b) + '! ';
                    }
                    counter--;
                    outputString += dec2char((n << 6) | (b-0x80));
                    n = 0;
                    break;
                case 2: case 3:
                if (b < 0x80 || b > 0xBF) {
                    outputString += 'convertUTF82Char: error3 ' + dec2hex(b) + '! ';
                }
                n = (n << 6) | (b-0x80);
                counter--;
                break;
            }
        }
        return outputString.replace(/ $/, '');
    }
    function convertUTF162Char ( str ) {
        // Converts a string of UTF-16 code units to characters
        // str: sequence of UTF16 code units, separated by spaces
        var highsurrogate = 0;
        var suppCP;
        var n = 0;
        var outputString = '';

        // remove leading and multiple spaces
        str = str.replace(/^\s+/,'');
        str = str.replace(/\s+$/,'');
        if (str.length == 0){ return; }
        str = str.replace(/\s+/g,' ');

        var listArray = str.split(' ');
        for (var i = 0; i < listArray.length; i++) {
            var b = parseInt(listArray[i], 16); //alert(listArray[i]+'='+b);
            if (b < 0 || b > 0xFFFF) {
                outputString += '!Error in convertUTF162Char: unexpected value, b=' + dec2hex(b) + '!';
            }
            if (highsurrogate != 0) {
                if (0xDC00 <= b && b <= 0xDFFF) {
                    outputString += dec2char(0x10000 + ((highsurrogate - 0xD800) << 10) + (b - 0xDC00));
                    highsurrogate = 0;
                    continue;
                }
                else {
                    outputString += 'Error in convertUTF162Char: low surrogate expected, b=' + dec2hex(b) + '!';
                    highsurrogate = 0;
                }
            }
            if (0xD800 <= b && b <= 0xDBFF) { // start of supplementary character
                highsurrogate = b;
            }
            else {
                outputString += dec2char(b);
            }
        }
        return outputString;
    }
    function convertpEsc2Char ( str ) {
        // converts to characters a sequence of %-separated hex numbers representing bytes in utf8
        // str: string, the sequence to be converted

        var outputString = "";
        var counter = 0;
        var n = 0;

        var listArray = str.split('%');
        for ( var i = 1; i < listArray.length; i++ ) {
            var b = parseInt(listArray[i], 16);  // alert('b:'+dec2hex(b));
            switch (counter) {
                case 0:
                    if (0 <= b && b <= 0x7F) {  // 0xxxxxxx
                        outputString += dec2char(b); }
                    else if (0xC0 <= b && b <= 0xDF) {  // 110xxxxx
                        counter = 1;
                        n = b & 0x1F; }
                    else if (0xE0 <= b && b <= 0xEF) {  // 1110xxxx
                        counter = 2;
                        n = b & 0xF; }
                    else if (0xF0 <= b && b <= 0xF7) {  // 11110xxx
                        counter = 3;
                        n = b & 0x7; }
                    else {
                        outputString += 'convertpEsc2Char: error ' + dec2hex(b) + '! ';
                    }
                    break;
                case 1:
                    if (b < 0x80 || b > 0xBF) {
                        outputString += 'convertpEsc2Char: error ' + dec2hex(b) + '! ';
                    }
                    counter--;
                    outputString += dec2char((n << 6) | (b-0x80));
                    n = 0;
                    break;
                case 2: case 3:
                if (b < 0x80 || b > 0xBF) {
                    outputString += 'convertpEsc2Char: error ' + dec2hex(b) + '! ';
                }
                n = (n << 6) | (b-0x80);
                counter--;
                break;
            }
        }
        return outputString;
    }
    function convertXML2Char (str) {
        // converts XML or HTML text to characters by removing all character entities and ncrs
        // str: string, the sequence to be converted

        // remove various escaped forms
        str = convertHexNCR2Char(str);
        str = convertDecNCR2Char(str);
        str = convertEntities2Char(str);

        return str;
    }
    
    utils.convertUTF82Char = convertUTF82Char;
    utils.convertUTF162Char = convertUTF162Char;
    
// ============================== Convert to escapes ===============================================

    function convertCharStr2XML ( str, parameters ) {
        // replaces xml/html syntax-sensitive characters in a string with entities
        // also replaces invisible and ambiguous characters with escapes (list to be extended)
        // str: string, the input string
        // convertinvisibles: boolean, if true, invisible characters are converted to NCRs
        // bidimarkup: boolean, if true, bidi rle/lre/pdf/rli/lri/fsi/pdi characters are converted to markup
        str = str.replace(/&/g, '&amp;')
        str = str.replace(/"/g, '&quot;')
        str = str.replace(/</g, '&lt;')
        str = str.replace(/>/g, '&gt;')

        // replace invisible and ambiguous characters
        if (parameters.match(/convertinvisibles/)) {
            str = str.replace(/\u2066/g, '&#x2066;')  // lri
            str = str.replace(/\u2067/g, '&#x2067;')  // rli
            str = str.replace(/\u2068/g, '&#x2068;')  // fsi
            str = str.replace(/\u2069/g, '&#x2069;')  // pdi

            str = str.replace(/\u202A/g, '&#x202A;') // lre
            str = str.replace(/\u202B/g, '&#x202B;') // rle
            str = str.replace(/\u202D/g, '&#x202D;') // lro
            str = str.replace(/\u202E/g, '&#x202E;') // rlo
            str = str.replace(/\u202C/g, '&#x202C;') // pdf
            str = str.replace(/\u200E/g, '&#x200E;') // lrm
            str = str.replace(/\u200F/g, '&#x200F;') // rlm

            str = str.replace(/\u2000/g, '&#x2000;') // en quad
            str = str.replace(/\u2001/g, '&#x2001;') // em quad
            str = str.replace(/\u2002/g, '&#x2002;') // en space
            str = str.replace(/\u2003/g, '&#x2003;') // em space
            str = str.replace(/\u2004/g, '&#x2004;') // 3 per em space
            str = str.replace(/\u2005/g, '&#x2005;') // 4 per em space
            str = str.replace(/\u2006/g, '&#x2006;') // 6 per em space
            str = str.replace(/\u2007/g, '&#x2007;') // figure space
            str = str.replace(/\u2008/g, '&#x2008;') // punctuation space
            str = str.replace(/\u2009/g, '&#x2009;') // thin space
            str = str.replace(/\u200A/g, '&#x200A;') // hair space
            str = str.replace(/\u200B/g, '&#x200B;') // zwsp
            str = str.replace(/\u205F/g, '&#x205F;') // mmsp
            str = str.replace(/\uA0/g, '&#xA0;') // nbsp
            str = str.replace(/\u3000/g, '&#x3000;') // ideographic sp
            str = str.replace(/\u202F/g, '&#x202F;') // nnbsp

            str = str.replace(/\u180B/g, '&#x180B;') // mfvs1
            str = str.replace(/\u180C/g, '&#x180C;') // mfvs2
            str = str.replace(/\u180D/g, '&#x180D;') // mfvs3

            str = str.replace(/\u200C/g, '&#x200C;') // zwnj
            str = str.replace(/\u200D/g, '&#x200D;') // zwj
            str = str.replace(/\u2028/g, '&#x2028;') // line sep
            str = str.replace(/\u206A/g, '&#x206A;') // iss
            str = str.replace(/\u206B/g, '&#x206B;') // ass
            str = str.replace(/\u206C/g, '&#x206C;') // iafs
            str = str.replace(/\u206D/g, '&#x206D;') // aafs
            str = str.replace(/\u206E/g, '&#x206E;') // nads
            str = str.replace(/\u206F/g, '&#x206F;') // nods
        }

        // convert lre/rle/pdf/rli/lri/fsi/pdi to markup
        if (parameters.match(/bidimarkup/)) {
            str = str.replace(/\u2066/g, '&lt;span dir=&quot;ltr&quot;&gt;') // lri
            str = str.replace(/\u2067/g, '&lt;span dir=&quot;rtl&quot;&gt;') // rli
            str = str.replace(/\u2068/g, '&lt;span dir=&quot;auto&quot;&gt;') // fsi
            str = str.replace(/\u2069/g, '&lt;/span&gt;') // pdi

            str = str.replace(/\u202A/g, '&lt;span dir=&quot;ltr&quot;&gt;') //
            str = str.replace(/\u202B/g, '&lt;span dir=&quot;rtl&quot;&gt;')
            str = str.replace(/\u202C/g, '&lt;/span&gt;')
            str = str.replace(/&#x202A;/g, '&lt;span dir=&quot;ltr&quot;&gt;')
            str = str.replace(/&#x202B;/g, '&lt;span dir=&quot;rtl&quot;&gt;')
            //str = str.replace(/\u202D/g, '&lt;bdo dir=&quot;ltr&quot;&gt;')
            //str = str.replace(/\u202E/g, '&lt;bdo dir=&quot;rtl&quot;&gt;')
            str = str.replace(/&#x202C;/g, '&lt;/span&gt;')
        }

        return str;
    }
    function convertCharStr2SelectiveCPs ( str, parameters, pad, before, after, base ) {
        // converts a string of characters to code points or code point based escapes
        // str: string, the string to convert
        // parameters: string enum [ascii, latin1], a set of characters to not convert
        // pad: boolean, if true, hex numbers lower than 1000 are padded with zeros
        // before: string, any characters to include before a code point (eg. &#x for NCRs)
        // after: string, any characters to include after (eg. ; for NCRs)
        // base: string enum [hex, dec], hex or decimal output
        var haut = 0;
        var n = 0; var cp;
        var CPstring = '';
        for (var i = 0; i < str.length; i++) {
            var b = str.charCodeAt(i);
            if (b < 0 || b > 0xFFFF) {
                CPstring += 'Error in convertCharStr2SelectiveCPs: byte out of range ' + dec2hex(b) + '!';
            }
            if (haut != 0) {
                if (0xDC00 <= b && b <= 0xDFFF) {
                    if (base == 'hex') {
                        CPstring += before + dec2hex(0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00)) + after;
                    }
                    else { cp = 0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00);
                        CPstring += before + cp + after;
                    }
                    haut = 0;
                    continue;
                }
                else {
                    CPstring += 'Error in convertCharStr2SelectiveCPs: surrogate out of range ' + dec2hex(haut) + '!';
                    haut = 0;
                }
            }
            if (0xD800 <= b && b <= 0xDBFF) {
                haut = b;
            }
            else {
                if (parameters.match(/ascii/) && b <= 127) { //  && b != 0x3E && b != 0x3C &&  b != 0x26) {
                    CPstring += str.charAt(i);
                }
                else if (b <= 255 && parameters.match(/latin1/)) { // && b != 0x3E && b != 0x3C &&  b != 0x26) {
                    CPstring += str.charAt(i);
                }
                else {
                    if (base == 'hex') {
                        cp = dec2hex(b);
                        if (pad) { while (cp.length < 4) { cp = '0'+cp; } }
                    }
                    else { cp = b; }
                    CPstring += before + cp + after;
                }
            }
        }
        return CPstring;
    }
    function convertCharStr2HexNCR ( textString ) {
        var outputString = "";
        textString = textString.replace(/^\s+/, '');
        if (textString.length == 0) { return ""; }
        textString = textString.replace(/\s+/g, ' ');
        var listArray = textString.split(' ');
        for ( var i = 0; i < listArray.length; i++ ) {
            var n = parseInt(listArray[i], 16);
            outputString += '&#x' + dec2hex(n) + ';';
        }
        return( outputString );
    }
    function convertCharStr2pEsc ( str ) {
        // str: sequence of Unicode characters
        var outputString = "";
        var CPstring = convertChar2CP(str);
        if (str.length == 0) { return ""; }
        // process each codepoint
        var listArray = CPstring.split(' ');
        for ( var i = 0; i < listArray.length; i++ ) {
            var n = parseInt(listArray[i], 16);
            //if (i > 0) { outputString += ' ';}
            if (n == 0x20) { outputString += '%20'; }
            else if (n >= 0x41 && n <= 0x5A) { outputString += String.fromCharCode(n); } // alpha
            else if (n >= 0x61 && n <= 0x7A) { outputString += String.fromCharCode(n); } // alpha
            else if (n >= 0x30 && n <= 0x39) { outputString += String.fromCharCode(n); } // digits
            else if (n == 0x2D || n == 0x2E || n == 0x5F || n == 0x7E) { outputString += String.fromCharCode(n); } // - . _ ~
            else if (n <= 0x7F) { outputString += '%'+dec2hex2(n); }
            else if (n <= 0x7FF) { outputString += '%'+dec2hex2(0xC0 | ((n>>6) & 0x1F)) + '%' + dec2hex2(0x80 | (n & 0x3F)); }
            else if (n <= 0xFFFF) { outputString += '%'+dec2hex2(0xE0 | ((n>>12) & 0x0F)) + '%' + dec2hex2(0x80 | ((n>>6) & 0x3F)) + '%' + dec2hex2(0x80 | (n & 0x3F)); }
            else if (n <= 0x10FFFF) {outputString += '%'+dec2hex2(0xF0 | ((n>>18) & 0x07)) + '%' + dec2hex2(0x80 | ((n>>12) & 0x3F)) + '%' + dec2hex2(0x80 | ((n>>6) & 0x3F)) + '%' + dec2hex2(0x80 | (n & 0x3F)); }
            else { outputString += '!Error ' + dec2hex(n) +'!'; }
        }
        return( outputString );
    }
    function convertCharStr2UTF8 ( str ) {
        // Converts a string of characters to UTF-8 byte codes, separated by spaces
        // str: sequence of Unicode characters
        var highsurrogate = 0;
        var suppCP; // decimal code point value for a supp char
        var n = 0;
        var outputString = '';
        for (var i = 0; i < str.length; i++) {
            var cc = str.charCodeAt(i);
            if (cc < 0 || cc > 0xFFFF) {
                outputString += '!Error in convertCharStr2UTF8: unexpected charCodeAt result, cc=' + cc + '!';
            }
            if (highsurrogate != 0) {
                if (0xDC00 <= cc && cc <= 0xDFFF) {
                    suppCP = 0x10000 + ((highsurrogate - 0xD800) << 10) + (cc - 0xDC00);
                    outputString += ' '+dec2hex2(0xF0 | ((suppCP>>18) & 0x07)) + ' ' + dec2hex2(0x80 | ((suppCP>>12) & 0x3F)) + ' ' + dec2hex2(0x80 | ((suppCP>>6) & 0x3F)) + ' ' + dec2hex2(0x80 | (suppCP & 0x3F));
                    highsurrogate = 0;
                    continue;
                }
                else {
                    outputString += 'Error in convertCharStr2UTF8: low surrogate expected, cc=' + cc + '!';
                    highsurrogate = 0;
                }
            }
            if (0xD800 <= cc && cc <= 0xDBFF) { // high surrogate
                highsurrogate = cc;
            }
            else {
                if (cc <= 0x7F) { outputString += ' '+dec2hex2(cc); }
                else if (cc <= 0x7FF) { outputString += ' '+dec2hex2(0xC0 | ((cc>>6) & 0x1F)) + ' ' + dec2hex2(0x80 | (cc & 0x3F)); }
                else if (cc <= 0xFFFF) { outputString += ' '+dec2hex2(0xE0 | ((cc>>12) & 0x0F)) + ' ' + dec2hex2(0x80 | ((cc>>6) & 0x3F)) + ' ' + dec2hex2(0x80 | (cc & 0x3F)); }
            }
        }
        return outputString.substring(1);
    }
    function convertCharStr2UTF16 ( str ) {
        // Converts a string of characters to UTF-16 code units, separated by spaces
        // str: sequence of Unicode characters
        var highsurrogate = 0;
        var suppCP;
        var n = 0;
        var outputString = '';
        for (var i = 0; i < str.length; i++) {
            var cc = str.charCodeAt(i);
            if (cc < 0 || cc > 0xFFFF) {
                outputString += '!Error in convertCharStr2UTF16: unexpected charCodeAt result, cc=' + cc + '!';
            }
            if (highsurrogate != 0) {
                if (0xDC00 <= cc && cc <= 0xDFFF) {
                    suppCP = 0x10000 + ((highsurrogate - 0xD800) << 10) + (cc - 0xDC00);
                    suppCP -= 0x10000; outputString += dec2hex4(0xD800 | (suppCP >> 10)) + ' ' + dec2hex4(0xDC00 | (suppCP & 0x3FF)) + ' ';
                    highsurrogate = 0;
                    continue;
                }
                else {
                    outputString += 'Error in convertCharStr2UTF16: low surrogate expected, cc=' + cc + '!';
                    highsurrogate = 0;
                }
            }
            if (0xD800 <= cc && cc <= 0xDBFF) { // start of supplementary character
                highsurrogate = cc;
            }
            else {
                result = dec2hex(cc)
                while (result.length < 4) result = '0' + result
                outputString += result + ' '
            }
        }
        return outputString.substring(0, outputString.length-1);
    }
    function convertCharStr2jEsc ( str, parameters ) {
        // Converts a string of characters to JavaScript escapes
        // str: sequence of Unicode characters
        // parameters: a semicolon separated string showing ids for checkboxes that are turned on
        var highsurrogate = 0;
        var suppCP;
        var pad;
        var n = 0;
        var pars = parameters.split(';')
        var outputString = '';
        for (var i = 0; i < str.length; i++) {
            var cc = str.charCodeAt(i);
            if (cc < 0 || cc > 0xFFFF) {
                outputString += '!Error in convertCharStr2UTF16: unexpected charCodeAt result, cc=' + cc + '!';
            }
            if (highsurrogate != 0) { // this is a supp char, and cc contains the low surrogate
                if (0xDC00 <= cc && cc <= 0xDFFF) {
                    suppCP = 0x10000 + ((highsurrogate - 0xD800) << 10) + (cc - 0xDC00);
                    if (parameters.match(/cstyleSC/)) {
                        pad = suppCP.toString(16);
                        while (pad.length < 8) { pad = '0'+pad; }
                        outputString += '\\U'+pad;
                    }
                    else if (parameters.match(/es6styleSC/)) {
                        pad = suppCP.toString(16)
                        outputString += '\\u{'+pad+'}'
                    }
                    else {
                        suppCP -= 0x10000;
                        outputString += '\\u'+ dec2hex4(0xD800 | (suppCP >> 10)) +'\\u'+ dec2hex4(0xDC00 | (suppCP & 0x3FF));
                    }
                    highsurrogate = 0;
                    continue;
                }
                else {
                    outputString += 'Error in convertCharStr2UTF16: low surrogate expected, cc=' + cc + '!';
                    highsurrogate = 0;
                }
            }
            if (0xD800 <= cc && cc <= 0xDBFF) { // start of supplementary character
                highsurrogate = cc;
            }
            else { // this is a BMP character
                //outputString += dec2hex(cc) + ' ';
                switch (cc) {
                    case 0: outputString += '\\0'; break;
                    case 8: outputString += '\\b'; break;
                    case 9: if (parameters.match(/noCR/)) {outputString += '\\t';} else {outputString += '\t'}; break;
                    case 10: if (parameters.match(/noCR/)) {outputString += '\\n';} else {outputString += '\n'}; break;
                    case 13: if (parameters.match(/noCR/)) {outputString += '\\r';} else {outputString += '\r'}; break;
                    case 11: outputString += '\\v'; break;
                    case 12: outputString += '\\f'; break;
                    case 34: if (parameters.match(/noCR/)) {outputString += '\\\"';} else {outputString += '"'}; break;
                    case 39: if (parameters.match(/noCR/)) {outputString += "\\\'";} else {outputString += '\''}; break;
                    case 92: outputString += '\\\\'; break;
                    default:
                        if (cc > 0x1f && cc < 0x7F) { outputString += String.fromCharCode(cc); }
                        else {
                            pad = cc.toString(16).toUpperCase();
                            while (pad.length < 4) { pad = '0'+pad; }
                            outputString += '\\u'+pad;
                        }
                }
            }
        }
        return outputString;
    }
    function convertCharStr2CSS ( str ) {
        // Converts a string of characters to CSS escapes
        // str: sequence of Unicode characters
        var highsurrogate = 0;
        var suppCP;
        var pad;
        var outputString = '';
        for (var i = 0; i < str.length; i++) {
            var cc = str.charCodeAt(i);
            if (cc < 0 || cc > 0xFFFF) {
                outputString += '!Error in convertCharStr2CSS: unexpected charCodeAt result, cc=' + cc + '!';
            }
            if (highsurrogate != 0) { // this is a supp char, and cc contains the low surrogate
                if (0xDC00 <= cc && cc <= 0xDFFF) {
                    suppCP = 0x10000 + ((highsurrogate - 0xD800) << 10) + (cc - 0xDC00);
                    pad = suppCP.toString(16).toUpperCase();
                    if (suppCP < 0x10000) { while (pad.length < 4) { pad = '0'+pad; } }
                    else { while (pad.length < 6) { pad = '0'+pad; } }
                    outputString += '\\'+pad+' ';
                    highsurrogate = 0;
                    continue;
                }
                else {
                    outputString += 'Error in convertCharStr2CSS: low surrogate expected, cc=' + cc + '!';
                    highsurrogate = 0;
                }
            }
            if (0xD800 <= cc && cc <= 0xDBFF) { // start of supplementary character
                highsurrogate = cc;
            }
            else { // this is a BMP character
                if (cc == 0x5C) { outputString += '\\\\'; }
                else if (cc > 0x1f && cc < 0x7F) { outputString += String.fromCharCode(cc); }
                else if (cc == 0x9 || cc == 0xA || cc == 0xD) { outputString += String.fromCharCode(cc); }
                else /* if (cc > 0x7E) */ {
                    pad = cc.toString(16).toUpperCase();
                    while (pad.length < 4) { pad = '0'+pad; }
                    outputString += '\\'+pad+' ';
                }
            }
        }
        return outputString;
    }
    function convertCharStr2CP ( textString, parameters, pad, type ) {
        // converts a string of characters to code points, separated by space
        // textString: string, the string to convert
        // parameters: string enum [ascii, latin1], a set of characters to not convert
        // pad: boolean, if true, hex numbers lower than 1000 are padded with zeros
        // type: string enum[hex, dec, unicode, zerox], whether output should be in hex or dec or unicode U+ form
        var haut = 0;
        var n = 0;
        var CPstring = '';
        var afterEscape = false;
        for (var i = 0; i < textString.length; i++) {
            var b = textString.charCodeAt(i);
            if (b < 0 || b > 0xFFFF) {
                CPstring += 'Error in convertChar2CP: byte out of range ' + dec2hex(b) + '!';
            }
            if (haut != 0) {
                if (0xDC00 <= b && b <= 0xDFFF) {
                    if (afterEscape) { CPstring += ' '; }
                    if (type == 'hex') {
                        CPstring += dec2hex(0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00));
                    }
                    else if (type == 'unicode') {
                        CPstring += 'U+'+dec2hex(0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00));
                    }
                    else if (type == 'zerox') {
                        CPstring += '0x'+dec2hex(0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00));
                    }
                    else {
                        CPstring += 0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00);
                    }
                    haut = 0;
                    continue;
                    afterEscape = true;
                }
                else {
                    CPstring += 'Error in convertChar2CP: surrogate out of range ' + dec2hex(haut) + '!';
                    haut = 0;
                }
            }
            if (0xD800 <= b && b <= 0xDBFF) {
                haut = b;
            }
            else {
                if (b <= 127 && parameters.match(/ascii/)) {
                    CPstring += textString.charAt(i);
                    afterEscape = false;
                }
                else if (b <= 255 && parameters.match(/latin1/)) {
                    CPstring += textString.charAt(i);
                    afterEscape = false;
                }
                else {
                    if (afterEscape) { CPstring += ' '; }
                    if (type == 'hex') {
                        cp = dec2hex(b);
                        if (pad) { while (cp.length < 4) { cp = '0'+cp; } }
                    }
                    else if (type == 'unicode') {
                        cp = dec2hex(b);
                        if (pad) { while (cp.length < 4) { cp = '0'+cp; } }
                        CPstring += 'U+';
                    }
                    else if (type == 'zerox') {
                        cp = dec2hex(b);
                        if (pad) { while (cp.length < 4) { cp = '0'+cp; } }
                        CPstring += '0x';
                    }
                    else {
                        cp = b;
                    }
                    CPstring += cp;
                    afterEscape = true;
                }
            }
        }
        return CPstring;
    }
    function convertCharStr2Unicode ( textString, preserve, pad ) { alert('here');
        // converts a string of characters to U+... notation, separated by space
        // textString: string, the string to convert
        // preserve: string enum [ascii, latin1], a set of characters to not convert
        // pad: boolean, if true, hex numbers lower than 1000 are padded with zeros
        var haut = 0;
        var n = 0;
        var CPstring = ''; pad=false;
        for (var i = 0; i < textString.length; i++) {
            var b = textString.charCodeAt(i);
            if (b < 0 || b > 0xFFFF) {
                CPstring += 'Error in convertChar2CP: byte out of range ' + dec2hex(b) + '!';
            }
            if (haut != 0) {
                if (0xDC00 <= b && b <= 0xDFFF) {
                    CPstring += 'U+' + dec2hex(0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00)) + ' ';
                    haut = 0;
                    continue;
                }
                else {
                    CPstring += 'Error in convertChar2CP: surrogate out of range ' + dec2hex(haut) + '!';
                    haut = 0;
                }
            }
            if (0xD800 <= b && b <= 0xDBFF) {
                haut = b;
            }
            else {
                if (b <= 127 && preserve == 'ascii') {
                    CPstring += textString.charAt(i)+' ';
                }
                else if (b <= 255 && preserve == 'latin1') {
                    CPstring += textString.charAt(i)+' ';
                }
                else {
                    cp = dec2hex(b);
                    if (pad) { while (cp.length < 4) { cp = '0'+cp; } }
                    CPstring += 'U+' + cp + ' ';
                }
            }
        }
        return CPstring.substring(0, CPstring.length-1);
    }


    utils.convertCharStr2pEsc=convertCharStr2pEsc;
    
    utils.convertAllEscapes = convertAllEscapes;

    function stringify(obj, replacer, spaces, cycleReplacer) {
        return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
    }

    var digit_array=new Array('0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f');

    /**
     * Takes a number and returns a rounded fixed digit string.
     * Returns an empty string if first parameter is NaN, (-)Infinity or not of type number.
     * If parameter trailing is set to true trailing zeros will be kept.
     *
     * @param {number} num the number
     * @param {number} [digits=3] digit count
     * @param {boolean} [trailing=false] keep trailing zeros
     *
     * @example
     *
         test(fsuxx(-6.8999999999999995), '-6.9');
         test(fsuxx(0.020000000000000004), '0.02');
         test(fsuxx(0.199000000000000004), '0.199');
         test(fsuxx(0.199000000000000004, 2), '0.2');
         test(fsuxx(0.199000000000000004, 1), '0.2');
         test(fsuxx(0.199000000000000004, 2, true), '0.20');
         test(fsuxx('muh'), '');
         test(fsuxx(false), '');
         test(fsuxx(null), '');
         test(fsuxx(), '');
         test(fsuxx(NaN), '');
         test(fsuxx(Infinity), '');
         test(fsuxx({bla: 'blub'}), '');
         test(fsuxx([1,2,3]), '');
         test(fsuxx(6.8999999999999995), '6.9');
         test(fsuxx(0.199000000000000004), '0.199');
         test(fsuxx(0.199000000000000004, 2), '0.2');
         test(fsuxx(0.199000000000000004, 2, true), '0.20');
     *
     *
     * @returns {string}
     *
     */
    utils.round=function(num, digits, trailing) {

        if (typeof num !== 'number' || isNaN(num) || num === Infinity || num === -Infinity) return '';

        digits = ((typeof digits === 'undefined') ? 3 : (parseInt(digits, 10) || 0));

        var f = Math.pow(10, digits);
        var res = (Math.round(num * f) / f).toFixed(digits);

        // remove trailing zeros and cast back to string
        if (!trailing) res = '' + (+res);

        return res;
    }


    utils.replaceHex = function(str) {
        if(_.isString(str)) {
            return str.replace(/x([0-9A-Fa-f]{2})/gmi, function () {
                //console.log('match ',arguments);
                return String.fromCharCode(parseInt(arguments[1], 16));
            });
        }
        return str;
    };

    function d2h(d) {
        return d.toString(16);
    }
    function h2d (h) {
        return parseInt(h, 16);
    }

    utils.stringToHex=function(tmp) {
        var str = '',
            i = 0,
            tmp_len = tmp.length,
            c;

        for (; i < tmp_len; i += 1) {
            c = tmp.charCodeAt(i);
            str += zero(d2h(c),2) + ' ';
        }
        return str;
    }

    utils.stringToHex2=function(tmp) {
        var str = '',
            i = 0,
            tmp_len = tmp.length,
            c;

        for (; i < tmp_len; i += 1) {
            c = tmp.charCodeAt(i);
            str += zero(d2h(c),2) + ' ';
        }
        return str;
    }
    function hexToString (tmp) {
        var arr = tmp.split(' '),
            str = '',
            i = 0,
            arr_len = arr.length,
            c;

        for (; i < arr_len; i += 1) {
            c = String.fromCharCode( h2d( arr[i] ) );
            str += c;
        }

        return str;
    }

    var zero = function (n, max) {
        n = n.toString(16).toUpperCase();
        while (n.length < max) {
            n = '0' + n;
        }
        return n;
    };

    utils.prettyHex = function (buffer) {
        var rows = Math.ceil(buffer.length / 16);
        var last = buffer.length % 16 || 16;
        var offsetLength = buffer.length.toString(16).length;
        if (offsetLength < 6) offsetLength = 6;

        var str = 'Offset';
        while (str.length < offsetLength) {
            str += ' ';
        }

        str = '\u001b[36m' + str + '  ';

        var i;
        for (i = 0; i < 16; i++) {
            str += ' ' + zero(i, 2);
        }

        str += '\u001b[0m\n';
        if (buffer.length) str += '\n';

        var b = 0;
        var lastBytes;
        var lastSpaces;
        var v;

        for (i = 0; i < rows; i++) {
            str += '\u001b[36m' + zero(b, offsetLength) + '\u001b[0m  ';
            lastBytes = i === rows - 1 ? last : 16;
            lastSpaces = 16 - lastBytes;

            var j;
            for (j = 0; j < lastBytes; j++) {
                str += ' ' + zero(buffer[b], 2);
                b++;
            }

            for (j = 0; j < lastSpaces; j++) {
                str += '   ';
            }

            b -= lastBytes;
            str += '   ';

            for (j = 0; j < lastBytes; j++) {
                v = buffer[b];
                str += (v > 31 && v < 127) || v > 159 ? String.fromCharCode(v) : '.';
                b++;
            }

            str += '\n';
        }

        //process.stdout.write(str);
        //console.log(str);
        return str;
    };


    utils.hexEncode = function(str,prefix){
        var hex, i;

        var result = "";
        for (i=0; i<str.length; i++) {
            hex = str.charCodeAt(i).toString(16);
            result += ((prefix!==null ? prefix : "000")+hex).slice(-4);
        }

        return result
    }
    utils.markHex=function(str,prefix,suffix,sign){
        //var myString = "test \x7f asd \n \t  dsf \r";
        prefix = prefix || "";
        suffix = suffix || "";
        var myString = "" + str;
        var pattern = /[^\x20-\x7E]/gim;
        var match = pattern.exec(myString);
        var matches = myString.match(pattern);
        var newString = "" + myString;

        myString.replace(pattern, function(a,b){
            var _raw = utils.hexEncode(a,'$');
            if(_raw.length==2){
                _raw = _raw.replace("$","$0")
            }
            //myString = myString.toUpperCase();
            _raw = _raw.toUpperCase();
            myString = myString.replace(a,prefix +  _raw + suffix);
        });
        //console.log(myString);
        //console.log(myString.toUpperCase());
        return myString;
    }
    /**
     *
     * @param n
     * @returns {string}
     */
    utils.to_hex=function(n){
        var hex_result=''
        var the_start=true;
        for(var i=32;i>0;){
            i-=4;
            var one_digit=(n>>i)&0xf;
            if(!the_start||one_digit!=0){
                the_start=false;
                hex_result+=digit_array[one_digit];
            }
        }
        return '0x'+(hex_result==''?'0':hex_result);
    }


    function serializer(replacer, cycleReplacer) {
        var stack = [], keys = []

        if (cycleReplacer == null) cycleReplacer = function(key, value) {
            if (stack[0] === value) return "[Circular ~]"
            return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
        }

        return function(key, value) {
            if (stack.length > 0) {
                var thisPos = stack.indexOf(this)
                ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
                ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
                if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
            }
            else stack.push(value)

            return replacer == null ? value : replacer.call(this, key, value)
        }
    }

    utils.stringify=function(obj){
        return JSON.stringify(obj, serializer(), 2);
    }
    utils.humanFileSize=function(bytes, si) {
        var thresh = si ? 1000 : 1024;
        if(Math.abs(bytes) < thresh) {
            return bytes + ' B';
        }
        var units = si
            ? ['kB','MB','GB','TB','PB','EB','ZB','YB']
            : ['KiB','MiB','GiB','TiB','PiB','EiB','ZiB','YiB'];
        var u = -1;
        do {
            bytes /= thresh;
            ++u;
        } while(Math.abs(bytes) >= thresh && u < units.length - 1);
        return bytes.toFixed(1)+' '+units[u];
    }

    if (typeof String.prototype.startsWith != 'function') {
        // see below for better implementation!
        String.prototype.startsWith = function (str){
            return this.indexOf(str) === 0;
        };
    }

    utils.isNativeEvent=function(str){
        var _foo=null,//just for having an optimized object map for a native event lookup below
            _nativeEvents = {
                "onclick": _foo,
                "ondblclick":_foo,
                "onmousedown":_foo,
                "onmouseup":_foo,
                "onmouseover":_foo,
                "onmousemove":_foo,
                "onmouseout":_foo,
                "onkeypress":_foo,
                "onkeydown":_foo,
                "onkeyup":_foo,
                "onfocus":_foo,
                "onblur":_foo,
                "onchange":_foo
            };

        if(str in _nativeEvents){
            return true;
        };


        _nativeEvents = {
            "click": _foo,
            "dblclick":_foo,
            "mousedown":_foo,
            "mouseup":_foo,
            "mouseover":_foo,
            "mousemove":_foo,
            "mouseout":_foo,
            "keypress":_foo,
            "keydown":_foo,
            "keyup":_foo,
            "focus":_foo,
            "blur":_foo,
            "change":_foo
        };

        return str in _nativeEvents;

    };
    utils.isSystemEvent=function(str){

        for(var t in types.EVENTS){
            if(types.EVENTS[t]===str){
                return true;
            }
        }
        return false;
    };

    /**
     *
     * @param arr
     * @param val
     * @returns {number}
     */
    utils.contains = function (arr, val) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === val) {
                return i;
            }
        }
        return -1;
    };
    /**
     *
     * @param obj
     * @param val
     * @returns {*}
     */
    utils.getObjectKeyByValue = function (obj, val) {
        if (obj && val) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    if (obj[prop] === val)
                        return prop;
                }
            }
        }
        return null;
    };

    /**
     *
     * @param url
     * @param parameter
     * @returns {*}
     */
    utils.removeURLParameter = function (url, parameter) {
        //prefer to use l.search if you have a location/link object
        var urlparts = url.split('?');
        if (urlparts.length >= 2) {

            var prefix = encodeURIComponent(parameter) + '=';
            var pars = urlparts[1].split(/[&;]/g);

            //reverse iteration as may be destructive
            for (var i = pars.length; i-- > 0;) {
                //idiom for string.startsWith
                if (pars[i].lastIndexOf(prefix, 0) !== -1) {
                    pars.splice(i, 1);
                }
            }

            url = urlparts[0] + '?' + pars.join('&');
            return url;
        } else {
            return url;
        }
    };

    utils.replaceUrlParam = function (url, paramName, paramValue) {
        if(url.indexOf(paramName)==-1){
            url +=(url.indexOf('?') > 0 ? '&' : '?') + paramName +'=' +paramValue;
            return url;
        }
        var pattern = new RegExp('(' + paramName + '=).*?(&|$)');
        var newUrl = url.replace(pattern, '$1' + paramValue + '$2');
        if (newUrl == url) {
            newUrl = newUrl + (newUrl.indexOf('?') > 0 ? '&' : '?') + paramName + '=' + paramValue
        }
        return newUrl
    };

    /**
     *
     * @param mount
     * @param path
     * @param encode
     * @returns {string}
     */
    utils.buildPath = function (mount, path, encode) {

        //fix mount
        var _mount = '' + mount;
        _mount = utils.replaceAll('/', '', mount);
        var _path = '' + path;
        _path = _path.replace('./', '/').replace(/^\/|\/$/g, '');

        var _res = _mount + '://' + _path;
        if (encode === true) {
            return encodeURIComponent(_res);
        }
        return _res;
    };

    /**
     *
     * @param string
     * @returns {boolean}
     */
    utils.isImage = function (string) {
        return string.toLowerCase().match(/\.(jpeg|jpg|gif|png)$/) != null;
    };

    /**
     *
     * @param field
     * @param enumValue
     * @returns {boolean}
     */
    utils.hasFlag3 = function (field, enumValue) {
        var _enumUp = 1 << enumValue;
        var _res = _enumUp & field;
        return ((1 << enumValue) & field) ? true : false;
    };
    utils.hasFlag = function (field, enumValue) {
        var _enumUp = 1 << enumValue;
        var _res = _enumUp & field;
        return ((1 << enumValue) & field) ? true : false;
    };

    utils.disableFlag=function(enumValue,field)
    {
        enumValue &=~(1<<field);
        return enumValue;
    };
    /**
     * XApp specific url string cleaner
     * @param string
     * @returns {*}
     */
    utils.cleanUrl = function (string) {
        if (string) {
            //subject.replace(/(?<!(?:ht|f)tps?:)\/*\//g, "/");
            string = string.replace('//', '/');
            string = string.replace('./', '/');
            string = string.replace('http:/', 'http://');
            string = string.replace('./', '/');
            string = string.replace('////', '/');
            string = string.replace('///', '/');
            return string;
        }
        return string;
    };
    /**
     * Return data from JSON
     * @param inData
     * @param validOnly
     * @returns {*}
     */
    utils.getJson = function (inData, validOnly,ommit) {
        try {
            return _.isString(inData) ? json.parse(inData, false) : validOnly === true ? null : inData;
        } catch (e) {
            ommit !== false && console.error('error parsing json data ' + inData + ' error = ' + e);
        }
        return null;
    };

    /**
     * Hard Dojo override to catch malformed JSON.
     * @param js
     * @returns {*}
     */
    utils.fromJson = function (js) {

        if(!lang.isString(js)){
            return js;
        }
        var res = null;
        var didFail = false;
        try {
            res = eval("(" + js + ")",{});
        } catch (e) {
            didFail = true;

        }
        if (didFail) {
            js = js.substring(js.indexOf('{'), js.lastIndexOf('}') + 1);
            try {
                res = eval("(" + js + ")",{});
            } catch (e) {
                //console.error('error in json parsing! ' + js);
                throw new Error(js);
            }
        }
        return res;
    };

    /**
     * String Replace which works with multiple found items. Native aborts on the first needle.
     * @param find
     * @param replace
     * @param str
     * @returns {string}
     */
    utils.replaceAll = function (find, replace, str) {
        //return str.replace(new RegExp(find, 'g'), replace);\
        if (!str) {
            //debugger;
        }
        return str ? str.split(find).join(replace) : '';//faster!
    };

    /**
     * CI compatible string check for null and length>0
     * @param input
     * @returns {boolean}
     */
    utils.isValidString = function (input) {
        // summary:
        //		Validates a string against null, phantom objects and a length of 0
        // input:
        //		The value to test
        return input != null && input.length != null && input.length > 0 && input != "undefined"; //Boolean
    };

    utils.substituteString = function (template, obj) {
        return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g, function (match, key) {
            return obj[key];
        });
    };

    /**
     *
     * @param expression
     * @param delimiters
     * @returns {*}
     * @private
     */
    utils.findOcurrences = function (expression, delimiters) {

        // prepare delimiters for the regular expression
        var d = {
            begin: utils.escapeRegExp(delimiters.begin),
            end: utils.escapeRegExp(delimiters.end)
        };

        // regular expression for [<content>]
        var allExceptEnd = "[^" + d.end + "]*";

        // final regular expression = find all [variables]
        var patt = d.begin + "(" + allExceptEnd + ")" + d.end;

        return expression.match(new RegExp(patt, 'g'));
    };

    /**
     * Escape regular expressions in a string
     * @param string
     * @returns {*}
     * @private
     */
    utils.escapeRegExp = function (string) {

        var special = ["[", "]", "(", ")", "{", "}", "*", "+", ".","|","||"];
        for (var n = 0; n < special.length; n++) {
            string = string.replace(special[n], "\\" + special[n]);
        }

        return string;
    };

    /**
     * Tokenizes by begin & end pattern
     * @param expression
     * @param delimiters
     * @returns {string}
     */
    utils.findOcurrences = function (expression, delimiters) {
        // prepare delimiters for the regular expression
        var d = {
            begin: utils.escapeRegExp(delimiters.begin),
            end: utils.escapeRegExp(delimiters.end)
        };

        // regular expression for [<content>]
        var allExceptEnd = "[^" + d.end + "]*";

        // final regular expression = find all [variables]
        var patt = d.begin + "(" + allExceptEnd + ")" + d.end;

        return expression.match(new RegExp(patt, 'g'));
    };

    /**
     *
     * @param str {string} hackstack
     * @param hash {Object}
     * @returns {string}
     */
    utils.multipleReplace = function (str, hash) {
        //to array
        var a = [];
        for (var key in hash) {
            a[a.length] = key;
        }
        return str.replace(new RegExp(a.join('\\b|\\b'), 'g'), function (m) {
            return hash[m] || hash["\\" + m];
        });
    };

    /**
     * Flexible replacer, supports multiple replace and safe replace
     *
     * @param str {string} the haystack

     * @param needle {string|null} optional, only needed for simple cases, otherwise its using the 'what' map
     *
     * @param what {string|Object}. When string, its replacing 'needle' with 'what'. If its a hash-map:
     * variable:value, its replacing occurrences of all variables in 'haystack'. In such case, you can specify
     * delimiters to make sure that 'unresolved' variables will be stripped of in the result.
     *
     * @param delimiters {Object} Delimiters to identify variables. This is used to eliminate unresolved variables from
     * the result.
     *
     * @param delimiters.begin {string}
     * @param delimiters.end {string}
     *
     * @returns {string}
     *
     *
     * @example:
     *
     * 1. simple case: replace all '/' with ''
     *
     * return utils.replace('/foo/','/','') //returns 'foo'
     *
     * 2. simple case with multiple variables:
     *
     * return utils.replace('darling, i miss you so much',null,{'miss':'kiss','much':'little'})
     * # darling, i kiss you so little
     *
     * @memberOf module:xide/utils
     * @extends xide/utils
     */
    utils.replace = function (str, needle, what, delimiters) {
        if (!str) {
            return '';
        }
        if (what && lang.isObject(what) || lang.isArray(what)) {

            if (delimiters) {

                var ocurr = utils.findOcurrences(str, delimiters),
                    replaceAll = utils.replaceAll;
                if (ocurr) {

                    for (var i = 0, j = ocurr.length; i < j; i++) {
                        var el = ocurr[i];

                        //strip off delimiters
                        var _variableName = replaceAll(delimiters.begin, '', el);
                        _variableName = replaceAll(delimiters.end, '', _variableName);
                        str = replaceAll(el, what[_variableName], str);
                    }
                } else {
                    return str;
                }
            } else {
                //fast case
                return utils.multipleReplace(str, what)
            }
            return str;
        }
        //fast case
        return utils.replaceAll(needle, what, str);
    };

    utils.capitalize = function (word) {
        return word.substring(0, 1).toUpperCase() + word.substring(1);
    };

    utils.vsprintf = function (format, args) {
        // http://kevin.vanzonneveld.net
        // +   original by: ejsanders
        // -    depends on: sprintf
        // *     example 1: vsprintf('%04d-%02d-%02d', [1988, 8, 1]);
        // *     returns 1: '1988-08-01'
        return utils.sprintf.apply(this, [format].concat(args));
    };
    utils.sprintf = function () {
        // http://kevin.vanzonneveld.net
        // +   original by: Ash Searle (http://hexmen.com/blog/)
        // + namespaced by: Michael White (http://getsprink.com)
        // +    tweaked by: Jack
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +      input by: Paulo Freitas
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +      input by: Brett Zamir (http://brett-zamir.me)
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +   improved by: Dj
        // +   improved by: Allidylls
        // *     example 1: sprintf("%01.2f", 123.1);
        // *     returns 1: 123.10
        // *     example 2: sprintf("[%10s]", 'monkey');
        // *     returns 2: '[    monkey]'
        // *     example 3: sprintf("[%'#10s]", 'monkey');
        // *     returns 3: '[####monkey]'
        // *     example 4: sprintf("%d", 123456789012345);
        // *     returns 4: '123456789012345'
        var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
        var a = arguments,
            i = 0,
            format = a[i++];

        // pad()
        var pad = function (str, len, chr, leftJustify) {
            if (!chr) {
                chr = ' ';
            }
            var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
            return leftJustify ? str + padding : padding + str;
        };

        // justify()
        var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
            var diff = minWidth - value.length;
            if (diff > 0) {
                if (leftJustify || !zeroPad) {
                    value = pad(value, minWidth, customPadChar, leftJustify);
                } else {
                    value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
                }
            }
            return value;
        };

        // formatBaseX()
        var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
            // Note: casts negative numbers to positive ones
            var number = value >>> 0;
            prefix = prefix && number && {
                '2': '0b',
                '8': '0',
                '16': '0x'
            }[base] || '';
            value = prefix + pad(number.toString(base), precision || 0, '0', false);
            return justify(value, prefix, leftJustify, minWidth, zeroPad);
        };

        // formatString()
        var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
            if (precision != null) {
                value = value.slice(0, precision);
            }
            return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
        };

        // doFormat()
        var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
            var number;
            var prefix;
            var method;
            var textTransform;
            var value;

            if (substring === '%%') {
                return '%';
            }

            // parse flags
            var leftJustify = false,
                positivePrefix = '',
                zeroPad = false,
                prefixBaseX = false,
                customPadChar = ' ';
            var flagsl = flags.length;
            for (var j = 0; flags && j < flagsl; j++) {
                switch (flags.charAt(j)) {
                    case ' ':
                        positivePrefix = ' ';
                        break;
                    case '+':
                        positivePrefix = '+';
                        break;
                    case '-':
                        leftJustify = true;
                        break;
                    case "'":
                        customPadChar = flags.charAt(j + 1);
                        break;
                    case '0':
                        zeroPad = true;
                        break;
                    case '#':
                        prefixBaseX = true;
                        break;
                }
            }

            // parameters may be null, undefined, empty-string or real valued
            // we want to ignore null, undefined and empty-string values
            if (!minWidth) {
                minWidth = 0;
            } else if (minWidth === '*') {
                minWidth = +a[i++];
            } else if (minWidth.charAt(0) == '*') {
                minWidth = +a[minWidth.slice(1, -1)];
            } else {
                minWidth = +minWidth;
            }

            // Note: undocumented perl feature:
            if (minWidth < 0) {
                minWidth = -minWidth;
                leftJustify = true;
            }

            if (!isFinite(minWidth)) {
                throw new Error('sprintf: (minimum-)width must be finite');
            }

            if (!precision) {
                precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type === 'd') ? 0 : undefined;
            } else if (precision === '*') {
                precision = +a[i++];
            } else if (precision.charAt(0) == '*') {
                precision = +a[precision.slice(1, -1)];
            } else {
                precision = +precision;
            }

            // grab value using valueIndex if required?
            value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

            switch (type) {
                case 's':
                    return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
                case 'c':
                    return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
                case 'b':
                    return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'o':
                    return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'x':
                    return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'X':
                    return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
                case 'u':
                    return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'i':
                case 'd':
                    number = +value || 0;
                    number = Math.round(number - number % 1); // Plain Math.round doesn't just truncate
                    prefix = number < 0 ? '-' : positivePrefix;
                    value = prefix + pad(String(Math.abs(number)), precision, '0', false);
                    return justify(value, prefix, leftJustify, minWidth, zeroPad);
                case 'e':
                case 'E':
                case 'f': // Should handle locales (as per setlocale)
                case 'F':
                case 'g':
                case 'G':
                    number = +value;
                    prefix = number < 0 ? '-' : positivePrefix;
                    method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
                    textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
                    value = prefix + Math.abs(number)[method](precision);
                    return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
                default:
                    return substring;
            }
        };

        return format.replace(regex, doFormat);
    };
    /***
     *
     * @param str
     * @returns {*}
     */
    utils.cleanString = function (str) {

        if (!str) {
            return null;
        }
        str = str.replace(/[\r]/g, '')
            .replace(/[\b]/g, '')
            .replace(/[\f]/g, '')
            .replace(/[\n]/g, '')
            .replace(/\\/g, '');

        //str = str.leftTrim();//defined in Commons boot strap
        //str = str.rightTrim();
        return str;
    };
    /***
     *
     * @param str
     * @returns {*}
     */
    utils.normalizePath = function (str) {

        if (!str) {
            return null;
        }
        str = utils.cleanString(str);//control characters
        str = str.replace('./', '');//file store specifics
        str = str.replace('/.', '');//file store specifics
        str = str.replace(/([^:]\/)\/+/g, "$1");//double slashes
        return str;
    };

    types.PATH_PARTS={
        'DIRNAME'       : 1,
        'BASENAME'      : 2,
        'EXTENSION'     : 4,
        'FILENAME'      : 8,
        'PATHINFO_ALL'  : 0
    }
    utils.basename=function(path, suffix) {
        //  discuss at: http://phpjs.org/functions/basename/
        // original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // improved by: Ash Searle (http://hexmen.com/blog/)
        // improved by: Lincoln Ramsay
        // improved by: djmix
        // improved by: Dmitry Gorelenkov
        //   example 1: basename('/www/site/home.htm', '.htm');
        //   returns 1: 'home'
        //   example 2: basename('ecra.php?p=1');
        //   returns 2: 'ecra.php?p=1'
        //   example 3: basename('/some/path/');
        //   returns 3: 'path'
        //   example 4: basename('/some/path_ext.ext/','.ext');
        //   returns 4: 'path_ext'

        var b = path;
        var lastChar = b.charAt(b.length - 1);

        if (lastChar === '/' || lastChar === '\\') {
            b = b.slice(0, -1);
        }

        b = b.replace(/^.*[\/\\]/g, '');

        if (typeof suffix === 'string' && b.substr(b.length - suffix.length) == suffix) {
            b = b.substr(0, b.length - suffix.length);
        }

        return b;
    }

    /**
     *
     * @param path
     * @param options
     * @returns {*}
     */
    utils.pathinfo=function(path, options)
    {
        //  discuss at: http://phpjs.org/functions/pathinfo/
        // original by: Nate
        //  revised by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // improved by: Brett Zamir (http://brett-zamir.me)
        // improved by: Dmitry Gorelenkov
        //    input by: Timo
        //        note: Inspired by actual PHP source: php5-5.2.6/ext/standard/string.c line #1559
        //        note: The way the bitwise arguments are handled allows for greater flexibility
        //        note: & compatability. We might even standardize this code and use a similar approach for
        //        note: other bitwise PHP functions
        //        note: php.js tries very hard to stay away from a core.js file with global dependencies, because we like
        //        note: that you can just take a couple of functions and be on your way.
        //        note: But by way we implemented this function, if you want you can still declare the PATHINFO_*
        //        note: yourself, and then you can use: pathinfo('/www/index.html', PATHINFO_BASENAME | PATHINFO_EXTENSION);
        //        note: which makes it fully compliant with PHP syntax.
        //  depends on: basename
        //   example 1: pathinfo('/www/htdocs/index.html', 1);
        //   returns 1: '/www/htdocs'
        //   example 2: pathinfo('/www/htdocs/index.html', 'PATHINFO_BASENAME');
        //   returns 2: 'index.html'
        //   example 3: pathinfo('/www/htdocs/index.html', 'PATHINFO_EXTENSION');
        //   returns 3: 'html'
        //   example 4: pathinfo('/www/htdocs/index.html', 'PATHINFO_FILENAME');
        //   returns 4: 'index'
        //   example 5: pathinfo('/www/htdocs/index.html', 2 | 4);
        //   returns 5: {basename: 'index.html', extension: 'html'}
        //   example 6: pathinfo('/www/htdocs/index.html', 'PATHINFO_ALL');
        //   returns 6: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
        //   example 7: pathinfo('/www/htdocs/index.html');
        //   returns 7: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}

        var opt = '',
            real_opt = '',
            optName = '',
            optTemp = 0,
            tmp_arr = {},
            cnt = 0,
            i = 0;
        var have_basename = false,
            have_extension = false,
            have_filename = false;

        // Input defaulting & sanitation
        if (!path) {
            return false;
        }
        if (!options) {
            options = 'PATHINFO_ALL';
        }

        // Initialize binary arguments. Both the string & integer (constant) input is
        // allowed
        var OPTS = {
            'PATHINFO_DIRNAME'   : 1,
            'PATHINFO_BASENAME'  : 2,
            'PATHINFO_EXTENSION' : 4,
            'PATHINFO_FILENAME'  : 8,
            'PATHINFO_ALL'       : 0
        };
        // PATHINFO_ALL sums up all previously defined PATHINFOs (could just pre-calculate)
        for (optName in OPTS) {
            if (OPTS.hasOwnProperty(optName)) {
                OPTS.PATHINFO_ALL = OPTS.PATHINFO_ALL | OPTS[optName];
            }
        }
        if (typeof options !== 'number') {
            // Allow for a single string or an array of string flags
            options = [].concat(options);
            for (i = 0; i < options.length; i++) {
                // Resolve string input to bitwise e.g. 'PATHINFO_EXTENSION' becomes 4
                if (OPTS[options[i]]) {
                    optTemp = optTemp | OPTS[options[i]];
                }
            }
            options = optTemp;
        }

        // Internal Functions
        var __getExt = function(path) {
            var str = path + '';
            var dotP = str.lastIndexOf('.') + 1;
            return !dotP ? false : dotP !== str.length ? str.substr(dotP) : '';
        };

        // Gather path infos
        if (options & OPTS.PATHINFO_DIRNAME) {
            var dirName = path.replace(/\\/g, '/')
                .replace(/\/[^\/]*\/?$/, ''); // dirname
            tmp_arr.dirname = dirName === path ? '.' : dirName;
        }

        if (options & OPTS.PATHINFO_BASENAME) {
            if (false === have_basename) {
                have_basename = utils.basename(path);
            }
            tmp_arr.basename = have_basename;
        }

        if (options & OPTS.PATHINFO_EXTENSION) {
            if (false === have_basename) {
                have_basename = utils.basename(path);
            }
            if (false === have_extension) {
                have_extension = __getExt(have_basename);
            }
            if (false !== have_extension) {
                tmp_arr.extension = have_extension;
            }
        }

        if (options & OPTS.PATHINFO_FILENAME) {
            if (false === have_basename) {
                have_basename = utils.basename(path);
            }
            if (false === have_extension) {
                have_extension = __getExt(have_basename);
            }
            if (false === have_filename) {
                have_filename = have_basename.slice(0, have_basename.length - (have_extension ? have_extension.length + 1 :
                        have_extension === false ? 0 : 1));
            }

            tmp_arr.filename = have_filename;
        }

        // If array contains only 1 element: return string
        cnt = 0;
        for (opt in tmp_arr) {
            if (tmp_arr.hasOwnProperty(opt)) {
                cnt++;
                real_opt = opt;
            }
        }
        if (cnt === 1) {
            return tmp_arr[real_opt];
        }

        // Return full-blown array
        return tmp_arr;
    }

    utils.parse_url = function (str, component) {
        //       discuss at: http://phpjs.org/functions/parse_url/
        //      original by: Steven Levithan (http://blog.stevenlevithan.com)
        // reimplemented by: Brett Zamir (http://brett-zamir.me)
        //         input by: Lorenzo Pisani
        //         input by: Tony
        //      improved by: Brett Zamir (http://brett-zamir.me)
        //             note: original by http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
        //             note: blog post at http://blog.stevenlevithan.com/archives/parseuri
        //             note: demo at http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
        //             note: Does not replace invalid characters with '_' as in PHP, nor does it return false with
        //             note: a seriously malformed URL.
        //             note: Besides function name, is essentially the same as parseUri as well as our allowing
        //             note: an extra slash after the scheme/protocol (to allow file:/// as in PHP)
        //        example 1: parse_url('http://username:password@hostname/path?arg=value#anchor');
        //        returns 1: {scheme: 'http', host: 'hostname', user: 'username', pass: 'password', path: '/path', query: 'arg=value', fragment: 'anchor'}

        var query, key = ['source', 'scheme', 'authority', 'userInfo', 'user', 'pass', 'host', 'port',
                'relative', 'path', 'directory', 'file', 'query', 'fragment'
            ],
            ini = (this.php_js && this.php_js.ini) || {},
            mode = (ini['phpjs.parse_url.mode'] &&
                ini['phpjs.parse_url.mode'].local_value) || 'php',
            parser = {
                php: /^(?:([^:\/?#]+):)?(?:\/\/()(?:(?:()(?:([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?()(?:(()(?:(?:[^?#\/]*\/)*)()(?:[^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/\/?)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ // Added one optional slash to post-scheme to catch file:/// (should restrict this)
            };

        var m = parser[mode].exec(str),
            uri = {},
            i = 14;
        while (i--) {
            if (m[i]) {
                uri[key[i]] = m[i];
            }
        }

        if (component) {
            return uri[component.replace('PHP_URL_', '')
                .toLowerCase()];
        }
        if (mode !== 'php') {
            var name = (ini['phpjs.parse_url.queryKey'] &&
                ini['phpjs.parse_url.queryKey'].local_value) || 'queryKey';
            parser = /(?:^|&)([^&=]*)=?([^&]*)/g;
            uri[name] = {};
            query = uri[key[12]] || '';
            query.replace(parser, function ($0, $1, $2) {
                if ($1) {
                    uri[name][$1] = $2;
                }
            });
        }
        delete uri.source;
        return uri;
    }
    /***
     *
     * @returns {{mid: string, txt: string, sql: string, js: string, gif: string, jpg: string, html: string, htm: string, rar: string, gz: string, tgz: string, z: string, ra: string, ram: string, rm: string, pl: string, zip: string, wav: string, php: string, php3: string, phtml: string, exe: string, bmp: string, png: string, css: string, mp3: string, m4a: string, aac: string, xls: string, xlsx: string, ods: string, sxc: string, csv: string, tsv: string, doc: string, docx: string, odt: string, swx: string, rtf: string, ppt: string, pps: string, odp: string, sxi: string, pdf: string, mov: string, avi: string, mpg: string, mpeg: string, mp4: string, m4v: string, ogv: string, webm: string, wmv: string, swf: string, flv: string, tiff: string, tif: string, svg: string, psd: string, ers: string}}
     */
    utils.getMimeTable = function () {
        return {
            "mid": "midi.png",
            "txt": "txt2.png",
            "sql": "txt2.png",
            "js": "javascript.png",
            "gif": "image.png",
            "jpg": "image.png",
            "html": "html.png",
            "htm": "html.png",
            "rar": "archive.png",
            "gz": "zip.png",
            "tgz": "archive.png",
            "z": "archive.png",
            "ra": "video.png",
            "ram": "video.png",
            "rm": "video.png",
            "pl": "source_pl.png",
            "zip": "zip.png",
            "wav": "sound.png",
            "php": "php.png",
            "php3": "php.png",
            "phtml": "php.png",
            "exe": "exe.png",
            "bmp": "image.png",
            "png": "image.png",
            "css": "css.png",
            "mp3": "sound.png",
            "m4a": "sound.png",
            "aac": "sound.png",
            "xls": "spreadsheet.png",
            "xlsx": "spreadsheet.png",
            "ods": "spreadsheet.png",
            "sxc": "spreadsheet.png",
            "csv": "spreadsheet.png",
            "tsv": "spreadsheet.png",
            "doc": "word.png",
            "docx": "word.png",
            "odt": "word.png",
            "swx": "word.png",
            "rtf": "word.png",
            "ppt": "presentation.png",
            "pps": "presentation.png",
            "odp": "presentation.png",
            "sxi": "presentation.png",
            "pdf": "pdf.png",
            "mov": "video.png",
            "avi": "video.png",
            "mpg": "video.png",
            "mpeg": "video.png",
            "mp4": "video.png",
            "m4v": "video.png",
            "ogv": "video.png",
            "webm": "video.png",
            "wmv": "video.png",
            "swf": "flash.png",
            "flv": "flash.png",
            "tiff": "image.png",
            "tif": "image.png",
            "svg": "image.png",
            "psd": "image.png",
            "ers": "horo.png"
        };
    };

    /***
     *
     * @returns {{mid: string, txt: string, sql: string, js: string, gif: string, jpg: string, html: string, htm: string, rar: string, gz: string, tgz: string, z: string, ra: string, ram: string, rm: string, pl: string, zip: string, wav: string, php: string, php3: string, phtml: string, exe: string, bmp: string, png: string, css: string, mp3: string, m4a: string, aac: string, xls: string, xlsx: string, ods: string, sxc: string, csv: string, tsv: string, doc: string, docx: string, odt: string, swx: string, rtf: string, ppt: string, pps: string, odp: string, sxi: string, pdf: string, mov: string, avi: string, mpg: string, mpeg: string, mp4: string, m4v: string, ogv: string, webm: string, wmv: string, swf: string, flv: string, tiff: string, tif: string, svg: string, psd: string, ers: string}}
     */
    utils.getMimeTable2 = function () {
        return {
            "mid": "fa-file-audio-o",
            "txt": "fa-file-text-o",
            "sql": "fa-cube",
            "js": "fa-cube",
            "gif": "fa-file-picture-o",
            "jpg": "fa-file-picture-o",
            "html": "fa-cube",
            "htm": "fa-cube",
            "rar": "fa-file-zip-o",
            "gz": "fa-file-zip-o",
            "tgz": "fa-file-zip-o",
            "z": "fa-file-zip-o",
            "ra": "fa-file-movie-o",
            "ram": "fa-file-movie-o",
            "rm": "fa-file-movie-o",
            "pl": "source_pl.png",
            "zip": "fa-file-zip-o",
            "wav": "fa-file-audio-o",
            "php": "fa-cube",
            "php3": "fa-cube",
            "phtml": "fa-cube",
            "exe": "fa-file-o",
            "bmp": "fa-file-picture-o",
            "png": "fa-file-picture-o",
            "css": "fa-cube",
            "mp3": "fa-file-audio-o",
            "m4a": "fa-file-audio-o",
            "aac": "fa-file-audio-o",
            "xls": "fa-file-excel-o",
            "xlsx": "fa-file-excel-o",
            "ods": "fa-file-excel-o",
            "sxc": "fa-file-excel-o",
            "csv": "fa-file-excel-o",
            "tsv": "fa-file-excel-o",
            "doc": "fa-file-word-o",
            "docx": "fa-file-word-o",
            "odt": "fa-file-word-o",
            "swx": "fa-file-word-o",
            "rtf": "fa-file-word-o",
            "ppt": "fa-file-powerpoint-o",
            "pps": "fa-file-powerpoint-o",
            "odp": "fa-file-powerpoint-o",
            "sxi": "fa-file-powerpoint-o",
            "pdf": "fa-file-pdf-o",
            "mov": "fa-file-movie-o",
            "avi": "fa-file-movie-o",
            "mpg": "fa-file-movie-o",
            "mpeg": "fa-file-movie-o",
            "mp4": "fa-file-movie-o",
            "m4v": "fa-file-movie-o",
            "ogv": "fa-file-movie-o",
            "webm": "fa-file-movie-o",
            "wmv": "fa-file-movie-o",
            "swf": "fa-file-movie-o",
            "flv": "fa-file-movie-o",
            "tiff": "fa-file-picture-o",
            "tif": "fa-file-picture-o",
            "svg": "fa-file-picture-o",
            "psd": "fa-file-picture-o",
            "ers": "horo.png"
        };
    };
    /***
     *
     * @returns {{mid: string, txt: string, sql: string, js: string, gif: string, jpg: string, html: string, htm: string, rar: string, gz: string, tgz: string, z: string, ra: string, ram: string, rm: string, pl: string, zip: string, wav: string, php: string, php3: string, phtml: string, exe: string, bmp: string, png: string, css: string, mp3: string, m4a: string, aac: string, xls: string, xlsx: string, ods: string, sxc: string, csv: string, tsv: string, doc: string, docx: string, odt: string, swx: string, rtf: string, ppt: string, pps: string, odp: string, sxi: string, pdf: string, mov: string, avi: string, mpg: string, mpeg: string, mp4: string, m4v: string, ogv: string, webm: string, wmv: string, swf: string, flv: string, tiff: string, tif: string, svg: string, psd: string, ers: string}}
     */
    utils.getIconTable = function () {
        return {
            "mid": "midi.png",
            "txt": "txt2.png",
            "sql": "txt2.png",
            "js": "javascript.png",
            "gif": "image.png",
            "jpg": "image.png",
            "html": "html.png",
            "htm": "html.png",
            "rar": "archive.png",
            "gz": "zip.png",
            "tgz": "archive.png",
            "z": "archive.png",
            "ra": "video.png",
            "ram": "video.png",
            "rm": "video.png",
            "pl": "source_pl.png",
            "zip": "zip.png",
            "wav": "sound.png",
            "php": "php.png",
            "php3": "php.png",
            "phtml": "php.png",
            "exe": "exe.png",
            "bmp": "image.png",
            "png": "image.png",
            "css": "css.png",
            "mp3": "sound.png",
            "m4a": "sound.png",
            "aac": "sound.png",
            "xls": "spreadsheet.png",
            "xlsx": "spreadsheet.png",
            "ods": "spreadsheet.png",
            "sxc": "spreadsheet.png",
            "csv": "spreadsheet.png",
            "tsv": "spreadsheet.png",
            "doc": "word.png",
            "docx": "word.png",
            "odt": "word.png",
            "swx": "word.png",
            "rtf": "word.png",
            "ppt": "presentation.png",
            "pps": "presentation.png",
            "odp": "presentation.png",
            "sxi": "presentation.png",
            "pdf": "pdf.png",
            "mov": "video.png",
            "avi": "video.png",
            "mpg": "video.png",
            "mpeg": "video.png",
            "mp4": "video.png",
            "m4v": "video.png",
            "ogv": "video.png",
            "webm": "video.png",
            "wmv": "video.png",
            "swf": "flash.png",
            "flv": "flash.png",
            "tiff": "image.png",
            "tif": "image.png",
            "svg": "image.png",
            "psd": "image.png",
            "ers": "horo.png"
        };
    };


    utils.urlDecode = function (string, overwrite) {
        if (!string || !string.length) {
            return {}
        }
        var obj = {};
        var pairs = string.split("&");
        var pair, name, value;
        for (var i = 0, len = pairs.length; i < len; i++) {
            pair = pairs[i].split("=");
            name = decodeURIComponent(pair[0]);
            value = decodeURIComponent(pair[1]);
            if (value != null && value === 'true') {
                value = true;
            } else if (value === 'false') {
                value = false;
            }
            if (overwrite !== true) {
                if (typeof obj[name] == "undefined") {
                    obj[name] = value
                } else {
                    if (typeof obj[name] == "string") {
                        obj[name] = [obj[name]];
                        obj[name].push(value)
                    } else {
                        obj[name].push(value)
                    }
                }
            } else {
                obj[name] = value
            }
        }
        return obj;
    };
    utils.getUrlArgs = function (string) {

        var args = {};
        if (string && (string.indexOf('?') != -1 || string.indexOf('&') != -1)) {

            var query = string.substr(string.indexOf("?") + 1) || location.search.substring(1);
            var pairs = query.split("&");
            for (var i = 0; i < pairs.length; i++) {
                var pos = pairs[i].indexOf("=");
                var name = pairs[i].substring(0, pos);
                var value = pairs[i].substring(pos + 1);
                value = decodeURIComponent(value);
                args[name] = value;
            }
        }
        return args;
    };

    /**
     *
     * @param url
     * @returns {{}}
     */
    utils.urlArgs = function(url){

        var query = utils.getUrlArgs(url);

        var map = {};
        for(var param in query){

            var value = query[param],
                options = utils.findOcurrences(value,{
                    begin:"|",
                    end:"|"
                }),
                parameterOptions = null;

            if(options && options.length){
                //clean value:
                value = value.replace(options[0],'');
                //parse options
                var optionString = options[0].substr(1,options[0].length-2),
                    optionSplit = optionString.split(','),
                    optionsData = {};

                for (var i = 0; i < optionSplit.length; i++) {

                    var keyValue = optionSplit[i],
                        pair = keyValue.split(':');

                    optionsData[pair[0]]=pair[1];
                }
                parameterOptions = optionsData;
            }

            if(value && value.length) {
                map[param] = {
                    value: value,
                    options: parameterOptions
                }
            }
        }
        return map;
    };

    utils.getIcon = function (fileName) {
        if (!fileName) {
            return 'txt2.png';
        }
        var extension = utils.getFileExtension(fileName);
        if (extension) {
            var mime = utils.getMimeTable();
            if (mime[extension] != null) {
                return mime[extension];
            }
        }
        return 'txt2.png';
    };
    utils.getIconClass = function (fileName) {
        if (!fileName) {
            return 'fa-file-o';
        }
        var extension = utils.getFileExtension(fileName);
        if (types.customMimeIcons[extension]) {
            return types.customMimeIcons[extension];
        }
        if (extension) {
            var mime = utils.getMimeTable2();
            if (mime[extension] != null) {
                return mime[extension];
            }
        }
        return 'fa-file-o';
    };
    utils.getFileExtension = function (fileName) {
        if (!fileName || fileName == "") return "";
        var split = utils.getBaseName(fileName).split('.');
        if (split.length > 1) return split[split.length - 1].toLowerCase();

        return '';
    };
    utils.getBaseName = function (fileName) {
        if (fileName == null) return null;
        var separator = "/";
        if (fileName.indexOf("\\") != -1)
            separator = "\\";
        return fileName.substr(fileName.lastIndexOf(separator) + 1, fileName.length);
    };
    utils.createUUID = function () {
        // summary:
        //		Create a basic UUID
        // description:
        //		The UUID is created with Math.Random
        var S4 = function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };
        return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4()); //String
    };
    /**
     * 
     * @param path
     * @param suffix
     * @returns {*}
     */
    utils.basename =function basename (path, suffix) {
        //  discuss at: http://locutus.io/php/basename/
        // original by: Kevin van Zonneveld (http://kvz.io)
        // improved by: Ash Searle (http://hexmen.com/blog/)
        // improved by: Lincoln Ramsay
        // improved by: djmix
        // improved by: Dmitry Gorelenkov
        //   example 1: basename('/www/site/home.htm', '.htm')
        //   returns 1: 'home'
        //   example 2: basename('ecra.php?p=1')
        //   returns 2: 'ecra.php?p=1'
        //   example 3: basename('/some/path/')
        //   returns 3: 'path'
        //   example 4: basename('/some/path_ext.ext/','.ext')
        //   returns 4: 'path_ext'

        var b = path
        var lastChar = b.charAt(b.length - 1)

        if (lastChar === '/' || lastChar === '\\') {
            b = b.slice(0, -1)
        }

        b = b.replace(/^.*[\/\\]/g, '')

        if (typeof suffix === 'string' && b.substr(b.length - suffix.length) === suffix) {
            b = b.substr(0, b.length - suffix.length)
        }

        return b
    }
    /**
     *
     * @param path
     * @param options
     * @returns {*}
     */
    utils.pathinfo=function(path, options) {
        //  discuss at: http://locutus.io/php/pathinfo/
        // original by: Nate
        //  revised by: Kevin van Zonneveld (http://kvz.io)
        // improved by: Brett Zamir (http://brett-zamir.me)
        // improved by: Dmitry Gorelenkov
        //    input by: Timo
        //      note 1: Inspired by actual PHP source: php5-5.2.6/ext/standard/string.c line #1559
        //      note 1: The way the bitwise arguments are handled allows for greater flexibility
        //      note 1: & compatability. We might even standardize this
        //      note 1: code and use a similar approach for
        //      note 1: other bitwise PHP functions
        //      note 1: Locutus tries very hard to stay away from a core.js
        //      note 1: file with global dependencies, because we like
        //      note 1: that you can just take a couple of functions and be on your way.
        //      note 1: But by way we implemented this function,
        //      note 1: if you want you can still declare the PATHINFO_*
        //      note 1: yourself, and then you can use:
        //      note 1: pathinfo('/www/index.html', PATHINFO_BASENAME | PATHINFO_EXTENSION);
        //      note 1: which makes it fully compliant with PHP syntax.
        //   example 1: pathinfo('/www/htdocs/index.html', 1)
        //   returns 1: '/www/htdocs'
        //   example 2: pathinfo('/www/htdocs/index.html', 'PATHINFO_BASENAME')
        //   returns 2: 'index.html'
        //   example 3: pathinfo('/www/htdocs/index.html', 'PATHINFO_EXTENSION')
        //   returns 3: 'html'
        //   example 4: pathinfo('/www/htdocs/index.html', 'PATHINFO_FILENAME')
        //   returns 4: 'index'
        //   example 5: pathinfo('/www/htdocs/index.html', 2 | 4)
        //   returns 5: {basename: 'index.html', extension: 'html'}
        //   example 6: pathinfo('/www/htdocs/index.html', 'PATHINFO_ALL')
        //   returns 6: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
        //   example 7: pathinfo('/www/htdocs/index.html')
        //   returns 7: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}

        var basename = utils.basename;
        var opt = ''
        var realOpt = ''
        var optName = ''
        var optTemp = 0
        var tmpArr = {}
        var cnt = 0
        var i = 0
        var haveBasename = false
        var haveExtension = false
        var haveFilename = false

        // Input defaulting & sanitation
        if (!path) {
            return false
        }
        if (!options) {
            options = 'PATHINFO_ALL'
        }

        // Initialize binary arguments. Both the string & integer (constant) input is
        // allowed
        var OPTS = {
            'PATHINFO_DIRNAME': 1,
            'PATHINFO_BASENAME': 2,
            'PATHINFO_EXTENSION': 4,
            'PATHINFO_FILENAME': 8,
            'PATHINFO_ALL': 0
        }
        // PATHINFO_ALL sums up all previously defined PATHINFOs (could just pre-calculate)
        for (optName in OPTS) {
            if (OPTS.hasOwnProperty(optName)) {
                OPTS.PATHINFO_ALL = OPTS.PATHINFO_ALL | OPTS[optName]
            }
        }
        if (typeof options !== 'number') {
            // Allow for a single string or an array of string flags
            options = [].concat(options)
            for (i = 0; i < options.length; i++) {
                // Resolve string input to bitwise e.g. 'PATHINFO_EXTENSION' becomes 4
                if (OPTS[options[i]]) {
                    optTemp = optTemp | OPTS[options[i]]
                }
            }
            options = optTemp
        }

        // Internal Functions
        var _getExt = function (path) {
            var str = path + ''
            var dotP = str.lastIndexOf('.') + 1
            return !dotP ? false : dotP !== str.length ? str.substr(dotP) : ''
        }

        // Gather path infos
        if (options & OPTS.PATHINFO_DIRNAME) {
            var dirName = path
                .replace(/\\/g, '/')
                .replace(/\/[^\/]*\/?$/, '') // dirname
            tmpArr.dirname = dirName === path ? '.' : dirName
        }

        if (options & OPTS.PATHINFO_BASENAME) {
            if (haveBasename === false) {
                haveBasename = basename(path)
            }
            tmpArr.basename = haveBasename
        }

        if (options & OPTS.PATHINFO_EXTENSION) {
            if (haveBasename === false) {
                haveBasename = basename(path)
            }
            if (haveExtension === false) {
                haveExtension = _getExt(haveBasename)
            }
            if (haveExtension !== false) {
                tmpArr.extension = haveExtension
            }
        }

        if (options & OPTS.PATHINFO_FILENAME) {
            if (haveBasename === false) {
                haveBasename = basename(path)
            }
            if (haveExtension === false) {
                haveExtension = _getExt(haveBasename)
            }
            if (haveFilename === false) {
                haveFilename = haveBasename.slice(0, haveBasename.length - (haveExtension
                            ? haveExtension.length + 1
                            : haveExtension === false
                            ? 0
                            : 1
                    )
                )
            }

            tmpArr.filename = haveFilename
        }

        // If array contains only 1 element: return string
        cnt = 0
        for (opt in tmpArr) {
            if (tmpArr.hasOwnProperty(opt)) {
                cnt++
                realOpt = opt
            }
        }
        if (cnt === 1) {
            return tmpArr[realOpt]
        }

        // Return full-blown array
        return tmpArr
    }

    utils.strip_tags = function (input, allowed) {
        //  discuss at: http://phpjs.org/functions/strip_tags/
        // original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // improved by: Luke Godfrey
        // improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        //    input by: Pul
        //    input by: Alex
        //    input by: Marc Palau
        //    input by: Brett Zamir (http://brett-zamir.me)
        //    input by: Bobby Drake
        //    input by: Evertjan Garretsen
        // bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // bugfixed by: Onno Marsman
        // bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // bugfixed by: Eric Nagel
        // bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // bugfixed by: Tomasz Wesolowski
        //  revised by: Rafał Kukawski (http://blog.kukawski.pl/)
        //   example 1: strip_tags('<p>Kevin</p> <br /><b>van</b> <i>Zonneveld</i>', '<i><b>');
        //   returns 1: 'Kevin <b>van</b> <i>Zonneveld</i>'
        //   example 2: strip_tags('<p>Kevin <img src="someimage.png" onmouseover="someFunction()">van <i>Zonneveld</i></p>', '<p>');
        //   returns 2: '<p>Kevin van Zonneveld</p>'
        //   example 3: strip_tags("<a href='http://kevin.vanzonneveld.net'>Kevin van Zonneveld</a>", "<a>");
        //   returns 3: "<a href='http://kevin.vanzonneveld.net'>Kevin van Zonneveld</a>"
        //   example 4: strip_tags('1 < 5 5 > 1');
        //   returns 4: '1 < 5 5 > 1'
        //   example 5: strip_tags('1 <br/> 1');
        //   returns 5: '1  1'
        //   example 6: strip_tags('1 <br/> 1', '<br>');
        //   returns 6: '1 <br/> 1'
        //   example 7: strip_tags('1 <br/> 1', '<br><br/>');
        //   returns 7: '1 <br/> 1'

        allowed = (((allowed || '') + '')
            .toLowerCase()
            .match(/<[a-z][a-z0-9]*>/g) || [])
            .join(''); // making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)
        var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi,
            commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi;
        return input.replace(commentsAndPhpTags, '')
            .replace(tags, function ($0, $1) {
                return allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
            });
    };
    return utils;
});

define('xwire/Binding',[
    'dcl/dcl',
    'xwire/_Base'
],function(dcl,_Base){
    return dcl(_Base,{
        declaredClass:"xwire.Binding",
        source:null,
        target:null,
        destroy:function()
        {
            if(this.source){
                this.source.destroy();
            }
        },
        /**
         * trigger is being invoked by the source
         */
        trigger:function(data){

            if(this.target){
                this.target.run(data);
            }
        },
        /**
         *
         */
        start:function(){

            if(this.source){
                this.source.binding=this;
                this.source.start();
            }

            if(this.target){
                this.target.binding=this;
                this.target.start();
            }
        }
    });
});
define('xwire/Source',[
    'dcl/dcl',
    'xide/types',
    'xwire/_Base'
],function(dcl,types,_Base){
    /**
     * Abstract binding source
     */
    return dcl(_Base,{
        declaredClass:"xwire.Source",
        destroy:function(){
        }
    });
});
define('xwire/EventSource',[
    'dcl/dcl',
    'xwire/Source',
    'xide/mixins/EventedMixin'
],function(dcl,Source,EventedMixin){
    /**
     * Event based binding source
     */
    return dcl([Source,EventedMixin.dcl],{
        declaredClass:"xwire.EventSource",
        /**
         * Trigger specifies the event name
         * {String|Array}
         */
        trigger:null,
        /**
         * Path to the value within the triggered event.
         * {String}
         */
        path:null,
        /**
         * An array of filters, specified by path and value :
         * {
         *      path:string,
         *      value:string (path value must match this)
         * }
         *
         */
        filters:null,

        _started:false,
        /**
         * _matches evaluates a number of filters on an object
         * @param object {Object}
         * @param filters {Array}
         * @returns {boolean}
         * @private
         */
        _matches:function(object,filters){

            for(var i =0 ; i<filters.length;i++){

                var value = this.getValue(object,filters[i].path);
                if(value!==filters[i].value){
                    return false;
                }
            }

            return true;
        },
        /**
         *
         * @param evt
         */
        onTriggered:function(evt){

            //var value = this.getVariable('value');var out = 0;if (value.indexOf('MV') != -1 && value.indexOf('MVMAX') == -1) {    var _volume = value.substring(2, value.length);    _volume = parseInt(_volume.substring(0, 2));    if (!isNaN(_volume)) {        this.setVariable('Volume', _volume);        out = _volume;    }else{        return null;    }}else{    return null;}return out;
            /**
             * Run event filters if specified
             */
            if(this.filters && !this._matches(evt,this.filters)){
                return;
            }
            if(this.path){

                var value = this.getValue(evt,this.path);
                /**
                 * forward to owner
                 */
                if(this.binding){
                    this.binding.trigger({
                        value:value,
                        source:this
                    })
                }
            }

        },
        /***
         * Start will subscribe to event specified in trigger
         */
        start:function(){
            if(this._started){
                console.warn('already started',this);
                return;
            }
            this.subscribe(this.trigger,this.onTriggered);

            this._started = true;
        }
    });
});
define('xwire/Target',[
    'dcl/dcl',
    'xwire/_Base'
],function(dcl,_Base){
    /**
     * Abstract binding target
     */
    var Module = dcl(_Base,{
        declaredClass:"xwire.Target",
        /**
         * The binding we belong to
         * {xwire.Binding}
         */
        binding:null,
        /**
         * The object instance we're operating on
         */
        object:null,
        /**
         * The path within the object
         */
        path:null,
        /**
         * run is performed when a source is being triggered
         */
        run:function(){

        },
        /**
         * start the target, this is not really needed
         */
        start:function(){

        }
    });

    dcl.chainAfter(Module,'run');
    return Module
});
define('xwire/WidgetTarget',[
    'dcl/dcl',
    'xide/types',
    'xwire/Target',
    'xide/utils'
],function(dcl,types,Target,utils){
    /**
     * Widget based binding target
     */
    return dcl(Target,{
        declaredClass:"xwire.WidgetTarget",
        targetFilter:null,
        /**
         * Run the action
         */
        run:function(data){
            var thiz = this,
                isDelite = thiz.object !=null && thiz.object.render!=null;

            if(thiz.object){
                var value = data.value;
                if(this.targetFilter!=null && this.targetFilter.length && this.delegate && this.delegate.resolveFilter){
                    value = this.delegate.resolveFilter(this.targetFilter,value,this.object);
                }
                thiz.object.ignore=true;
                if(!isDelite && thiz.object.set) {
                    thiz.object.set(thiz.path, value);
                }else if(thiz.object._set){
                    thiz.object._set(thiz.path, value);
                    var _funcPath = "set" + utils.capitalize(thiz.path);
                    if(thiz.object[_funcPath]) {
                        thiz.object[_funcPath](value,data);
                    }

                }else{
                    thiz.object[thiz.path] = value;
                }
                thiz.object.ignore=false;
            }
        }
    });
});
define('xblox/RunScript',[
    "dojo/_base/lang",
    "dojo/on",
    "dcl/dcl",//make sure
    "delite/register",
    "delite/CustomElement",
    //explicit because a bootstrap might not be loaded at some point
    "xide/factory/Events",
    //explicit because a bootstrap might not be loaded at some point
    'xide/utils/StringUtils',
    'xide/types/Types',
    'xblox/model/Referenced',
    'xide/mixins/EventedMixin',
    'xide/mixins/ReloadMixin',

/** 2way binding dependencies **/

    'xwire/Binding',
    'xwire/EventSource',
    'xwire/WidgetTarget'
    //'xide/registry'

], function (lang, on, dcl,register, CustomElement, Events, utils, Types, Referenced, EventedMixin, ReloadMixin, Binding, EventSource, WidgetTarget,registry) {

    var debugWidgets = false;
    var debugApp = true;
    var debugAttach = false;
    var debugCreated = false;
    var debugBinding = true;
    var debugRun = true;


    console.error('---run script')
    /**
     * Proxy widget to run a selected blox script on the parent widget/node.
     *
     * @class xblox/RunScript
     */
    var Impl = {

        declaredClass: 'xblox/RunScript',
        targetevent: '',
        //sourceevent: "onDriverVariableChanged",
        //sourceeventvaluepath: "item.value",
        //sourceeventnamepath: "item.name",
        //targetproperty: "value",

        sourceevent: "",
        sourceeventvaluepath: "",
        sourceeventnamepath: "",
        targetproperty: "",
        targetvariable: "",
        targetfilter:"",
        script:"",
        bidirectional: false,
        blockGroup:'',
        block:'',
        _targetBlock: null,
        _targetReference: null,
        _appContext: null,
        _complete: false,
        enabled: true,
        stop: false,
        _events: [],
        context: null,
        /**
         * @type {xide/types/BlockMode}
         */
        mode:0,
        /**
         * 2 way binding
         */
        _2wayHandle: null,//the handle
        binding: null,//the binding

        /**
         * soft destroy
         */
        reset:function(){
            this._destroyHandles();
            if (this._2wayHandle) {
                this._2wayHandle.remove();
            }
            if(this.binding){
                this.binding.destroy();

            }

            this.binding = null;
            //this._targetBlock = null;
            this._appContext = null;
            this._targetReference = null;
        },
        /**
         *
         * @param newSettings
         */
        onSettingsChanged:function(newSettings){

            this.reset();

            if (!this.enabled) {
                return;
            }

            this.onAppReady(null);

        },
        getChildren: function () {
            return [];
        },
        /**
         * @inheritDoc
         */
        destroy: function () {
            //console.error('destroy')
            this.onDestroy && this.onDestroy();
            this.reset();
        },
        /**
         * The final execution when 'target event' has been triggered. This
         * will run the select block.
         * @param event
         * @param val
         */
        run: function (event, val) {

            if (!this.enabled) {
                return;
            }
            var settings = {};

            //filter, in design mode, we ain't do anything
            if (this.context && this.context.delegate) {

                if (this.context.delegate.isDesignMode && this.context.delegate.isDesignMode()) {
                    return;
                }
                if (this.context.delegate.getBlockSettings) {
                    settings  =this.context.delegate.getBlockSettings();
                }
            }



            //setup variables
            var block = this._targetBlock,
                context = this._targetReference,
                result;

            if (block && context) {
                block.context = context;
                block._targetReference = context;

                if (this.targetvariable && this.targetvariable.length && val != null) {

                    block.override = {
                        variables: {}
                    };
                    block.override.variables[this.targetvariable] = val;
                }
                result = block.solve(block.scope,settings);

                debugRun && console.log('run ' + block.name + ' for even ' + event, result + ' for ' + this.id, this._targetReference);
            }
        },
        /**
         * Callback when the minimum parameters are given: targetReference & targetBlock
         */
        onReady: function () {

            if (!this._targetReference) {
                this._setupTargetReference();
            }

            //resolve 2way binding
            if (this._targetReference && this['bidirectional'] === true && this.sourceevent && this.sourceevent.length && !this.binding) {
                this._setup2WayBinding();
            }

            if (this._complete) {
                return;
            }
            if (!this._targetReference) {
                console.error('have no target reference');
            }
            if (!this._targetBlock) {
                console.error('have no target block');
            }

            if (this._targetReference && this._targetBlock) {

                //we trigger on events
                if (this.targetevent) {

                    this._complete = true;

                    //patch the target
                    lang.mixin(this._targetReference, EventedMixin.prototype);
                    //<d-xscript style="position: absolute; left: 151px; top: 37px;" bidirectional="true" targetevent="change" targetvariable="Volume" blockid="5edc09c5-7118-84d1-69b9-8321f3fb33aa" scopeid="235eb680-cb87-11e3-9c1a-0800200c9a66" script="SetMasterVolume"></d-xscript>
                    //subscribe
                    /*this._targetReference.subscribe(this.targetevent,this.run,this);*/

                    var _target = this._targetReference.domNode || this._targetReference,
                        _event = this.targetevent,
                        _isWidget = this._targetReference.declaredClass || this._targetReference.startup,
                        _hasWidgetCallback = this._targetReference.on != null && this._targetReference['on' + utils.capitalize(_event)] != null,
                        _handle = null,
                        _isDelite = _target.render != null && _target.on != null,
                        thiz = this;


                    if (_isWidget &&
                            //dijit
                        (this._targetReference.baseClass && this._targetReference.baseClass.indexOf('dijitContentPane') != -1)
                            //delite
                        || this._targetReference.render != null || this._targetReference.on != null) {
                        _isWidget = false;//use on
                    }

                    if (_target) {

                        debugBinding && console.log('wire success ' + this.id + ' for '+this.targetevent);

                        if (!_isDelite && (!_hasWidgetCallback || !_isWidget)) {

                            _handle = on(_target, this.targetevent, function (evt) {

                                /*
                                if (this.stop) {
                                    evt.preventDefault();
                                    evt.stopImmediatePropagation();
                                }
                                */

                                this.run(this.targetevent);

                            }.bind(this));

                        } else {
                            _target = this._targetReference;
                            var useOn = true;

                            if (useOn) {

                                /*

                                bloody, dojo

                                 _handle=dojo.connect(_target,_event, function (value) {
                                 debugger;
                                 thiz.onTriggered(value);
                                 });

                                 _handle=dojo.connect(_target,'onchange', function (value) {
                                 debugger;
                                 thiz.onTriggered(value);
                                 });

                                 _handle=dojo.connect(_target.domNode,_event, function (value) {
                                 debugger;
                                 thiz.onTriggered(value);
                                 });
                                 _handle = on(_target,this.targetevent, function (evt) {
                                 debugger;
                                 if (this.stop) {
                                 evt.preventDefault();
                                 evt.stopImmediatePropagation();
                                 }
                                 this.run(this.targetevent);
                                 }.bind(this));

                                 _handle = _target.on(this.targetevent, function (evt) {
                                 debugger;
                                 if (this.stop) {
                                 evt.preventDefault();
                                 evt.stopImmediatePropagation();
                                 }
                                 this.run(this.targetevent);
                                 }.bind(this));

                                 */

                                if (!_isDelite) {
                                    var _e = 'on' + utils.capitalize(_event);

                                    this._targetReference[_e] = function (val, nada) {
                                        if (_target.ignore !== true) {
                                            thiz.run(thiz.targetevent, val);
                                        }
                                    }
                                } else {

                                    _handle = _target.on(this.targetevent, function (evt) {

                                        if (this.stop) {
                                            evt.preventDefault();
                                            evt.stopImmediatePropagation();
                                        }
                                        this.run(this.targetevent, evt.currentTarget.value);
                                    }.bind(this));

                                }

                            } else {

                                this._targetReference['on' + utils.capitalize(_event)] = function (val) {
                                    if (_target.ignore !== true) {
                                        thiz.run(thiz.targetevent, val);
                                    }
                                }
                            }
                        }
                        if (_handle) {
                            this._events.push(_handle);
                        }
                    } else {
                        console.error('have no target to wire')
                    }
                }
            } else {
                console.error('invalid params, abort', this);
            }
            if (this.binding) {
                this.binding.start();
            }
        },
        resolveBlock:function(block){
            var ctx  = this._appContext;
            var deviceManager = ctx.getDeviceManager();

            if(block.indexOf('://')!==-1) {
                if(!deviceManager){
                    return;
                }
                var _block = deviceManager.getBlock(this.block);
                if(_block){
                    return _block
                }
            }
        },
        /**
         *
         * @param ctx
         * @private
         */
        _setBlock: function (ctx) {

            ctx = ctx || window['appContext'];

            if (!ctx || !ctx.getBlockManager) {
                debugApp && console.warn('have no context or block manager');
                return;
            }

            this._appContext = ctx;

            var blockManager = ctx.getBlockManager(),
                deviceManager = ctx.getDeviceManager(),
                thiz = this;

            if (!blockManager) {
                return;
            }
            var _block = this.block ? this.block : this.getAttribute('block');
            if (_block && _block.length > 0) {
                var parts = utils.parse_url(_block);
                if(_block.indexOf('://')!==-1) {
                    if(!deviceManager){
                        debugApp && console.warn('xScript::_setBlock : have no device manager');
                        return;
                    }
                    var _block2 = deviceManager.getBlock(_block);
                    if(_block2){
                        thiz._targetBlock = _block2;
                        thiz.onReady();
                        return;
                    }else{
                        debugBinding && console.warn('cant get block : '+_block);
                    }
                }else {
                    blockManager.load(parts.scheme, parts.host).then(function (scope) {
                        var block = scope.getBlockById(thiz.blockid);
                        if (block) {
                            thiz._targetBlock = block;
                            thiz.onReady();
                        }
                    });
                }

            } else if (this.scopeid) {

                var scope = blockManager.hasScope(thiz.scopeid);
                if (scope) {
                    var block = scope.getBlockById(thiz.blockid);
                    if (block) {
                        thiz._targetBlock = block;
                        thiz.onReady();
                    }else{
                        block = scope.getVariableById(thiz.blockid);
                        if (block) {
                            thiz._targetBlock = block;
                            thiz.onReady();
                        }
                    }
                }else{
                    console.error('have no scope!');
                }
            }
        },
        initWithReference: function (ref) {
            //target node or widget
            if(ref.nodeType!==1){
                //console.error('invalid node type '+ref.nodeType);
                return;
            }
            this._targetReference = ref;
            this._setBlock(null);
        },
        onReloaded: function () {
            //console.log('on reloaded');
        },
        resolveFilter:function(expression,value,widget){

            if(this._targetBlock){

                var expressionModel = this._targetBlock.scope.expressionModel;
                value = expressionModel.parseVariable(this._targetBlock.scope,{
                    value:expression
                },'',false,false,widget,[value]);
            }
            return value;
        },
        /**
         * setup outbound wire, assumes all parameters are checked
         * @private
         */
        _setup1WayBinding: function () {

            debugBinding && console.log('setup 1 way binding');

            //destroy old handle
            if (this._2wayHandle) {
                this._2wayHandle.remove();
            }

            if(!this._targetBlock){
                console.error('invalid params for one way binding');
                return;
            }

            var sourceVariableTitle = this._targetBlock.name;


            //wire to system event
            var bindingSource = new EventSource({
                //listen to variable changes
                trigger: this.sourceevent,
                //the path to value, ie: 'item.value'
                path: this.sourceeventvaluepath,
                //add an event filter
                filters: [{
                    // variable title must match,ie: 'item.title'
                    path: this.sourceeventnamepath,
                    // the name of the variable, ie: 'Volume'
                    value: sourceVariableTitle
                }]
            });


            //now map the event source to a widget
            var bindingTarget = new WidgetTarget({
                //the path to value
                path: this.targetproperty,
                object: this._targetReference,
                targetFilter:this.targetfilter,
                delegate:this
            });

            //construct the binding
            var binding = new Binding({
                source: bindingSource,
                target: bindingTarget
            });

            this.binding = binding;

            binding.start();
        },

        /**
         * setup inbound wire, assumes all parameters are checked
         * @private
         */
        _setup2WayBinding: function () {

            if(this.binding){
                return;
            }
            debugBinding && console.log('setup 2 way binding');

            //destroy old handle
            if (this._2wayHandle) {
                this._2wayHandle.remove();
            }


            //wire to system event
            var bindingSource = new EventSource({
                //listen to variable changes
                trigger: this.sourceevent,
                //the path to value, ie: 'item.value'
                path: this.sourceeventvaluepath,
                //add an event filter
                filters: [{
                    // variable title must match,ie: 'item.title'
                    path: this.sourceeventnamepath,
                    // the name of the variable, ie: 'Volume'
                    value: this.targetvariable
                }]
            });


            //now map the event source to a widget
            var bindingTarget = new WidgetTarget({
                //the path to value
                path: 'value',
                object: this._targetReference
            });


            //construct the binding
            var binding = new Binding({
                source: bindingSource,
                target: bindingTarget
            });

            this.binding = binding;


            this.binding.start();
        },

        /**
         * Returns the widget whose DOM tree contains the specified DOMNode, or null if
         * the node is not contained within the DOM tree of any widget
         * @param {Element} node
         */
        getEnclosingWidget: function (node) {
            if(node) {
                do {
                    if (node.nodeType === 1 && node.render) {
                        return node;
                    }
                } while ((node = node.parentNode));
            }
            return null;
        },
        /**
         * Function to setup the target reference
         * on the surrounding widget!
         *
         */
        _setupTargetReference: function () {
            var i = 0,
                element = this,
                widget = null;

            while (i < 2 && !widget) {

                if (element) {
                    element = element.parentNode;
                    widget = this.getEnclosingWidget(element, "widgetId");
                    if (!widget) {
                        widget = this.getEnclosingWidget(element, "widgetid");
                    }
                }
                i++;
            }
            if (widget) {
                debugWidgets && console.info('have widget reference' + '  : ', widget);
                this.initWithReference(widget);
            } else {
                if (this.domNode && this.domNode.parentNode) {
                    this.initWithReference(this.domNode.parentNode);
                    debugWidgets && console.error('cant find widget reference, using parent node', this._targetReference);
                } else {
                    if(this.parentNode){

                        this.initWithReference(this.parentNode);

                    }
                    debugWidgets && console.error('cant find widget reference', this);
                }

            }
        },
        /**
         * Required in case of dojoConfig.parseOnLoad
         * @param evt
         */
        onAppReady: function (evt) {

            //var _r = registry.hash;

            debugApp && console.log('-ready');
            //resolve target reference
            if (!this._targetReference) {
                this._setupTargetReference();
            }

            //resolve target block
            if (!this._targetBlock) {
                this._setBlock(evt ? evt.context : null);
            }

            this.mode = this['bidirectional'] ===true ? 0 : 1;

            //normal mode, allows 2-way binding
            if(this.mode===0) {
                //resolve 2way binding
                if (this._targetBlock && this._targetReference && this['bidirectional'] === true && this.sourceevent && this.sourceevent.length) {
                    this._setup2WayBinding();
                }

                //if both are valid, run the the init procedure
                if (this._targetReference && this._targetBlock) {
                    this.onReady();
                }

            }else if(this.mode===1 && this._targetBlock){

                if (this._targetReference && this.sourceevent && this.sourceevent.length && this.targetproperty && this.targetproperty.length) {
                    this._setup1WayBinding();
                    if(this.binding){
                        this.binding.start();
                    }
                }

            }

            //track context {xapp/manager/Context}
            if (evt && evt.context) {
                this.context = evt.context;
            }
        },
        detachedCallback:function(){
            debugAttach && console.info('detachedCallback', this);
            if(this._appContext){
                this.destroy();
            }else{

            }

        },
        /**
         * Delite created callback
         */
        createdCallback: function () {
            //console.error('createdCallback', this);
            debugCreated && console.info('createdCallback', this);
        },
        /**
         * Delite attached callback
         */
        attachedCallback: function () {

            debugAttach && console.info('attachedCallback', this);

            if (this._started) {
                return;
            }

            //this._blockId = '' + this.blockid;

            //this.onAppReady();//emulates

            this.initReload();

            this.subscribe(Types.EVENTS.ON_APP_READY);

            this._started = true;
            //registry.add(this);

        },
        detachCallback: function () {

        },
        render: function () {
            console.log('render');
        },
        postRender: function () {
            console.log('post render');
        },
        startup: function () {

            debugAttach && console.log('startup');

            this.inherited(arguments);

            this.onAppReady();

            this.initReload();

            this.subscribe(Types.EVENTS.ON_APP_READY);

        }
    };

    //package and declare via dcl
    var _class = dcl([EventedMixin.dcl, ReloadMixin.dcl, Referenced.dcl], Impl);
    //static access to Impl.
    _class.Impl = Impl;
    return register("d-xscript", [HTMLElement, CustomElement, _class]);
});
define('xblox/_State',[
    "dojo/_base/lang",
    "dojo/on",
    "dcl/dcl",//make sure
    "delite/register",
    "delite/CustomElement",
    //explicit because a bootstrap might not be loaded at some point
    "xide/factory/Events",
    //explicit because a bootstrap might not be loaded at some point
    'xide/utils/StringUtils',
    'xide/types/Types',
    'xblox/model/Referenced',
    'xide/mixins/EventedMixin',
    'xide/mixins/ReloadMixin',
    'xwire/Binding',
    'xwire/EventSource',
    'xwire/WidgetTarget'
], function (lang, on, dcl,register, CustomElement, Events, utils, Types, Referenced, EventedMixin, ReloadMixin, Binding, EventSource, WidgetTarget) {

    var debugWidgets = false;
    var debugApp = false;
    var debugAttach = false;
    var debugCreated = false;
    var debugBinding = false;
    var debugRun = false;
    /**
     * Proxy widget to run a selected blox script on the parent widget/node.
     *
     * @class xblox/RunScript
     */
    var Impl = {
        declaredClass: 'xblox/_State',
        script:"",
        bidirectional: false,
        _targetBlock: null,
        _targetReference: null,
        _complete: false,
        enabled: true,
        stop: false,
        _events: [],
        context: null,
        name:"Default",
        isState:true,
        _isState:function(){
            return true;
        },
        /**
         * soft destroy
         */
        reset:function(){
            
        },
        getChildren: function () {
            return [];
        },
        /**
         * @inheritDoc
         */
        destroy: function () {
            this.onDestroy && this.onDestroy();
            console.log('-destroy');
            this.reset();
        },
        /**
         * The final execution when 'target event' has been triggered. This
         * will run the select block.
         * @param event
         * @param val
         */
        run: function (event, val) {
            if (!this.enabled) {
                return;
            }            
        },
        /**
         * Callback when the minimum parameters are given: targetReference & targetBlock
         */
        onReady: function () {            
        },
        getEnclosingWidget: function (node) {
            if(node) {
                do {
                    if (node.nodeType === 1 && node.render) {
                        return node;
                    }
                } while ((node = node.parentNode));
            }
            return null;
        },
        initWithReference: function (ref) {
            //target node or widget
            if(ref.nodeType!==1){
                return;
            }
            this._targetReference = ref;
        },
        /**
         * Function to setup the target reference
         * on the surrounding widget!
         *
         */
        _setupTargetReference: function () {
            var i = 0,
                element = this,
                widget = null;

            while (i < 2 && !widget) {

                if (element) {
                    element = element.parentNode;
                    widget = this.getEnclosingWidget(element, "widgetId");
                    if (!widget) {
                        widget = this.getEnclosingWidget(element, "widgetid");
                    }
                }
                i++;
            }
            if (widget) {
                debugWidgets && console.info('have widget reference' + '  : ', [widget,this]);
                this.initWithReference(widget);
                if(widget._attached && widget.stateReady){
                    widget.stateReady(this);
                }

            } else {
                if (this.domNode && this.domNode.parentNode) {
                    this.initWithReference(this.domNode.parentNode);
                    debugWidgets && console.error('cant find widget reference, using parent node', this._targetReference);
                } else {
                    if(this.parentNode){
                        this.initWithReference(this.parentNode);
                    }
                    debugWidgets && console.error('cant find widget reference', this);
                }
            }
        },
        onAppReady: function (evt) {
            debugApp && console.log('-ready');
            //resolve target reference
            //if (!this._targetReference) {
                this._setupTargetReference();
            //}

            //track context {xapp/manager/Context}
            if (evt && evt.context) {
                this.context = evt.context;
            }
        },
        detachedCallback:function(){
            debugAttach && console.info('detachedCallback', this);
            if(this._appContext){
                this.destroy();
            }

        },
        applyTo:function(widget){
            
        },
        /**
         * Delite created callback
         */
        createdCallback: function () {
            //console.error('createdCallback', this);
            debugCreated && console.info('createdCallback', this);
            if (!this._targetReference) {
                this._setupTargetReference();
                if(this._targetReference && this._targetReference.stateReady){
                    this._targetReference.stateReady(this);
                }
            }
        },
        attachedCallback: function () {
            debugAttach && console.info('attachedCallback', this);
            if (this._started) {
                return;
            }
            this.onAppReady();//emulates
            this.subscribe(Types.EVENTS.ON_APP_READY);
            this._started = true;
        }

    };
    //package and declare via dcl
    var _class = dcl([EventedMixin.dcl,Referenced.dcl], Impl);
    return _class; 
});
define('xblox/CSSState',[
    "dojo/on",
    "dcl/dcl",
    "delite/register",
    "delite/CustomElement",
    'xide/types/Types',
    'xblox/_State',
    'xide/utils',
    'xide/registry',
    'xdojo/has'

], function (on, dcl,register, CustomElement, Types, _State,utils,registry,has) {

    var extraRules = [],
        extraSheet,
        removeMethod,
        rulesProperty,
        invalidCssChars = /([^A-Za-z0-9_\u00A0-\uFFFF-])/g;

    has.add('dom-contains', function (global, doc, element) {
        return !!element.contains; // not supported by FF < 9
    });
    function removeRule(index) {
        // Function called by the remove method on objects returned by addCssRule.
        var realIndex = extraRules[index],
            i, l;
        if (realIndex === undefined) {
            return; // already removed
        }

        // remove rule indicated in internal array at index
        extraSheet[removeMethod](realIndex);

        // Clear internal array item representing rule that was just deleted.
        // NOTE: we do NOT splice, since the point of this array is specifically
        // to negotiate the splicing that occurs in the stylesheet itself!
        extraRules[index] = undefined;

        // Then update array items as necessary to downshift remaining rule indices.
        // Can start at index + 1, since array is sparse but strictly increasing.
        for (i = index + 1, l = extraRules.length; i < l; i++) {
            if (extraRules[i] > realIndex) {
                extraRules[i]--;
            }
        }
    }
    var Impl = {
        _lastState:null,
        declaredClass: 'xblox/CSSState',
        addCssRule: function (selector, css) {
            // summary:
            //		Dynamically adds a style rule to the document.  Returns an object
            //		with a remove method which can be called to later remove the rule.

            if (!extraSheet) {
                // First time, create an extra stylesheet for adding rules
                extraSheet = document.createElement('style');
                document.getElementsByTagName('head')[0].appendChild(extraSheet);
                // Keep reference to actual StyleSheet object (`styleSheet` for IE < 9)
                extraSheet = extraSheet.sheet || extraSheet.styleSheet;
                // Store name of method used to remove rules (`removeRule` for IE < 9)
                removeMethod = extraSheet.deleteRule ? 'deleteRule' : 'removeRule';
                // Store name of property used to access rules (`rules` for IE < 9)
                rulesProperty = extraSheet.cssRules ? 'cssRules' : 'rules';
            }

            var index = extraRules.length;
            extraRules[index] = (extraSheet.cssRules || extraSheet.rules).length;
            extraSheet.addRule ?
                extraSheet.addRule(selector, css) :
                extraSheet.insertRule(selector + '{' + css + '}', extraRules[index]);

            //console.log('adding css ' + index + ' selector ' + selector,[extraRules]);

            return {
                get: function (prop) {
                    return extraSheet[rulesProperty][extraRules[index]].style[prop];
                },
                set: function (prop, value) {
                    if (typeof extraRules[index] !== 'undefined') {
                        extraSheet[rulesProperty][extraRules[index]].style[prop] = value;
                    }
                },
                remove: function () {
                    removeRule(index);
                },
                sheet:extraSheet
            };
        },
        escapeCssIdentifier: function (id, replace) {
            // summary:
            //		Escapes normally-invalid characters in a CSS identifier (such as . or :);
            //		see http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
            // id: String
            //		CSS identifier (e.g. tag name, class, or id) to be escaped
            // replace: String?
            //		If specified, indicates that invalid characters should be
            //		replaced by the given string rather than being escaped

            return typeof id === 'string' ? id.replace(invalidCssChars, replace || '\\$1') : id;
        },
        detachedCallback:function(){
            this._styles && _.each(this._styles,function(style){
                style.remove();
            })
            delete this._styles;
        },
        applyTo:function(widget,name){

            if(this._lastState){
                this._lastState.remove();
            }


            if(this._lastStateName ===name){
                //return;
            }

            this._lastStateName = name;

            if(!this._attached){
                return;
            }


            //console.log('apply state ' + name);


            var id = widget.id || utils.createUUID();
            //var _uniqueId = registry.getUniqueId(widget.tagName.replace(/\./g,"_")) + '_' + id;
            var _uniqueId = widget.tagName.replace(/\./g,"_") + '_' + id;
            var css = '' + this.innerHTML;
            css = css.replace('.style','');
            css = css.replace(/<(?:.|\n)*?>/gm, '');
            css = css.replace('{','');
            css = css.replace('}','');
            css = css.replace(/(\r\n|\n|\r|\t)/gm,"");

            _uniqueId+='_state_' + name;



            $(widget).removeClass($(widget).data('_lastCSSState'));
            $(widget).addClass(_uniqueId);
            $(widget).data('_lastCSSState',_uniqueId);

            var  selectorPrefix = '.' + this.escapeCssIdentifier(_uniqueId);
            if(!this._styles){
                this._styles = [];
            }
            
            var style = this.addCssRule(selectorPrefix,css);
            
            this._styles.push(style);
        }

    };

    //package and declare via dcl
    var _class = dcl([_State], Impl);
    //static access to Impl.
    _class.Impl = Impl;
    return register("d-xstate-css", [HTMLElement, CustomElement, _class]);
});
define('xblox/StyleState',[
    'dcl/dcl',
    'delite/register',
    'delite/CustomElement',
    'xide/factory/Events',
    'xide/utils/StringUtils',
    'xide/types/Types',
    'xblox/_State'
], function (dcl,register, CustomElement, Events, utils, Types,_State) {

    var Impl = {
        declaredClass: 'xblox/StyleState',
        _targetReference: null,        
        name:"Default",
        /**
         * Convert Style String to an object array, eg: { color:value,.... }
         * @param styleString
         * @returns {{}}
         * @private
         */
        _toObject:function(styleString){
            if(!styleString){
                return {};
            }
            var _result = {};
            var _values = styleString.split(';');
            for (var i = 0; i < _values.length; i++) {
                var obj = _values[i];
                if(!obj || obj.length==0 || !obj.split){
                    continue;
                }
                var keyVal = obj.split(':');
                if(!keyVal || !keyVal.length){
                    continue;
                }
                _result[keyVal[0]]=keyVal[1];
            }
            return _result;
        },
        _toStyleString:function(values){

            var _values = [];
            for(var prop in values){
                _values.push( prop + ':' + values[prop]);
            }
            return _values.join(';') + ';';
        },
        _widget:null,
        onChanged:function () {
            this.applyTo(this._widget);
        },
        applyTo:function(widget){

            if(widget && widget._attached){
                this._widget = widget;
                //console.error('css ',$(widget).attr());
                var _cssWidget = this._toObject($(widget).attr('style'));
                var _cssThis = this._toObject($(this).attr('style'));
                var styleOut = utils.mixin(_cssWidget,_cssThis);
                $(widget).attr('style',this._toStyleString(styleOut));
            }else{
                console.error('not attached');
            }



        }
    };
    var _class = dcl(_State, Impl);
    return register("d-xstate-style", [HTMLElement, CustomElement, _class]);
});
define('xblox/mainr',[
    "xblox/component",
    "xblox/embedded",
    "xblox/model/Block",
    "xblox/model/logic/CaseBlock",
    "xblox/model/functions/CallBlock",
    "xblox/model/code/CallMethod",
    "xblox/model/code/RunScript",
    "xblox/model/code/RunBlock",
    "xblox/model/loops/ForBlock",
    "xblox/model/loops/WhileBlock",
    "xblox/model/variables/VariableAssignmentBlock",
    "xblox/model/logic/IfBlock",
    "xblox/model/logic/ElseIfBlock",
    "xblox/model/logic/SwitchBlock",
    "xblox/model/variables/VariableSwitch",
    "xblox/model/events/OnEvent",
    "xblox/model/events/OnKey",
    "xblox/model/logging/Log",
    "xblox/model/html/SetStyle",
    "xblox/model/html/SetCSS",
    "xblox/manager/BlockManager",
    "xblox/factory/Blocks",
    "xblox/model/Referenced",
    "xblox/types/Types",
    "xblox/RunScript",
    "xblox/CSSState",
    "xblox/StyleState"
], function(){});

define('dojo/dom-class',["./_base/lang", "./_base/array", "./dom"], function(lang, array, dom){
	// module:
	//		dojo/dom-class

	var className = "className";

	/* Part I of classList-based implementation is preserved here for posterity
	var classList = "classList";
	has.add("dom-classList", function(){
		return classList in document.createElement("p");
	});
	*/

	// =============================
	// (CSS) Class Functions
	// =============================

	var cls, // exports object
		spaces = /\s+/, a1 = [""];

	function str2array(s){
		if(typeof s == "string" || s instanceof String){
			if(s && !spaces.test(s)){
				a1[0] = s;
				return a1;
			}
			var a = s.split(spaces);
			if(a.length && !a[0]){
				a.shift();
			}
			if(a.length && !a[a.length - 1]){
				a.pop();
			}
			return a;
		}
		// assumed to be an array
		if(!s){
			return [];
		}
		return array.filter(s, function(x){ return x; });
	}

	/* Part II of classList-based implementation is preserved here for posterity
	if(has("dom-classList")){
		// new classList version
		cls = {
			contains: function containsClass(node, classStr){
				var clslst = classStr && dom.byId(node)[classList];
				return clslst && clslst.contains(classStr); // Boolean
			},

			add: function addClass(node, classStr){
				node = dom.byId(node);
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length; i < len; ++i){
					node[classList].add(classStr[i]);
				}
			},

			remove: function removeClass(node, classStr){
				node = dom.byId(node);
				if(classStr === undefined){
					node[className] = "";
				}else{
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].remove(classStr[i]);
					}
				}
			},

			replace: function replaceClass(node, addClassStr, removeClassStr){
				node = dom.byId(node);
				if(removeClassStr === undefined){
					node[className] = "";
				}else{
					removeClassStr = str2array(removeClassStr);
					for(var i = 0, len = removeClassStr.length; i < len; ++i){
						node[classList].remove(removeClassStr[i]);
					}
				}
				addClassStr = str2array(addClassStr);
				for(i = 0, len = addClassStr.length; i < len; ++i){
					node[classList].add(addClassStr[i]);
				}
			},

			toggle: function toggleClass(node, classStr, condition){
				node = dom.byId(node);
				if(condition === undefined){
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].toggle(classStr[i]);
					}
				}else{
					cls[condition ? "add" : "remove"](node, classStr);
				}
				return condition;   // Boolean
			}
		}
	}
	*/

	// regular DOM version
	var fakeNode = {};  // for effective replacement
	cls = {
		// summary:
		//		This module defines the core dojo DOM class API.

		contains: function containsClass(/*DomNode|String*/ node, /*String*/ classStr){
			// summary:
			//		Returns whether or not the specified classes are a portion of the
			//		class list currently applied to the node.
			// node: String|DOMNode
			//		String ID or DomNode reference to check the class for.
			// classStr: String
			//		A string class name to look for.
			// example:
			//		Do something if a node with id="someNode" has class="aSillyClassName" present
			//	|	if(dojo.hasClass("someNode","aSillyClassName")){ ... }

			return ((" " + dom.byId(node)[className] + " ").indexOf(" " + classStr + " ") >= 0); // Boolean
		},

		add: function addClass(/*DomNode|String*/ node, /*String|Array*/ classStr){
			// summary:
			//		Adds the specified classes to the end of the class list on the
			//		passed node. Will not re-apply duplicate classes.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to add a class string too
			//
			// classStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//		Add a class to some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "anewClass");
			//	|	});
			//
			// example:
			//		Add two classes at once:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Add two classes at once (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple additions
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").addClass("firstLevel");
			//	|	});

            if(!node){
                //console.error('dom class::add failed');
                return;
            }
			node = dom.byId(node);
			classStr = str2array(classStr);
			var cls = node[className], oldLen;
			cls = cls ? " " + cls + " " : " ";
			oldLen = cls.length;
			for(var i = 0, len = classStr.length, c; i < len; ++i){
				c = classStr[i];
				if(c && cls.indexOf(" " + c + " ") < 0){
					cls += c + " ";
				}
			}
			if(oldLen < cls.length){
				node[className] = cls.substr(1, cls.length - 2);
			}
		},

		remove: function removeClass(/*DomNode|String*/ node, /*String|Array?*/ classStr){
			// summary:
			//		Removes the specified classes from node. No `contains()`
			//		check is required.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// classStr: String|Array
			//		An optional String class name to remove, or several space-separated
			//		class names, or an array of class names. If omitted, all class names
			//		will be deleted.
			//
			// example:
			//		Remove a class from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Remove all classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode");
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple removal
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").removeClass("foo");
			//	|	});

			node = dom.byId(node);
            if(!node){
                console.error('dom class remove failed');
                return;
            }
			var cls;
			if(classStr !== undefined){
				classStr = str2array(classStr);
				cls = " " + node[className] + " ";
				for(var i = 0, len = classStr.length; i < len; ++i){
					cls = cls.replace(" " + classStr[i] + " ", " ");
				}
				cls = lang.trim(cls);
			}else{
				cls = "";
			}
			if(node[className] != cls){ node[className] = cls; }
		},

		replace: function replaceClass(/*DomNode|String*/ node, /*String|Array*/ addClassStr, /*String|Array?*/ removeClassStr){
			// summary:
			//		Replaces one or more classes on a node if not present.
			//		Operates more quickly than calling dojo.removeClass and dojo.addClass
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// addClassStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// removeClassStr: String|Array?
			//		A String class name to remove, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "add1 add2", "remove1 remove2");
			//	|	});
			//
			// example:
			//	Replace all classes with addMe
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "addMe");
			//	|	});
			//
			// example:
			//	Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".findMe").replaceClass("addMe", "removeMe");
			//	|	});

			node = dom.byId(node);
			fakeNode[className] = node[className];
			cls.remove(fakeNode, removeClassStr);
			cls.add(fakeNode, addClassStr);
			if(node[className] !== fakeNode[className]){
				node[className] = fakeNode[className];
			}
		},

		toggle: function toggleClass(/*DomNode|String*/ node, /*String|Array*/ classStr, /*Boolean?*/ condition){
			// summary:
			//		Adds a class to node if not present, or removes if present.
			//		Pass a boolean condition if you want to explicitly add or remove.
			//		Returns the condition that was specified directly or indirectly.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to toggle a class string
			//
			// classStr: String|Array
			//		A String class name to toggle, or several space-separated class names,
			//		or an array of class names.
			//
			// condition:
			//		If passed, true means to add the class, false means to remove.
			//		Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered");
			//	|	});
			//
			// example:
			//		Forcefully add a class
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered", true);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".toggleMe").toggleClass("toggleMe");
			//	|	});

			node = dom.byId(node);
			if(condition === undefined){
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length, c; i < len; ++i){
					c = classStr[i];
					cls[cls.contains(node, c) ? "remove" : "add"](node, c);
				}
			}else{
				cls[condition ? "add" : "remove"](node, classStr);
			}
			return condition;   // Boolean
		}
	};

	return cls;
});

/** @module xide/utils/HTMLUtils **/
define('xide/utils/HTMLUtils',[
    'xide/utils',
    'xide/types',
    'xide/registry',
    'dojo/_base/declare',
    "dojo/dom-geometry",
    "dojo/dom-construct",
    "dojo/dom-style",
    'dojo/has',
    'dojo/dom-class',
    "dojo/_base/window",
    'xide/lodash'
], function (utils, types, registry, declare, domGeometry, domConstruct, 
             domStyle, has, domClass,win,_) {
    /**
     * @TODO: remove
     * #Maqetta back compat tool
     * @returns {*}
     */
    utils.getDoc=function(){
        return win.doc;
    };
    /**
     *
     * @param tag
     * @param options
     * @param where
     * @memberOf module:xide/utils
     * @returns {*}
     */
    utils.create=function(tag,options,where){
        var doc = win.doc;
        if(where){
            doc = where.ownerDocument;
        }

        if(typeof tag == "string"){
            tag = doc.createElement(tag);
        }
        options && $(tag).attr(options);
        where && $(where).append(tag);
        return tag;
    };

    /**
     * Returns true when a node is child of another node
     * @param parent {HTMLElement}
     * @param child {HTMLElement}
     * @returns {boolean}
     */
    utils.isDescendant = function (parent, child) {
        var node = child.parentNode;
        while (node != null) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    };
    /**
     * Finds and returns a widgets instance in a stack-container by name
     * @param name
     * @param container
     * @returns {module:xide/layout/_Container}
     */
    utils.hasChild = function (name, container) {
        if (!!name || !container && container.getChildren) {
            return _.find(container.getChildren(),{
                title:name
            });
        }
    };
    /**
     *
     * @TODO: remove, not needed since 3.0
     * @param startNode
     * @param mustHaveClass
     * @returns {*}
     */
    utils.findEmptyNode = function (startNode, mustHaveClass) {
        if (!startNode || startNode.children == null || startNode.children.length == null) {
            return null;
        }
        var children = startNode.children;
        if (mustHaveClass != null) {
            children = utils.find(mustHaveClass, startNode, false);
        }
        for (var i in children) {
            var child = children[i];
            if (child.innerHTML === '') {
                return child;
            }
        }
        return null;
    };
    /**
     *
     * @param proto {Module} a module
     * @param args {Object} the constructor arguments
     * @param node {HTMLElement|null}
     * @param extraBaseClasses {Module[]} additional base classes
     * @param classExtension
     * @returns {Object}
     */
    utils.createInstanceSync = function(proto,args,node,extraBaseClasses,classExtension){
        //extra bases and/or class extension, create a dynamic class and fill extra-bases
        if(extraBaseClasses || classExtension){
            extraBaseClasses = extraBaseClasses || [];
            if(classExtension){
                extraBaseClasses.push(declare(proto,classExtension));
            }
        }
        if (extraBaseClasses) {
            extraBaseClasses.push(proto);
            extraBaseClasses.reverse();
            proto = declare(extraBaseClasses,{});
        }
        return new proto(args || {} , node || win.doc.createElement('div'));

    };
    /***
     * addWidget
     * @param widgetProto
     * @param ctrArgsIn
     * @param delegate
     * @param parent
     * @param startup
     * @param cssClass
     * @param baseClasses
     * @param select
     * @param classExtension
     * @returns {widgetProto}
     */
    utils.addWidget = function (widgetProto, ctrArgsIn, delegate, parent, startup, cssClass,baseClasses,select,classExtension) {
        var ctrArgs = {
            delegate: delegate
        };
        ctrArgsIn = ctrArgsIn || {};
        utils.mixin(ctrArgs, ctrArgsIn);

        //deal with class name
        if(_.isString(widgetProto)){
            var _widgetProto = utils.getObject(widgetProto);
            if(_widgetProto){
                widgetProto = _widgetProto;
            }
        }

        parent = _.isString(parent) ? domConstruct.create(parent) : parent == null ? win.doc.createElement('div') : parent;
        var isDirect = ctrArgsIn.attachDirect !=null ? ctrArgsIn.attachDirect : (widgetProto && widgetProto.prototype ? widgetProto.prototype.attachDirect : false);
        ctrArgs._parent = parent;

        var _target = utils.getNode(parent);
        //@TODO: remove
        if(parent && parent.finishLoading){
            parent.finishLoading();
        }
        //@TODO: remove
        if(ctrArgs.attachChild && parent.addChild){
            delete ctrArgs.attachChild;
            return parent.addChild(widgetProto,ctrArgs,startup);
        }


        //@TODO: replace
        if(parent.addWidget && ctrArgs.ignoreAddChild!==true){
            return parent.addWidget(widgetProto,ctrArgsIn,delegate, parent, startup, cssClass,baseClasses,select,classExtension);
        }

        var widget = utils.createInstanceSync(widgetProto,ctrArgs,isDirect ? _target : null ,baseClasses,classExtension);// new widgetProto(ctrArgs, dojo.doc.createElement('div'));
        if (!widget) {
            console.error('widget creation failed! ', arguments);
            return null;
        }

        if (parent) {
            if(!isDirect) {
                utils.addChild(parent, widget, startup, select);
            }else{
                startup && widget.startup();
            }
        } else {
            return widget;
        }

        if (cssClass) {
            domClass.add(widget.domNode, cssClass);
        }

        if(parent.resize || parent.startup){
            widget._parent = parent;
        }

        //@TODO: remove
        widget.utils = utils;
        widget.types = types;
        return widget;
    };

    /***
     * addChild is a Dojo abstraction. It tries to call addChild on the parent when the client is fitted for this case.
     * @param parent {HTMLElement|dijit/_WidgetBase}
     * @param child {HTMLElement|dijit/_WidgetBase}
     * @param startup {boolean} call startup() on the child
     */
    utils.addChild = function (parent, child, startup,select) {
        if (!parent || !child) {
            console.error('error! parent or child is invalid!');
            return;
        }
        try {
            var _parentNode = parent.addChild != null ? parent : utils.getNode(parent);
            var _childNode = parent.addChild != null ? child : child.domNode || child;
            if (_parentNode && _childNode) {
                if (!parent.addChild) {
                    if(_childNode.nodeType) {
                        _parentNode.appendChild(_childNode);
                        if (startup === true && child.startup) {
                            child.startup();
                        }
                    }else{
                        logError('child is not html');
                    }
                } else {
                    var insertIndex = -1;
                    if (parent.getChildren) {
                        insertIndex = parent.getChildren().length;
                    }
                    try {
                        //@TODO: this has wrong signature in beta3
                        parent.addChild(_childNode, insertIndex, select!=null ? select : startup);
                    } catch (e) {
                        logError(e,'add child failed for some reason!'+e);
                    }
                }
            } else if (has('debug')) {
                console.error("utils.addChild : invalid parameters :: parent or child domNode is null");
            }
        } catch (e) {
            logError(e,'addWidget : crashed : ');
        }
    };
    /***
     *
     * 'templatify' creates a sort of dynamic widget which behaves just like a normal templated widget. Its
     * there for simple widget creation which goes beyond the string substitute alternative. This can
     * avoid also to carry around too many widget modules in your app.
     *
     * @param baseClass {xide/widgets/TemplatedWidgetBase|dijit/_TemplatedMixin} a base class to use, this must be
     * anything which is a dijit/_TemplatedMixin.
     *
     * @param templateString {string} template string as usual, can have all tags like  data-dojo-attach-point and so
     * forth
     *
     * @param parentNode {HTMLNode} the node where the 'dynamic widget' is being added to.

     * @param templateArguments {Object} some parameters mixed into the widget. In the example below you might use
     * {iconClass:'fa-play'} to insert the icon class 'fa-play' into the widget's template
     *
     * @param baseClasses {Object[]=} optional, a number of additional base classes you want make the 'dynamic widget'
     * to be inherited from.
     *
     * @param startup {boolean} call startup on the widget
     *
     * @returns {Widget} returns the templated widget
     *
     *
     * @example var _tpl =  "<div>" +
     "<div class='' data-dojo-type='dijit.form.DropDownButton' data-dojo-props=\"iconClass:'${!iconClass}'\" +
     "data-dojo-attach-point='wButton'>" +
     "<span></span>" +
     "<div data-dojo-attach-point='menu' data-dojo-type='dijit.Menu' style='display: none;'></div>" +
     "</div></div>";

     var widget  = this.templatify(xide/widgets/TemplatedWidgetBase,_tpl, parent , {
            iconClass:'fa-play'
        },[xide/mixins/ReloadMixin]);

     * @memberOf module:xide/utils
     * @extends xide/utils

     */
    utils.templatify = function (baseClass, templateString, parentNode, templateArguments, baseClasses, startup) {
        var widgetClassIn = baseClass || 'xide/widgets/TemplatedWidgetBase',
            widgetProto = null;
        if (baseClasses) {
            widgetProto = declare([baseClass].concat(baseClasses));
        } else {
            widgetProto = utils.getObject(widgetClassIn);
        }
        if (!widgetProto) {
            return null;
        }
        var ctrArgs = {
            templateString: templateString
        };
        utils.mixin(ctrArgs, templateArguments);
        var widget = new widgetProto(ctrArgs, dojo.doc.createElement('div'));
        utils.addChild(parentNode, widget, startup);
        return widget;
    };
    /**
     * XIDE specific
     * @param prop
     * @param owner
     * @private
     */
    utils._clearProperty = function (prop, owner) {
        var _key = null;
        if (owner) {
            _key = utils.getObjectKeyByValue(owner, prop);
        }
        if (_key) {
            owner[_key] = null;
        }
    };
    /**
     * XIDE specific destroy
     * @param view
     * @param callDestroy
     * @param owner
     * @private
     */
    utils._destroyWidget = function (view, callDestroy, owner) {
        try {
            _.isString(view) && (view = $(view)[0]);
            if (view) {
                if (view.parentContainer &&
                    view.parentContainer.removeChild &&
                    view.domNode){
                    if (view.destroy && callDestroy !== false) {
                        try {
                            view.destroy();
                        }catch(e){
                            console.error('error destroying view');
                        }
                    }
                    view.parentContainer.removeChild(view);
                    if(owner) {
                        utils._clearProperty(view, owner);
                    }
                    return;
                }
                view.destroyRecursive && view.destroyRecursive();
                view.destroy && view._destroyed!==true && view.destroy();
                view._destroyed = true;
                if (view.domNode || view["domNode"]) {
                    if (view.domNode) {
                        domConstruct.destroy(view.domNode);
                    }
                } else {
                    var doc = view.ownerDocument;
                    // cannot use _destroyContainer.ownerDocument since this can throw an exception on IE
                    if (doc) {
                        domConstruct.destroy(view);
                    }
                }
                utils._clearProperty(view, owner);
            }

        } catch (e) {
            logError(e,'error in destroying widget ' + e);
        }
    };
    /**
     * Destroys a widget or HTMLElement savly. When an owner
     * is specified, 'widget' will be nulled in owner
     * @param widget {Widget|HTMLElement}
     * @param callDestroy instruct to call 'destroy'
     * @param owner {Object=}
     * @deprecated use utils.destroy
     */
    utils.destroyWidget = function (widget, callDestroy, owner) {
        if (widget) {
            if (_.isArray(widget)) {
                for (var i = 0; i < widget.length; i++) {
                    var obj1 = widget[i];
                    var _key = null;
                    if (owner) {
                        _key = utils.getObjectKeyByValue(owner, obj1);
                    }
                    utils._destroyWidget(obj1, callDestroy);
                    if (_key) {
                        owner[_key] = null;
                    }
                }
            } else {
                utils._destroyWidget(widget, callDestroy, owner);
            }
        }
    };

    /**
     *
     * @param widget
     * @param calldestroy
     * @param owner
     * @returns {*}
     */
    utils.destroy=function(widget,calldestroy,owner){
        return utils.destroyWidget(widget,calldestroy,owner);
    };

    /**
     *
     * @param target
     * @returns {*}
     */
    utils.getNode = function(target){
        if(target) {
            return target.domNode || target.containerNode || target;
        }
        return target;
    };

    /**
     *
     * @param widgets
     * @returns {number}
     */
    utils.getHeight = function(widgets){
        if(!_.isArray(widgets)){
            widgets = [widgets];
        }
        var total = 0;
        _.each(widgets,function(w){
            total+=$(utils.getNode(w)).outerHeight();
        });
        return total;

    };
    /**
     *
     * @param source
     * @param target
     * @param height
     * @param width
     * @param force
     */
    utils.resizeTo = function (source, target,height,width,force,offset) {
        target = utils.getNode(target);
        source = utils.getNode(source);
        if(height===true) {
            var targetHeight = $(target).height();
            if(offset && offset.h!=null){
                targetHeight+=offset.h;
            }
            $(source).css('height', targetHeight + 'px' + (force==true ? '!important' : ''));
        }
        if(width===true){
            var targetWidth = $(target).width();
            $(source).css('width', targetWidth + 'px' + (force==true ? '!important' : ''));
            if(width==100){
                console.log('- resize to 100' +targetWidth);
            }

        }
    };

    /**
     * @TODO: remove
     * Save empty a node or a widget
     * @param mixed {HTMLElement|xide/_base/_Widget || dijit/_WidgetBase}
     * @returns void
     */
    utils.empty = function (mixed) {
        //seems widget
        if (mixed.getChildren && mixed.removeChild) {
            var children = mixed.getChildren();
            _.each(children, function (widget) {
                mixed.removeChild(widget);
            });
        }
        //now remove anything non-widget
        var _el = mixed.containerNode || mixed.domNode || _.isElement(mixed) ? mixed : null;
        if (_el) {
            domConstruct.empty(_el);
        }

    };
    return utils;
});

define('dojo/store/util/SimpleQueryEngine',["../../_base/array" /*=====, "../api/Store" =====*/], function(arrayUtil /*=====, Store =====*/){

// module:
//		dojo/store/util/SimpleQueryEngine

return function(query, options){
	// summary:
	//		Simple query engine that matches using filter functions, named filter
	//		functions or objects by name-value on a query object hash
	//
	// description:
	//		The SimpleQueryEngine provides a way of getting a QueryResults through
	//		the use of a simple object hash as a filter.  The hash will be used to
	//		match properties on data objects with the corresponding value given. In
	//		other words, only exact matches will be returned.
	//
	//		This function can be used as a template for more complex query engines;
	//		for example, an engine can be created that accepts an object hash that
	//		contains filtering functions, or a string that gets evaluated, etc.
	//
	//		When creating a new dojo.store, simply set the store's queryEngine
	//		field as a reference to this function.
	//
	// query: Object
	//		An object hash with fields that may match fields of items in the store.
	//		Values in the hash will be compared by normal == operator, but regular expressions
	//		or any object that provides a test() method are also supported and can be
	//		used to match strings by more complex expressions
	//		(and then the regex's or object's test() method will be used to match values).
	//
	// options: dojo/store/api/Store.QueryOptions?
	//		An object that contains optional information such as sort, start, and count.
	//
	// returns: Function
	//		A function that caches the passed query under the field "matches".  See any
	//		of the "query" methods on dojo.stores.
	//
	// example:
	//		Define a store with a reference to this engine, and set up a query method.
	//
	//	|	var myStore = function(options){
	//	|		//	...more properties here
	//	|		this.queryEngine = SimpleQueryEngine;
	//	|		//	define our query method
	//	|		this.query = function(query, options){
	//	|			return QueryResults(this.queryEngine(query, options)(this.data));
	//	|		};
	//	|	};

	// create our matching query function
	switch(typeof query){
		default:
			throw new Error("Can not query with a " + typeof query);
		case "object": case "undefined":
			var queryObject = query;
			query = function(object){
				for(var key in queryObject){
					var required = queryObject[key];
					if(required && required.test){
						// an object can provide a test method, which makes it work with regex
						if(!required.test(object[key], object)){
							return false;
						}
					}else if(required != object[key]){
						return false;
					}
				}
				return true;
			};
			break;
		case "string":
			// named query
			if(!this[query]){
				throw new Error("No filter function " + query + " was found in store");
			}
			query = this[query];
			// fall through
		case "function":
			// fall through
	}
	function execute(array){
		// execute the whole query, first we filter
		var results = arrayUtil.filter(array, query);
		// next we sort
		var sortSet = options && options.sort;
		if(sortSet){
			results.sort(typeof sortSet == "function" ? sortSet : function(a, b){
				for(var sort, i=0; sort = sortSet[i]; i++){
					var aValue = a[sort.attribute];
					var bValue = b[sort.attribute];
					// valueOf enables proper comparison of dates
					aValue = aValue != null ? aValue.valueOf() : aValue;
					bValue = bValue != null ? bValue.valueOf() : bValue;
					if (aValue != bValue){
						return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
					}
				}
				return 0;
			});
		}
		// now we paginate
		if(options && (options.start || options.count)){
			var total = results.length;
			results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
			results.total = total;
		}
		return results;
	}
	execute.matches = query;
	return execute;
};

});

define('dojo/store/Memory',["../_base/declare", "./util/QueryResults", "./util/SimpleQueryEngine" /*=====, "./api/Store" =====*/],
function(declare, QueryResults, SimpleQueryEngine /*=====, Store =====*/){

// module:
//		dojo/store/Memory

// No base class, but for purposes of documentation, the base class is dojo/store/api/Store
var base = null;
/*===== base = Store; =====*/

return declare("dojo.store.Memory", base, {
	// summary:
	//		This is a basic in-memory object store. It implements dojo/store/api/Store.
	constructor: function(options){
		// summary:
		//		Creates a memory object store.
		// options: dojo/store/Memory
		//		This provides any configuration information that will be mixed into the store.
		//		This should generally include the data property to provide the starting set of data.
		for(var i in options){
			this[i] = options[i];
		}
		this.setData(this.data || []);
	},
	// data: Array
	//		The array of all the objects in the memory store
	data:null,

	// idProperty: String
	//		Indicates the property to use as the identity property. The values of this
	//		property should be unique.
	idProperty: "id",

	// index: Object
	//		An index of data indices into the data array by id
	index:null,

	// queryEngine: Function
	//		Defines the query engine to use for querying the data store
	queryEngine: SimpleQueryEngine,
	get: function(id){
		// summary:
		//		Retrieves an object by its identity
		// id: Number
		//		The identity to use to lookup the object
		// returns: Object
		//		The object in the store that matches the given id.
		return this.data[this.index[id]];
	},
	getIdentity: function(object){
		// summary:
		//		Returns an object's identity
		// object: Object
		//		The object to get the identity from
		// returns: Number
		return object[this.idProperty];
	},
	put: function(object, options){
		// summary:
		//		Stores an object
		// object: Object
		//		The object to store.
		// options: dojo/store/api/Store.PutDirectives?
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		// returns: Number
		var data = this.data,
			index = this.index,
			idProperty = this.idProperty;
		var id = object[idProperty] = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
		if(id in index){
			// object exists
			if(options && options.overwrite === false){
				throw new Error("Object already exists");
			}
			// replace the entry in data
			data[index[id]] = object;
		}else{
			// add the new object
			index[id] = data.push(object) - 1;
		}
		return id;
	},
	add: function(object, options){
		// summary:
		//		Creates an object, throws an error if the object already exists
		// object: Object
		//		The object to store.
		// options: dojo/store/api/Store.PutDirectives?
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		// returns: Number
		(options = options || {}).overwrite = false;
		// call put with overwrite being false
		return this.put(object, options);
	},
	remove: function(id){
		// summary:
		//		Deletes an object by its identity
		// id: Number
		//		The identity to use to delete the object
		// returns: Boolean
		//		Returns true if an object was removed, falsy (undefined) if no object matched the id
		var index = this.index;
		var data = this.data;
		if(id in index){
			data.splice(index[id], 1);
			// now we have to reindex
			this.setData(data);
			return true;
		}
	},
	query: function(query, options){
		// summary:
		//		Queries the store for objects.
		// query: Object
		//		The query to use for retrieving objects from the store.
		// options: dojo/store/api/Store.QueryOptions?
		//		The optional arguments to apply to the resultset.
		// returns: dojo/store/api/Store.QueryResults
		//		The results of the query, extended with iterative methods.
		//
		// example:
		//		Given the following store:
		//
		// 	|	var store = new Memory({
		// 	|		data: [
		// 	|			{id: 1, name: "one", prime: false },
		//	|			{id: 2, name: "two", even: true, prime: true},
		//	|			{id: 3, name: "three", prime: true},
		//	|			{id: 4, name: "four", even: true, prime: false},
		//	|			{id: 5, name: "five", prime: true}
		//	|		]
		//	|	});
		//
		//	...find all items where "prime" is true:
		//
		//	|	var results = store.query({ prime: true });
		//
		//	...or find all items where "even" is true:
		//
		//	|	var results = store.query({ even: true });
		return QueryResults(this.queryEngine(query, options)(this.data));
	},
	setData: function(data){
		// summary:
		//		Sets the given data as the source for this store, and indexes it
		// data: Object[]
		//		An array of objects to use as the source of data.
		if(data.items){
			// just for convenience with the data format IFRS expects
			this.idProperty = data.identifier || this.idProperty;
			data = this.data = data.items;
		}else{
			this.data = data;
		}
		this.index = {};
		for(var i = 0, l = data.length; i < l; i++){
			this.index[data[i][this.idProperty]] = i;
		}
	}
});

});

define('xide/utils/StoreUtils',[
    'xide/utils',
    'dojo/store/Memory'
], function (utils,Memory)
{
    "use strict";
    /**
     *
     * @param store
     * @param item
     * @param recursive
     * @param idAttribute
     * @param parentAttr
     */
    utils.removeFromStore=function(store,item,recursive,idAttribute,parentAttr){

        var _item = store.getSync(item[idAttribute]);
        if(_item){
            console.error('no such item !! ', store);
        }
        //remove the item:
        store.removeSync(item[idAttribute]);


        //get children

        var query = {};
        query[parentAttr]=item[idAttribute];
        var items = store.query(query);

        if(items && items.length){
            for (var i = 0; i < items.length; i++) {
                var obj = items[i];
                utils.removeFromStore(store,obj,recursive,idAttribute,parentAttr);
            }
        }
    };
    /**
     * CI related tools.
     * @param d
     * @returns {*}
     */
    utils.toString = function (d){
        if (d != null) {
            if(!dojo.isArray(d))
            {
                return ''+ d;
            }
            if(d && d.length==1 && d[0]==null)
            {
                return null;
            }
            return '' + (d[0] !=null ? d[0] : d);
        }
        return null;
    };
    utils.toBoolean = function (data)
    {
        var resInt = false;
        if (data != null) {
            var _dataStr =data[0] ? data[0] : data;
            if(_dataStr!=null)
            {
                resInt= !!(( _dataStr === true || _dataStr === 'true' || _dataStr === '1'));
            }
        }
        return resInt ;
    };
    utils.toObject = function (data)
    {
        if (data != null) {
            var _obj =data[0] ? data[0] : data;
            return _obj;
        }

        return null;
    };
    utils.toInt= function (data)
    {
        var resInt = -1;
        if (data != null) {
            var _dataStr = data.length>1 ? data :  data[0] ? data[0] : data;
            if(_dataStr!=null)
            {
                try{
                    resInt = parseInt(_dataStr);
                }catch(e)
                {

                }
            }
        }
        return resInt;
    };
   /**
     * @param store
     * @param itemIdAsString
     * @return {Boolean}
     */
    utils.deleteStoreItemById = function (store, itemIdAsString) {
        var found = false;
        store.fetch(
            {query:{id:itemIdAsString }, queryOptions:{'deep':true},
                onComplete:function (items) {
                    for (var i = 0; i < items.length; i++)
                    {
                        var item = items[i];
                        store.deleteItem(item);
                        store.save();
                        found = true;
                        break;
                    }
                }
            });
        return found;
    };
    /***
     *
     * @param store
     * @param id
     * @return {null}
     */
    utils.getStoreItemByName = function (store, id){
        var res = null;
        store.fetch(
            {query:{name:id }, queryOptions:{'deep':true},
                onComplete:function (items) {
                    res = items.length > 0 ? items[0] : null;
                }
            });
        return res;
    };
    /***
     *
     * @param store
     * @param id
     * @return {null}
     */
    utils.getStoreItemById = function (store, id)
    {
        return utils.queryStoreEx(store,{id:id});
    };
    /***
     *
     * @param store
     * @param id
     * @param type
     * @return {null}
     */
    utils.getAppDataElementByIdAndType = function (store, id, type) {
        return utils.queryStore(store,{uid:id,type:type});
    };
    /***
     *
     * @param store
     * @param type
     * @return {null}
     */
    utils.getElementsByType = function (store,type) {
        return utils.queryStoreEx(store,{type:type});
    };


    /***
     *
     * @param store
     * @param query
     * @param nullEmpty
     * @returns {*}
     */
    utils.queryStoreEx=function(store,query,nullEmpty,single){

        if(!store){
            console.error('utils.queryStoreEx: store = null');
            console.trace();
            return null;
        }
        if((dojo.store!=null && store instanceof dojo.store.Memory) || store instanceof xide.data.Memory){
            var result = utils.queryMemoryStoreEx(store,query);
            if(single && result && result[0]){
                return result[0];
            }
            return result;
        }
        var res = null;
        if(store.fetch) {
            store.fetch({
                query: query,
                queryOptions: {
                    'deep': true
                },
                onComplete: function (items) {
                    res = items;
                }
            });
        }else if(store.query){
            res = store.query(query);
        }

        if(nullEmpty!=null && nullEmpty===true){
            if(res && res.length==0){
                return null;
            }
        }

        if(single===true){
            if(res && res.length==1){
                return res[0];
            }
        }

        return res;
    };

    utils.queryStore=function(store,query,nullEmpty)
    {

        if(dojo.store!=null && store instanceof dojo.store.Memory){
            return utils.queryMemoryStoreSingle(store,query);
        }
        var res = utils.queryStoreEx(store,query);

        if(res && res.length==1){
            return res[0];
        }
        if(nullEmpty!=null && nullEmpty===true){
            if(res && res.length==0){
                return null;
            }
        }
        return res;
    };
    utils.queryMemoryStoreEx=function(store,query)
    {
        var result = [];
        store.query(query).forEach(function(entry){
            result.push(entry);
        });
        return result;
    };
    utils.queryMemoryStoreSingle=function(store,query)
    {
        var result = utils.queryMemoryStoreEx(store,query);
        if (result.length == 1) {
            return result[0];
        }
        return result;
    };

    return utils;
});
define('xide/utils/WidgetUtils',[
    'xide/utils',
    'xide/types',
    'xide/factory',
    'dojo/aspect',
    'dojo/dom-class',
    'xide/registry'
], function (utils,types,factory,aspect,domClass,registry) {

    "use strict";

    utils.getParentWidget=function(start,declaredClass,max){
        //sanitize start
        start = start.containerNode || start.domNode || start;
        var i = 0,
            element = start,
            widget = null,
            _max = max || 10,
            _lastWidget = null;

        while (i < _max && !widget) {
            if (element) {
                element = element.parentNode;
                var _widgetById = registry.byId(element.id);
                var _widget = _widgetById || registry.getEnclosingWidget(element);
                _widget && (_lastWidget = _widget);
                if(_widget && declaredClass &&  _widget.declaredClass && _widget.declaredClass.indexOf(declaredClass)!=-1){
                    widget = _widget;
                }
            }
            i++;
        }
        return widget;
    };


    /**
     * @param menu
     * @param emit
     * @param owner
     * @param context
     * @param onAfterOpenFunction
     */
    utils.patchMenu=function(menu,emit,owner,context,onAfterOpenFunction){
        aspect.after(menu, 'onOpen', function () {
            if(emit) {
                factory.publish(emit, {
                    mainMenu: owner,
                    menu: menu,
                    item: context
                });
            }
            if (this._popupWrapper && !this._popupWrapper._patched) {
                var dst = this._popupWrapper;
                dst._patched=true;
                domClass.add(dst, 'ui-widget ui-widget-content');
            }
            if(onAfterOpenFunction){
                onAfterOpenFunction(menu,owner);
            }
        });
    };

    /**
     *
     * @param type
     * @returns {string}
     */
    utils.getWidgetType = function (type) {
        var res = "";

        var root = 'xide.widgets.';
        if (type == types.ECIType.ENUMERATION) {
            res = root  + "Select";
        }
        if (type == types.ECIType.STRING) {
            res = root  + "TextBox";
        }

        if (type == types.ECIType.ICON) {
            res = root  + "TextBox";
        }

        if (type == types.ECIType.REFERENCE) {
            res = root  + "Button";
        }

        if (type == types.ECIType.EXPRESSION) {
            res = root  + "Expression";
        }

        if (type == types.ECIType.EXPRESSION_EDITOR) {
            res = root  + "ExpressionEditor";
        }

        if (type == types.ECIType.ARGUMENT) {
            res = root  + "ArgumentsWidget";
        }

        if (type == types.ECIType.WIDGET_REFERENCE) {
            res = root  + "WidgetReference";
        }

        if (type == types.ECIType.BLOCK_REFERENCE) {
            res =root  +  "BlockPickerWidget";
        }

        if (type == types.ECIType.BLOCK_SETTINGS) {
            res = root  + "BlockSettingsWidget";
        }


        if (type == types.ECIType.DOM_PROPERTIES) {
            res = root  + "DomStyleProperties";
        }

        if (type == types.ECIType.FILE_EDITOR) {
            res = root  + "FileEditor";
        }

        return res;
    };
    /**
     * @TODO : find a better way, use xas.widgets._TranslationMixin
     * Group to title mapping
     * @param widgetGroup
     * @return {*}
     */
    utils.getWidgetGroupTitle = function (widgetGroup) {
        switch (widgetGroup) {
            case types.WidgetGroup.General :
                return types.WidgetGroupTitle.General;
            case types.WidgetGroup.Visual:
                return types.WidgetGroupTitle.Visual;
            case types.WidgetGroup.All:
                return types.WidgetGroupTitle.All;
            case types.WidgetGroup.User:
                return types.WidgetGroupTitle.User;
            case types.WidgetGroup.System:
                return types.WidgetGroupTitle.System;
        }
        return types.WidgetGroupTitle.Unknown;
    };

    /***
     * @TODO : Find a better way to group CIs
     * @param ci
     */
    utils.getWidgetGroup = function (ci) {
        if (!ci || utils.toBoolean(ci.visible) === false) {
            return types.WidgetGroup.Hidden;
        }

        var ciName = utils.toString(ci.name);
        //visuals
        if (
            ciName == types.DRIVER_PROPERTY.CF_DRIVER_NAME ||
            ciName == types.DRIVER_PROPERTY.CF_DRIVER_ICON) {
            return types.WidgetGroup.Visual;
        }

        if (ciName == types.DRIVER_PROPERTY.CF_DRIVER_CLASS) {
            return types.WidgetGroup.System;
        }
        return types.WidgetGroup.Unknown;
    };

    /**
     * Traverses a dijit.tree store model
     * @param lookfor
     * @param model
     * @param buildme
     * @param item
     * @returns {*}
     */
    utils.recursiveHunt = function (lookfor, model, buildme, item) {
        return undefined;
    };
    /**
     * Selects an item in a dijit.tree store model
     * @param tree
     * @param lookfor
     * @returns {*}
     */
    utils.selectTreeNodeById = function (tree, lookfor) {};

    return utils;
});
define('xide/utils/CIUtils',[
    'xide/utils',
    'xide/types',
    'xide/factory',
    'dojo/has',
    'xide/lodash'
],function(utils,types,factory,has,_){
    "use strict";
    /**
     *
     * @param cis
     * @returns {Array}
     */
    utils.toOptions  = function(cis){
        cis = utils.flattenCIS(cis);
        var result = [];
        for (var i = 0; i < cis.length; i++) {
            var ci = cis[i];
            result.push({
                name:utils.toString(ci['name']),
                value:utils.getCIValue(ci),
                type: utils.toInt(ci['type']),
                enumType:utils.toString(ci['enumType']),
                visible:utils.toBoolean(ci['visible']),
                active:utils.toBoolean(ci['active']),
                changed:utils.toBoolean(ci['changed']),
                group:utils.toString(ci['group']),
                user:utils.toObject(ci['user']),
                dst:utils.toString(ci['dst']),
                params:utils.toString(ci['params'])
            })
        }
        return result;
    };

    if(has('xideve') || has('xblox-ui')) {
        utils.getEventsAsOptions = function (selected) {
            var result = [
                {label: "Select Event", value: ""}
            ];
            for (var e in types.EVENTS) {
                var label = types.EVENTS[e];

                var item = {
                    label: label,
                    value: types.EVENTS[e]
                };
                result.push(item);
            }
            result = result.concat(
                [{label: "onclick", value: "onclick"},
                    {label: "ondblclick", value: "dblclick"},
                    {label: "onmousedown", value: "mousedown"},
                    {label: "onmouseup", value: "mouseup"},
                    {label: "onmouseover", value: "mouseover"},
                    {label: "onmousemove", value: "mousemove"},
                    {label: "onmouseout", value: "mouseout"},
                    {label: "onkeypress", value: "keypress"},
                    {label: "onkeydown", value: "keydown"},
                    {label: "onkeyup", value: "keyup"},
                    {label: "onfocus", value: "focus"},
                    {label: "onblur", value: "blur"},
                    {label: "On Load", value: "Load"}
                ]);
            //select the event we are listening to
            for (var i = 0; i < result.length; i++) {
                var obj = result[i];
                if (obj.value === selected) {
                    obj.selected = true;
                    break;
                }
            }
            return result;
        };
    }

    utils.flattenCIS  = function(cis){
        var addedCIS = [];
        var removedCIs = [];
        for (var i = 0; i < cis.length; i++) {
            var ci = cis[i];

            var ciType = utils.toInt(ci.type);

            if(ciType > types.ECIType.END){//type is higher than core types, try to resolve it
                var resolved = types.resolveType(ciType);
                if(resolved){
                    utils.mixin(addedCIS,resolved);
                    removedCIs.push(ci);
                }
            }
        }
        if(addedCIS.length>0){
            cis = cis.concat(addedCIS);
        }
        if(removedCIs){
            for(var i in removedCIs){
                cis.remove(removedCIs[i]);
            }
        }
        return cis;
    };

    utils.arrayContains=function(array,element){
        for (var i = 0; i < array.length; i++){
            var _e = array[i];
            if(_e===element){
                return true;
            }
        }
        return false;
    };

    utils.setStoreCIValueByField = function (d, field, value) {
        if (d[field] == null) {
            d[field] = [];
        }
        d[field][0] = utils.getStringValue(value);
        return d;
    };
    /**
     *
     * @param label
     * @param value
     * @param extra
     * @returns {Object}
     */
    utils.createOption=function(label,value,extra){
        return utils.mixin({
            label:label,
            value:value !=null ? value : label
        },extra);
    };
    /**
     *
     * @param name
     * @param type
     * @param value
     * @param args
     * @param settings
     * @returns {{dataRef: null, dataSource: null, name: *, group: number, id: *, title: *, type: *, uid: number, value: *, visible: boolean, enumType: number, class: string}}
     */
    utils.createCI = function (name, type, value,args,settings) {
        var res = {
            dataRef:null,
            dataSource:null,
            name:name,
            group:-1,
            id:name,
            title:name,
            type:type,
            uid:-1,
            value: value!=null ? value : -1,
            visible:true,
            enumType:-1,
            "class":"cmx.types.ConfigurableInformation"
        };
        utils.mixin(res,args);
        if(settings){
            if(settings.publish){
                factory.publish(settings.publish,{
                    CI:res,
                    owner:settings.owner
                },settings.owner);
            }
        }
        return res;
    };

    utils.createCIAsArray = function (name, type, chain,value) {
        return {
            chainType:[chain ? chain : 0],
            dataRef:[null],
            dataSource:[null],
            params:[],
            name:[name],
            group:[-1],
            id:[name],
            title:[name],
            type:[type],
            uid:[-1],
            value: [value ? value : -1],
            visible:[true],
            enumType:[-1],
            parentId:[-1],
            "class":["cmx.types.ConfigurableInformation"]
        };
    };

    utils.hasValue = function (data){
        return data.value &&  data.value[0] !=null && data.value[0].length > 0 && data.value[0] !="0" && data.value[0] !="undefined" && data.value[0] !="Unset";
    };

    utils.hasValueAndDataRef = function (data){
        return data.value &&  data.value[0] !=null && data.value[0].length > 0 && data.value[0] !="0" && data.value[0] !="undefined" && data.value[0] !="Unset" &&
            data.dataRef &&  data.dataRef[0] !=null && data.dataRef[0].length > 0 && data.dataRef[0] !="0" && data.dataRef[0] !="undefined";
    };

    utils.getInputCIByName = function (data,name){
        if(!data){
            return null;
        }
        var chain = 0;
        var dstChain = chain == 0 ? data.inputs : chain == 1 ? data.outputs : null;
        if(!dstChain){//has no chains, be nice
            dstChain=data;
        }
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                var _n = utils.getStringValue(ci.name);
                if (_n!=null && _n.toLowerCase() === name.toLowerCase()){
                    return ci;
                }
            }
        }
        return null;
    };
    /***
     *
     * @param data
     * @param chain
     * @param name
     * @returns {*}
     */
    utils.getCIByChainAndName = function (data, chain, name) {
        if(!data){
            return null;
        }
        var dstChain = chain == 0 ? data.inputs : chain == 1 ? data.outputs : null;
        if(!dstChain){//has no chains
            dstChain=data;
        }
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                var _n = utils.getStringValue(ci.name);
                if (_n!=null && _n.toLowerCase() === name.toLowerCase()){
                    return ci;
                }
            }
        }
        return null;
    };
    utils.getCIByUid= function (dstChain, uid) {
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                var _n = utils.getStringValue(ci.uid);
                if (_n!=null && _n === uid)
                {
                    return ci;
                }
            }
        }
        return null;
    };
    utils.getCIById= function (data, chain, id) {
        var dstChain = chain == 0 ? data.inputs : chain == 1 ? data.outputs : null;
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                if (ci.id[0] == id[0]  )
                    return ci;
            }
        }
        return null;
    };
    utils.getCIInputValueByName = function (data, name) {
        var ci = utils.getCIByChainAndName(data, 0, name);
        if (ci) {
            return ci.value;
        }
        return null;
    };
    utils.getCIValue = function (data){
        return utils.getCIValueByField(data,"value");
    };
    utils.getStringValue = function (d){
        return utils.toString(d);
    };
    utils.toString = function (d){
        if (d != null) {
            if(!_.isArray(d))
            {
                return ''+ d;
            }
            if(d && d.length==1 && d[0]==null)
            {
                return null;
            }
            return '' + (d[0] !=null ? d[0] : d);
        }
        return null;
    };
    utils.setIntegerValue = function (data,value){
        if (data != null) {

            if(dojo.isArray(data))
            {
                data[0]=value;
            }else{
                data=value;
            }
        }
    };

    utils.getCIValueByField = function (data, field) {
        if (data[field] != null) {
            if(_.isArray(data[field])){
                return data[field][0] ? data[field][0] : data[field];
            }else{
                return data[field];
            }
        }
        return null;
    };
    utils.setCIValueByField = function (data, field, value) {
        if(!data){
            return data;
        }
        if (data[field] == null) {
            data[field] = [];
        }
        data[field]=value
        return data;
    };

    utils.setCIValue = function (data, field, value) {
        var ci = utils.getInputCIByName(data,field);
        if(ci){
            utils.setCIValueByField(ci,'value',value);
        }
        return ci;
    };
    utils.getCIInputValueByNameAndField = function (data, name, field) {
        var ci = utils.getCIByChainAndName(data, 0, name);
        if (ci) {
            return ci["" + field];
        }
        return null;
    };

    utils.getCIInputValueByNameAndFieldStr = function (data, name, field) {
        var rawValue = utils.getCIInputValueByNameAndField(data,name,field);
        if(rawValue){
            return utils.getStringValue(rawValue);
        }
        return null;
    };
    utils.getCIInputValueByNameAndFieldBool = function (data, name, field) {
        var rawValue = utils.getCIInputValueByNameAndField(data,name,field);
        if(rawValue){
            return utils.toBoolean(rawValue);
        }
        return null;
    };
    utils.getCIWidgetByName=function(cis,name){

        for (var i = 0; i < cis.length; i++) {
            var ci = cis[i];
            if(ci['_widget'] && ci.name===name){
                return ci['_widget'];
            }
        }
        return null;
    };
    return utils;
});
define('xide/utils/ObjectUtils',[
    'xide/utils',
    'require',
    "dojo/Deferred",
    "dojo/_base/json",
    "dojo/has"
], function (utils, require, Deferred,json,has) {

    var _debug = false;

    "use strict";
    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Loader utils
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    utils.debounce = function(who,methodName,_function,delay,options,now){
        var _place = who[methodName+'_debounced'];
        if(!_place){
            _place = who[methodName+'_debounced'] =  _.debounce(_function, delay,options);
        }
        if(now==true){
            if(!who[methodName+'_debouncedFirst']){
                who[methodName+'_debouncedFirst']=true;
                _function.apply(who);
            }
        }
        return _place();
    };

    utils.pluck=function(items,prop){
        var result = [];
        if(!items){
            _debug && console.warn('pluck: no items');
            return result;
        }
        for (var i = 0; i < items.length; i++) {
            result.push(items[i][prop]);
        }
        return result;

    };

    /**
     * Trigger downloadable file
     * @param filename
     * @param text
     */
    utils.download  = function(filename, text){
        var element = document.createElement('a');
        text = _.isString(text) ? text : JSON.stringify(text,null,2);
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
    };

    /**
     * Ask require registry at this path
     * @param mixed
     * @param _default
     * @param ready
     * @returns {*}
     */
    utils.hasObject = function (mixed, _default, ready) {
        var result = null;
        var _re = require;
        try {
            result = _re(mixed);
        } catch (e) {
            console.error('error in utils.hasObject ', e);
        }
        return result;
    };
    /**
     * Returns a module by module path
     * @param mixed {String|Object}
     * @param _default {Object} default object
     * @returns {Object|Promise}
     */
    utils.getObject = function (mixed, _default) {
        var result = null;
        if (utils.isString(mixed)) {
            var _re = require;
            try {
                result = _re(mixed);
            } catch (e) {
                _debug && console.warn('utils.getObject::require failed for ' + mixed);
            }
            //not a loaded module yet
            try {
                if (!result) {

                    var deferred = new Deferred();
                    //try loader
                    result = _re([
                        mixed
                    ], function (module) {
                        deferred.resolve(module);
                    });
                    return deferred.promise;
                }
            }catch(e){
                _debug &&  console.error('error in requiring '+mixed,e);
            }
            return result;

        } else if (utils.isObject(mixed)) {
            return mixed;//reflect
        }
        return result !== null ? result : _default;
    };


    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  True object utils
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    utils.toArray = function (obj) {
        var result = [];
        for (var c in obj) {
            result.push({
                name: c,
                value: obj[c]
            });
        }
        return result;
    };
    /**
     * Array to object conversion
     * @param arr
     * @returns {Object}
     */
    utils.toObject = function (arr, lodash) {
        if (!arr) {
            return {};
        }
        if (lodash !== false) {
            return _.object(_.map(arr, _.values));
        } else {
            //CI related back compat hack
            if (utils.isObject(arr) && arr[0]) {
                return arr[0];
            }

            var rv = {};
            for (var i = 0; i < arr.length; ++i) {
                rv[i] = arr[i];
            }
            return rv;
        }
    };

    /**
     * Gets an object property by string, eg: utils.byString(someObj, 'part3[0].name');
     * @deprecated, see objectAtPath below
     * @param o {Object}    : the object
     * @param s {String}    : the path within the object
     * @param defaultValue {Object|String|Number} : an optional default value
     * @returns {*}
     */
    utils.byString = function (o, s, defaultValue) {
        s = s.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
        s = s.replace(/^\./, '');           // strip a leading dot
        var a = s.split('.');
        while (a.length) {
            var n = a.shift();
            if (n in o) {
                o = o[n];
            } else {
                return;
            }
        }
        return o;
    };

    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Object path
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Internals
     */

    //cache
    var toStr = Object.prototype.toString,
        _hasOwnProperty = Object.prototype.hasOwnProperty;

    /**
     * @private
     * @param type
     * @returns {*}
     */
    function toString(type) {
        return toStr.call(type);
    }

    /**
     * @private
     * @param key
     * @returns {*}
     */
    function getKey(key) {
        var intKey = parseInt(key);
        if (intKey.toString() === key) {
            return intKey;
        }
        return key;
    }

    /**
     * internal set value at path in object
     * @private
     * @param obj
     * @param path
     * @param value
     * @param doNotReplace
     * @returns {*}
     */
    function set(obj, path, value, doNotReplace) {
        if (_.isNumber(path)) {
            path = [path];
        }
        if (_.isEmpty(path)) {
            return obj;
        }
        if (_.isString(path)) {
            return set(obj, path.split('.').map(getKey), value, doNotReplace);
        }
        var currentPath = path[0];

        if (path.length === 1) {
            var oldVal = obj[currentPath];
            if (oldVal === void 0 || !doNotReplace) {
                obj[currentPath] = value;
            }
            return oldVal;
        }

        if (obj[currentPath] === void 0) {
            //check if we assume an array
            if (_.isNumber(path[1])) {
                obj[currentPath] = [];
            } else {
                obj[currentPath] = {};
            }
        }
        return set(obj[currentPath], path.slice(1), value, doNotReplace);
    }

    /**
     * deletes an property by a path
     * @param obj
     * @param path
     * @returns {*}
     */
    function del(obj, path) {
        if (_.isNumber(path)) {
            path = [path];
        }
        if (_.isEmpty(obj)) {
            return void 0;
        }

        if (_.isEmpty(path)) {
            return obj;
        }
        if (_.isString(path)) {
            return del(obj, path.split('.'));
        }

        var currentPath = getKey(path[0]);
        var oldVal = obj[currentPath];

        if (path.length === 1) {
            if (oldVal !== void 0) {
                if (_.isArray(obj)) {
                    obj.splice(currentPath, 1);
                } else {
                    delete obj[currentPath];
                }
            }
        } else {
            if (obj[currentPath] !== void 0) {
                return del(obj[currentPath], path.slice(1));
            }
        }
        return obj;
    }

    /**
     * Private helper class
     * @private
     * @type {{}}
     */
    var objectPath = {};

    objectPath.has = function (obj, path) {
        if (_.isEmpty(obj)) {
            return false;
        }
        if (_.isNumber(path)) {
            path = [path];
        } else if (_.isString(path)) {
            path = path.split('.');
        }

        if (_.isEmpty(path) || path.length === 0) {
            return false;
        }

        for (var i = 0; i < path.length; i++) {
            var j = path[i];
            if ((_.isObject(obj) || _.isArray(obj)) && _hasOwnProperty.call(obj, j)) {
                obj = obj[j];
            } else {
                return false;
            }
        }

        return true;
    };

    /**
     * Define private public 'ensure exists'
     * @param obj
     * @param path
     * @param value
     * @returns {*}
     */
    objectPath.ensureExists = function (obj, path, value) {
        return set(obj, path, value, true);
    };

    /**
     * Define private public 'set'
     * @param obj
     * @param path
     * @param value
     * @param doNotReplace
     * @returns {*}
     */
    objectPath.set = function (obj, path, value, doNotReplace) {
        return set(obj, path, value, doNotReplace);
    };

    /**
     Define private public 'insert'
     * @param obj
     * @param path
     * @param value
     * @param at
     */
    objectPath.insert = function (obj, path, value, at) {
        var arr = objectPath.get(obj, path);
        at = ~~at;
        if (!isArray(arr)) {
            arr = [];
            objectPath.set(obj, path, arr);
        }
        arr.splice(at, 0, value);
    };

    /**
     * Define private public 'empty'
     * @param obj
     * @param path
     * @returns {*}
     */
    objectPath.empty = function (obj, path) {
        if (_.isEmpty(path)) {
            return obj;
        }
        if (_.isEmpty(obj)) {
            return void 0;
        }

        var value, i;
        if (!(value = objectPath.get(obj, path))) {
            return obj;
        }

        if (_.isString(value)) {
            return objectPath.set(obj, path, '');
        } else if (_.isBoolean(value)) {
            return objectPath.set(obj, path, false);
        } else if (_.isNumber(value)) {
            return objectPath.set(obj, path, 0);
        } else if (_.isArray(value)) {
            value.length = 0;
        } else if (_.isObject(value)) {
            for (i in value) {
                if (_hasOwnProperty.call(value, i)) {
                    delete value[i];
                }
            }
        } else {
            return objectPath.set(obj, path, null);
        }
    };

    /**
     * Define private public 'push'
     * @param obj
     * @param path
     */
    objectPath.push = function (obj, path /*, values */) {
        var arr = objectPath.get(obj, path);
        if (!_.isArray(arr)) {
            arr = [];
            objectPath.set(obj, path, arr);
        }
        arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
    };

    /**
     * Define private public 'coalesce'
     * @param obj
     * @param paths
     * @param defaultValue
     * @returns {*}
     */
    objectPath.coalesce = function (obj, paths, defaultValue) {
        var value;
        for (var i = 0, len = paths.length; i < len; i++) {
            if ((value = objectPath.get(obj, paths[i])) !== void 0) {
                return value;
            }
        }
        return defaultValue;
    };

    /**
     * Define private public 'get'
     * @param obj
     * @param path
     * @param defaultValue
     * @returns {*}
     */
    objectPath.get = function (obj, path, defaultValue) {
        if (_.isNumber(path)) {
            path = [path];
        }
        if (_.isEmpty(path)) {
            return obj;
        }
        if (_.isEmpty(obj)) {
            //lodash doesnt seem to work with html nodes
            if (obj && obj.innerHTML == null) {
                return defaultValue;
            }
        }
        if (_.isString(path)) {
            return objectPath.get(obj, path.split('.'), defaultValue);
        }
        var currentPath = getKey(path[0]);
        if (path.length === 1) {
            if (obj && obj[currentPath] === void 0) {
                return defaultValue;
            }
            if (obj) {
                return obj[currentPath];
            }
        }
        if (!obj) {
            return defaultValue;
        }
        return objectPath.get(obj[currentPath], path.slice(1), defaultValue);
    };

    /**
     * Define private public 'del'
     * @param obj
     * @param path
     * @returns {*}
     */
    objectPath.del = function (obj, path) {
        return del(obj, path);
    };
    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Object path public xide/utils mixin
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    /**
     *  Returns a value by a give object path
     *
     *  //works also with arrays
     *    objectPath.get(obj, "a.c.1");  //returns "f"
     *    objectPath.get(obj, ["a","c","1"]);  //returns "f"
     *
     * @param obj {object}
     * @param path {string}
     * @param _default {object|null}
     * @returns {*}
     */
    utils.getAt = function (obj, path, _default) {
        return objectPath.get(obj, path, _default);
    };

    /**
     * Sets a value in an object/array at a given path.
     * @example
     *
     * utils.setAt(obj, "a.h", "m"); // or utils.setAt(obj, ["a","h"], "m");
     *
     * //set will create intermediate object/arrays
     * objectPath.set(obj, "a.j.0.f", "m");
     *
     * @param obj{Object|Array}
     * @param path {string}
     * @param value {mixed}
     * @returns {Object|Array}
     */
    utils.setAt = function (obj, path, value) {
        return objectPath.set(obj, path, value);
    };

    /**
     * Returns there is anything at given path within an object/array.
     * @param obj
     * @param path
     */
    utils.hasAt = function (obj, path) {
        return objectPath.has(obj, path);
    };

    /**
     * Ensures at given path, otherwise _default will be placed
     * @param obj
     * @param path
     * @returns {*}
     */
    utils.ensureAt = function (obj, path, _default) {
        return objectPath.ensureExists(obj, path, _default);
    };
    /**
     * Deletes at given path
     * @param obj
     * @param path
     * @returns {*}
     */
    utils.deleteAt = function (obj, path) {
        return objectPath.del(obj, path);
    };

    /**
     *
     * @param to
     * @param from
     * @returns {*}
     */
    utils.merge = function (to, from) {
        for (var n in from) {
            if (typeof to[n] != 'object') {
                to[n] = from[n];
            } else if (typeof from[n] == 'object') {
                to[n] = utils.merge(to[n], from[n]);
            }
        }

        return to;
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Dojo's most wanted
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    utils.clone=function(/*anything*/ src){
        // summary:
        // Clones objects (including DOM nodes) and all children.
        // Warning: do not clone cyclic structures.
        // src:
        // The object to clone
        if(!src || typeof src != "object" || utils.isFunction(src)){
            // null, undefined, any non-object, or function
            return src; // anything
        }
        if(src.nodeType && "cloneNode" in src){
            // DOM Node
            return src.cloneNode(true); // Node
        }
        if(src instanceof Date){
            // Date
            return new Date(src.getTime()); // Date
        }
        if(src instanceof RegExp){
            // RegExp
            return new RegExp(src); // RegExp
        }
        var r, i, l;
        if(utils.isArray(src)){
            // array
            r = [];
            for(i = 0, l = src.length; i < l; ++i){
                if(i in src){
                    r.push(utils.clone(src[i]));
                }
            }
            // we don't clone functions for performance reasons
            // }else if(d.isFunction(src)){
            // // function
            // r = function(){ return src.apply(this, arguments); };
        }else{
            // generic objects
            r = src.constructor ? new src.constructor() : {};
        }
        return utils._mixin(r, src, utils.clone);
    };

    /**
     * Copies/adds all properties of source to dest; returns dest.
     * @description All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
     * found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
     * delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
     * Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
     * @param dest {object} The object to which to copy/add all properties contained in source.
     * @param source {object} The object from which to draw all properties to copy into dest.
     * @param copyFunc {function} The process used to copy/add a property in source; defaults to the Javascript assignment operator.
     * @returns {object} dest, as modified
     * @private
     */
    utils._mixin=function (dest, source, copyFunc) {
        var name, s, i, empty = {};
        for (name in source) {
            // the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
            // inherited from Object.prototype.	 For example, if dest has a custom toString() method,
            // don't overwrite it with the toString() method that source inherited from Object.prototype
            s = source[name];
            if (!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))) {
                dest[name] = copyFunc ? copyFunc(s) : s;
            }
        }

        return dest; // Object
    };
    /**
     * Copies/adds all properties of one or more sources to dest; returns dest.
     * @param dest {object} The object to which to copy/add all properties contained in source. If dest is falsy, then
     * a new object is manufactured before copying/adding properties begins.
     *
     * @param sources One of more objects from which to draw all properties to copy into dest. sources are processed
     * left-to-right and if more than one of these objects contain the same property name, the right-most
     * value "wins".
     *
     * @returns {object} dest, as modified
     *
     * @example
     * make a shallow copy of an object
     * var copy = utils.mixin({}, source);
     *
     * @example
     *
     * many class constructors often take an object which specifies
     *        values to be configured on the object. In this case, it is
     *        often simplest to call `lang.mixin` on the `this` object:
     *        declare("acme.Base", null, {
    *			constructor: function(properties){
    *				//property configuration:
    *				lang.mixin(this, properties);
    *				console.log(this.quip);
    *			},
    *			quip: "I wasn't born yesterday, you know - I've seen movies.",
    *			* ...
    *		});
     *
     *        //create an instance of the class and configure it
     *        var b = new acme.Base({quip: "That's what it does!" });
     *
     */
    utils.mixin = function (dest, sources) {
        if(sources) {

            if (!dest) {
                dest = {};            }

            var l = arguments.length;
            for (var i = 1 ; i < l; i++) {
                utils._mixin(dest, arguments[i]);
            }
            return dest; // Object
        }
        return dest;
    };

    /**
     * Clone object keys
     * @param defaults
     * @returns {{}}
     */
    utils.cloneKeys = function (defaults, skipEmpty) {
        var result = {};
        for (var _class in defaults) {
            if (skipEmpty === true && !(_class in defaults)) {
                continue;
            }
            result[_class] = defaults[_class];
        }
        return result;
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  STD
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isArray=function(what){
        return _.isArray(what);
    };
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isObject=function(what){
        return _.isObject(what);
    };
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isString=function(what){
        return _.isString(what);
    };
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isNumber=function(what){
        return _.isNumber(what);
    };
    /**
     *
     * @param it
     * @returns {*}
     */
    utils.isFunction=function(it){
        // summary:
        // Return true if it is a Function
        // it: anything
        // Item to test.
        return _.isFunction(it);
    };
    return utils;
});
define('xide/factory/Objects',[
    'dcl/dcl',
    'xide/utils',
    'xide/factory',
    'xdojo/declare'
], function (dcl,utils, factory, declare) {
    /***
     * Convinience object factory via dojo/declare
     * @param classNameOrPrototype
     * @param ctrArgs
     * @param baseClasses
     * @returns {*}
     */
    factory.createInstance = function (classNameOrPrototype, ctrArgs, baseClasses) {
        var ctrArgsFinal = {};
        utils.mixin(ctrArgsFinal, ctrArgs);
        //prepare object prototype, try dojo and then abort
        var objectProtoType = classNameOrPrototype;
        if (_.isString(classNameOrPrototype)) {
            var proto = dojo.getObject(objectProtoType) || dcl.getObject(objectProtoType);
            if (proto) {
                objectProtoType = proto;
            } else {
                console.error('no such class : ' + classNameOrPrototype);
                return null;
            }
        }

        baseClasses && ( objectProtoType = declare(baseClasses, objectProtoType.prototype));

        if(!ctrArgsFinal.id){
            var className = objectProtoType.declaredClass || 'no_class_';
            ctrArgsFinal.id = className.replace(/\//g, "_") + utils.createUUID();
        }

        var instance = new objectProtoType(ctrArgsFinal);

        //@TODO: trash
        instance && ( instance.ctrArgs = ctrArgsFinal);

        return instance;
    };
    return factory;
});
define('xide/utils/_LogMixin',[
    'dcl/dcl',
    'xide/utils',
    'xide/model/Base'
], function (dcl, utils,Base) {
    return dcl(Base.dcl,{
        declaredClass:"xide.utils._LogMixin",
        debug_conf: null,
        initLogger: function (debug_config) {
            this.debug_conf = debug_config;
        },
        log: function (msg, msg_context) {
            if (!msg_context) msg_context = this._debugContext()["main"];
            if (this.showDebugMsg(msg_context)) {
                console.log(msg);
            }
        },
        showDebugMsg: function (msg_context) {
            if (this.debug_conf != null) {
                if (this.debug_conf["all"]) {
                    return true;
                }
                else {
                    if (this.debug_conf[msg_context]) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            } else {
                console.log("No debug config, showing all.");
                this.debug_conf = {
                    "all": true
                };
                return true;
            }
        }
    });
});
define('dojo/_base/unload',["./kernel", "./lang", "../on"], function(dojo, lang, on){

// module:
//		dojo/unload

var win = window;

var unload = {
	// summary:
	//		This module contains the document and window unload detection API.
	//		This module is deprecated.  Use on(window, "unload", func)
	//		and on(window, "beforeunload", func) instead.

	addOnWindowUnload: function(/*Object|Function?*/ obj, /*String|Function?*/ functionName){
		// summary:
		//		Registers a function to be triggered when window.onunload fires.
		//		Deprecated, use on(window, "unload", lang.hitch(obj, functionName)) instead.
		// description:
		//		The first time that addOnWindowUnload is called Dojo
		//		will register a page listener to trigger your unload
		//		handler with. Note that registering these handlers may
		//		destroy "fastback" page caching in browsers that support
		//		it. Be careful trying to modify the DOM or access
		//		JavaScript properties during this phase of page unloading:
		//		they may not always be available. Consider
		//		addOnUnload() if you need to modify the DOM or do
		//		heavy JavaScript work since it fires at the equivalent of
		//		the page's "onbeforeunload" event.
		// example:
		//	|	var afunc = function() {console.log("global function");};
		//	|	require(["dojo/_base/unload"], function(unload) {
		//	|		var foo = {bar: function(){ console.log("bar unloading...");}, 
		//	|		           data: "mydata"};
		//	|		unload.addOnWindowUnload(afunc);
		//	|		unload.addOnWindowUnload(foo, "bar");
		//	|		unload.addOnWindowUnload(foo, function(){console.log("", this.data);});
		//	|	});

		if (!dojo.windowUnloaded){
			on(win, "unload", (dojo.windowUnloaded = function(){
				// summary:
				//		signal fired by impending window destruction. You may use
				//		dojo.addOnWindowUnload() to register a listener for this
				//		event. NOTE: if you wish to dojo.connect() to this method
				//		to perform page/application cleanup, be aware that this
				//		event WILL NOT fire if no handler has been registered with
				//		addOnWindowUnload(). This behavior started in Dojo 1.3.
				//		Previous versions always triggered windowUnloaded(). See
				//		addOnWindowUnload for more info.
			}));
		}
		on(win, "unload", lang.hitch(obj, functionName));
	},

	addOnUnload: function(/*Object?|Function?*/ obj, /*String|Function?*/ functionName){
		// summary:
		//		Registers a function to be triggered when the page unloads.
		//		Deprecated, use on(window, "beforeunload", lang.hitch(obj, functionName)) instead.
		// description:
		//		The first time that addOnUnload is called Dojo will
		//		register a page listener to trigger your unload handler
		//		with.
		//
		//		In a browser environment, the functions will be triggered
		//		during the window.onbeforeunload event. Be careful of doing
		//		too much work in an unload handler. onbeforeunload can be
		//		triggered if a link to download a file is clicked, or if
		//		the link is a javascript: link. In these cases, the
		//		onbeforeunload event fires, but the document is not
		//		actually destroyed. So be careful about doing destructive
		//		operations in a dojo.addOnUnload callback.
		//
		//		Further note that calling dojo.addOnUnload will prevent
		//		browsers from using a "fast back" cache to make page
		//		loading via back button instantaneous.
		// example:
		//	|	var afunc = function() {console.log("global function");};
		//	|	require(["dojo/_base/unload"], function(unload) {
		//	|		var foo = {bar: function(){ console.log("bar unloading...");}, 
		//	|		           data: "mydata"};
		//	|		unload.addOnUnload(afunc);
		//	|		unload.addOnUnload(foo, "bar");
		//	|		unload.addOnUnload(foo, function(){console.log("", this.data);});
		//	|	});

		on(win, "beforeunload", lang.hitch(obj, functionName));
	}
};

dojo.addOnWindowUnload = unload.addOnWindowUnload;
dojo.addOnUnload = unload.addOnUnload;

return unload;

});

define('xide/client/ClientBase',[
    'dcl/dcl',
    'xide/mixins/EventedMixin',
    'xide/model/Base',
    'dojo/_base/unload',
    'xide/utils'
], function (dcl,EventedMixin,Base, unload,utils) {
    var Module = dcl([Base.dcl,EventedMixin.dcl], {
        declaredClass:"xide.client.ClientBase",
        options: null,
        _socket: null,
        onConnectionReady: function () {
        },
        onClosed: function () {
        },
        destroy: function () {
            if (this._socket && this._socket.close) {
                this._socket.close();
                this.onClosed();
            }
        },
        _defaultOptions: function () {
            return {};
        },
        init: function (args) {
            this.options = utils.mixin(this._defaultOptions(), args.options);
            //disconnect on onload
            unload.addOnUnload(function () {
                this.destroy();
            }.bind(this));
        }
    });

    dcl.chainAfter(Module,"destroy");
    return Module;
});
define('xide/client/WebSocket',[
    "dcl/dcl",
    'xide/utils',
    'xide/utils/_LogMixin',
    'xide/client/ClientBase'
], function (dcl, utils, _logMixin, ClientBase) {
    var debug = false;
    return dcl([ClientBase, _logMixin], {
        declaredClass:"xide.client.WebSocket",
        _socket: null,
        debugConnect: true,
        autoReconnect: true,
        reconnect: function () {
            debug && console.log('reconnect!');
        },
        close: function () {
            this.destroy();
        },
        onLostConnection:function(){
            debug && console.log('lost connection');
        },
        onConnected:function(){
            debug && console.log('on connected');
        },
        connect: function (_options) {
            this.options = utils.mixin(this.options, _options);
            var host = this.options.host;
            var port = this.options.port;
            if (this.options.debug) {
                this.initLogger(this.options.debug);
            }
            if (!host) {
                console.error('something wrong with data!',_options);
                return;
            }
            debug && console.log("Connecting to " + host + ':' + port, "socket_client");
            var protocol = [
                'websocket',
                'xdr-streaming',
                'xhr-streaming',
                'iframe-eventsource',
                'iframe-htmlfile',
                'xdr-polling',
                'xhr-polling',
                'iframe-xhr-polling',
                'jsonp-polling'];

            var options = {
                debug: debug,
                devel: false
            };
            options.transports = protocol;
            var sock = new SockJS(host + ":" + port, null, options);
            var thiz = this;

            sock.onopen = function () {
                thiz.onConnected();
                if (thiz.delegate.onConnected) {
                    thiz.delegate.onConnected();
                }
            };

            sock.onmessage = function (e) {
                if (thiz.delegate.onServerResponse) {
                    thiz.delegate.onServerResponse(e);
                }
            };

            sock.onclose = function (e) {
                if (thiz.autoReconnect) {
                    debug &&  console.log('closed ' + host + ' try re-connect');
                    if (thiz.delegate.onLostConnection) {
                        thiz.delegate.onLostConnection(e);
                    }
                    thiz.reconnect();
                }else{
                    debug && console.log('closed ' + host);
                }
            };
            this._socket = sock;
        },
        emit: function (signal, dataIn, tag) {
            dataIn.tag = tag || 'notag';
            var data = JSON.stringify(dataIn);
            var res = this._socket.send(data);
            debug && console.log('send ',res);
        },

        onSignal: function (signal, callback) {
            this._socket.on('data', callback);
        }
    });
});
define('xide/factory/Clients',[
    'xide/factory',
    'xide/utils',
    'xide/types',
    'xide/client/WebSocket'
], function (factory,utils,types,WebSocket)
{
    var debug = false;
    /**
     * Low Level Web-Socket-Client factory method
     * @param ctrArgs
     * @param host
     * @param port
     * @param delegate
     */
    factory.createClient=function(ctrArgs,host,port,delegate){};
    /***
     * High-Level Web-Socket-Client factory method
     * @param store
     * @param serviceName
     * @param ctrArgs
     * @param clientClass : optional client class prototype, default : WebSocket
     * @returns {xide/client/WebSocket} | null
     */
    factory.createClientWithStore=function(store,serviceName,ctrArgs,clientClass){

        var service = utils.queryStoreEx(store,{
                name:serviceName
            },true,true),
            _ctorArgs = {};

        utils.mixin(_ctorArgs,ctrArgs);

        if(!service||service.length===0){
            console.error('create client with : failed, no such service :  ' + serviceName );
            return;
        }

        //service=service[0];

        /*
        if(!service.info && service.status==types.SERVICE_STATUS.OFFLINE){
            console.error('create client with store : failed! Service has no info for '  + serviceName);
            return;
        }
        */
        if(service.status!==types.SERVICE_STATUS.ONLINE){
            debug && console.error('create client with store : failed! Service ' +  serviceName + ' is not online ');
            return;
        }

        var host = 'http://' + service.host,
            port = service.port,
            channel='',
            _clientProto = clientClass || WebSocket;

        if(service.info){
            host=service.info.host;
            port=service.info.port;
        }

        try{
            var client = new _clientProto(_ctorArgs);
            utils.mixin(client,_ctorArgs);
            client.init({
                options:{
                    host:host,
                    port:port,
                    channel:channel,
                    debug:{
                        "all": false,
                        "protocol_connection": true,
                        "protocol_messages": true,
                        "socket_server":true,
                        "socket_client":true,
                        "socket_messages":true,
                        "main":true
                    }
                }
            });
            client.connect();
            return client;
        }catch(e){
            debug && console.error('create client with store : failed : ' + e) && logError(e);
        }
    };
    return factory;
});
/** @module xide/data/Reference **/
define('xide/data/Reference',[
    "dojo/_base/declare",
    "xide/utils"
], function (declare,utils) {

    var debug = false;
    /**
     * @class module:xide/data/Reference
     */
    var Implementation = {
        _sources: [],
        removeSource: function (source) {
        },
        updateSource: function (sources) {
        },
        onSourceUpdate: function (source) {
        },
        onSourceRemoved: function (source) {
        },
        onSourceDelete: function (source) {
        },
        onItemChanged: function (args) {
        },
        destroy: function () {
            if (!this.item.removeReference) {
                debug && console.error('item has no removeReference');
            } else {
                this.item.removeReference(this);
            }
            this.inherited(arguments);
        },
        addSource: function (item, settings) {

            this._sources.push({
                item: item,
                settings: settings
            });
            var thiz = this;
            if (settings && settings.onDelete) {
                item._store.on('delete', function (evt) {
                    if (evt.target == item) {
                        thiz._store.removeSync(thiz[thiz._store['idProperty']]);
                    }
                })
            }
        },
        updateSources: function (args) {
            for (var i = 0; i < this._sources.length; i++) {
                var link = this._sources[i];
                var item = link.item;
                var settings = link.settings;
                if (args.property && settings.properties &&
                    settings.properties[args.property]) {
                    item._store._ignoreChangeEvents = true;
                    item.set(args.property, args.value);
                    item._store._ignoreChangeEvents = false;
                    item._store.emit('update', {target: item});
                }
            }
        },
        constructor: function (properties) {
            this._sources = [];
            utils.mixin(this, properties);
        }
    };

    //package via declare
    var _class = declare('xgrid.data.Reference', null, Implementation);
    _class.Implementation = Implementation;
    return _class;
});
define('xide/encoding/_base',[
	"dojo/_base/lang"

], function(lang){

	//	These functions are 32-bit word-based.  See _sha-64 for 64-bit word ops.
	var base = {};//lang.getObject("dojox.encoding.digests", true);

	base.outputTypes={
		// summary:
		//		Enumeration for input and output encodings.
		Base64:0, Hex:1, String:2, Raw:3
	};

	//	word-based addition
	base.addWords=function(/* word */a, /* word */b){
		// summary:
		//		add a pair of words together with rollover
		var l=(a&0xFFFF)+(b&0xFFFF);
		var m=(a>>16)+(b>>16)+(l>>16);
		return (m<<16)|(l&0xFFFF);	//	word
	};

	//	word-based conversion method, for efficiency sake;
	//	most digests operate on words, and this should be faster
	//	than the encoding version (which works on bytes).
	var chrsz=8;	//	16 for Unicode
	var mask=(1<<chrsz)-1;

	base.stringToWord=function(/* string */s){
		// summary:
		//		convert a string to a word array
		var wa=[];
		for(var i=0, l=s.length*chrsz; i<l; i+=chrsz){
			wa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(i%32);
		}
		return wa;	//	word[]
	};

	base.wordToString=function(/* word[] */wa){
		// summary:
		//		convert an array of words to a string
		var s=[];
		for(var i=0, l=wa.length*32; i<l; i+=chrsz){
			s.push(String.fromCharCode((wa[i>>5]>>>(i%32))&mask));
		}
		return s.join("");	//	string
	};

	base.wordToHex=function(/* word[] */wa){
		// summary:
		//		convert an array of words to a hex tab
		var h="0123456789abcdef", s=[];
		for(var i=0, l=wa.length*4; i<l; i++){
			s.push(h.charAt((wa[i>>2]>>((i%4)*8+4))&0xF)+h.charAt((wa[i>>2]>>((i%4)*8))&0xF));
		}
		return s.join("");	//	string
	};

	base.wordToBase64=function(/* word[] */wa){
		// summary:
		//		convert an array of words to base64 encoding, should be more efficient
		//		than using dojox.encoding.base64
		var p="=", tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s=[];
		for(var i=0, l=wa.length*4; i<l; i+=3){
			var t=(((wa[i>>2]>>8*(i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*((i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*((i+2)%4))&0xFF);
			for(var j=0; j<4; j++){
				if(i*8+j*6>wa.length*32){
					s.push(p);
				} else {
					s.push(tab.charAt((t>>6*(3-j))&0x3F));
				}
			}
		}
		return s.join("");	//	string
	};

	//	convert to UTF-8
	base.stringToUtf8 = function(input){
		var output = "";
		var i = -1;
		var x, y;

		while(++i < input.length){
			x = input.charCodeAt(i);
			y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
			if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF){
				x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
				i++;
			}

			if(x <= 0x7F)
				output += String.fromCharCode(x);
			else if(x <= 0x7FF)
				output += String.fromCharCode(0xC0 | ((x >>> 6) & 0x1F), 0x80 | (x & 0x3F));
			else if(x <= 0xFFFF)
				output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F), 0x80 | ((x >>> 6) & 0x3F), 0x80 | (x & 0x3F));
			else if(x <= 0x1FFFFF)
				output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07), 0x80 | ((x >>> 12) & 0x3F), 0x80 | ((x >>> 6) & 0x3F), 0x80 | (x & 0x3F));
		}
		return output;
	};

	return base;
});

define('xide/encoding/MD5',["./_base"], function(base) {

/*	A port of Paul Johnstone's MD5 implementation
 *	http://pajhome.org.uk/crypt/md5/index.html
 *
 *	Copyright (C) Paul Johnston 1999 - 2002.
 *	Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * 	Distributed under the BSD License
 *
 *	Dojo port by Tom Trenka
 */

	var chrsz=8;

	//	MD5 rounds functions
	function R(n,c){ return (n<<c)|(n>>>(32-c)); }
	function C(q,a,b,x,s,t){ return base.addWords(R(base.addWords(base.addWords(a, q), base.addWords(x, t)), s), b); }
	function FF(a,b,c,d,x,s,t){ return C((b&c)|((~b)&d),a,b,x,s,t); }
	function GG(a,b,c,d,x,s,t){ return C((b&d)|(c&(~d)),a,b,x,s,t); }
	function HH(a,b,c,d,x,s,t){ return C(b^c^d,a,b,x,s,t); }
	function II(a,b,c,d,x,s,t){ return C(c^(b|(~d)),a,b,x,s,t); }

	//	the core MD5 rounds method
	function core(x,len){
		x[len>>5]|=0x80<<((len)%32);
		x[(((len+64)>>>9)<<4)+14]=len;
		var a= 1732584193;
		var b=-271733879;
		var c=-1732584194;
		var d= 271733878;
		for(var i=0; i<x.length; i+=16){
			var olda=a;
			var oldb=b;
			var oldc=c;
			var oldd=d;

			a=FF(a,b,c,d,x[i+ 0],7 ,-680876936);
			d=FF(d,a,b,c,x[i+ 1],12,-389564586);
			c=FF(c,d,a,b,x[i+ 2],17, 606105819);
			b=FF(b,c,d,a,x[i+ 3],22,-1044525330);
			a=FF(a,b,c,d,x[i+ 4],7 ,-176418897);
			d=FF(d,a,b,c,x[i+ 5],12, 1200080426);
			c=FF(c,d,a,b,x[i+ 6],17,-1473231341);
			b=FF(b,c,d,a,x[i+ 7],22,-45705983);
			a=FF(a,b,c,d,x[i+ 8],7 , 1770035416);
			d=FF(d,a,b,c,x[i+ 9],12,-1958414417);
			c=FF(c,d,a,b,x[i+10],17,-42063);
			b=FF(b,c,d,a,x[i+11],22,-1990404162);
			a=FF(a,b,c,d,x[i+12],7 , 1804603682);
			d=FF(d,a,b,c,x[i+13],12,-40341101);
			c=FF(c,d,a,b,x[i+14],17,-1502002290);
			b=FF(b,c,d,a,x[i+15],22, 1236535329);

			a=GG(a,b,c,d,x[i+ 1],5 ,-165796510);
			d=GG(d,a,b,c,x[i+ 6],9 ,-1069501632);
			c=GG(c,d,a,b,x[i+11],14, 643717713);
			b=GG(b,c,d,a,x[i+ 0],20,-373897302);
			a=GG(a,b,c,d,x[i+ 5],5 ,-701558691);
			d=GG(d,a,b,c,x[i+10],9 , 38016083);
			c=GG(c,d,a,b,x[i+15],14,-660478335);
			b=GG(b,c,d,a,x[i+ 4],20,-405537848);
			a=GG(a,b,c,d,x[i+ 9],5 , 568446438);
			d=GG(d,a,b,c,x[i+14],9 ,-1019803690);
			c=GG(c,d,a,b,x[i+ 3],14,-187363961);
			b=GG(b,c,d,a,x[i+ 8],20, 1163531501);
			a=GG(a,b,c,d,x[i+13],5 ,-1444681467);
			d=GG(d,a,b,c,x[i+ 2],9 ,-51403784);
			c=GG(c,d,a,b,x[i+ 7],14, 1735328473);
			b=GG(b,c,d,a,x[i+12],20,-1926607734);

			a=HH(a,b,c,d,x[i+ 5],4 ,-378558);
			d=HH(d,a,b,c,x[i+ 8],11,-2022574463);
			c=HH(c,d,a,b,x[i+11],16, 1839030562);
			b=HH(b,c,d,a,x[i+14],23,-35309556);
			a=HH(a,b,c,d,x[i+ 1],4 ,-1530992060);
			d=HH(d,a,b,c,x[i+ 4],11, 1272893353);
			c=HH(c,d,a,b,x[i+ 7],16,-155497632);
			b=HH(b,c,d,a,x[i+10],23,-1094730640);
			a=HH(a,b,c,d,x[i+13],4 , 681279174);
			d=HH(d,a,b,c,x[i+ 0],11,-358537222);
			c=HH(c,d,a,b,x[i+ 3],16,-722521979);
			b=HH(b,c,d,a,x[i+ 6],23, 76029189);
			a=HH(a,b,c,d,x[i+ 9],4 ,-640364487);
			d=HH(d,a,b,c,x[i+12],11,-421815835);
			c=HH(c,d,a,b,x[i+15],16, 530742520);
			b=HH(b,c,d,a,x[i+ 2],23,-995338651);

			a=II(a,b,c,d,x[i+ 0],6 ,-198630844);
			d=II(d,a,b,c,x[i+ 7],10, 1126891415);
			c=II(c,d,a,b,x[i+14],15,-1416354905);
			b=II(b,c,d,a,x[i+ 5],21,-57434055);
			a=II(a,b,c,d,x[i+12],6 , 1700485571);
			d=II(d,a,b,c,x[i+ 3],10,-1894986606);
			c=II(c,d,a,b,x[i+10],15,-1051523);
			b=II(b,c,d,a,x[i+ 1],21,-2054922799);
			a=II(a,b,c,d,x[i+ 8],6 , 1873313359);
			d=II(d,a,b,c,x[i+15],10,-30611744);
			c=II(c,d,a,b,x[i+ 6],15,-1560198380);
			b=II(b,c,d,a,x[i+13],21, 1309151649);
			a=II(a,b,c,d,x[i+ 4],6 ,-145523070);
			d=II(d,a,b,c,x[i+11],10,-1120210379);
			c=II(c,d,a,b,x[i+ 2],15, 718787259);
			b=II(b,c,d,a,x[i+ 9],21,-343485551);

			a=base.addWords(a, olda);
			b=base.addWords(b, oldb);
			c=base.addWords(c, oldc);
			d=base.addWords(d, oldd);
		}
		return [a,b,c,d];
	}

	function hmac(data, key){
		var wa=base.stringToWord(key);
		if(wa.length>16){
			wa=core(wa, key.length*chrsz);
		}
		var l=[], r=[];
		for(var i=0; i<16; i++){
			l[i]=wa[i]^0x36363636;
			r[i]=wa[i]^0x5c5c5c5c;
		}
		var h=core(l.concat(base.stringToWord(data)), 512+data.length*chrsz);
		return core(r.concat(h), 640);
	}

	//	public function
	base.MD5=function(/* string */data, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		computes the digest of data, and returns the result according to type outputType
		var out=outputType || base.outputTypes.Base64;
		var wa=core(base.stringToWord(data), data.length*chrsz);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return base.wordToHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return base.wordToString(wa);	//	string
			}
			default:{
				return base.wordToBase64(wa);	//	string
			}
		}
	};

	//	make this private, for later use with a generic HMAC calculator.
	base.MD5._hmac=function(/* string */data, /* string */key, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		computes the digest of data, and returns the result according to type outputType
		var out=outputType || base.outputTypes.Base64;
		var wa=hmac(data, key);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return base.wordToHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return base.wordToString(wa);	//	string
			}
			default:{
				return base.wordToBase64(wa);	//	string
			}
		}
	};

	return base.MD5;
});

define('xide/encoding/SHA1',["./_base"], function(base){

	var chrsz=8,	//	change to 16 for unicode.
		mask=(1<<chrsz)-1;

	function R(n,c){ return (n<<c)|(n>>>(32-c)); }
	function FT(t,b,c,d){
		if(t<20){ return (b&c)|((~b)&d); }
		if(t<40){ return b^c^d; }
		if(t<60){ return (b&c)|(b&d)|(c&d); }
		return b^c^d;
	}
	function KT(t){ return (t<20)?1518500249:(t<40)?1859775393:(t<60)?-1894007588:-899497514; }

	function core(x,len){
		x[len>>5]|=0x80<<(24-len%32);
		x[((len+64>>9)<<4)+15]=len;

		var w=new Array(80), a=1732584193, b=-271733879, c=-1732584194, d=271733878, e=-1009589776;
		for(var i=0; i<x.length; i+=16){
			var olda=a, oldb=b, oldc=c, oldd=d, olde=e;
			for(var j=0;j<80;j++){
				if(j<16){ w[j]=x[i+j]; }
				else { w[j]=R(w[j-3]^w[j-8]^w[j-14]^w[j-16],1); }
				var t = base.addWords(base.addWords(R(a,5),FT(j,b,c,d)),base.addWords(base.addWords(e,w[j]),KT(j)));
				e=d; d=c; c=R(b,30); b=a; a=t;
			}
			a=base.addWords(a,olda);
			b=base.addWords(b,oldb);
			c=base.addWords(c,oldc);
			d=base.addWords(d,oldd);
			e=base.addWords(e,olde);
		}
		return [a, b, c, d, e];
	}

	function hmac(data, key){
		var wa=toWord(key);
		if(wa.length>16){ wa=core(wa, key.length*chrsz); }

		var ipad=new Array(16), opad=new Array(16);
		for(var i=0;i<16;i++){
			ipad[i]=wa[i]^0x36363636;
			opad[i]=wa[i]^0x5c5c5c5c;
		}

		var hash=core(ipad.concat(toWord(data)),512+data.length*chrsz);
		return core(opad.concat(hash), 512+160);
	}

	function toWord(s){
		var wa=[];
		for(var i=0, l=s.length*chrsz; i<l; i+=chrsz){
			wa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(32-chrsz-i%32);
		}
		return wa;	//	word[]
	}

	function toHex(wa){
		//	slightly different than the common one.
		var h="0123456789abcdef", s=[];
		for(var i=0, l=wa.length*4; i<l; i++){
			s.push(h.charAt((wa[i>>2]>>((3-i%4)*8+4))&0xF), h.charAt((wa[i>>2]>>((3-i%4)*8))&0xF));
		}
		return s.join("");	//	string
	}

	function _toString(wa){
		var s=[];
		for(var i=0, l=wa.length*32; i<l; i+=chrsz){
			s.push(String.fromCharCode((wa[i>>5]>>>(32-chrsz-i%32))&mask));
		}
		return s.join("");	//	string
	}

	function toBase64(/* word[] */wa){
		// summary:
		//		convert an array of words to base64 encoding, should be more efficient
		//		than using dojox.encoding.base64
		var p="=", tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s=[];
		for(var i=0, l=wa.length*4; i<l; i+=3){
			var t=(((wa[i>>2]>>8*(3-i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*(3-(i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*(3-(i+2)%4))&0xFF);
			for(var j=0; j<4; j++){
				if(i*8+j*6>wa.length*32){
					s.push(p);
				} else {
					s.push(tab.charAt((t>>6*(3-j))&0x3F));
				}
			}
		}
		return s.join("");	//	string
	};

	//	public function
	base.SHA1=function(/* String */data, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		Computes the SHA1 digest of the data, and returns the result according to output type.
		var out=outputType||base.outputTypes.Base64;
		var wa=core(toWord(data), data.length*chrsz);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return toHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return _toString(wa);	//	string
			}
			default:{
				return toBase64(wa);	//	string
			}
		}
	};

	//	make this private, for later use with a generic HMAC calculator.
	base.SHA1._hmac=function(/* string */data, /* string */key, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		computes the digest of data, and returns the result according to type outputType
		var out=outputType || base.outputTypes.Base64;
		var wa=hmac(data, key);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return toHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return _toString(wa);	//	string
			}
			default:{
				return toBase64(wa);	//	string
			}
		}
	};

	return base.SHA1;
});


define('xide/debug',[
    'xdojo/declare',
    'dojo/has',
    'xdojo/has!debug?xide/serverDebug'
],function(declare,has,serverDebug){
	var Module = declare("xide.debug", null,{});

    if(has('debug')) {

        function displayServerDebugData(data){
            serverDebug && serverDebug.logError(data);
        }

        window.xappServerDebug = displayServerDebugData;

        var callback = function (stackframes) {
            var stringifiedStack = stackframes.map(function (sf) {
                return sf.toString();
            }).join('\n');
            console.log(stringifiedStack);
        };

        var errback = function (err) {
            console.log(err.message);
        };


        window.onerror = function (msg, file, line, col, error) {
            StackTrace.fromError(error).then(callback)['catch'](errback);
        };
        if (!window.logError) {
            window.logError = function (e, message) {
                console.error((message || '') + ' :: ' + e.message + ' stack:\n', e);
                if (typeof 'StackTracke' === 'undefined') {
                    var stack = e.stack;
                    stack = stack.split('\n').map(function (line) {
                        return line.trim();
                    });
                    stack.splice(stack[0] == 'Error' ? 2 : 1);
                    console.log(stack.join('\n'));
                } else {
                    StackTrace.fromError(e).then(callback)['catch'](errback);

                }
            }
        } else {
            console.log('logError already created');
        }
    }else{
        window.onerror = function (msg, file, line, col, error) {
            console.error(msg, error);
        };
        window.logError = function (e, message) {
            console.error((message || '') + ' :: ' + e.message + ' stack:\n', e);
        }
    }
    return Module;
});
define('xide/min',[
    'xide/utils',
    'xide/utils/StringUtils',
    'xide/utils/HTMLUtils',
    'xide/utils/WidgetUtils',
    'xide/types',
    'xide/types/Types',
    'xide/factory',
    'xide/factory/Objects',
    'xide/factory/Events',
    'xide/lodash'
], function () {
});
define('xide/manager/BeanManager',[
    'dcl/dcl',
    "dojo/_base/lang",
    "xide/utils",
    'xide/encoding/MD5',
    'xide/registry',
    'xide/data/TreeMemory'
], function (dcl,lang, utils, MD5, registry, TreeMemory) {

    return dcl(null,{
        declaredClass:'xide.manager.BeanManager',
        beanNamespace: 'beanNS',
        beanName: 'beanName',
        /**
         *
         * @param title
         * @param scope
         * @param parentId
         * @param path
         * @param isDir
         * @param beanType
         * @returns {{name: *, isDir: *, parentId: *, path: *, beanType: *, scope: *}}
         */
        createItemStruct: function (title, scope, parentId, path, isDir, beanType) {
            return {
                name: title,
                isDir: isDir,
                parentId: parentId,
                path: path,
                beanType: beanType,
                scope: scope
            };
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Standard impl of the bean interface
        //
        /////////////////////////////////////////////////////////////////////////////////////
        getMetaValue: function (item, title) {
            var path = this.itemMetaPath || 'user';
            return utils.getCIInputValueByName(utils.getAt(item, path), title);
        },
        /***********************************************************************/
        /*
         * @Obselete
         */
        setCurrentItem: function (item) {},
        getItem: function () {},
        onItemSelected: function (evt) {},
        onItemAdded: function (res) {},
        onItemRemoved: function (res) {},
        reload: function (){},


        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UX related utils
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /***
         * Determine a parent container for new views. Currently
         * the 'Application' holds a 'mainView' instance which
         * prepares us a tab container.
         *
         * @returns {*}
         */
        getViewTarget: function () {
            var mainView = this.ctx.getApplication().mainView;
            return mainView.getNewAlternateTarget();
        },
        getRightTopTarget: function (clear, open, style, className) {
            var mainView = this.ctx.getApplication().mainView;
            return mainView.getRightTopTarget(clear, open, style, className);
        },
        getLayoutRightMain: function (clear, open) {
            var mainView = this.ctx.getApplication().mainView;
            return mainView.getLayoutRightMain(clear, open);
        },
        getRightBottomTarget: function (clear, open) {
            var mainView = this.ctx.getApplication().mainView;
            return mainView.getRightBottomTarget(clear, open);
        },
        /***
         * getViewId generates a unique id upon a driver's scope and the drivers path.
         * @param item
         * @returns {string}
         */
        getViewId: function (item, suffix) {
            return this.beanNamespace + MD5(utils.toString(item.scope) + utils.toString(item.path), 1) + (suffix != null ? suffix : '');
        },
        /**
         *
         * @param item
         */
        getView: function (item, suffix) {
            var id = this.getViewId(item, suffix);
            var view = registry.byId(id);
            return view;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Data related
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /***
         * @returns {dojo.data.ItemFileWriteStore}
         */
        getStore: function () {
            return this.store;
        },
        /***
         * Common function that this instance is in a valid state
         * @returns {boolean}
         */
        isValid: function () {
            return this.store != null;
        },
        /***
         * Inits the store with the driver data
         * @param data
         * @returns {xide.data.TreeMemory}
         */
        initStore: function (data) {
            this.store = new TreeMemory({
                data: data.items,
                idProperty: 'path'
            });
            this.onStoreReady(this.store);
            return this.store;
        },
        /**
         * Stub
         */
        onStoreReady: function () {},
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Server methods
        //
        /////////////////////////////////////////////////////////////////////////////////////
        createGroup: function (scope, name, readyCB) {
            return this.callMethodEx(null, 'createGroup', [scope, name], readyCB, true);
        },
        removeGroup: function (scope, path, name, readyCB) {
            return this.callMethodEx(null, 'removeGroup', [scope, path, name], readyCB, true);
        },
        removeItem: function (scope, path, name, readyCB) {
            return this.callMethodEx(null, 'removeItem', [scope, path, name], readyCB, true);
        },
        /**
         * Shared for consumer
         * @param ci
         * @param newValue
         * @param oldValue
         * @param storeRef
         */
        updateCI: function (ci, newValue, oldValue, storeRef) {

            if (ci && storeRef) {

                this.updateItemMetaData(
                    utils.toString(storeRef.scope), //the scope of the driver
                    utils.toString(storeRef.path),  //the relative path of the driver
                    this.itemMetaStorePath || '/inputs',  //the path of the CIS in the meta db
                    {
                        id: utils.toString(ci.id)
                    },
                    {
                        value: newValue
                    }
                );
            }
        },
        /**
         * updateItemMetaData updates a CI in the drivers meta data store
         * @param scope {string}
         * @param driverMetaPath {string}
         * @param dataPath {string} : /inputs
         * @param query
         * @param value
         * @param readyCB
         * @param errorCB
         * @returns {*}
         */
        updateItemMetaData: function (scope, driverMetaPath, dataPath, query, value, readyCB, errorCB) {
            return this.callMethodEx(null, 'updateItemMetaData', [scope, driverMetaPath, dataPath, query, value], readyCB, false);
        },
        mergeNewModule: function (source) {
            for (var i in source) {
                var o = source[i];
                if (o && _.isFunction(o)) {
                    this[i] = o;
                }
            }
        },
        _onReloaded:function(newModule){
            this.mergeNewModule(newModule.prototype);
            var _class = this.declaredClass;
            var _module = lang.getObject(utils.replaceAll('/', '.', _class)) || lang.getObject(_class);
            if(_module){
                if(_module.prototype && _module.prototype.solve){
                    this.mergeNewModule(_module.prototype);
                }
            }
        }
    });
});
/** module:xide/manager/Context **/
define('xide/manager/ContextBase',[
    'dcl/dcl',
    'xide/factory',
    'xide/types',
    'xide/utils',
    'xide/mixins/EventedMixin'
], function (dcl,factory, types,utils,EventedMixin) {

    var _debug = false;
    /**
     * @class module:xide/manager/ContextBase
     */
    var Module = dcl(EventedMixin.dcl,{
        declaredClass:"xide.manager.ContextBase",
        language: "en",
        managers: [],
        mixins: null,
        /***
         * createManager creates and instances and tracks it in a local array.
         * @param clz : class name or prototype
         * @param config {object|null}: explicit config, otherwise its using local config
         * @param ctrArgs {object|null}: extra constructor arguments
         * @returns {module:xide/manager/ManagerBase} : instance of the manager
         */
        createManager: function (clz, config, ctrArgs) {

            try {
                if (!this.managers) {
                    this.managers = [];
                }
                //1. prepare constructor arguments
                var ctrArgsFinal = {
                    ctx: this,
                    config: config || this.config
                };
                utils.mixin(ctrArgsFinal, ctrArgs);


                if (_.isString(clz) && this.namespace) {
                    var _clz = null;
                    if (clz.indexOf('.') == -1) {
                        _clz = this.namespace + clz;
                    } else {
                        _clz = '' + clz;
                    }
                    //test this really exists, if not fallback to default namespace
                    if (!dojo.getObject(_clz) || !dcl.getObject(_clz)) {
                        _debug && console.log('creating manager instance : ' + _clz + ' doesnt exists!' + ' Using default! ');
                        clz = this.defaultNamespace + clz;
                    } else {
                        clz = _clz;
                    }
                    _debug && console.log('creating manager instance : ' + clz);
                } else if (_.isObject(clz)) {
                    _debug &&  console.log('creating manager instance : ' + (clz.declaredClass || clz.prototype.declaredClass));
                }

                //2. create instance
                var mgr = factory.createInstance(clz, ctrArgsFinal);
                if (!mgr) {
                    _debug && console.error('creating manager instance failed : ' + clz);
                    return;
                }

                //3. track instance
                this.managers.push(mgr);

                //4. tell everybody
                factory.publish(types.EVENTS.ON_CREATED_MANAGER, {
                    instance: mgr,
                    className: clz,
                    ctx: this,
                    config: config || this.config
                });
                return mgr;
            } catch (e) {
                console.error('error creating manager ' + e, arguments);
            }
        },
        constructManagers: function () {},
        initManagers: function () {},
        /***
         * Monkey patch prototypes
         * @param mixins
         */
        doMixins: function (mixins) {

            this.mixins = mixins || this.mixins;
            for (var i = 0; i < mixins.length; i++) {
                var mixin = mixins[i];
                var obj = dojo.getObject(mixin.declaredClass) || dcl.getObject(mixin.declaredClass);
                if (mixin.declaredClass === this.declaredClass) {
                    obj = this;
                }
                if (obj) {
                    utils.mixin(obj.prototype, mixin.mixin);
                } else {
                    _debug && console.error('couldnt apply mixin to : ' + mixin.declaredClass);
                }
            }
        }
    });
    dcl.chainAfter(Module,'constructManagers');
    dcl.chainAfter(Module,'initManagers');
    return Module;
});

/** module:xide/manager/Context **/
define('xide/manager/Context',[
    'dcl/dcl',
    'dojo/_base/lang',
    'dojo/_base/json',
    'dojo/Deferred',
    'dojo/has',
    'xide/manager/ContextBase',
    'xide/factory',
    'xide/types',
    'xide/utils',
    'require',
    "dojo/promise/all",
    'xdojo/has!host-browser?xide/manager/Context_UI'

], function (dcl, lang, json, Deferred, has, ContextBase, factory,
             types, utils, _require, all, Context_UI) {

    !has('host-browser') && has.add('xlog', function () {
        return true;
    }, true);

    var isServer = has('host-node'),
        isBrowser = has('host-browser'),
        bases = isBrowser ? [ContextBase, Context_UI] : [ContextBase],
        debugFileChanges = false,
        debugModuleReload  = true;

    /**
     * @class module:xide/manager/Context
     * @extends module:xide/manager/ContextBase
     */
    var Module = dcl(bases, {
        getMount:function(mount){

            var resourceManager = this.getResourceManager(),
                vfsConfig =  resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;

            if(vfsConfig && vfsConfig[mount]) {
                return vfsConfig[mount];
            }
            return null;
        },
        toVFSShort:function(path,mount){

            var resourceManager = this.getResourceManager(),
                vfsConfig =  resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;

            if(vfsConfig && vfsConfig[mount]){
                var mountPath = vfsConfig[mount];
                mountPath = utils.replaceAll('//','/',mountPath);
                mountPath = mountPath.replace(/\/+$/, "");
                if(path.indexOf(mountPath) !==-1){
                    var _start = mountPath;
                    _start = _start.replace(/\/+$/, "");
                    var libPath = path.substr(path.indexOf(_start) + (_start.length + 1 ),path.length);
                    return libPath;
                }
            }
            return null;
        },
        findVFSMount:function(path){

            var resourceManager = this.getResourceManager(),
                vfsConfig =  resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;

            if(vfsConfig){
                for (var mount in vfsConfig) {
                    var mountPath = vfsConfig[mount];
                    mountPath = utils.replaceAll('//','/',mountPath);
                    mountPath = mountPath.replace(/\/+$/, "");
                    if(path.indexOf(mountPath) !==-1){
                        return mount;
                    }
                }

            }
            return null;
        },
        declaredClass: "xide.manager.Context",
        application: null,
        contextManager: null,
        fileManager: null,
        resourceManager: null,
        notificationManager: null,
        serviceObject: null,
        pluginManager: null,
        windowManager: null,
        logManager: null,
        mountManager: null,
        config: null,
        managers: null,
        namespace: 'xide.manager.',
        defaultNamespace: 'xide.manager.',
        vfsMounts: null,
        xideServiceClient: null,
        fileUpdateTimes: {},
        /***********************************************************************/
        /*
         * Global event handlers
         */
        onXIDEMessage: function (data, publish) {

            if(!data || !data.event){
                return;
            }
            var thiz = this;
            if (data.event === types.EVENTS.ON_FILE_CHANGED) {

                debugFileChanges && console.log("on file changed " ,data);

                //inotify plus
                if (data.data && data.data.mask && data.data.mask.indexOf('delete') !== -1) {
                    thiz.publish(types.EVENTS.ON_FILE_DELETED, data);
                    return;
                }

                if (data.data && data.data.type == 'delete') {
                    thiz.publish(types.EVENTS.ON_FILE_DELETED, data);
                    return;
                }
                var _path = data.data.path;
                var timeNow = new Date().getTime();
                if (thiz.fileUpdateTimes[_path]) {
                    var last = thiz.fileUpdateTimes[_path];
                    var diff = timeNow - last;
                    if (diff < 1000) {
                        thiz.fileUpdateTimes[_path] = timeNow;
                        return;
                    }
                }


                publish !== false && thiz.publish(data.event, data);
                thiz.fileUpdateTimes[_path] = timeNow;
                //path is absolute and might look like: /PMaster/projects/xbox-app/client/src/lib/xfile/Views.js
                //fix windows path
                var path = utils.replaceAll('\\', '/', data.data.path);
                path = utils.replaceAll('//', '/', data.data.path);
                path = path.replace(/\\/g, "/");
                if (path == null || path.indexOf == null) {
                    return;
                }
                if (path.match(/\.css$/)) {
                    thiz.onCSSChanged({
                        path: path
                    });
                }

                /**
                 * Try generic
                 */
                if (path.match(/\.js$/)) {

                    var modulePath = data.data.modulePath;
                    if (modulePath) {
                        modulePath = modulePath.replace('.js', '');
                        var _re = _require;//hide from gcc
                        //try pre-amd module
                        var module = null;
                        try {
                            module = _re(modulePath);
                        } catch (e) {
                        }


                        //special: driver
                        var _start = 'data/system/drivers';
                        if (path.indexOf(_start) != -1) {
                            var libPath = path.substr(path.indexOf(_start) + (_start.length + 1 ), path.length);
                            libPath = libPath.replace('.js', '');
                            modulePath = 'system_drivers/' + libPath;
                        }

                        _start = 'user/drivers';
                        if (path.indexOf(_start) != -1) {
                            var libPath = path.substr(path.indexOf(_start) + (_start.length + 1 ), path.length);
                            libPath = libPath.replace('.js', '');
                            modulePath = 'user_drivers/' + libPath;
                        }


                        var resourceManager = this.getResourceManager(),
                            vfsConfig =  resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;

                        if(vfsConfig && vfsConfig['user_drivers']){

                            if(path.indexOf(vfsConfig['user_drivers']) !==-1){
                                var _start = vfsConfig['user_drivers'];
                                _start = _start.replace(/\/+$/, "");
                                var libPath = path.substr(path.indexOf(_start) + (_start.length + 1 ),path.length);
                                libPath = libPath.replace('.js', '');
                                modulePath = 'user_drivers/' + libPath;
                            }
                        }




                        modulePath = utils.replaceAll('.', '/', modulePath);
                        setTimeout(function () {
                            if(!isServer) {
                                console.log('reloading module '+modulePath);
                                thiz._reloadModule(modulePath, true);
                            }
                        }, 400);
                    }
                }
            }
        },
        onNodeServiceStoreReady: function (evt) {

            if (this.xideServiceClient) {
                this.xideServiceClient.destroy();
            }

            var thiz = this,
                store = evt.store;

            if(has('debug')) {
                this.deviceServerClient = factory.createClientWithStore(store, 'XIDE Server', {
                    delegate: {
                        onServerResponse: function (e) {
                            thiz.onXIDEMessage(json.fromJson(e.data));
                        }
                    }
                });
            }
        },
        mergeFunctions: function (target, source) {
            for (var i in source) {
                var o = source[i];
                if (_.isFunction(source[i])) {
                    if (source[i] && target) {
                        target[i] = source[i];//swap
                    }
                }
            }
        },
        /***********************************************************************/
        /*
         * File - Change - Handlers
         */
        /**
         * Special case when module has been reloaded : update all functions in our singleton
         * managers!
         * @param evt
         */
        reloadModules: function (modules, patch) {

            var head = new Deferred(),
                pluginPromises = [],
                newModules = [],
                thiz = this;

            _require({
                cacheBust: 'time=' + new Date().getTime()
            });

            _.each(modules, function (module) {

                var oldModule = null,
                    dfd = new Deferred();
                if (patch !== false) {
                    oldModule = _require(module);
                }
                _require.undef(module);
                _require([module], function (moduleLoaded) {
                    oldModule && thiz.mergeFunctions(oldModule.prototype, moduleLoaded.prototype);
                    newModules.push(moduleLoaded);
                    dfd.resolve();
                });
                pluginPromises.push(dfd);
            });

            all(pluginPromises).then(function () {
                head.resolve(newModules);
                _require({
                    cacheBust: null
                });
            });
            return head;
        },
        _reloadModule: function (_module, reload) {

            var _errorHandle = null;

            function handleError(error){

                debugModuleReload && console.log(error.src, error.id);
                debugModuleReload && console.error('require error ' + _module,error);
                _errorHandle.remove();
            }



            var obj = lang.getObject(utils.replaceAll('/', '.', _module)) || lang.getObject(_module);
            if (obj && obj.prototype && obj.prototype.reloadModule) {
                obj.prototype.reloadModule();
                return;
            }

            _errorHandle = _require.on("error", handleError);
            
            var oldModule = lang.getObject(utils.replaceAll('/', '.', _module)) || lang.getObject(_module);
            if (!oldModule) {
                oldModule = typeof _module !== 'undefined' ? oldModule : null;
                if (!oldModule && typeof window !== 'undefined') {
                    //try global namespace
                    oldModule = utils.getAt(window, utils.replaceAll('/', '.', _module), null);

                    if (oldModule) {
                        obj = oldModule;
                    } else {
                        try {
                            oldModule = _require(utils.replaceAll('.', '/', _module));
                        } catch (e) {

                        }
                    }
                }
            }
            if (oldModule) {
                obj = oldModule;
            }

            //remove from dom
            if (isBrowser) {
                var scripts = document.getElementsByTagName('script');
                _.each(scripts, function (script) {
                    if (script && script.src && script.src.indexOf(_module) !== -1) {
                        script.parentElement.removeChild(script);
                    }
                })
            }

            _require.undef(_module);

            var thiz = this;

            if (reload) {

                setTimeout(function () {
                    _require({
                        cacheBust: 'time=' + new Date().getTime(),
                        waitSeconds: 5
                    });

                    try {
                        _require([_module], function (moduleLoaded) {

                            _require({
                                cacheBust: null
                            });

                            if (_.isString(moduleLoaded)) {
                                console.error('module reloaded failed : ' + moduleLoaded + ' for module : ' + _module);
                                return;
                            }

                            moduleLoaded.modulePath = _module;

                            if (obj) {
                                thiz.mergeFunctions(obj.prototype, moduleLoaded.prototype);
                                if (obj.prototype && obj.prototype._onReloaded) {
                                    obj.prototype._onReloaded(moduleLoaded);
                                }
                            }

                            thiz.publish(types.EVENTS.ON_MODULE_RELOADED, {
                                module: _module,
                                newModule: moduleLoaded
                            });

                            if (moduleLoaded.prototype && moduleLoaded.prototype.declaredClass) {
                                thiz.publish(types.EVENTS.ON_MODULE_UPDATED, {
                                    moduleClass: moduleLoaded.prototype.declaredClass,
                                    moduleProto: moduleLoaded.prototype
                                });
                            }

                        });
                    } catch (e) {
                        console.error('error reloading module', e);
                        logError(e, 'error reloading module');
                    }

                }, 100);
            }
        },


        onCSSChanged: function (evt) {
            if(isBrowser) {
                console.log('onCSSChanged',evt);;
                var path = evt.path;
                path = utils.replaceAll('//', '/', path);
                path = path.replace('/PMaster/', '');
                var reloadFn = window['xappOnStyleSheetChanged'];
                if (reloadFn) {
                    reloadFn(path);
                }
            }
        },
        onDidChangeFileContent: function (evt) {

            if (evt['didProcess']) {
                return;
            }
            evt['didProcess'] = true;

            if (!this.vfsMounts) {
                return;
            }
            if (!evt.path) {
                return;
            }
            var path = evt.path;
            if (path.indexOf('.css') != -1) {
                if(isBrowser) {
                    this.onCSSChanged(evt);
                }
                return;
            }

            if (path.indexOf('resources') != -1 ||
                path.indexOf('meta') != -1 ||
                path.indexOf('.js') == -1) {
                return;
            }

            var mount = evt.mount.replace('/', ''),
                module = null;

            if (!this.vfsMounts[mount]) {
                return;
            }

            module = '' + evt.path;
            module = module.replace('./', '');
            module = module.replace('/', '.');
            module = module.replace('.js', '');
            module = utils.replaceAll('.', '/', module);
            var thiz = this;
            setTimeout(function () {
                try {
                    thiz._reloadModule(module, true);
                }catch(e){
                    console.error('error reloading module',e);
                }
            }, 100);

        },
        /***********************************************************************/
        /*
         * get/set
         */
        getBlockManager: function () {
            return this.blockManager;
        },
        getPluginManager: function () {
            return this.pluginManager;
        },
        getService: function () {
            return this.serviceObject;
        },
        getFileManager: function () {
            return this.fileManager;
        },
        getResourceManager: function () {
            return this.resourceManager;
        },
        getMountManager: function () {
            return this.mountManager;
        },
        getContextManager: function () {
            return this.contextManager;
        },
        getLogManager: function () {
            return this.logManager;
        },
        getApplication: function () {
            return this.application;
        },
        /***********************************************************************/
        /*
         * STD - API
         */
        constructor: function (config) {
            this.managers = [];
            this.config = config;
            this.language = 'en';
            this.subscribe(types.EVENTS.ON_CHANGED_CONTENT, this.onDidChangeFileContent);
            if (has('xnode')) {
                //this.subscribe(types.EVENTS.ON_MODULE_RELOADED, this.onModuleReloaded);
                this.subscribe(types.EVENTS.ON_NODE_SERVICE_STORE_READY, this.onNodeServiceStoreReady);
            }
        },
        prepare: function () {
            if (this.config) {
                this.initWithConfig(this.config);
            }
        },
        /**
         * The config is put into the index.php as JSON. The server has also some data
         * which gets mixed into the manager instances.
         * @param config
         */
        initWithConfig:function(config){
            if(config && config.mixins){
                this.doMixins(config.mixins);
            }
        },
        isEditor:function(){
            return this.args && this.args.file;
        }
    });

    dcl.chainAfter(Module, 'constructManagers');
    dcl.chainAfter(Module, 'initManagers');

    return Module;
});
/** @module xide/manager/PluginManager */
define('xide/manager/PluginManager',[
    'dcl/dcl',
    'dojo/has',
    'xide/manager/ManagerBase',
    'xide/utils',
    'xide/types',
    'xide/factory',
    "dojo/Deferred",
    "dojo/promise/all"
], function (dcl,has,ManagerBase,utils,types,factory,Deferred,all)
{
    var _debug = false;
    /**
     * Plugin manager which provides loading of additional modules at any time after the main layer(s)
     * have been loaded.
     *
     * @class module:xide/manager/PluginManager
     * @extends module:xide/manager/ManagerBase
     */
    return dcl(ManagerBase,{
        declaredClass:"xide.manager.PluginManager",
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Variables
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * When load() receives a module name without a slash, use this prefix
         *
         * @TODO: this must be changed into a map to configure this per 'run-time configuration'
         * @member string _defaultPackageLocationPrefix
         */
        _defaultPackageLocationPrefix:'../../',
        /**
         * When load() receives a module name without a slash, use this prefix
         * @member string _defaultPackageLocationSuffix
         */
        _defaultPackageLocationSuffix:'/component',
        /**
         * Whe loading a component, use this flags by default
         * @member module:xide.types.COMPONENT_FLAGS
         */
        _defaultComponentFlags:{
            /**
             * call load() when loaded
             * @enum module:xide.types.COMPONENT_FLAGS:LOAD
             */
            LOAD:1,
            /**
             * call run() when loaded
             * @enum module:xide.types.COMPONENT_FLAGS:RUN
             */
            RUN:2  //call run() when loaded
        },
        /**
         * Whe loading a component, mixin these properties/members
         * @member {Object}
         */
        defaultComponentMixin:function(flags){
            return {
                owner:this,
                ctx:this.ctx,
                flags:flags
            };
        },
        /**
         * List of modules to add to a components base classes. That will be used to add logging and others
         * @member {String[]}
         */
        componentBaseClasses:null,
        /**
         * Our context object
         * @member module: xide/manager/Context
         */
        ctx:null,
        /**
         * JSON data of plugin data
         * @member {Array}
         */
        pluginResources:null,
        /**
         * Array of plugin instances
         * @member {object[]}
         */
        pluginInstances:null,
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Components
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Called when component::load() is finish
         * @param component
         * @param flags
         * @param deferred
         * @private
         */
        _componentReady:function(component,flags,deferred){
            if (flags.RUN) {

                try {
                    component.run(this.ctx);//fire only, don't bother when it crashes
                }catch(e){
                    _debug && console.error('component: ' + component.getLabel() + ' crashed in run ' + e);
                }
            }
            return deferred.resolve(component);
        },
        /**
         * Called when a component has been loaded
         * @param component
         * @param flags
         * @param componentArguments
         * @param deferred
         * @private
         */
        _componentLoaded:function(component,flags,componentArguments,deferred){
            try {

                //add constructor arguments
                utils.mixin(componentArguments,this.defaultComponentMixin(flags));
                var componentInstance = factory.createInstance(component, componentArguments, this.componentBaseClasses);

                var _afterLoaded = function(componentInstance,flags,deferred){
                    this._componentReady(componentInstance,flags,deferred);
                }.bind(this);


                if (flags.LOAD) {
                    //call load, its async
                    componentInstance.load().then(function(){
                        _afterLoaded(componentInstance,flags,deferred);
                    });
                }else{
                    _afterLoaded(componentInstance,flags,deferred);
                }
            }catch(e){
                _debug && console.error('error in component creation!' + e);
                deferred.reject(arguments);
                logError(e);
            }

        },
        /**
         * Load a component
         *
         * @memberOf module:xide/manager/PluginManager#
         *
         * @param path {string} A require-js module path
         * @param {int} flags being used whilst loading
         * @param {object} componentArguments
         * @param packageLocation {string=}
         * @param packagePath {string=}
         */
        loadComponent:function(path,flags,componentArguments,packageLocation,packagePath){


            //defaults, sanitizing
            componentArguments = componentArguments ==='true' ? {} : componentArguments;

            path = path.indexOf('/') == -1 ? ( this._defaultPackageLocationPrefix + path + this._defaultPackageLocationSuffix ) : path;

            flags = flags!=null ? flags : this._defaultComponentFlags;

            var deferred = new Deferred(),
                self = this;

            var _component = utils.getObject(path);
            if(_component){
                //not loaded yet?
                if(_.isFunction(_component.then)){
                    _component.then(function(module){
                        self._componentLoaded(module,flags,componentArguments,deferred);
                    },function(err){
                        //shouldn't happen
                        console.error('error in loading component at path ' + path,err);
                    });
                }else{
                    //already loaded
                    this._componentLoaded(_component,flags,componentArguments,deferred);
                }
            }else{
                console.error('cant get object at ' + path);
            }

            _debug &&  console.log('load component ' + path);

            return deferred;
        },
        /**
         * Each component has a resource file within its directory with this pattern : resources-config.json.
         * When component is being loaded, we do load also client resources for that component (css,js,...)
         * @param component {xide.model.Component}
         * @param config {string}
         */
        loadComponentResources:function(component,path){},
        /**
         * @TODO
         *
         * @param component
         */
        reloadComponent:function(component){},
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Plugins: to be removed soon.
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * @deprecated
         * @param pluginResources
         */
        loadPlugins:function(pluginResources)
        {
            if(!has('plugins')) {
                return;
            }
            var dfd = new Deferred(),
                pluginPromises = [],
                thiz = this;

            this.pluginResources = pluginResources;
            this.pluginInstances = [];

            if(this.pluginResources){
                for(var i=0 ; i < this.pluginResources.length; i++){
                    var plug = this.pluginResources[i];
                    if(plug.type && plug.type=="JS-PLUGIN" && plug.path){
                        pluginPromises.push(this.loadComponent(plug.path,null,plug).then(function(component){
                            component.pluginResources = plug;
                            thiz.pluginInstances.push(component);
                        }));
                    }else{
                        _debug &&  console.warn('something wrong with plugin data');
                    }
                }
            }
            all(pluginPromises).then(function(){
                dfd.resolve(pluginPromises);
                _debug && console.log('plugins ready',thiz.pluginInstances);
                thiz.publish(types.EVENTS.ALL_PLUGINS_READY,{
                    instances:thiz.pluginInstances,
                    resources:pluginResources
                });
            });
            return dfd;
        }
    });
});
define('xide/rpc/AdapterRegistry',["dojo/_base/kernel", "dojo/_base/lang"], function (dojo, lang) {
    var AdapterRegistry = dojo.AdapterRegistry = function (/*Boolean?*/ returnWrappers) {
        // summary:
        //		A registry to make contextual calling/searching easier.
        // description:
        //		Objects of this class keep list of arrays in the form [name, check,
        //		wrap, directReturn] that are used to determine what the contextual
        //		result of a set of checked arguments is. All check/wrap functions
        //		in this registry should be of the same arity.
        // example:
        //	|	// create a new registry
        //	|	require(["dojo/AdapterRegistry"],
        //	|	function(AdapterRegistry){
        //	|		var reg = new AdapterRegistry();
        //	|		reg.register("handleString",
        //	|			function(str){
        //	|				return typeof val == "string"
        //	|			},
        //	|			function(str){
        //	|				// do something with the string here
        //	|			}
        //	|		);
        //	|		reg.register("handleArr",
        //	|			dojo.isArray,
        //	|			function(arr){
        //	|				// do something with the array here
        //	|			}
        //	|		);
        //	|
        //	|		// now we can pass reg.match() *either* an array or a string and
        //	|		// the value we pass will get handled by the right function
        //	|		reg.match("someValue"); // will call the first function
        //	|		reg.match(["someValue"]); // will call the second
        //	|	});

        this.pairs = [];
        this.returnWrappers = returnWrappers || false; // Boolean
    };

    lang.extend(AdapterRegistry, {
        register: function (/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override) {
            // summary:
            //		register a check function to determine if the wrap function or
            //		object gets selected
            // name:
            //		a way to identify this matcher.
            // check:
            //		a function that arguments are passed to from the adapter's
            //		match() function.  The check function should return true if the
            //		given arguments are appropriate for the wrap function.
            // directReturn:
            //		If directReturn is true, the value passed in for wrap will be
            //		returned instead of being called. Alternately, the
            //		AdapterRegistry can be set globally to "return not call" using
            //		the returnWrappers property. Either way, this behavior allows
            //		the registry to act as a "search" function instead of a
            //		function interception library.
            // override:
            //		If override is given and true, the check function will be given
            //		highest priority. Otherwise, it will be the lowest priority
            //		adapter.
            this.pairs[((override) ? "unshift" : "push")]([name, check, wrap, directReturn]);
        },

        match: function (/* ... */) {
            // summary:
            //		Find an adapter for the given arguments. If no suitable adapter
            //		is found, throws an exception. match() accepts any number of
            //		arguments, all of which are passed to all matching functions
            //		from the registered pairs.
            for (var i = 0; i < this.pairs.length; i++) {
                var pair = this.pairs[i];
                if (pair[1].apply(this, arguments)) {
                    if ((pair[3]) || (this.returnWrappers)) {
                        return pair[2];
                    } else {
                        return pair[2].apply(this, arguments);
                    }
                }
            }
            throw new Error("No match found");
        },

        unregister: function (name) {
            // summary:
            //		Remove a named adapter from the registry
            // name: String
            //		The name of the adapter.
            // returns: Boolean
            //		Returns true if operation is successful.
            //		Returns false if operation fails.

            // FIXME: this is kind of a dumb way to handle this. On a large
            // registry this will be slow-ish and we can use the name as a lookup
            // should we choose to trade memory for speed.
            for (var i = 0; i < this.pairs.length; i++) {
                var pair = this.pairs[i];
                if (pair[0] == name) {
                    this.pairs.splice(i, 1);
                    return true;
                }
            }
            return false;
        }
    });

    return AdapterRegistry;
});

define('dojo/_base/url',["./kernel"], function(dojo){
	// module:
	//		dojo/url

	var
		ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"),
		ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$"),
		_Url = function(){
			var n = null,
				_a = arguments,
				uri = [_a[0]];
			// resolve uri components relative to each other
			for(var i = 1; i<_a.length; i++){
				if(!_a[i]){ continue; }

				// Safari doesn't support this.constructor so we have to be explicit
				// FIXME: Tracked (and fixed) in Webkit bug 3537.
				//		http://bugs.webkit.org/show_bug.cgi?id=3537
				var relobj = new _Url(_a[i]+""),
					uriobj = new _Url(uri[0]+"");

				if(
					relobj.path == "" &&
					!relobj.scheme &&
					!relobj.authority &&
					!relobj.query
				){
					if(relobj.fragment != n){
						uriobj.fragment = relobj.fragment;
					}
					relobj = uriobj;
				}else if(!relobj.scheme){
					relobj.scheme = uriobj.scheme;

					if(!relobj.authority){
						relobj.authority = uriobj.authority;

						if(relobj.path.charAt(0) != "/"){
							var path = uriobj.path.substring(0,
								uriobj.path.lastIndexOf("/") + 1) + relobj.path;

							var segs = path.split("/");
							for(var j = 0; j < segs.length; j++){
								if(segs[j] == "."){
									// flatten "./" references
									if(j == segs.length - 1){
										segs[j] = "";
									}else{
										segs.splice(j, 1);
										j--;
									}
								}else if(j > 0 && !(j == 1 && segs[0] == "") &&
									segs[j] == ".." && segs[j-1] != ".."){
									// flatten "../" references
									if(j == (segs.length - 1)){
										segs.splice(j, 1);
										segs[j - 1] = "";
									}else{
										segs.splice(j - 1, 2);
										j -= 2;
									}
								}
							}
							relobj.path = segs.join("/");
						}
					}
				}

				uri = [];
				if(relobj.scheme){
					uri.push(relobj.scheme, ":");
				}
				if(relobj.authority){
					uri.push("//", relobj.authority);
				}
				uri.push(relobj.path);
				if(relobj.query){
					uri.push("?", relobj.query);
				}
				if(relobj.fragment){
					uri.push("#", relobj.fragment);
				}
			}

			this.uri = uri.join("");

			// break the uri into its main components
			var r = this.uri.match(ore);

			this.scheme = r[2] || (r[1] ? "" : n);
			this.authority = r[4] || (r[3] ? "" : n);
			this.path = r[5]; // can never be undefined
			this.query = r[7] || (r[6] ? "" : n);
			this.fragment	 = r[9] || (r[8] ? "" : n);

			if(this.authority != n){
				// server based naming authority
				r = this.authority.match(ire);

				this.user = r[3] || n;
				this.password = r[4] || n;
				this.host = r[6] || r[7]; // ipv6 || ipv4
				this.port = r[9] || n;
			}
		};
	_Url.prototype.toString = function(){ return this.uri; };

	return dojo._Url = _Url;
});

define('xide/rpc/Service',[
    "dojo/_base/kernel",
    "dojo/_base/lang",
    "dojo/_base/xhr",
    "dojo/_base/declare",
    "xide/rpc/AdapterRegistry",
    "dojo/_base/url"
], function(dojo,lang,xhr,declare,AdapterRegistry,url)
{

    var transportRegistry = new AdapterRegistry(true);
    var envelopeRegistry = new AdapterRegistry(true);
    var _nextId  = 1;
    var _sync = false;

    function getTarget(smd, method){
        var dest=smd._baseUrl;
        if(smd.target){
            dest = new dojo._Url(dest,smd.target) + '';
        }
        if(method.target){
            dest = new dojo._Url(dest,method.target) + '';
        }
        return dest;
    }

    function toOrdered(parameters, args){
        if(dojo.isArray(args)){ return args; }
        var data=[];
        for(var i=0;i<parameters.length;i++){
            data.push(args[parameters[i].name]);
        }
        return data;
    }

    var service = declare("xide.rpc.Service", null, {

        constructor: function(smd, options){
            // summary:
            //		Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
            //		as a definition for the service
            // description:
            //		dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
            //		dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
            //		a "No match found" error.
            // smd: object
            //		Takes a number of properties as kwArgs for defining the service.  It also
            //		accepts a string.  When passed a string, it is treated as a url from
            //		which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
            //		object.  It accepts serviceUrl, to manually define a url for the rpc service
            //		allowing the rpc system to be used without an smd definition. strictArgChecks
            //		forces the system to verify that the # of arguments provided in a call
            //		matches those defined in the smd.  smdString allows a developer to pass
            //		a jsonString directly, which will be converted into an object or alternatively
            //		smdObject is accepts an smdObject directly.

            var url;
            var self = this;
            function processSmd(smd){

                smd._baseUrl = new dojo._Url((dojo.isBrowser ? location.href : dojo.config.baseUrl) ,url || '.') + '';
                self._smd = smd;
                if(options && options.services==='methods'){
                    smd.services = smd.methods;
                    delete smd.methods;
                    smd.transport = "POST";
                    if(options.mixin){
                        lang.mixin(smd,options.mixin);
                    }
                    options = null;

                }

                //generate the methods
                for(var serviceName in self._smd.services){
                    var pieces = serviceName.split("."); // handle "namespaced" services by breaking apart by .
                    var current = self;
                    for(var i=0; i< pieces.length-1; i++){
                        // create or reuse each object as we go down the chain
                        current = current[pieces[i]] || (current[pieces[i]] = {});
                    }
                    current[pieces[pieces.length-1]]=	self._generateService(serviceName, self._smd.services[serviceName]);
                }
            }
            if(smd){
                //ifthe arg is a string, we assume it is a url to retrieve an smd definition from
                if( (dojo.isString(smd)) || (smd instanceof dojo._Url)){
                    if(smd instanceof dojo._Url){
                        url = smd + "";
                    }else{
                        url = smd;
                    }

                    var text = xhr._getText(url);
                    if(!text){
                        throw new Error("Unable to load SMD from " + smd);
                    }else{
                        processSmd(dojo.fromJson(text));
                    }
                }else{
                    processSmd(smd);
                }
            }

            this._options = (options ? options : {});
            this._requestId = 0;
        },

        _generateService: function(serviceName, method){

            if(this[method]){
                throw new Error("WARNING: "+ serviceName+ " already exists for service. Unable to generate function");
            }
            method.name = serviceName;

            var func = dojo.hitch(this, "_executeMethod",method);


            var transport = transportRegistry.match(method.transport || this._smd.transport);
            if(transport.getExecutor){
                func = transport.getExecutor(func,method,this);
            }
            var schema = method.returns || (method._schema = {}); // define the schema
            var servicePath = '/' + serviceName +'/';
            // schemas are minimally used to track the id prefixes for the different services
            schema._service = func;
            func.servicePath = servicePath;
            func._schema = schema;
            func.id = _nextId++;
            return func;
        },
        _getRequest: function(method,args){
            var smd = this._smd;
            var envDef = envelopeRegistry.match(method.envelope || smd.envelope || "NONE");
            var parameters = (method.parameters || []).concat(smd.parameters || []);
            if(envDef.namedParams){
                // the serializer is expecting named params
                if((args.length==1) && dojo.isObject(args[0])){
                    // looks like we have what we want
                    args = args[0];
                }else{
                    // they provided ordered, must convert
                    var data={};
                    for(var i=0;i<method.parameters.length;i++){
                        if(typeof args[i] != "undefined" || !method.parameters[i].optional){
                            data[method.parameters[i].name]=args[i];
                        }
                    }
                    args = data;
                }
                if(method.strictParameters||smd.strictParameters){
                    //remove any properties that were not defined
                    for(i in args){
                        var found=false;
                        for(var j=0; j<parameters.length;j++){
                            if(parameters[j].name==i){ found=true; }
                        }
                        if(!found){
                            delete args[i];
                        }
                    }

                }
                // setting default values
                for(i=0; i< parameters.length; i++){
                    var param = parameters[i];
                    if(!param.optional && param.name && !args[param.name]){
                        if(param["default"]){
                            args[param.name] = param["default"];
                        }else if(!(param.name in args)){
                            throw new Error("Required parameter " + param.name + " was omitted");
                        }
                    }
                }
            }else if(parameters && parameters[0] && parameters[0].name && (args.length==1) && dojo.isObject(args[0])){
                // looks like named params, we will convert
                if(envDef.namedParams === false){
                    // the serializer is expecting ordered params, must be ordered
                    args = toOrdered(parameters, args);
                }else{
                    // named is ok
                    args = args[0];
                }
            }

            if(dojo.isObject(this._options)){
                args = dojo.mixin(args, this._options);
            }
            delete args['mixin'];

            var schema = method._schema || method.returns; // serialize with the right schema for the context;
            var request = envDef.serialize.apply(this, [smd, method, args]);
            request._envDef = envDef;// save this for executeMethod
            var contentType = (method.contentType || smd.contentType || request.contentType);

            // this allows to mandate synchronous behavior from elsewhere when necessary, this may need to be changed to be one-shot in FF3 new sync handling model
            return dojo.mixin(request, {
                sync: _sync,
                contentType: contentType,
                headers: method.headers || smd.headers || request.headers || {},
                target: request.target || getTarget(smd, method),
                transport: method.transport || smd.transport || request.transport,
                envelope: method.envelope || smd.envelope || request.envelope,
                timeout: method.timeout || smd.timeout,
                callbackParamName: method.callbackParamName || smd.callbackParamName,
                rpcObjectParamName: method.rpcObjectParamName || smd.rpcObjectParamName,
                schema: schema,
                handleAs: request.handleAs || "auto",
                preventCache: method.preventCache || smd.preventCache,
                frameDoc: this._options.frameDoc || undefined
            });
        },
        _executeMethod: function(method){
            var args = [];
            var i;
            for(i=1; i< arguments.length; i++){
                args.push(arguments[i]);
            }
            var request = this._getRequest(method,args);
            var deferred = transportRegistry.match(request.transport).fire(request);

            deferred.addBoth(function(results){
                return request._envDef.deserialize.call(this,results);
            });
            return deferred;
        }
});

    service.transportRegistry = transportRegistry;
    service.envelopeRegistry = envelopeRegistry;
    service._nextId = _nextId;

    service.getTarget = getTarget;

    service.toOrdered= toOrdered;
    service._sync = _sync;

    envelopeRegistry.register("URL", function(str){ return str == "URL"; },{
		serialize:function(smd, method, data ){
			var d = dojo.objectToQuery(data);
			return {
				data: d,
				transport:"POST"
			};
		},
		deserialize:function(results){
			return results;
		},
		namedParams: true
	});
    envelopeRegistry.register("JSON",function(str){ return str == "JSON"; },{
        serialize: function(smd, method, data){
            var d = dojo.toJson(data);

            return {
                data: d,
                handleAs: 'json',
                contentType : 'application/json'
            };
        },
        deserialize: function(results){
            return results;
        }
    });
    envelopeRegistry.register("PATH",function(str){ return str == "PATH"; },{
        serialize:function(smd, method, data){
			var i;
			var target = getTarget(smd, method);
			if(dojo.isArray(data)){
				for(i = 0; i < data.length;i++){
					target += '/' + data[i];
				}
			}else{
				for(i in data){
					target += '/' + i + '/' + data[i];
				}
			}

			return {
				data:'',
				target: target
			};
		},
		deserialize:function(results){
			return results;
		}
	});
    //post is registered first because it is the default;
    transportRegistry.register("POST",function(str){ return str == "POST"; },{
		fire:function(r){
			r.url = r.target;
			r.postData = r.data;
			return dojo.rawXhrPost(r);
		}
	});
    transportRegistry.register("GET",function(str){ return str == "GET"; },{
		fire: function(r){
			r.url=  r.target + (r.data ? '?' + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data : '');
			return xhr.get(r);
		}
	});
    //only works ifyou include dojo.io.script
    /*
    transportRegistry.register("JSONP",function(str){ return str == "JSONP"; },{
        fire: function(r){
            r.url = r.target + ((r.target.indexOf("?") == -1) ? '?' : '&') + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data;
            r.callbackParamName = r.callbackParamName || "callback";
            return dojo.io.script.get(r);
        }
    });*/

    if(dojo._contentHandlers) {
        dojo._contentHandlers.auto = function (xhr) {
            // automatically choose the right handler based on the returned content type
            var handlers = dojo._contentHandlers;
            var retContentType = xhr.getResponseHeader("Content-Type");
            var results = !retContentType ? handlers.text(xhr) :
                retContentType.match(/\/.*json/) ? handlers.json(xhr) :
                    retContentType.match(/\/javascript/) ? handlers.javascript(xhr) :
                        retContentType.match(/\/xml/) ? handlers.xml(xhr) : handlers.text(xhr);
            return results;
        };
    }

    return service;

});

define('xide/rpc/JsonRPC',[
    "dojo/_base/lang",
    "dojo/_base/json",
    "./Service",
    "dojo/errors/RequestError"
], function(lang,dojo,Service, RequestError){

	function jsonRpcEnvelope(version){
		return {
			serialize: function(smd, method, data, options){
				//not converted to json it self. This  will be done, if
				//appropriate, at the transport level
	
				var d = {
					id: this._requestId++,
					method: method.name,
					params: data
				};
				if(version){
					d.jsonrpc = version;
				}
				return {
					data: dojo.toJson(d),
					handleAs:'json',
					contentType: 'application/json',
					transport:"POST"
				};
			},
	
			deserialize: function(obj){
				if ('Error' == obj.name // old xhr
					|| obj instanceof RequestError // new xhr
				){
					obj = dojo.fromJson(obj.responseText);
				}
				if(obj.error) {
					var e = new Error(obj.error.message || obj.error);
					e._rpcErrorObject = obj.error;
					return e;
				}
				return obj.result;
			}
		};
	}
    Service.envelopeRegistry.register(
		"JSON-RPC-1.0",
		function(str){
			return str == "JSON-RPC-1.0";
		},
		lang.mixin({namedParams:false}, jsonRpcEnvelope()) // 1.0 will only work with ordered params
	);
    Service.envelopeRegistry.register(
		"JSON-RPC-2.0",
		function(str){
			return str == "JSON-RPC-2.0";
		},
        lang.mixin({namedParams:true }, jsonRpcEnvelope("2.0")) // 2.0 supports named params
	);

});

define('xide/manager/RPCService',[
    'dojo/_base/declare',
    'dojo/_base/lang',
    'xide/rpc/Service',
    'xide/rpc/JsonRPC',
    'dojo/has',
    'dojo/Deferred',
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xide/encoding/SHA1'
], function (declare, lang, Service, JsonRPC, has, Deferred,utils,types,EventedMixin,SHA1) {

    return declare("xide.manager.RPCService", [Service,EventedMixin], {
        extraArgs: null,
        signatureField: 'sig',
        signatureToken: null,
        correctTarget: true,
        sync: false,
        defaultOptions: {
            omit: true,
            checkMessages: true,
            checkErrors: true
        },
        onError: function (err) {

            if (err) {
                if (err.code === 1) {

                    if (err.message && _.isArray(err.message)) {

                        this.publish(types.EVENTS.ERROR, {message: err.message.join('<br/>')});
                        return;
                    }
                } else if (err.code === 0) {
                    this.publish(types.EVENTS.STATUS, 'Ok');
                }
            }

            var struct = {
                error: err
            };
            this.publish(types.EVENTS.ERROR, struct, this);
        },
        prepareCall: function () {
            var params = {};



            if (this.config && this.config.RPC_PARAMS) {

                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);

                this.extraArgs = params;

                if (this.config.RPC_PARAMS.rpcUserField) {

                    params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;

                    this.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                    this.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                }
            }
        },
        runDeferred: function (serviceClassIn, method, args, options) {

            var deferred = new Deferred();

            options = options || this.defaultOptions;


            //check this method exists
            if (!this.checkCall(serviceClassIn, method, options.omit)) {
                return deferred.reject('method doesnt exists: ' + method + ' for service class:' + this.serviceClass + ' in ' + this.declaredClass);
            }

            //setup signing in serviceObject
            this.prepareCall();

            //variable shortcuts
            var service = this,
                serviceClass = this.getServiceClass(serviceClassIn),
                thiz = this;

            var resolve = function (data) {
                deferred.resolve(data);
            };

            var promise = service[serviceClass][method](args);
            promise.then(function (res) {

                //the server has some messages for us
                if (options.checkMessages) {
                    if (res && res.error && res.error.code == 3) {
                        thiz.onMessages(res.error);
                    }
                }

                //check for error messages (non-fatal) and abort
                if (options.checkErrors) {
                    if (res && res.error && res.error && res.error.code != 0) {
                        thiz.onError(res.error);
                        deferred.reject(res.error);
                        return;
                    }
                }

                //until here all is ok, tell everybody
                if (options.omit) {
                    thiz.publish(types.EVENTS.STATUS, {
                        message: 'Ok!',
                        what: arguments
                    }, this);
                }


                //final delivery
                resolve(res);


            }, function (err) {
                thiz.onError(err);
            });

            return deferred;
        },
        getParameterMap: function (serviceClass, serviceClassMethod) {

            var services = this._smd.services;
            var smd = services[serviceClass + '.' + serviceClassMethod];
            if (smd && smd.parameters) {
                return smd.parameters;
            }
            return [];
        },
        _getRequest: function (method, args) {
            var smd = this._smd;
            var envDef = Service.envelopeRegistry.match(method.envelope || smd.envelope || "NONE");
            var parameters = (method.parameters || method.params || []).concat(smd.parameters || []);

            if (envDef.namedParams) {
                // the serializer is expecting named params
                if ((args.length == 1) && lang.isObject(args[0])) {
                    // looks like we have what we want
                    args = args[0];
                } else {
                    // they provided ordered, must convert
                    var data = {};
                    var params = method.parameters || method.params;
                    for (var i = 0; i < params.length; i++) {
                        if (typeof args[i] != "undefined" || !params[i].optional) {
                            data[params[i].name] = args[i];
                        }
                    }
                    args = data;
                }
                if (method.strictParameters || smd.strictParameters) {
                    //remove any properties that were not defined
                    for (i in args) {
                        var found = false;
                        for (var j = 0; j < parameters.length; j++) {
                            if (parameters[i].name == i) {
                                found = true;
                            }
                        }
                        if (!found) {
                            delete args[i];
                        }
                    }

                }
                // setting default values
                for (i = 0; i < parameters.length; i++) {
                    var param = parameters[i];
                    if (!param.optional && param.name && args != null && !args[param.name]) {
                        if (param["default"]) {
                            args[param.name] = param["default"];
                        } else if (!(param.name in args)) {
                            throw new Error("Required parameter " + param.name + " was omitted");
                        }
                    }
                }
            } else if (parameters && parameters[0] && parameters[0].name && (args.length == 1) && dojo.isObject(args[0])) {
                // looks like named params, we will convert
                if (envDef.namedParams === false) {
                    // the serializer is expecting ordered params, must be ordered
                    args = Service.toOrdered(parameters, args);
                } else {
                    // named is ok
                    args = args[0];
                }
            }

            if (lang.isObject(this._options)) {
                args = dojo.mixin(args, this._options);
            }

            var schema = method._schema || method.returns; // serialize with the right schema for the context;
            var request = envDef.serialize.apply(this, [smd, method, args]);
            request._envDef = envDef;// save this for executeMethod
            var contentType = (method.contentType || smd.contentType || request.contentType);

            // this allows to mandate synchronous behavior from elsewhere when necessary, this may need to be changed to be one-shot in FF3 new sync handling model
            return dojo.mixin(request, {
                sync: this.sync,//dojox.rpc._sync,
                contentType: contentType,
                headers: method.headers || smd.headers || request.headers || {},
                target: request.target || Service.getTarget(smd, method),
                transport: method.transport || smd.transport || request.transport,
                envelope: method.envelope || smd.envelope || request.envelope,
                timeout: method.timeout || smd.timeout,
                callbackParamName: method.callbackParamName || smd.callbackParamName,
                rpcObjectParamName: method.rpcObjectParamName || smd.rpcObjectParamName,
                schema: schema,
                handleAs: request.handleAs || "auto",
                preventCache: method.preventCache || smd.preventCache,
                frameDoc: this._options.frameDoc || undefined
            });
        },
        _executeMethod: function (method) {
            var args = [];
            var i;
            if (arguments.length == 2 && lang.isArray(arguments[1])) {
                args = arguments[1];
            } else {
                for (i = 1; i < arguments.length; i++) {
                    args.push(arguments[i]);
                }
            }
            var request = this._getRequest(method, args);
            if (this.correctTarget) {
                request.target = this._smd.target;
            }


            if (this.extraArgs) {
                var index = 0;
                for (var key in this.extraArgs) {

                    request.target += request.target.indexOf('?') != -1 ? '&' : '?';
                    request.target += key + '=' + this.extraArgs[key];
                }
            }
            if (this.signatureToken) {
                request.target += request.target.indexOf('?') != -1 ? '&' : '?';
                var signature = SHA1._hmac(request.data, this.signatureToken, 1);

                /*                  var aParams = {
                 "service": serviceClass + ".get",
                 "path":path,
                 "callback":"asdf",
                 "raw":"html",
                 "attachment":"0",
                 "send":"1",
                 "user":this.config.RPC_PARAMS.rpcUserValue
                 };

                 var pStr  =  dojo.toJson(aParams);
                 var signature = SHA1._hmac(pStr, this.config.RPC_PARAMS.rpcSignatureToken, 1);

                 console.error('sign ' + pStr + ' with ' + this.config.RPC_PARAMS.rpcSignatureToken + ' to ' + signature);
                 */
                //var pStr  =  dojo.toJson(request.data);

                var signature = SHA1._hmac(request.data, this.signatureToken, 1);
                //console.error('sign ' + request.data + ' with ' +  this.signatureToken + ' to ' + signature);
                request.target += this.signatureField + '=' + signature;
            }

            var deferred = Service.transportRegistry.match(request.transport).fire(request);
            deferred.addBoth(function (results) {
                return request._envDef.deserialize.call(this, results);
            });
            return deferred;
        },
        getServiceClass: function (serviceClassIn) {
            return serviceClassIn || this.serviceClass;
        },
        hasMethod: function (method,serviceClass) {

            var _service = this,
                _serviceClass = serviceClass || this.getServiceClass();

            return _service &&
                _serviceClass &&
                _service[_serviceClass] != null &&
                _service[_serviceClass][method] != null;
        },
        checkCall: function (serviceClass, method, omit) {

            serviceClass = this.getServiceClass(serviceClass);

            if (!this.hasMethod(method,serviceClass) && omit === true) {

                this.onError({
                    code: 1,
                    message: ['Sorry, server doesnt know ' + method]
                });
                return false;
            }

            return true;
        },


        /************************************************
         *
         * @param data
         * @returns {*}
         */
        base64_encode: function (data) {
            // From: http://phpjs.org/functions
            // +   original by: Tyler Akins (http://rumkin.com)
            // +   improved by: Bayron Guevara
            // +   improved by: Thunder.m
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   bugfixed by: Pellentesque Malesuada
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   improved by: Rafał Kukawski (http://kukawski.pl)
            // *     example 1: base64_encode('Kevin van Zonneveld');
            // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
            // mozilla has this native
            // - but breaks in 2.0.0.12!
            //if (typeof this.window.btoa === 'function') {
            //    return btoa(data);
            //}
            var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                enc = '',
                tmp_arr = [];

            if (!data) {
                return data;
            }

            do { // pack three octets into four hexets
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                // use hexets to index into b64, and append result to encoded string
                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);

            enc = tmp_arr.join('');

            var r = data.length % 3;

            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);

        },
        callMethodEx: function (serviceClass, method, args, readyCB, errorCB, omitError) {

            /***
             * Check we the RPC method is in the SMD
             */

            var thiz = this;
            if (!this[serviceClass] || this[serviceClass][method] == null) {
                if (omitError === true && errorCB) {
                    errorCB({
                        code: 1,
                        message: ['Sorry, server doesnt know ' + method + ' in class' + serviceClass]
                    });
                }
                return null;
            }

            /***
             * Build signature
             */
            var params = {};


            /**
             * Mixin mandatory fields
             */
            if (this.config && this.config.RPC_PARAMS) {
                params = lang.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                this.extraArgs = params;
                this.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                this.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
            }


            this[serviceClass][method](args).then(function (res) {
                try {
                    if (readyCB) {
                        readyCB(res);
                    }
                } catch (e) {
                    console.error('bad news : callback for method ' + method + ' caused a crash in service class ' + serviceClass);
                }

                if (res && res.error && res.error && res.error.code != 0 && errorCB) {
                    errorCB(res.error);
                    return;
                }
                if (omitError == true) {

                }

            }, function (err) {
                errorCB(err);
            });
        },
        callMethod: function (serviceClass, method, args, readyCB, errorCB, omitError) {

            /***
             * Check we the RPC method is in the SMD
             */
            try {
                var thiz = this;
                if (this[serviceClass][method] == null) {
                    if (omitError === true && errorCB) {
                        errorCB({
                            code: 1,
                            message: ['Sorry, server doesnt know ' + method]
                        });
                    }
                    return null;
                }
                /***
                 * Build signature
                 */
                var params = {};
                params = lang.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                /**
                 * Mixin mandatory fields
                 */
                this[serviceClass][method](args).then(function (res) {
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        console.error('crashed in ' + method);
                        console.dir(e);

                    }
                    if (res && res.error && res.error && res.error.code == 1 && errorCB) {
                        errorCB(res.error);
                        return;
                    }

                    if (omitError !== false) {
                        var struct = {
                            message: 'Ok!'
                        };
                        //thiz.publish(types.EVENTS.STATUS,struct ,this);
                    }

                }, function (err) {
                    thiz.onError(err);
                });
            } catch (e) {
                console.error('crash! ' + e);
                //thiz.onError(e);
            }


        }

    });
});
/** @module xide/manager/Reloadable **/
define('xide/manager/Reloadable',[
    'dcl/dcl',
    "dojo/_base/lang",
    "xide/utils",
    "xide/types",
    "xide/factory"
], function (dcl,lang,utils,types,factory) {

    var throttle = function(timeout, callback) {
        var blocked = false;
        return function() {

            if (blocked)
                return;

            blocked = true;
            setTimeout(function() {
                blocked = false;
            }, timeout);

            callback();
        };
    };
    /**
     *
     * Resource manager which provides:
     *
     * - Resolving variables in strings
     * - Loading & unloading of resources: CSS,JS, Blox, API-Docs and plugins
     *
     *
     *
     * @class xide.manager.ResourceManager
     */
    return dcl(null, {
        declaredClass:"xide.manager.Reloadable",
        vfsMounts: null,
        xideServiceClient: null,
        fileUpdateTimes:{},
        onXIDELoaded: function (min, WebSocket) {
            var thiz = this;
            var _ctorArgs = {
                delegate: {
                    onServerResponse: function (e) {
                        thiz.onXIDEMessage(dojo.fromJson(e.data));
                    }
                }
            };
            try {
                var client = new WebSocket(_ctorArgs);

                lang.mixin(client, _ctorArgs);

                client.init({
                    options: {
                        host: 'http://0.0.0.0',
                        port: 9993,
                        channel: '',
                        debug: {
                            "all": false,
                            "protocol_connection": true,
                            "protocol_messages": true,
                            "socket_server": true,
                            "socket_client": true,
                            "socket_messages": true,
                            "main": true
                        }
                    }
                });
                client.connect();

            } catch (e) {
                console.error('create client with store : failed : ' + e);
            }

        },
        loadXIDE: function () {
            var thiz = this;

            this.subscribe(types.EVENTS.ON_NODE_SERVICE_STORE_READY, this.onNodeServiceStoreReady);

            require(['xide/min', 'xide/client/WebSocket'], function (min, WebSocket) {
                if (thiz._didXIDE) {
                    return;
                }
                thiz._didXIDE = true;
                thiz.onXIDELoaded(min, WebSocket);
            });
        },
        onXIDEMessage: function (data) {

            var thiz = this;

            thiz.publish(data.event, data);

            if (data.event === types.EVENTS.ON_FILE_CHANGED) {


                var _path = data.data.path;

                var timeNow = new Date().getTime();

                if (thiz.fileUpdateTimes[_path]) {


                    var last = thiz.fileUpdateTimes[_path];
                    var diff = timeNow - last;

                    if (diff < 30) {
                        thiz.fileUpdateTimes[_path] = timeNow;
                        return;
                    }
                }
                thiz.fileUpdateTimes[_path] = timeNow;

                //path is absolute and might look like: /PMaster/projects/xbox-app/client/src/lib/xfile/Views.js
                //fix windows path
                var path = utils.replaceAll('\\', '/', data.data.path);

                path = utils.replaceAll('//', '/', data.data.path);

                //console.log('on file changed : ' + path);

                /**
                 * Check its a css file
                 */
                if (path == null || path.indexOf == null) {
                    console.error('on file changed : have no path, aborting');
                    return;
                }
                if (path.match(/\.css$/)) {
                    var newEvt = {
                        path: path
                    };

                    thiz.onCSSChanged(newEvt);

                }


                /**
                 * Try generic
                 */
                if (path.match(/\.js$/)) {

                    var modulePath = data.data.modulePath;
                    if (modulePath) {
                        modulePath = modulePath.replace('.js', '');
                        var _re = require;//hide from gcc
                        //try pre-amd module
                        var module = null;
                        try {
                            module = _re(modulePath);
                        } catch (e) {

                        }


                        var _start = 'node_modules';
                        if (path.indexOf(_start) != -1) {
                            var libPath = path.substr(path.indexOf(_start) + _start.length, path.length);
                            libPath = libPath.replace('.js', '');
                            if (path.indexOf('xcfnode') != -1) {
                                path = libPath;
                                modulePath = path.replace('/xcfnode', 'xcfnode');
                            }
                        }
                        modulePath = utils.replaceAll('.', '/', modulePath);
                        setTimeout(function () {
                            thiz._reloadModule(modulePath, true);
                        }, 400);
                    }
                }
            }

        },
        onNodeServiceStoreReady: function (evt) {

            if (this.xideServiceClient) {
                this.xideServiceClient.destroy();
            }
            this.xideServiceClient = null;
            var thiz = this;
            var store = evt.store;
            this.deviceServerClient = factory.createClientWithStore(store, 'XIDE Server', {
                delegate: {
                    onServerResponse: function (e) {
                        thiz.onXIDEMessage(dojo.fromJson(e.data));
                    }
                }
            });
        },
        mergeFunctions: function (target, source) {

            for (var i in source) {
                var o = source[i];
                if (lang.isFunction(source[i]) /*&& lang.isFunction(target[i])*/) {
                    target[i] = source[i];//swap
                }

            }
        },
        /**
         * Special case when module has been reloaded : update all functions in our singleton
         * managers!
         * @param evt
         */
        onModuleReloaded: function (evt) {


            if(evt._didHandle){
                return;
            }
            evt._didHandle=true;

            this.inherited(arguments);

            if(this.managers) {
                var newModule = evt.newModule;
                for (var i = 0; i < this.managers.length; i++) {
                    var manager = this.managers[i];
                    if (newModule.prototype
                        && newModule.prototype.declaredClass
                        && newModule.prototype.declaredClass === manager.declaredClass) {
                        this.mergeFunctions(manager, newModule.prototype);
                        if (manager.onReloaded) {
                            manager.onReloaded(newModule);
                        }
                        break;
                    }
                }
            }
        },
        _reloadModule: function (module, reload) {
            require.undef(module);
            var thiz = this;
            if (reload) {
                setTimeout(function () {
                    require([module], function (moduleLoaded) {
                        if (lang.isString(moduleLoaded)) {
                            console.error('module reloaded failed : ' + moduleLoaded + ' for module : ' + module);
                            return;
                        }
                        console.log('did - re-require module : ' + module);
                        moduleLoaded.modulePath = module;
                        var obj = lang.getObject(utils.replaceAll('/', '.', module));
                        if (obj) {
                            thiz.mergeFunctions(obj.prototype, moduleLoaded.prototype);
                        }
                        thiz.publish(types.EVENTS.ON_MODULE_RELOADED, {
                            module: module,
                            newModule: moduleLoaded
                        });
                        thiz.publish(types.EVENTS.ON_MODULE_UPDATED,{
                            moduleClass:moduleLoaded.prototype.declaredClass,
                            moduleProto:moduleLoaded.prototype
                        });
                    });
                }, 500);
            }
        },
        onCSSChanged: function (evt) {

            if (evt['didProcess']) {
                return;
            }
            evt['didProcess'] = true;

            var path = evt.path;

            path = utils.replaceAll('//', '/', path);
            path = path.replace('/PMaster/', '');
            var reloadFn = window['xappOnStyleSheetChanged'];
            if (reloadFn) {
                reloadFn(path);
            }
        },
        onDidChangeFileContent: function (evt) {

            if (evt['didProcess']) {
                return;
            }
            evt['didProcess'] = true;

            if (!this.vfsMounts) {
                return;
            }
            if (!evt.path) {
                return;
            }
            var path = evt.path;
            if (path.indexOf('.css') != -1) {
                this.onCSSChanged(evt);
                return;
            }

            if (path.indexOf('resources') != -1 ||
                path.indexOf('meta') != -1 ||
                path.indexOf('.js') == -1) {
                return;
            }

            var mount = evt.mount.replace('/', '');
            var module = null;
            if (!this.vfsMounts[mount]) {
                return;
            }

            module = '' + evt.path;
            module = module.replace('./', '');
            module = module.replace('/', '.');
            module = module.replace('.js', '');
            module = utils.replaceAll('.', '/', module);
            var thiz = this;
            setTimeout(function () {
                thiz._reloadModule(module, true);
            }, 500);
            console.error('reload module : ' + module);

        }
    });
});




define('xide/manager/ServerActionBase',[
    'dcl/dcl',
    'dojo/_base/declare',
    'xdojo/has',
    'dojo/Deferred',
    'xide/manager/RPCService',
    'xide/manager/ManagerBase',
    'xide/types',
    'xide/utils'
], function (dcl,declare, has, Deferred, RPCService, ManagerBase, types, utils) {

    var Singleton = null;

    var Implementation = {
        declaredClass:"xide.manager.ServerActionBase",
        serviceObject: null,
        serviceUrl: null,
        singleton: true,
        serviceClass: null,
        defaultOptions: {
            omit: true,
            checkMessages: true,
            checkErrors: true
        },
        base64_encode: function (data) {

            // From: http://phpjs.org/functions
            // +   original by: Tyler Akins (http://rumkin.com)
            // +   improved by: Bayron Guevara
            // +   improved by: Thunder.m
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   bugfixed by: Pellentesque Malesuada
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   improved by: Rafał Kukawski (http://kukawski.pl)
            // *     example 1: base64_encode('Kevin van Zonneveld');
            // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
            // mozilla has this native
            // - but breaks in 2.0.0.12!
            //if (typeof this.window.btoa === 'function') {
            //    return btoa(data);
            //}
            var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                enc = '',
                tmp_arr = [];

            if (!data) {
                return data;
            }

            do { // pack three octets into four hexets
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                // use hexets to index into b64, and append result to encoded string
                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);

            enc = tmp_arr.join('');

            var r = data.length % 3;

            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);

        },
        /**
         * Public main entry, all others below are deprecated
         * @param serviceClassIn
         * @param method
         * @param args
         * @param options
         * @returns {Deferred}
         */
        runDeferred: function (serviceClassIn, method, args, options) {

            var deferred = new Deferred(),
                promise;

            options = options || this.defaultOptions;

            //check we the RPC method is in the SMD
            this.check();

            //check this method exists
            if (!this.checkCall(serviceClassIn, method, options.omit)) {
                return deferred.reject('method doesnt exists: ' + method + ' for service class:' + this.serviceClass + ' in ' + this.declaredClass);
            }

            //setup signing in serviceObject
            this.prepareCall();

            //variable shortcuts
            var service = this.getService(),
                serviceClass = this.getServiceClass(serviceClassIn),
                thiz = this;

            var resolve = function (data,error) {

                var dfd = deferred;
                if(options.returnProm){
                    dfd = promise;
                }

                dfd._data = data;

                if(error) {
                    //dfd.reject(error,true);
                    //throw new Error(error);
                    if(options.onError){
                        return options.onError(error);
                    }
                }
                dfd.resolve(data);

            };

            promise = service[serviceClass][method](args);

            promise.then(function (res) {
                res = res || {};
                var error = res.error || {};
                //the server has some messages for us
                if (options.checkMessages) {
                    if (error && error.code == 3) {
                        thiz.onMessages(error);
                    }
                }
                //check for error messages (non-fatal) and abort
                if (options.checkErrors) {

                    if (error.code == 1) {
                        thiz.onError(error,serviceClass + '::' + method);
                        deferred.reject(error);
                        return;
                    }
                }else{

                    if (error.code == 1 && options.displayError) {
                        thiz.onError(error,serviceClass + '::' + method);
                    }

                    if (error && error.code != 0) {
                        resolve(res,error);
                        return;
                    }
                }

                //until here all is ok, tell everybody
                if (options.omit) {
                    thiz.publish(types.EVENTS.STATUS, {
                        message: 'Ok!',
                        what: arguments
                    }, this);
                }


                //final delivery
                resolve(res);


            }, function (err) {
                thiz.onError(err);
            });


            if(options.returnProm){
                return promise;
            }

            return deferred;
        },
        getService: function () {
            return this.serviceObject;
        },
        getServiceClass: function (serviceClassIn) {
            return serviceClassIn || this.serviceClass;
        },
        hasMethod: function (method,serviceClass) {

            var _service = this.getService(),
                _serviceClass = serviceClass || this.getServiceClass();

            return _service &&
                _serviceClass &&
                _service[_serviceClass] != null &&
                _service[_serviceClass][method] != null;
        },
        findServiceUrl: function (declaredClass) {

            var config = window['xFileConfig'];
            if (config && config.mixins) {
                for (var i = 0; i < config.mixins.length; i++) {
                    var obj = config.mixins[i];
                    if (obj.declaredClass === declaredClass && obj.mixin && obj.mixin.serviceUrl) {
                        return obj.mixin.serviceUrl;
                    }
                }
            }
            return null;
        },
        init: function () {
            this.check();
        },
        _initService: function () {

            var thiz = this;

            if(!has('host-browser')){
                return false;
            }

            if (!this.serviceClass) {
                //console.error('have no service class : ' + this.declaredClass);
            }
            if (!this.serviceUrl) {
                //console.error('have no service url : ' + this.declaredClass);
            }
            try {
                var obj = Singleton;

                if (this.singleton) {

                    if (obj && obj.serviceObject) {
                        this.serviceObject = obj.serviceObject;
                        if(this.config){
                            this.config = this.config;
                        }
                        return;
                    }
                }
                if (!this.serviceObject) {
                    //console.log('Init RPC Class ' + this.serviceClass + ' with url : ' + this.serviceUrl + ' singleton ' + this.singleton);
                    this.serviceObject = new RPCService(this.serviceUrl,this.options);
                    this.serviceObject.runDeferred = function(){
                        return thiz.runDeferred.apply(thiz,arguments);
                    }

                    this.serviceObject.sync = this.sync;

                    if (this.singleton) {
                        obj.serviceObject = this.serviceObject;
                    }

                    if(this.config){
                        obj.serviceObject.config = this.config;
                    }
                }
            } catch (e) {
                console.error('error in rpc service creation : ' + e);
                logError(e);
            }

        },
        check: function () {

            if (!this.serviceObject)
                this._initService();
        },
        onError: function (err,suffix) {

            if (err) {
                if (err.code === 1) {

                    if (err.message && _.isArray(err.message)) {

                        this.publish(types.EVENTS.ERROR, {message: err.message.join('<br/>')});
                        return;
                    }
                } else if (err.code === 0) {
                    this.publish(types.EVENTS.STATUS, 'Ok');
                }
            }

            if(suffix){
                err.message = suffix +  ' -> ' + err.message;
            }

            var struct = {
                error:err
            };
            this.publish(types.EVENTS.ERROR, struct, this);
        },

        checkCall: function (serviceClass, method, omit) {

            serviceClass = this.getServiceClass(serviceClass);
            if (!this.getService()) {
                return false;
            }
            if (!this.hasMethod(method,serviceClass) && omit === true) {
                this.onError({
                    code: 1,
                    message: ['Sorry, server doesnt know ' + method]
                });
                return false;
            }

            return true;
        },
        prepareCall: function () {
            var params = {};
            /**
             * Mixin mandatory fields
             */
            if (this.config && this.config.RPC_PARAMS) {
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);

                this.serviceObject.extraArgs = params;

                if (this.config.RPC_PARAMS.rpcUserField) {
                    params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;

                    this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                    this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                }
            }
        },
        callMethodEx: function (serviceClassIn, method, args, readyCB, omitError) {

            serviceClassIn = serviceClassIn || this.serviceClass;
            if (!serviceClassIn) {
                console.error('have no service class! ' + this.declaredClass,this);

            }
            //init smd
            this.check();

            //check this method exists
            if (!this.checkCall(serviceClassIn, method, omitError)) {
                return;
            }
            //setup signing in serviceObject
            this.prepareCall();

            var thiz = this;
            var _sClass = this.getServiceClass(serviceClassIn);
            if (!_sClass) {
                debugger;
            }
            var ob = this.serviceObject[this.getServiceClass(serviceClassIn)];

            if (!ob || !ob[method]) {
                debugger;
            }
            var promise = this.serviceObject[this.getServiceClass(serviceClassIn)][method](args).then(function (res) {


                try {
                    if (readyCB) {
                        readyCB(res);
                    }
                } catch (e) {

                    console.error('bad news : callback for method ' + method + ' caused a crash in service class ' + serviceClassIn);
                    logError(e,'server method failed '+e);

                }

                if (res && res.error && res.error.code == 3) {
                    setTimeout(function () {
                        thiz.onMessages(res.error);
                    }, 50);
                }

                if (res && res.error && res.error && res.error.code != 0) {
                    thiz.onError(res.error);
                    return;
                }
                if (omitError == true) {
                    var struct = {
                        message: 'Ok!'
                    };
                    thiz.publish(types.EVENTS.STATUS, struct, this);
                }

            }, function (err) {
                thiz.onError(err);
            });
        },
        callMethodEx2: function (serverClassIn, method, args, readyCB, omitError) {

            /***
             * Check we the RPC method is in the SMD
             */
            this.check();

            //check this method exists
            if (!this.checkCall(serverClassIn, method, omitError)) {
                return;
            }
            //setup signing in serviceObject
            this.prepareCall();

            return this.serviceObject[this.getServiceClass(serverClassIn)][method](args);
        },
        callMethod: function (method, args, readyCB, omitError) {

            args = args || [[]];
            /***
             * Check we the RPC method is in the SMD
             */
            var serviceClass = this.serviceClass;
            try {
                var thiz = this;
                if (this.serviceObject[serviceClass][method] == null) {
                    if (omitError === true) {
                        this.onError({
                            code: 1,
                            message: ['Sorry, server doesnt know ' + method]
                        });
                    }
                    return null;
                }
                /***
                 * Build signature
                 */
                var params = {};
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);


                /**
                 * Mixin mandatory fields
                 */
                params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                this.serviceObject.extraArgs = params;
                this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                this.serviceObject[this.serviceClass][method](args).then(function (res) {

                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        console.error('crashed in ' + method);
                        console.dir(e);
                        debugger;
                    }

                    if (res && res.error && res.error.code == 3) {
                        setTimeout(function () {
                            thiz.onMessages(res.error);
                        }, 50);
                    }

                    if (res && res.error && res.error && res.error.code == 1) {
                        thiz.onError(res.error);
                        return;
                    }

                    if (omitError !== false) {
                        var struct = {
                            message: 'Ok!'
                        };
                        thiz.publish(types.EVENTS.STATUS, struct, this);
                    }

                }, function (err) {
                    thiz.onError(err);
                });
            } catch (e) {
                console.error('crash! ' + e);
                thiz.onError(e);
            }
        }
    };

    var Module = dcl(ManagerBase, Implementation);

    Module.declare = declare(null,Implementation);

    Singleton = Module;

    return Module;
});
/** @mixin xide/mixin/VariableMixin **/
define('xide/mixins/VariableMixin',[
    'dcl/dcl',
    'xdojo/declare',
    'xide/utils'
], function (dcl,declare,utils) {

    var Implementation = {
        /**
         *
         * @param what
         * @param variables
         * @param delimitters
         * @returns {*}
         */
        resolve:function(what,variables,delimitters){
            variables = variables || this.resourceVariables || this.ctx.getResourceManager().getResourceVariables() || null;
            delimitters = delimitters || this.variableDelimiters || null;
            return utils.replace(what,null,variables,delimitters);
        }
    }

    /**
     * Mixin to resolve resource variables in strings.
     * Currently stub
     */
    var Module = declare("xide/mixins/VariableMixin", null, Implementation);
    Module.dcl = dcl(null,Implementation);
    return Module;
});
/** @module xide/manager/ResourceManager **/
define('xide/manager/ResourceManager',[
    'dcl/dcl',
    "xide/manager/ServerActionBase",
    "xide/utils",
    'xide/mixins/VariableMixin'
], function (dcl,ServerActionBase, utils, VariableMixin) {
    /**
     *
     * Resource manager which provides:
     *
     * - Resolving variables in strings
     * - Loading & unloading of resources: CSS,JS, Blox, API-Docs and plugins
     *
     * @class xide.manager.ResourceManager
     */
    return dcl([ServerActionBase,VariableMixin.dcl], {
        declaredClass:"xide.manager.ResourceManager",
        serviceClass: "XApp_Resource_Service",
        resourceData: null,
        resourceVariables: null,
        getResourceVariables:function(){
            return this.resourceVariables;
        },
        setVariable: function (variableName,value) {
            return this.resourceVariables[variableName]=value;
        },
        getVariable: function (variableName) {
            return this.resourceVariables[variableName];
        },
        init: function () {
            if (!this.resourceVariables) {
                this.resourceVariables = {};
            }
        },
        replaceVariables: function (string, variables) {
            
            return utils.multipleReplace('' + string, variables || this.resourceVariables);
        }
    });
});
define('xide/mainr',[
    "xide/types",
    "xide/types/Types",
    'xide/utils/StringUtils',
    'xide/utils/HTMLUtils',
    'xide/utils/StoreUtils',
    'xide/utils/WidgetUtils',
    'xide/utils/CIUtils',
    'xide/utils/ObjectUtils',

    'xide/factory',
    'xide/factory/Objects',
    'xide/factory/Events',
    'xide/factory/Clients',
    "xide/client/ClientBase",

    "xide/client/WebSocket",
    "xide/data/Memory",
    "xide/data/Model",
    "xide/data/ObservableStore",
    "xide/data/Reference",
    "xide/data/Source",
    "xide/data/TreeMemory",
    "xide/data/_Base",
    "xide/encoding/MD5",
    "xide/encoding/SHA1",
    "xide/encoding/_base",

    "xide/model/Component",
    "xide/debug",

    "xide/mixins/EventedMixin",
    "xide/mixins/ReferenceMixin",
    "xide/mixins/ReloadMixin",
    "xide/min",

    "xide/manager/BeanManager",
    "xide/manager/ContextBase",
    "xide/manager/Context",
    "xide/manager/ManagerBase",
    "xide/manager/PluginManager",
    "xide/manager/RPCService",
    "xide/manager/Reloadable",
    "xide/manager/ResourceManager",
    "xide/manager/ServerActionBase",
    'xide/utils'
], function () {

});
define('xfile/types',[
    'dojo/_base/lang',
    'xide/types',
    'xide/types/Types'
],function(lang,types)
    {
        /**
         * Public mime registry setter
         * @param type
         * @param map
         */
        types.registerCustomMimeIconExtension = function (type, map) {
            types['customMimeIcons'][type] = map;
        };

        types.FIELDS = {
            SHOW_ISDIR:1602,
            SHOW_OWNER:1604,
            SHOW_MIME:1608,
            SHOW_SIZE:1616,
            SHOW_PERMISSIONS:1632,
            SHOW_TIME:1633,
            SHOW_FOLDER_SIZE:1634,
            SHOW_FOLDER_HIDDEN:1635,
            SHOW_TYPE:1636,
            SHOW_MEDIA_INFO:1637
        };

        types.FILE_PANEL_LAYOUT =
        {
            TREE:1,
            LIST:2,
            THUMB:3,
            PREVIEW:4,
            COVER:5,
            SPLIT_VERTICAL:6,
            SPLIT_HORIZONTAL:7,
            IMAGE_GRID:8
        };

        types.LAYOUT_PRESET =
        {
            DUAL:1,
            SINGLE:2,
            BROWSER:3,
            PREVIEW:4,
            GALLERY:5,
            EDITOR:6
        };

        types.PANEL_OPTIONS = {
            ALLOW_NEW_TABS:true,
            ALLOW_MULTI_TAB:false,
            ALLOW_INFO_VIEW:true,
            ALLOW_LOG_VIEW:true,
            ALLOW_CONTEXT_MENU:true,
            ALLOW_LAYOUT_SELECTOR:true,
            ALLOW_SOURCE_SELECTOR:true,
            ALLOW_COLUMN_RESIZE:true,
            ALLOW_COLUMN_REORDER:true,
            ALLOW_COLUMN_HIDE:true,
            ALLOW_ACTION_TOOLBAR:true,
            ALLOW_MAIN_MENU:true
        };

        /**
         * @TODO: remove
         * @type {{LAYOUT: number, AUTO_OPEN: boolean}}
         */
        types.FILE_PANEL_OPTIONS_LEFT={
            LAYOUT:2,
            AUTO_OPEN:true
        };

        types.FILE_PANEL_OPTIONS_MAIN={
            LAYOUT:3,
            AUTO_OPEN:true
        };

        types.FILE_PANEL_OPTIONS_RIGHT={
            LAYOUT:3,
            AUTO_OPEN:true
        };
        types.FILE_GRID_COLUMNS =
        {
            NAME:'name',
            SIZE:'size',
            MODIFIED:'modified'
        };
        types.ACTION_TOOLBAR_MODE =
        {
            SELF:'self'
        };

        lang.mixin(types.ITEM_TYPE,{
            FILE:'BTFILE'
        });

        /***
         *
         * Extend the core events with xfile specific events
         */
        /**
         * ActionVisibility
         * @enum module:xide/types/EVENTS
         * @memberOf module:xide/types
         */
        lang.mixin(types.EVENTS,{
            STORE_CHANGED:'onStoreChange',
            BEFORE_STORE_CHANGE:'onBeforeStoreChange',
            STORE_REFRESHED:'onStoreRefreshed',
            ON_FILE_STORE_READY:'onFileStoreReady',
            ON_DID_OPEN_ITEM:'onDidOpenItem',
            ON_SHOW_PANEL:'onShowPanel',
            ITEM_SELECTED:'onItemSelected',
            ERROR:'fileOperationError',
            STATUS:'fileOperationStatus',
            IMAGE_LOADED:'imageLoaded',
            IMAGE_ERROR:'imageError',
            RESIZE:'resize',
            ON_UPLOAD_BEGIN:'onUploadBegin',
            ON_UPLOAD_PROGRESS:'onUploadProgress',
            ON_UPLOAD_FINISH:'onUploadFinish',
            ON_UPLOAD_FAILED: 'onUploadFailed',
            ON_CLIPBOARD_COPY:'onClipboardCopy',
            ON_CLIPBOARD_PASTE:'onClipboardPaste',
            ON_CLIPBOARD_CUT:'onClipboardCut',
            ON_CONTEXT_MENU_OPEN:'onContextMenuOpen',
            ON_PLUGIN_LOADED:'onPluginLoaded',
            ON_PLUGIN_READY:'onPluginReady',
            ON_MAIN_VIEW_READY:'onMainViewReady',
            ON_FILE_CONTENT_CHANGED:'onFileContentChanged',
            ON_PANEL_CLOSED:'onPanelClosed',
            ON_PANEL_CREATED:'onPanelCreated',
            ON_COPY_BEGIN:'onCopyBegin',
            ON_COPY_END:'onCopyEnd',
            ON_DOWNLOAD_TO_BEGIN:'onDownloadToBegin',
            ON_DOWNLOAD_TO_END:'onDownloadToEnd',
            ON_DELETE_BEGIN:'onDeleteBegin',
            ON_DELETE_END:'onDeleteEnd',
            ON_MOVE_BEGIN:'onMoveBegin',
            ON_MOVE_END:'onMoveEnd',
            ON_COMPRESS_BEGIN:'onCompressBegin',
            ON_COMPRESS_END:'onCompressEnd',
            ON_SOURCE_MENU_OPEN:'onSourceMenuOpen',
            ON_MOUNT_DATA_READY:'onMountDataReady',
            ON_XFILE_READY:'onXFileReady',
            ON_CHANGE_PERSPECTIVE:'onChangePerspective',
            ON_FILE_PROPERTIES_RENDERED:'onFilePropertiesRendered'
        });

        /**
         * SELECTION_MODE specfies the possible selection modes for xfile grid views
         * @enum module:xide/types/SELECTION_MODE
         * @memberOf module:xide/types
         */
        types.SELECTION_MODE =
        {
            /** Single
             * @const
             * @type {string}
             */
            SINGLE:'single',
            /** Multiple
             * @const
             * @type {string}
             */
            MULTI:'multiple',
            /** Extended
             * @const
             * @type {string}
             */
            EXTENDED:'extended'
        };

        /**
         * @TODO: remove
         * OPERATION is the string representation of xfile commands
         * @enum module:xide/types/OPERATION
         * @memberOf module:xide/types
         */
        types.OPERATION=
        {

            COPY:'copy',
            MOVE:'move',
            RENAME:'rename',
            DELETE:'delete',
            OPEN:'open',
            EDIT:'edit',
            DOWNLOAD:'download',
            DOWNLOAD_TO:'downloadTo',
            INFO:'info',
            COMPRESS:'compress',
            RELOAD:'reload',
            PREVIEW:'preview',
            INSERT_IMAGE:'insertImage',
            COPY_PASTE:'copypaste',
            DND:'dnd',
            OPTIONS:'options',
            NEW_FILE:'mkfile',
            NEW_DIRECTORY:'mkdir',
            GET_CONTENT:'get',
            SET_CONTENT:'set',
            FIND:'find',
            CUSTOM:'custom',
            PERMA_LINK:'permaLink',
            ADD_MOUNT:'ADD_MOUNT',
            REMOVE_MOUNT:'REMOVE_MOUNT',
            EDIT_MOUNT:'EDIT_MOUNT',
            PERSPECTIVE:'PERSPECTIVE',
            EXTRACT:'extract'
        };

        /**
         * @TODO: remove
         * OPERATION_INT is the integer version of {xide/types/OPERATION}
         * @enum module:xide/types/OPERATION_INT
         * @memberOf module:xide/types
         */
        types.OPERATION_INT={
            NONE:0,
            EDIT:1,
            COPY:2,
            MOVE:3,
            INFO:4,
            DOWNLOAD:5,
            COMPRESS:6,
            DELETE:7,
            RENAME:8,
            DND:9,
            COPY_PASTE:10,
            OPEN:11,
            RELOAD:12,
            PREVIEW:13,
            INSERT_IMAGE:15,
            NEW_FILE:16,
            NEW_DIRECTORY:17,
            UPLOAD:18,
            READ:19,
            WRITE:20,
            PLUGINS:21,
            CUSTOM:22,
            FIND:23,
            PERMA_LINK:24,
            ADD_MOUNT:25,
            REMOVE_MOUNT:26,
            EDIT_MOUNT:27,
            PERSPECTIVE:28,      //change perspective
            CLIPBOARD_COPY:29,
            CLIPBOARD_CUT:30,
            CLIPBOARD_PASTE:31,
            EXTRACT:32
        };

        return types;
});
define('xfile/manager/FileManagerActions',[
    'dcl/dcl',
    'xide/types',
    'xide/utils'
], function (dcl,types,utils) {
    /**
     * @class xfile.manager.FileManager
     * @augments module:xfile.manager.FileManager
     */
    return dcl(null, {
        declaredClass:"xfile/manager/FileManagerActions",
        /**
         * Publish a file's operations progress event
         * @param event
         * @param terminator
         * @param items
         * @param failed
         * @private
         */
        _publishProgress: function (event, terminator, items, failed, extra) {
            var _args = {
                terminatorItem: terminator,
                failed: failed,
                items: items || terminator
            };
            utils.mixin(_args, extra);
            this.publish(event, _args, this);
        },
        /**
         *
         * @param operation
         * @param args
         * @param terminator
         * @param items
         * @returns {*}
         */
        doOperation: function (operation, args, terminator, items, extra,dfdOptions) {
            var thiz = this,
                operationCapitalized = operation.substring(0, 1).toUpperCase() + operation.substring(1),
                beginEvent = 'on' + operationCapitalized + 'Begin', //will evaluate for operation 'delete' to 'onDeleteBegin'
                endEvent = 'on' + operationCapitalized + 'End';

            thiz._publishProgress(beginEvent, terminator, items, false, extra);
            var rpcPromise = this.runDeferred(null, operation, args,dfdOptions).then(function () {
                thiz._publishProgress(endEvent, terminator, items, false, extra);
            }, function (err) {
                thiz._publishProgress(endEvent, terminator, items, true, extra);
            });
            return rpcPromise;
        },
        deleteItems: function (selection, options,dfdOptions) {
            return this.doOperation(types.OPERATION.DELETE, [selection, options, true], selection,selection,null,dfdOptions);
        },
        copyItem: function (selection, dst, options,dfdOptions) {
            return this.doOperation(types.OPERATION.COPY, [selection, dst, options, false], selection, selection, {dst: dst},dfdOptions);
        },
        mkdir: function (mount, path,dfdOptions) {
            return this.doOperation(types.OPERATION.NEW_DIRECTORY, [mount, path], path,null,null,dfdOptions);
        },
        mkfile: function (mount, path, content) {
            return this.doOperation(types.OPERATION.NEW_FILE, [mount, path], path);
        },
        rename: function (mount, src, dst) {
            return this.doOperation(types.OPERATION.RENAME, [mount, src, dst], src);
        },
        moveItem: function (src, dst, include, exclude, mode, dfdOptions) {
            return this.doOperation(types.OPERATION.MOVE, [src, dst, include, exclude, mode], src,null,null,dfdOptions);
        },
        compressItem: function (mount, src, type, readyCB) {
            return this.doOperation(types.OPERATION.COMPRESS, [mount, src, type], src);
        },
        extractItem: function (mount, src, type) {
            return this.doOperation(types.OPERATION.EXTRACT, [mount, src], src);
        }
    });
});
/** @module xfile/manager/FileManager */
define('xfile/manager/FileManager',[
    'dcl/dcl',
    'dojo/_base/lang',
    'xide/manager/ServerActionBase',
    'xide/types',
    'xfile/types',
    'xide/utils',
    'xide/encoding/SHA1',
    'xide/manager/RPCService',
    'dojo/Deferred',
    'dojo/has',
    'xfile/manager/FileManagerActions',
    'require'
], function (dcl,lang, ServerActionBase, types, fTypes, utils, SHA1, RPCService, Deferred,has,FileManagerActions,require) {

    var bases = [ServerActionBase, FileManagerActions];
    if(has('electronx')){
        //console.error('add electron');
        ///bases.push(Electron);
    };

    var debug = true;
    /**
     * @class module:xfile.manager.FileManager
     * @extends module:xide.manager.ServerActionBase
     * @extends module:xide.manager.ManagerBase
     * @augments module:xide.mixin.EventedMixin
     */
    return dcl(bases, {
        declaredClass:"xfile.manager.FileManager",
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Variables
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        _uploadXHR: null,
        store: null,
        config: null,
        filesToUpload: null,
        serviceUrl: "index.php",
        serviceClass: 'XCOM_Directory_Service',
        settingsStore: null,
        stores:[],
        getStore:function(mount){
            return _.find(this.stores,{
                mount:mount
            });
        },
        addStore:function(store){

            this.stores.push(store);
            store._on('destroy',this.removeStore.bind(this));
        },
        removeStore:function(store){
            var index = this.stores.indexOf(store);
            if(index) {
                this.stores.remove(store);
            }
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Standard manager interface implementation
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        download: function (src) {
            var selection = [];

            selection.push(src.path);

            var thiz = this;
            var downloadUrl = this.serviceUrl;
            downloadUrl = downloadUrl.replace('view=rpc', 'view=smdCall');
            if (downloadUrl.indexOf('?') != -1) {
                downloadUrl += '&';
            } else {
                downloadUrl += '?';
            }
            var serviceClass = this.serviceClass || 'XCOM_Directory_Service';
            var path = utils.buildPath(src.mount, src.path, true);
            path = this.serviceObject.base64_encode(path);

            downloadUrl += 'service=' + serviceClass + '.get&path=' + path + '&callback=asdf';

            if (this.config.DOWNLOAD_URL != null) {
                downloadUrl = '' + this.config.DOWNLOAD_URL;
                downloadUrl += '&path=' + path + '&callback=asdf';
            }

            downloadUrl += '&raw=html';
            downloadUrl += '&attachment=1';
            //downloadUrl += '&send=1';

            var aParams = utils.getUrlArgs(location.href);

            utils.mixin(aParams, {
                "service": serviceClass + ".get",
                "path": path,
                "callback": "asdf",
                "raw": "html",
                "attachment": "1",
                "send": "1"
            });

            delete  aParams['theme'];
            delete  aParams['debug'];
            delete  aParams['width'];
            delete  aParams['attachment'];
            delete  aParams['send'];
            var pStr = dojo.toJson(aParams);
            var signature = SHA1._hmac(pStr, this.config.RPC_PARAMS.rpcSignatureToken, 1);
            //console.error('sign ' + pStr + ' with ' + this.config.RPC_PARAMS.rpcSignatureToken + ' to ' + signature,aParams);
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcUserField + '=' + this.config.RPC_PARAMS.rpcUserValue;
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcSignatureField + '=' + signature;

            window.open(downloadUrl);
            //http://localhost/projects/x4mm/Code/test2.php?view=smdCall&debug=true&service=XCOM_Directory_Service.get&path=cm9vdCUzQSUyRiUyRnR1dG9yaWFscy5tZA==&callback=asdf&raw=html&attachment=1&user=21232f297a57a5a743894a0e4a801fc3&sig=81102d7ee14b546b9cd2d5ae3ec69de0c52d9c23
            // http://localhost/projects/x4mm/Code/test2.php?view=smdCall&debug=true&service=XCOM_Directory_Service.get&path=cm9vdCUzQSUyRiUyRnR1dG9yaWFscy5tZA==&callback=asdf&raw=html&attachment=1&user=21232f297a57a5a743894a0e4a801fc3&sig=81102d7ee14b546b9cd2d5ae3ec69de0c52d9c23

        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  File manager only related
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        getImageUrl: function (src, preventCache, extraParams) {

            if (!src) {
                console.error('invalid item!');
            }
            var thiz = this;
            preventCache = location.href.indexOf('noImageCache') != -1 || preventCache === true || src.dirty === true;
            var downloadUrl = this.serviceUrl;
            downloadUrl = downloadUrl.replace('view=rpc', 'view=smdCall');
            var path = utils.buildPath(src.mount, src.path, true);
            path = this.serviceObject.base64_encode(path);

            var serviceClass = this.ctx.getFileManager().serviceClass || 'XCOM_Directory_Service';
            if (downloadUrl.indexOf('?') != -1) {
                downloadUrl += '&';
            } else {
                downloadUrl += '?';
            }
            downloadUrl += 'service=' + serviceClass + '.get&path=' + path + '&callback=asdf';
            if (this.config.DOWNLOAD_URL != null) {
                downloadUrl = '' + this.config.DOWNLOAD_URL;
                downloadUrl += '&path=' + path + '&callback=asdf';
            }
            downloadUrl += '&raw=html';
            downloadUrl += '&attachment=0';
            downloadUrl += '&send=1';
            var aParams = utils.getUrlArgs(location.href);
            utils.mixin(aParams, {
                "service": serviceClass + ".get",
                "path": path,
                "callback": "asdf",
                "raw": "html"
            });



            utils.mixin(aParams, extraParams);

            delete  aParams['theme'];
            delete  aParams['debug'];
            delete  aParams['width'];

            //{"service":"XCOM_Directory_Service.get","path":"cm9vdCUzQSUyRiUyRm1hcmFudHoucG5n","callback":"asdf","raw":"html","attachment":"0","send":"1","width":448} with 6ae3c21684c50742b7fce2e17a97657a to 1da8648ace2aaedfb49d4d1fd6be6c09d7996ef4
            //{"service":"XCOM_Directory_Service.get","path":"cm9vdCUzQSUyRiUyRm1hcmFudHoucG5n","callback":"asdf","raw":"html","attachment":"0","send":"1","width":"448"} with 6ae3c21684c50742b7fce2e17a97657a  to 7c3421b2ca35a106c6cae9f4c78a560beb711979
            var pStr = dojo.toJson(aParams);
            var signature = SHA1._hmac(pStr, this.config.RPC_PARAMS.rpcSignatureToken, 1);
            //http://192.168.1.37/projects/xbox-app/index.php?view=rpc&service=XCOM_Directory_Service.get
            //console.log('sign ' + pStr + ' with ' + this.config.RPC_PARAMS.rpcSignatureToken + ' to ' + signature,aParams);
            //server {"service":"XCOM_Directory_Service.get","path":"cm9vdCUzQSUyRiUyRlNlbGVjdGlvbl8xNjQucG5n","callback":"asdf","raw":"html"}
            //client {"service":"XCOM_Directory_Service.get","path":"cm9vdCUzQSUyRiUyRlNlbGVjdGlvbl8xNjQucG5n","callback":"asdf","raw":"html","attachment":"0","send":"1","width":448}
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcUserField + '=' + this.config.RPC_PARAMS.rpcUserValue;
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcSignatureField + '=' + signature;
            if (preventCache) {
                downloadUrl += '&time=' + new Date().getTime();
            }
            if (extraParams) {
                for (var p in extraParams) {
                    downloadUrl += '&' + p + '=' + extraParams[p];
                }
            }
            return downloadUrl;
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Upload related
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        onFileUploadFailed: function (item) {
            var thiz = this,
                eventKeys = types.EVENTS;
            if (item.dfd) {
                item.dfd.reject(item);
            }
            thiz.filesToUpload.remove(item);
            thiz.publish(eventKeys.ON_UPLOAD_FAILED, {item: item}, thiz);
        },
        onFileUploaded: function (item) {
            var thiz = this,
                eventKeys = types.EVENTS;
            setTimeout(function () {
                var struct1 = {
                    message: '' + item.file.name + ' uploaded to ' + item.dstDir,
                    messageArgs: {}
                };
                thiz.publish(eventKeys.STATUS, struct1, thiz);
                if (item.dfd) {
                    item.dfd.resolve(item);
                }
                thiz.filesToUpload.remove(item);
                thiz.publish(eventKeys.ON_UPLOAD_FINISH, {item: item});
            }, 500);

        },
        getUploadUrl: function () {
            var url = '' + this.serviceUrl;
            url = url.replace('view=rpc', 'view=upload');
            url = url.replace('../../../../', './');
            url += '&service=';
            url += this.serviceClass;
            url += '.put&callback=nada';
            return url;
        },
        initXHRUpload: function (item, autoRename, dstDir, mount) {
            var xhr = new XMLHttpRequest();
            var uploadUrl = this.getUploadUrl();
            var uri = '' + uploadUrl;

            uri += '&mount=' + encodeURIComponent(mount);
            uri += '&dstDir=' + encodeURIComponent(dstDir);

            var thiz = this;
            var upload = xhr.upload;

            upload.addEventListener("progress", function (e) {

                if (!e.lengthComputable) {
                    thiz.onFileUploaded(item);
                } else {
                    var struct = {
                        item: item,
                        progress: e
                    };
                    item.isLoading = true;
                    item.dfd.progress(struct);
                }
            }.bind(this), false);

            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                    if (xhr.responseText && xhr.responseText != 'OK') {
                        var error = utils.getJson(xhr.responseText);
                        if (!error && xhr.responseText.indexOf('Fata Error')) {
                            error = {
                                result: [xhr.responseText],
                                code: 1
                            }
                        }
                        if (error && error.result && lang.isArray(error.result) && error.result.length > 0) {
                            var _message = null;
                            for (var i = 0; i < error.result.length; i++) {
                                thiz.publish(types.EVENTS.ERROR, 'Error uploading : ' + item.name + ' ' + error.result[i], thiz);
                                _message = error.result[i];
                            }
                            if (_message) {
                                item.error = _message;
                            }
                            thiz.onFileUploadFailed(item);
                            thiz.submitNext();
                            return;
                        }
                        if (error && error.error) {
                            thiz.publish(types.EVENTS.ERROR, 'Error uploading : ' + item.name + ' ' + error.error.message, thiz);
                            thiz.onFileUploadFailed(item);
                        }
                    }
                    thiz.onFileUploaded(item);
                    thiz.submitNext();
                }
            }.bind(this);

            upload.onerror = function () {
                thiz.publish(types.EVENTS.ERROR, 'Error uploading : ' + item.name, thiz);
            };
            xhr.open("POST", uri, true);
            return xhr;
        },
        hasLoadingItem: function () {
            for (var i = 0; i < this.filesToUpload.length; i++) {
                if (this.filesToUpload[i].status == 'loading') {
                    return this.filesToUpload[i];
                }
            }
            return false;
        },
        /**
         *
         * @param files
         * @param mount
         * @param path
         * @param callee
         * @param view
         * @returns {Deferred[]}
         */
        upload: function (files, mount, path, callee, view) {
            var dfds = [];
            for (var i = 0; i < files.length; i++) {
                var file = files[i];
                var uploadStruct = {

                    file: files[i],
                    dstDir: '' + path,
                    mount: '' + mount,
                    callee: callee,
                    view: callee,
                    dfd: new Deferred()
                }
                dfds.push(uploadStruct['dfd']);
                this.filesToUpload.push(uploadStruct);
            }
            this.submitNext();
            return dfds;
        },
        sendFileUsingFormData: function (xhr, file) {
            var formData = new FormData();
            formData.append("userfile_0", file.file);
            xhr.send(formData);
        },
        sendFileMultipart: function (item) {
            var auto_rename = false;
            item.status = 'loading';
            var xhr = this.initXHRUpload(item, (auto_rename ? "auto_rename=true" : ""), item['dstDir'], item['mount']);
            //var file = item.file;
            var struct = {
                item: item,
                name: item.name
            };
            this.publish(types.EVENTS.ON_UPLOAD_BEGIN, struct, this);
            if (window.FormData) {
                this.sendFileUsingFormData(xhr, item);
            }
        },
        submitNext: function () {
            var item = this.getNextUploadItem();
            if (item) {
                this.sendFileMultipart(item);
            }
        },
        getNextUploadItem: function () {
            for (var i = 0; i < this.filesToUpload.length; i++) {
                if (this.filesToUpload[i].status == null) {
                    return this.filesToUpload[i];
                }
            }
            return false;
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Error handling
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        onError: function (err) {

            if (err) {
                if (err.code === 1) {

                    if (err.message && lang.isArray(err.message)) {

                        this.publish(types.EVENTS.ERROR, err.message.join('<br/>'), this);
                        return;
                    }
                } else if (err.code === 0) {
                    this.publish(types.EVENTS.STATUS, 'Ok', this);
                }
            }

            var struct = {
                error: err
            };
            this.publish(types.EVENTS.ERROR, struct, this);
        },
        addError: function (def) {
            var thiz = this;
            var _cb = function () {
                thiz.onError();
            };
            def.addCallback(_cb);
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  pre RPC roundup
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        downloadItem: function (src, readyCB) {
            return this.callMethod(types.OPERATION.DOWNLOAD, [src], readyCB, true);
        },
        downloadTo: function (url, mount, dst, readyCB, dstItem) {
            if (dstItem) {
                var thiz = this;
                var _cb = function (result) {

                    var _failed = false;
                    if (result && result.error && result.error.code == 1) {
                        _failed = true;
                    }
                    thiz.publish(types.EVENTS.ON_DOWNLOAD_TO_END, {
                        terminatorItem: dstItem,
                        failed: _failed
                    }, this);

                    readyCB(arguments);
                };

                thiz.publish(types.EVENTS.ON_DOWNLOAD_TO_BEGIN, {
                    dst: dstItem,
                    url: url,
                    items: [dstItem]
                }, this);
            } else {
                console.log('download from remote url have no dest item');
            }

            return this.callMethod(types.OPERATION.DOWNLOAD_TO, [url, mount, dst], _cb, true);
        },
        find: function (mount, conf, readyCB) {
            try {
                return this.callMethod(types.OPERATION.FIND, [mount, conf], readyCB, true);
            } catch (e) {
                debugger;
            }
        },
        getContent: function (mount, path, readyCB, emit) {
            /*
            if(this.getContentE){

                debug && console.log('use electron');
                return this.getContentE.apply(this,arguments);
            }
            */

            if(has('php')) {
                var _path = this.serviceObject.base64_encode(utils.buildPath(mount, path, true));
                return this.callMethod(types.OPERATION.GET_CONTENT, [_path, false, false], readyCB, false);
            }else{
                var def = this._getText(require.toUrl(mount).replace('main.js','') + '/' + path,{
                    sync: false,
                    handleAs: 'text'
                }).then(function(res){
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        logError(e, 'error running RPC');
                    }
                });
                return def;
            }
        },
        setContent: function (mount, path, content, readyCB) {

            this.publish(types.EVENTS.ON_CHANGED_CONTENT, {
                'mount': mount,
                'path': path,
                'content': content
            });

            this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                text: "Did save file : " + mount + '://' + path
            })
            return this.callMethod(types.OPERATION.SET_CONTENT, [mount, path, content], readyCB, true);
        },
        onMessages: function (res) {

            var events = utils.getJson(res.events);
            if (events && lang.isArray(events)) {
                for (var i = 0; i < events.length; i++) {

                    var struct = {
                        path: events[i].relPath
                    };
                    lang.mixin(struct, events[i]);
                    this.publish(events[i].clientEvent, struct, this);
                }
            }
        },
        onErrors: function (res) {},
        init:function(){
            this.stores = [];
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  RPC helpers
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        callMethodEx: function (serverClassIn, method, args, readyCB, omitError) {

            /***
             * Check we the RPC method is in the SMD
             */
            var serviceClass = serverClassIn || this.serviceClass;
            var thiz = this;
            if (this.serviceObject[serviceClass][method] == null) {
                if (omitError === true) {
                    this.onError({
                        code: 1,
                        message: ['Sorry, server doesnt know ' + method]
                    });
                }
                return null;
            }
            /***
             * Build signature
             */
            var params = {};
            params = lang.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);

            /**
             * Mixin mandatory fields
             */
            params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
            this.serviceObject.extraArgs = params;
            this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
            this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
            this.serviceObject[serviceClass][method](args).then(function (res) {

                try {
                    if (readyCB) {

                        readyCB(res);
                    }
                } catch (e) {
                    console.error('bad news : callback for method ' + method + ' caused a crash in service class ' + serviceClass);
                }

                if (res && res.error && res.error.code == 3) {
                    setTimeout(function () {
                        thiz.onMessages(res.error);
                    }, 50);
                }

                if (res && res.error && res.error && res.error.code != 0) {
                    thiz.onError(res.error);
                    return;
                }

                thiz.publish(types.EVENTS.STATUS, {
                    message: 'Ok!'
                }, this);

            }, function (err) {
                thiz.onError(err);
            });


        },
        callMethod: function (method, args, readyCB, omitError) {

            /***
             * Check we the RPC method is in the SMD
             */
            var serviceClass = this.serviceClass;
            try {
                var thiz = this;
                if (this.serviceObject[serviceClass][method] == null) {
                    if (omitError === true) {
                        this.onError({
                            code: 1,
                            message: ['Sorry, server doesnt know ' + method]
                        });
                    }
                    return null;
                }
                /***
                 * Build signature
                 */
                var params = {};
                params = lang.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);


                /**
                 * Mixin mandatory fields
                 */
                params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                this.serviceObject.extraArgs = params;
                this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                var dfd = this.serviceObject[this.serviceClass][method](args);
                dfd.then(function (res) {

                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        console.error('crashed in ' + method);
                        logError(e, 'error running RPC');

                    }

                    if (res && res.error && res.error.code == 3) {
                        setTimeout(function () {
                            thiz.onMessages(res.error);
                        }, 50);
                    }

                    if (res && res.error && res.error && res.error.code == 1) {
                        thiz.onError(res.error);
                        return;
                    }

                    if (omitError !== false) {
                        var struct = {
                            message: 'Ok!'
                        };
                        thiz.publish(types.EVENTS.STATUS, struct, this);
                    }

                }, function (err) {
                    thiz.onError(err);
                });

                return dfd;

            } catch (e) {
                console.error('crash calling method' + e,arguments);
                thiz.onError(e);
                logError(e,'error ');
            }


        },
        _initService: function () {
            this.filesToUpload = [];
            if (!this.serviceObject) {
                this.serviceObject = new RPCService(this.serviceUrl);
                this.serviceObject.config = this.config;
            }
        }
    });
});
define('xwire/WidgetSource',[
    'dcl/dcl'
],function(dcl,Source){
    /**
     * Event based binding source
     */
    return dcl(Source,{
        declaredClass:"xwire.WidgetSource",
        /**
         * Trigger specifies the event name
         * {String|Array}
         */
        trigger:null,
        /**
         * Dijit widget instance
         */
        object:null,
        /**
         * Widget changed its value,
         * @param value
         */
        onTriggered:function(value){

            var thiz=this;

            //skip
            if(this.object && this.object.ignore===true){
                /*this.object.ignore=false;*/
                setTimeout(function(){
                    thiz.object.ignore=false;
                },500);
                return;
            }

            /**
             * forward to owner
             */
            if(this.binding){
                this.binding.trigger({
                    value:value,
                    source:this
                });
            }
        },
        /***
         * Start will subscribe to event specified in trigger
         */
        start:function(){
            var thiz=this;
            this.handle=dojo.connect(this.object,this.trigger, function (value) {
                thiz.onTriggered(value);
            });

        },
        /**
         * Cleanup
         */
        destroy:function(){
            this.handle.remove();
        }
    });
});
define('xwire/DeviceTarget',[
    'dcl/dcl',
    'xide/types',
    'xwire/Target'
],function(dcl,types,Target){
    /**
     * Widget based binding target
     */
    return dcl(Target,{
        declaredClass:"xwire.DeviceTarget",
        /***
         * An optional variable to set before calling a command
         */
        variable:null,
        /**
         * The command to call (uses this.object(Block)) {String}
         */
        command:null,
        /**
         * Run the action
         */
        run:function(data){
            this.inherited(arguments);
            if(this.object){

                if(this.variable){
                    this.object.setVariable(this.variable,data.value,false,false,types.MESSAGE_SOURCE.GUI);
                }

                if(this.command){
                    this.object.callCommand(this.command);
                }
            }
        }
    });
});
define('xwire/main',[
    "xwire/Binding",
    "xwire/Source",
    "xwire/Target",
    "xwire/WidgetSource",
    "xwire/WidgetTarget",
    "xwire/EventSource",
    "xwire/DeviceTarget"
], function(dojo){
});

define('xcf/types',[
    'dojo/_base/declare'
],function(declare){

    return declare("xcf.types", null,
    {

    });
});


define('xaction/types',[
    'xide/types',
    'dojo/_base/lang'
],function(types,lang){

    lang.mixin(types.EVENTS,{
        ON_ACTION_CHANGE_CONTEXT: 'onChangeActionContext',
        ON_ACTION_CONTEXT_CHANGED: 'onActionContextChanged',
        REGISTER_ACTION: 'registerAction',
        SET_ITEM_ACTIONS: 'onSetItemsActions',
        ON_CLIPBOARD_COPY: 'onClipboardCopy',
        ON_CLIPBOARD_PASTE: 'onClipboardPaste',
        ON_CLIPBOARD_CUT: 'onClipboardCut',
        ON_RENDER_ACTIONS: 'onRenderActions',
        ON_DID_ACTION:'onDidAction',
        ON_AFTER_ACTION:'onAfterAction'
    });

    /**
     * Enumeration to define an Action command
     * @enum {string} module:xide/types/Action
     * @memberOf module:xide/types
     */
    types.ACTION =
    {
        LAYOUT: 'View/Layout',
        COLUMNS: 'View/Columns',
        SELECTION: 'File/Select',
        CLIPBOARD: 'Edit/Clipboard',
        UNDO: 'Edit/Undo',
        REDO: 'Edit/Redo',
        CLIPBOARD_COPY: 'Edit/Clipboard/Copy',
        CLIPBOARD_PASTE: 'Edit/Clipboard/Paste',
        CLIPBOARD_CUT: 'Edit/Clipboard/Cut',
        COPY: 'File/Copy',
        MOVE: 'File/Move',
        RENAME: 'File/Rename',
        DELETE: 'File/Delete',
        OPEN: 'File/Open',
        EDIT: 'File/Edit',
        SAVE: 'File/Save',
        SEARCH: 'File/Search',
        TOOLBAR: 'View/Show/Toolbar',
        STATUSBAR: 'View/Show/Statusbar',
        BREADCRUMB: 'View/Show/Breadcrumb',
        HEADER: 'View/Show/Header',
        DOWNLOAD: 'File/Download',
        DOWNLOAD_TO: 'File/downloadTo',
        INFO: 'File/Info',
        COMPRESS: 'File/Compress',
        RELOAD: 'File/Reload',
        UPLOAD: 'File/Upload',
        PREVIEW: 'File/Preview',
        OPEN_IN: 'File/Open In',
        INSERT_IMAGE: 'insertImage',
        COPY_PASTE: 'copypaste',
        DND: 'dnd',
        OPTIONS: 'options',
        NEW_FILE: 'File/New/New File',
        NEW_DIRECTORY: 'File/New/New Folder',
        GET_CONTENT: 'get',
        SET_CONTENT: 'set',
        FIND: 'File/Find',
        CUSTOM: 'custom',
        PERMA_LINK: 'permaLink',
        ADD_MOUNT: 'ADD_MOUNT',
        REMOVE_MOUNT: 'REMOVE_MOUNT',
        EDIT_MOUNT: 'EDIT_MOUNT',
        PERSPECTIVE: 'PERSPECTIVE',
        RUN: 'File/Run',
        GO_UP: 'Navigation/Go Up',
        STOP: 'File/Stop',
        CLOSE: 'View/Close',
        FULLSCREEN: 'View/Fullscreen',
        OPEN_IN_TAB: 'File/OpenInNewTab',
        SOURCE: 'Navigation/Source',
        RIBBON: 'View/Show/Ribbon',
        MAIN_MENU: 'View/Show/MainMenu',
        NAVIGATION: 'View/Show/Navigation',
        BASH_CONSOLE: 'File/Console/Bash',
        JS_CONSOLE: 'File/Console/JS',
        PHP_CONSOLE: 'File/Console/PHP',
        CONSOLE: 'File/Console/PHP',
        SIZE_STATS: 'View/Show/SizeStats',
        WELCOME: 'Window/Welcome'
    };

    types.ACTION_TYPE = {
        MULTI_TOGGLE: 'multiToggle',
        SINGLE_TOGGLE: 'singleToggle'
    }

    types.ACTION_ICON =
    {
        CLIPBOARD_COPY: 'fa-copy',
        CLIPBOARD_PASTE: 'fa-paste',
        UPLOAD: 'fa-upload',
        RENAME: 'el-icon-edit',
        DELETE: 'text-danger fa-remove',
        RELOAD: 'fa-refresh',
        EDIT: 'fa-pencil',
        SAVE: 'fa-floppy-o',
        SEARCH: 'fa-search',
        NEW_DIRECTORY: 'fa-magic',
        NEW_FILE: 'fa-magic',
        RUN: 'text-success el-icon-play',
        COMPRESS: 'fa-file-archive-o',
        EXTRACT: 'fa-folder-open',
        DOWNLOAD: 'fa-download',
        GO_UP: 'fa-level-up',
        TOOLBAR: 'fa-bars',
        STATUSBAR: 'fa-terminal',
        PREVIEW: 'fa-eye',
        MAXIMIZE: 'fa-arrows-alt',
        UNDO: 'fa-undo',
        REDO: 'fa-repeat'

    };

    return types;
});
define('xcf/types/Types',[
    'xaction/types',
    'xide/types/Types',
    'xide/types',
    'xide/utils/ObjectUtils'
], function (aTypes,cTypes,types,utils) {

    /**
     * Flags to define logging outputs per device or view
     *
     * @enum {int} LOGGING_FLAGS
     * @global
     */
    types.LOGGING_FLAGS = {
        /**
         * No logging
         * @constant
         * @type int
         */
        NONE: 0x00000000,
        /**
         * Log in the IDE's global console
         * @constant
         * @type int
         */
        GLOBAL_CONSOLE: 0x00000001,
        /**
         * Log in the IDE's status bar
         * @constant
         * @type int
         */
        STATUS_BAR: 0x00000002,
        /**
         * Create notification popup in the IDE
         * @constant
         * @type int
         */
        POPUP: 0x00000004,
        /**
         * Log to file
         * @constant
         * @type int
         */
        FILE: 0x00000008,
        /**
         * Log into the IDE's dev tool's console
         * @constant
         * @type int
         */
        DEV_CONSOLE: 0x00000010,
        /**
         * Log into the device's IDE console
         * @constant
         * @type int
         */
        DEVICE_CONSOLE: 0x00000020
    };

    /**
     * Help struct for jsDoc
     * @typedef {object} module:xide/types~DeviceInfo
     * @type Object
     * @property {string} host The IP address
     * @property {string} port The port
     * @property {string} scope The scope of the device
     * @property {string} driverId The id of the driver
     * @property {string} protocol The protocol, ie: tcp, serial,..
     * @property {string} devicePath The absolute path to the device's meta file
     * @property {string} id The device model id
     * @property {string} title The title of the device
     * @property {string} source Additional field to carry a source. That might be 'ide' or 'server'.
     * @property {string} deviceScope Field to store the device's scope: user_devices or system_devices
     * @property {string} driverScope Field to store the device's driver scope: user_drivers or system_drivers
     * @property {string} user_devices Absolute path to the user's devices
     * @property {string} system_devices Absolute path to the system devices
     * @property {string} user_drivers Absolute path to the user's drivers
     * @property {string} system_drivers Absolute path to the drivers drivers
     * @property {string} loggingFlags Absolute path to the user's drivers
     * @property {int} serverSide The device's driver runs server side if 1, otherwise 0
     * @property {string} hash A hash for client side. Its build of MD5(host,port,protocol,driverId,driverScope,id,devicePath,deviceScope,source,user_devices,system_devices,system_drivers,user_drivers)
     * @property {DRIVER_FLAGS} driverFlags The driver flags
     * @property {LOGGING_FLAGS} loggingFlags The device's logging flags
     * @property {object} responseSettings Contains the constants for receiving data from a device its being set at initialization time and has this structure:
     * @property {boolean} responseSettings.start 
     */
    
    
    utils.mixin(types.ITEM_TYPE, {
        DEVICE: 'Device',
        DEVICE_GROUP: 'Device Group',
        DRIVER: 'Driver',
        DRIVER_GROUP: 'Driver Group',
        PROTOCOL: 'Protocol',
        PROTOCOL_GROUP: 'Protocol Group'
    });
    
    /**
     * Possible Node-JS service status modes.
     *
     * @constant {Integer.<module:xide/types~SERVICE_STATUS>}
     *     module:xide/types~SERVICE_STATUS
     */
    types.SERVICE_STATUS = {
        OFFLINE: "offline",
        ONLINE: "online",
        TIMEOUT: "timeout"
    };

    /**
     *
     */
    types.PROTOCOL = {
        TCP: 'tcp',
        UDP: 'udp',
        SERIAL: 'serial',
        DRIVER: 'driver',
        SSH: 'ssh',
        MQTT: 'mqtt'
    };

    /**
     * Additional event keys
     * @enum {string} module:xcf/types/EVENTS
     * @extends module:xide/types/EVENTS
     */
    var Events = {
        ON_DEBUGGER_READY: 'onDebuggerReady',
        ON_DEVICE_SELECTED: 'onDeviceSelected',
        ON_DEVICE_GROUP_SELECTED: 'onDeviceGroupSelected',
        ON_PROTOCOL_SELECTED: 'onProtocolSelected',
        ON_PROTOCOL_GROUP_SELECTED: 'onProtocolGroupSelected',
        ON_PROTOCOL_CHANGED:'onProtocolChanged',
        ON_MQTT_MESSAGE:'onMQTTMessage',
        ON_DEVICE_MESSAGE: 'onDeviceMessage',
        ON_DEVICE_MESSAGE_EXT: 'onDeviceMessageExt',
        ON_COMMAND_FINISH:'onCommandFinish',
        ON_COMMAND_ERROR:'onCommandError',
        ON_DEVICE_DISCONNECTED: 'onDeviceDisconnected',
        ON_DEVICE_CONNECTED:'onDeviceConnected',
        ON_DEVICE_COMMAND: 'onDeviceCommand',
        ON_DEVICE_STATE_CHANGED: 'onDeviceStateChanged',
        ON_DEVICE_DRIVER_INSTANCE_READY: 'onDeviceDriveInstanceReady',
        ON_DRIVER_SELECTED: 'onDriverSelected',
        ON_DRIVER_GROUP_SELECTED: 'onDriverGroupSelected',
        ON_DRIVER_VARIABLE_ADDED: 'onDriverVariableAdded',
        ON_DRIVER_VARIABLE_REMOVED: 'onDriverVariableRemoved',
        ON_DRIVER_VARIABLE_CHANGED: 'onDriverVariableChanged',
        ON_DRIVER_COMMAND_ADDED: 'onDriverCommandAdded',
        ON_DRIVER_COMMAND_REMOVED: 'onDriverCommandRemoved',
        ON_DRIVER_COMMAND_CHANGE: 'onDriverVariableChanged',
        ON_SCOPE_CREATED: 'onScopeCreated',
        ON_DRIVER_MODIFIED:'onDriverModified',
        SET_DEVICE_VARIABLES:'setDeviceVariables',
        ON_SERVER_LOG_MESSAGE: 'onServerLogMessage',
        ON_CLIENT_LOG_MESSAGE: 'onClientLogMessage',
        ON_DEVICE_SERVER_CONNECTED:'onDeviceServerConnected'
    }
    
    utils.mixin(types.EVENTS,Events);

    /**
     * Enumeration to define a source type for variable change.
     * @enum module:xide/types/MESSAGE_SOURCE
     * @memberOf module:xide/types
     */
    types.MESSAGE_SOURCE = {
        DEVICE: 'DEVICE',
        GUI: 'GUI',
        BLOX: 'BLOX',
        CODE: 'CODE'
    };

    /**
     *
     * the device state
     * typedef {Object} xide.types~STATE
     *-@memberOf module:xide/types
     * -property {Number|String} [x] - X coordinate of the rectangle. Can be a pixel position, or a string with a 'px' or '%' suffix.
     */


    /**
     * Enumeration to define a device's status
     * @enum {String} module:xide/types/DEVICE_STATE
     * @memberOf module:xide/types
     */
    types.DEVICE_STATE = {
        CONNECTING: 'DeviceIsConnecting',
        CONNECTED: 'DeviceIsConnected',
        SYNCHRONIZING: 'DeviceIsSynchronizing',
        READY: 'DeviceIsReady',
        DISCONNECTED: 'DeviceIsDisconnected',
        DISABLED: 'DeviceIsDisabled'
    };

    /**
     * Keys to define a driver meta property
     * @enum module:xide/types/DRIVER_PROPERTY
     * @memberOf module:xide/types
     */
    types.DRIVER_PROPERTY = {
        CF_DRIVER_NAME: 'CF_DRIVER_NAME',
        CF_DRIVER_ICON: 'CF_DRIVER_ICON',
        CF_DRIVER_CLASS: 'CF_DRIVER_CLASS',
        CF_DRIVER_ID: 'CF_DRIVER_ID',
        CF_DRIVER_COMMANDS: 'CF_DRIVER_COMMANDS',
        CF_DRIVER_VARIABLES: 'CF_DRIVER_VARIABLES',
        CF_DRIVER_RESPONSES: 'CF_DRIVER_RESPONSES'
    };

    /**
     * Keys to define protocol meta properties
     * @enum module:xide/types/PROTOCOL_PROPERTY
     * @memberOf module:xide/types
     */
    types.PROTOCOL_PROPERTY ={
        CF_PROTOCOL_TITLE: 'Title',
        CF_PROTOCOL_ICON: 'CF_PROTOCOL_ICON',
        CF_PROTOCOL_CLASS: 'CF_PROTOCOL_CLASS',
        CF_PROTOCOL_ID: 'CF_PROTOCOL_ID',
        CF_PROTOCOL_COMMANDS: 'CF_PROTOCOL_COMMANDS',
        CF_PROTOCOL_VARIABLES: 'CF_PROTOCOL_VARIABLES',
        CF_PROTOCOL_RESPONSES: 'CF_PROTOCOL_RESPONSES'
    };

    /**
     * Keys to define protocol meta properties
     * @enum module:xide/types/DEVICE_PROPERTY
     * @memberOf module:xide/types
     */
    types.DEVICE_PROPERTY = {
        CF_DEVICE_DRIVER: 'Driver',
        CF_DEVICE_HOST: 'Host',
        CF_DEVICE_PORT: 'Port',
        CF_DEVICE_PROTOCOL: 'Protocol',
        CF_DEVICE_TITLE: 'Title',
        CF_DEVICE_ID: 'Id',
        CF_DEVICE_ENABLED: 'Enabled',
        CF_DEVICE_OPTIONS: 'Options',
        CF_DEVICE_DRIVER_OPTIONS: 'DriverOptions',
        CF_DEVICE_LOGGING_FLAGS: 'Logging Flags'
    };


    /**
     * @enum {int} DEVICE_LOGGING_SOURCE
     * @global
     */
    types.LOG_OUTPUT = {        
        DEVICE_CONNECTED:'Device Connected',
        DEVICE_DISCONNECTED:'Device Disonnected',
        RESPONSE:'Response',
        SEND_COMMAND:'Send Command',
        DEVICE_ERROR:'Device Error'       
    }

    /**
     * @enum {int} DEFAULT_DEVICE_LOGGING_FLAGS
     * @global
     */
    types.DEFAULT_DEVICE_LOGGING_FLAGS = {}

    var LOGGING_FLAGS = types.LOGGING_FLAGS;
    
    types.DEFAULT_DEVICE_LOGGING_FLAGS[types.LOG_OUTPUT.DEVICE_CONNECTED]  = LOGGING_FLAGS.GLOBAL_CONSOLE | LOGGING_FLAGS.POPUP |  LOGGING_FLAGS.STATUS_BAR | LOGGING_FLAGS.DEVICE_CONSOLE;
    types.DEFAULT_DEVICE_LOGGING_FLAGS[types.LOG_OUTPUT.DEVICE_DISCONNECTED]  = LOGGING_FLAGS.GLOBAL_CONSOLE | LOGGING_FLAGS.POPUP |  LOGGING_FLAGS.STATUS_BAR | LOGGING_FLAGS.DEVICE_CONSOLE;
    types.DEFAULT_DEVICE_LOGGING_FLAGS[types.LOG_OUTPUT.RESPONSE] = LOGGING_FLAGS.DEVICE_CONSOLE | LOGGING_FLAGS.GLOBAL_CONSOLE;
    types.DEFAULT_DEVICE_LOGGING_FLAGS[types.LOG_OUTPUT.SEND_COMMAND] = LOGGING_FLAGS.DEVICE_CONSOLE | LOGGING_FLAGS.GLOBAL_CONSOLE;
    types.DEFAULT_DEVICE_LOGGING_FLAGS[types.LOG_OUTPUT.DEVICE_ERROR] = LOGGING_FLAGS.GLOBAL_CONSOLE | LOGGING_FLAGS.POPUP | LOGGING_FLAGS.STATUS_BAR | LOGGING_FLAGS.DEV_CONSOLE | LOGGING_FLAGS.DEVICE_CONSOLE;

    /**
     * Bitmask or flags for device about its driver
     * @enum {int} DRIVER_FLAGS
     * @global
     */
    types.DRIVER_FLAGS ={
        /**
         * Mark the driver for "server side"
         */
        RUNS_ON_SERVER: 2,
        /**
         * Enable protocol's debug message on console
         */
        DEBUG: 4
    };


    var ITEM_TYPES = {
        /**
         *
         * @extends module:xide/types~ITEM_TYPE
         */
        CF_DRIVER_VARIABLE: 'DriverVariable',
        CF_DRIVER_BASIC_COMMAND: 'DriverBasicCommand',
        CF_DRIVER_CONDITIONAL_COMMAND: 'DriverConditionalCommand',
        CF_DRIVER_RESPONSE_VARIABLE: 'DriverResponseVariable'
    };

    utils.mixin(types.ITEM_TYPE,ITEM_TYPES);

    types.BLOCK_GROUPS =
    {
        CF_DRIVER_VARIABLE: 'DriverVariable',
        CF_DRIVER_BASIC_COMMAND: 'DriverBasicCommand',
        CF_DRIVER_CONDITIONAL_COMMAND: 'DriverConditionalCommand',
        CF_DRIVER_RESPONSE_VARIABLE: 'DriverResponseVariable',
        CF_DRIVER_RESPONSE_BLOCKS: 'conditionalProcess',
        CF_DRIVER_RESPONSE_VARIABLES: 'processVariables',
        CF_DRIVER_BASIC_VARIABLES: 'basicVariables'
    };

    types.COMMAND_TYPES =
    {
        BASIC_COMMAND: 'basic',
        CONDITIONAL_COMMAND: 'conditional',
        INIT_COMMAND: 'init'
    };


    /**
     * Mixin new Core types
     */
    utils.mixin(types.ECIType, {
        DEVICE_NETWORK_SETTINGS: types.ECIType.END + 1,
        DRIVER_COMMAND_SETTINGS: 'CommandSettings'
    });

    types.VFS_ROOTS = {

        SYSTEM_DRIVERS: 'system_drivers',
        USER_DRIVERS: 'user_drivers'
    };

    types.SOCKET_SERVER_COMMANDS =
    {
        SIGNAL_MANAGER: 'Manager_command',
        SIGNAL_DEVICE: 'Device_command',
        SIGNAL_RESPONSE: 'WebSocket_response',
        MANAGER_TEST: 'Manager_Test',
        MANAGER_CLOSE_ALL: 'Close_All_Connections',
        MANAGER_STATUS: 'status',
        MANAGER_START_DRIVER: 'startDriver',
        MANAGER_STOP_DRIVER: 'stopDriver',
        DEVICE_SEND: 'Device_Send',
        CALL_METHOD: 'Call_Method',
        RUN_SHELL: 'Run_Shell',
        WATCH: 'Watch_Directory',
        MQTT_PUBLISH:'MQTT_PUBLISH',
        MQTT_SUBSCRIBE:'MQTT_SUBSCRIBE',
        GET_DEVICE_VARIABLES: 'getVariables',
        WRITE_LOG_MESSAGE:'Write_Log_Message'
    };


    return types;
});

/** @module xcf/model/Device */
define('xcf/model/Device',[
    "xdojo/declare",
    "xide/data/Model",
    'xide/data/Source',
    'xide/types',
    'xide/utils',
    'xide/mixins/EventedMixin',

    "xcf/types/Types"
], function(dcl,Model,Source,types,utils,EventedMixin){
     /**
     *
     * Model for a device. It extends the base model class
     * and acts a source.
     *
     * @module xcf/model/Device
     * @extends {module:xide/mixins/EventedMixin}
     * @augments module:xide/data/Model
     * @augments module:xide/data/Source
     */
    return dcl('xcf.model.Device',[Model,Source,EventedMixin],{

        _userStopped:false,
        isServerSide:function(){
            var driverOptions = this.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS);
            return (1 << types.DRIVER_FLAGS.RUNS_ON_SERVER & driverOptions);
        },
        isDebug:function(){
            var driverOptions = this.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS);
            return (1 << types.DRIVER_FLAGS.DEBUG & driverOptions);
        },
        check:function(){
            if(this._startDfd && this._userStopped===true){
                this.reset();
            }
        },
        getStore:function(){
            return this._store;
        },
        getScope:function(){
            var store = this.getStore();
            return store ? store.scope : this.scope;
        },
        isEnabled:function(){
            return this.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_ENABLED) === true;
        },
        shouldReconnect:function(){
            if (this._userStopped) {
                return false;
            }
            return this.isEnabled();
        },
        reset:function(){

            delete this._startDfd;
            this._startDfd = null;
            delete this['blockScope'];
            this['blockScope'] = null;

            delete this.serverVariables;
            this.serverVariables = null;

            delete this['driverInstance'];
            this['driverInstance'] = null;
            this.setState(types.DEVICE_STATE.DISCONNECTED);
        },
        /**
         * @constructor
         * @alias module:xcf/model/Device
         */
        constructor:function(){},
        /**
         * @type {module:xide/types~DEVICE_STATE}
         * @link module:xide/types/DEVICE_STATE
         * @see module:xide/types/DEVICE_STATE
         */
        state:types.DEVICE_STATE.DISCONNECTED,
        /**
         * The driver instance
         * @private
         */
        driverInstance:null,
        /**
         * The block scope of the driver instance (if the device is connected and ready)
         * @private
         */
        blockScope:null,
        /**
         * Returns the block scope of the a driver's instance
         * @returns {module:xblox/model/Scope}
         */
        getBlockScope:function(){
            return this.blockScope;
        },
        /**
         * Returns the driver instance
         * @returns {model:xcf/driver/DriverBase}
         */
        getDriverInstance:function(){
            return this.driverInstance;
        },
        /**
         * Return the driver model item
         * @returns {module:xcf/model/Driver|null}
         */
        getDriver:function(){
            var scope = this.getBlockScope();
            if(scope){
                return scope.driver;
            }
            return null;
        },
        /**
         * Return a value by field from the meta database
         * @param title
         * @returns {string|int|boolean|null}
         */
        getMetaValue: function (title) {
            return utils.getCIInputValueByName(this.user,title);
        },
        /**
         * Set a value in the meta database
         * @param title {string} The name of the CI
         * @returns {void|null}
         */
        setMetaValue: function (what,value,publish) {
            var item = this;
            var meta = this.user;
            var ci = utils.getCIByChainAndName(meta, 0, what);
            if(!ci){
                return null;
            }
            var oldValue = this.getMetaValue(what);
            utils.setCIValueByField(ci, 'value', value);

            this[what] = value;
            if(publish!==false){
                var eventArgs = {
                    owner: this.owner,
                    ci: ci,
                    newValue: value,
                    oldValue: oldValue
                };
                return this.publish(types.EVENTS.ON_CI_UPDATE, eventArgs);
            }
        },
        /**
         * Return the internal state icon
         * @param state
         * @returns {string|null}
         */
        getStateIcon:function(state ){
            state = state || this.state;
            switch (state) {
                case types.DEVICE_STATE.DISCONNECTED:
                {
                    return 'fa-unlink iconStatusOff'
                }
                case types.DEVICE_STATE.READY:
                case types.DEVICE_STATE.CONNECTED:
                {
                    return 'fa-link iconStatusOn'
                }
                case types.DEVICE_STATE.SYNCHRONIZING:
                case types.DEVICE_STATE.CONNECTING:
                {
                    return 'fa-spinner fa-spin'
                }
            }
            return 'fa-unlink iconStatusOff';
        },
        /**
         * Set the state
         * @param state
         * @param silent
         */
        setState:function(state,silent){

            if(state==this.state){
                return;
            }
            var oldState = this.state,
                icon = this.getStateIcon(state);

            this.state = state;
            this.set('iconClass',icon);
            this.set('state',state);
            this._emit(types.EVENTS.ON_DEVICE_STATE_CHANGED,{
                old:oldState,
                state:state,
                icon:icon,
                "public":true
            });
        }
    });
});

/** @module xcf/model/Driver */
define('xcf/model/Driver',[
    "dojo/_base/declare",
    "xide/data/Model",
    "xide/utils"
], function(dcl,Model,utils){
    /**
     *
     * Model for a driver. It extends the base model class
     * and acts a source.
     *
     * @module xcf/model/Driver
     * @augments module:xide/mixins/EventedMixin
     * @augments module:xide/data/Model
     * @augments module:xide/data/Source
     */
    return dcl(Model,{
        itemMetaPath:'user.meta',
        getStore:function(){
            return this._store;
        },
        getScope:function(){
            var store = this.getStore();
            return store ? store.scope : this.scope;
        },
        /**
         * Return a value by field from the meta database
         * @param title
         * @returns {string|int|boolean|null}
         */
        getMetaValue: function (title) {
            return utils.getCIInputValueByName(this.user,title);
        },
        /**
         * Set a value in the meta database
         * @param title {string} The name of the CI
         * @returns {void|null}
         */
        setMetaValue: function (what,value,publish) {

            var item = this;
            var meta = this.user;
            var ci = utils.getCIByChainAndName(meta, 0, what);
            if(!ci){
                return null;
            }
            var oldValue = this.getMetaValue(what);
            utils.setCIValueByField(ci, 'value', value);
            this[what] = value;
            if(publish!==false){
                return this.publish(types.EVENTS.ON_CI_UPDATE,{
                    owner: this.owner,
                    ci: ci,
                    newValue: value,
                    oldValue: oldValue
                });
            }
        },
        /**
         * Return the parent folder
         * @returns {module:xcf/model/Driver}
         */
        getParent:function(){
            return this._store.getSync(this.parentId);
        }
    });
});

define('xcf/model/ModelBase',[
    'dcl/dcl',
    "xblox/model/ModelBase"
], function(dcl,ModelBase){
    return dcl(ModelBase,{
        declaredClass:'xcf.model.ModelBase'
    });
});
/** @module xcf/model/Variable */
define('xcf/model/Variable',[
    'dcl/dcl',
    'xide/types',
    "xblox/model/variables/Variable"
], function(dcl,types,Variable){
    /**
     *
     * Model for a variable. It extends the base model class
     * and acts a source.
     *
     * @module xcf/model/Variable
     * @extends module:xblox/model/Variables/Variable
     * @augments module:xide/mixins/EventedMixin
     * @augments module:xide/data/Model
     * @augments module:xide/data/Source
     */
    return dcl(Variable,{

        /**
         * @private
         */
        declaredClass: "xcf.model.Variable",

        /**
         * @private
         */
        hasInlineEdits:true,
        /////////////////////////////////////////////////
        //
        //  On-Change related members
        //
        // 3.12.9.4. a group of options that define a task to be performed when the variable value is changed.
        //
        /////////////////////////////////////////////////
        /**
         * 3.12.9.4.1. on a change to the variable, any object (button, text field, etc.) which references
         * the variable should be evaluated and updated accordingly. If Cmd is selected this should deselect.
         * @private
         */
        gui:"off",
        /**
         * 3.12.9.4.2. on a change to the variable, any command which references the variable
         * should be executed. If GUI is selected this should deselect.
         * @private
         */
        cmd:"off",
        /**
         * 3.12.9.4.3. selecting this checkbox signifies that the variable value automatically gets saved
         * to an xml file whenever changed for recallability.  When active,
         * the Initialize field should show “saved value” and at startup the saved
         * value should be assigned to the variable from the Saved Values File.
         * @private
         */
        save:false,
        /**
         * @private
         */
        target:'None',
        /**
         * The name of the variable
         */
        name:'No Title',
        /**
         * The value of the variable
         */
        value:-1,
        /**
         * @private
         */
        observed:[
            'value',
            'initial',
            'name'
        ],

        solve:function(){

            var extra = "";

            if(this.group=='processVariables'){

                var _val = this.scope.getVariable("value");
                if(_val) {
                    _val = _val.value;
                    if(!this.isNumber(_val)){
                        _val = ''+_val;
                        _val = "'" + _val + "'";
                    }
                    extra = "var value = " + _val +";\n";
                }
            }
            var _result = this.scope.parseExpression(extra + this.getValue(),true);
            return _result;
        },
        /**
         * @private
         * @returns {boolean}
         */
        canEdit:function(){
            return true;
        },
        /**
         * @private
         * @returns {boolean}
         */
        canDisable:function(){
            return false;
        },
        /**
         * @private
         * @returns {*}
         */
        getFields:function(){

            var fields = this.getDefaultFields();

            fields.push(this.utils.createCI('title',13,this.name,{
                group:'General',
                title:'Name',
                dst:'name'
            }));


            var thiz=this,
                defaultArgs = {
                    allowACECache:true,
                    showBrowser:false,
                    showSaveButton:true,
                    editorOptions:{
                        showGutter:false,
                        autoFocus:false,
                        hasConsole:false
                    },
                    aceOptions:{
                        hasEmmet:false,
                        hasLinking:false,
                        hasMultiDocs:false
                    },
                    item:this
                };


            //this.types.ECIType.EXPRESSION_EDITOR
            fields.push(this.utils.createCI('value',this.types.ECIType.EXPRESSION,this.value,{
                group:'General',
                title:'Value',
                dst:'value',
                widget:defaultArgs,
                delegate:{
                    runExpression:function(val,run,error){
                        if(thiz.group=='processVariables'){
                            var _val = thiz.scope.getVariable("value");
                            var extra = "";
                            if(_val) {
                                _val = _val.value;
                                if(!thiz.isNumber(_val)){
                                    _val = ''+_val;
                                    _val = "'" + _val + "'";
                                }
                                extra = "var value = " + _val +";\n";
                            }
                        }
                        return thiz.scope.expressionModel.parse(thiz.scope,extra + val,false,run,error);
                    }
                }
            }));


/*
            //this.types.ECIType.EXPRESSION_EDITOR
            fields.push(this.utils.createCI('initial',this.types.ECIType.EXPRESSION,this.initial,{
                group:'General',
                title:'Initial',
                dst:'initial',
                widget:defaultArgs,
                delegate:{
                    runExpression:function(val,run,error){
                        if(thiz.group=='processVariables'){
                            var _val = thiz.scope.getVariable("value");
                            var extra = "";
                            if(_val) {
                                _val = _val.value;
                                if(!thiz.isNumber(_val)){
                                    _val = ''+_val;
                                    _val = "'" + _val + "'";
                                }
                                extra = "var value = " + _val +";\n";
                            }
                        }
                        return thiz.scope.expressionModel.parse(thiz.scope,extra + val,false,run,error);
                    }
                }
            }));
            */

            return fields;
        },
        onChangeField:function(field,newValue,cis) {
            //console.log('-change field ' + field);
            if(field==='value'){
                this.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                    item: this,
                    scope: this.scope,
                    save: false,
                    source: types.MESSAGE_SOURCE.GUI  //for prioritizing
                });
            }
        }
    });
});




/** @module xcf/manager/BeanManager **/
define('xcf/manager/BeanManager',[
    'dcl/dcl',
    "xdojo/declare",
    "dojo/_base/lang",
    'xide/types',
    'xide/utils',
    'xide/manager/BeanManager',
    'xdojo/has!xcf-ui?xide/views/ActionDialog',
    'xdojo/has!xcf-ui?xide/views/CIActionDialog',
    'xdojo/has!xcf-ui?xide/views/CIGroupedSettingsView'
], function (dcl,declare,lang,types, utils, BeanManager,registry,ActionDialog, CIActionDialog, CIGroupedSettingsView){
    /**
     * @class module:xcf/manager/BeanManager
     * @extends module:xide/manager/BeanManager
     */
    return dcl(BeanManager, {
        declaredClass:"xcf.manager.BeanManager",
        /**
         * Url generator for device/driver/[command|block|variable]
         *
         * @param device
         * @param driver
         * @param block
         * @param prefix
         * @returns {*}
         */
        toUrl:function(device, driver, block, prefix) {

            prefix = prefix || '';
            var pattern = prefix + "deviceScope={deviceScope}&device={deviceId}&driver={driverId}&driverScope={driverScope}&block={block}";
            var url = lang.replace(
                pattern,
                {
                    deviceId: device.id,
                    deviceScope: device.scope,
                    driverId: driver.id,
                    driverScope: driver.scope,
                    block: block.id
                });
            return url;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Bean Editing
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /***
         * openItemSettings creates a new settings view for a protocol
         * @param item
         * @returns {xide.views.CIGroupedSettingsView|null}
         */
        openItemSettings: function (item,device) {

            //1. sanity check
            var userData = item.user;


            if (!userData || !userData.inputs) {
                return null;
            }

            //2. check its not open already
            var viewId = this.getViewId(item);
            var view = registry.byId(viewId);
            try {
                if (view) {
                    if (view.parentContainer) {
                        view.parentContainer.selectChild(view);
                    }
                    return null;
                }
            } catch (e) {
                utils.destroy(view);
            }

            var docker = this.ctx.mainView.getDocker(),
                title = this.getMetaValue(item, this.itemMetaTitleField),
                devinfo = device ? this.ctx.getDeviceManager().toDeviceControlInfo(device) : null;

            var parent = docker.addTab(null, {
                title: (title || item.name) + '' + (device ? ':' + device.name + ':' + devinfo.host + ':' : ''),
                icon: this.beanIconClass
            });


            //@Todo:driver, store device temporarly in Commands CI
            var commandsCI = utils.getCIByChainAndName(userData, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS);
            if(commandsCI){
                commandsCI.device = device;
            }

            if(item.blockScope && !item.blockScope.serviceObject){
                item.blockScope.serviceObject = this.serviceObject;

            }
            return utils.addWidget(CIGroupedSettingsView,{
                cis: userData.inputs,
                storeItem: item,
                iconClass: this.beanIconClass,
                id: viewId,
                delegate: this,
                storeDelegate: this,
                blockManager: this.ctx.getBlockManager(),
                options:{
                    groupOrder: {
                        'General': 1,
                        'Settings': 2,
                        'Visual':3
                    }
                }
            }, this, parent, true);

        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Bean Management
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         * Creates new group item dialog
         */
        newGroup: function () {

            var thiz = this,
                currentItem = this.getItem(),
                parent = currentItem ? currentItem.isDir === true ? currentItem.path : '' : '';

            var actionDialog = new CIActionDialog({
                title: 'New '  + this.groupType,
                delegate: {
                    onOk: function (dlg, data) {

                        var title = utils.getCIInputValueByName(data, 'Title');
                        var scope = utils.getCIInputValueByName(data, 'Scope');
                        var _final = parent + '/' + title;

                        thiz.createGroup(scope, _final, function (response) {

                            var newItem = thiz.createNewGroupItem(title, scope, parent);
                            thiz.store.putSync(newItem);
                            thiz.publish(types.EVENTS.ON_STORE_CHANGED, {
                                owner: thiz,
                                store: thiz.store,
                                action: types.NEW_DIRECTORY,
                                item: newItem
                            });
                        });
                    }
                },
                cis: [
                    utils.createCI('Title', 13, ''),
                    utils.createCI('Scope', 3, this.defaultScope, {
                        "options": [
                            {
                                label: 'System',
                                value: this.defaultScope
                            },
                            {
                                label: 'User',
                                value: this.userScope
                            },
                            {
                                label: 'App',
                                value: this.appScope
                            }
                        ]
                    })
                ]
            });
            actionDialog.startup();
            actionDialog.show();
        },
        onDeleteItem: function (item) {

            var isDir = utils.toBoolean(item.isDir) === true;
            //pick the right service function
            var removeFn = isDir ? 'removeGroup' : 'removeItem';
            var thiz = this;
            var actionDialog = new ActionDialog({
                title: 'Remove ' + this.beanName +   (isDir ? ' Group' : '') + ' ' + "\"" + item.name + "\"  ",
                style: 'max-width:400px',
                titleBarClass: 'text-danger',
                delegate: {
                    isRemoving: false,
                    onOk: function (dlg) {
                        thiz[removeFn](
                            utils.toString(item.scope),
                            utils.toString(item.path),
                            utils.toString(item.name),
                            function () {

                                thiz.onItemDeleted(item);

                                thiz.publish(types.EVENTS.ON_STORE_CHANGED, {
                                    owner: thiz,
                                    store: thiz.store,
                                    action: types.DELETE,
                                    item: item
                                });
                            });
                    }
                }
            });
            actionDialog.show();
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Bean protocol
        //
        /////////////////////////////////////////////////////////////////////////////////////
        hasItemActions: function () {
            return true;
        },
        onItemDeleted: function (item) {

            //delete subs
            this.store.removeSync(item.path);

            if(item == this.currentItem) {
                this.currentItem = null;
            }
            if (item) {
                var view = this.getView(item);
                if (view) {
                    utils.destroyWidget(view);
                }
            }
        },
        onItemSelected: function (item) {
            this.currentItem = item;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI-Callbacks
        //
        /////////////////////////////////////////////////////////////////////////////////////
        onCIUpdate: function (evt) {
            if (evt['owner'] === this) {
                this.updateCI(evt.ci, evt.newValue, evt.oldValue, evt.storeItem);
            }
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Bean utils
        //
        /////////////////////////////////////////////////////////////////////////////////////
        createNewGroupItem: function (title, scope, parent) {
            return this.createItemStruct(title, scope, parent, title, true, this.groupType);
        },
        createNewItem: function (title, scope, parent) {
            return this.createItemStruct(title, scope, parent, parent + "/" + title, false, this.itemType);
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        // main
        //
        /////////////////////////////////////////////////////////////////////////////////////
        init: function () {
            this.subscribe(types.EVENTS.ON_CI_UPDATE);
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Server methods (PHP)
        //
        /////////////////////////////////////////////////////////////////////////////////////
        createItem: function (scope, path, title, meta,code) {
            return this.runDeferred(null, 'createItem', [scope, path, title, meta, code]);
        },
        /***
         * ls is enumerating all drivers in a given scope
         * @param scope{string}
         * @returns {Deferred}
         */
        ls: function (scope) {

            return this.runDeferred(null, 'ls', [scope]).then(function (data) {
                try {
                    this.rawData = data;
                    this.initStore(data);
                    this.publish(types.EVENTS.ON_STORE_CREATED, {
                        data: data,
                        owner: this,
                        store: this.store,
                        type: this.itemType
                    });
                }catch(e){
                    logError(e,'error ls');
                }
            }.bind(this));
        }
        
    });
});

define('xcf/manager/DeviceManager_Server',["dcl/dcl"], function(dcl){
    return dcl(null,{});
});

/** @module xcf/manager/DeviceManager_DeviceServer */
define('xcf/manager/DeviceManager_DeviceServer',[
    'dcl/dcl',
    "xdojo/declare",
    "dojo/_base/lang",
    'xide/encoding/MD5',
    'xide/types',
    'xide/utils',
    'xide/factory',
    'xdojo/has',
    'dojo/Deferred',
    'xide/mixins/ReloadMixin',
    'xide/mixins/EventedMixin',
    'require',
    //'xdojo/has!host-node?nxapp/utils/_console'
], function (dcl,declare, lang, MD5,
             types, utils, factory, has,
             Deferred,ReloadMixin,EventedMixin,require,_console) {


    var isServer = has('host-node'),
        isIDE = has('xcf-ui');

    var console = typeof window !== 'undefined' ? window.console : console;
    if(_console && _console.error && _console.warn){
        console = _console;
    }

    //debug mqtt activity
    var _debugMQTT = false;

    //debug device - server messages
    var debug = false;
    // debug device server connectivity
    var debugDevice = true;
    var debugStrangers = false;
    var debugConnect = true;
    var debugServerCommands = false;
    var debugCreateInstance = false;
    var debugServerMessages = false;
    /***
     *
     * 1. startDevice
     *      ->createDriverInstance
     *          -> sendManagerCommand(MANAGER_START_DRIVER, cInfo);
     *              ->onDeviceConnected
     *                  serverVariables? ->
     *                      getDeviceServerVariables ->onSetDeviceServerVariables
     *
     *
     */

    /**
     *
     * @class module:xcf.manager.DeviceManager_DeviceServer
     * @augments module:xcf/manager/DeviceManager
     * @augments module:xide/mixins/EventedMixin
     */
    return dcl(null,{
        
        declaredClass:"xcf.manager.DeviceManager_Server",
        /**
         * Starts a device with a device store item
         * @param item
         */
        startDevice: function (item,force) {
            this.checkDeviceServerConnection();
            item.check();
            var dfd = new Deferred();
            if(item._startDfd && !item._startDfd.isResolved()){
                debugDevice && console.error('already starting ' + item.toString());
                return item._startDfd;
            }else{
                !item.driverInstance && item.reset();//fresh
            }

            force==true && item.setMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_ENABLED,true,false);

            var enabled = item.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_ENABLED);

            if(!enabled && force!==true){
                debugDevice && console.error('---abort start device : device is not enabled!' + item.toString());
                this.publish(types.EVENTS.ON_STATUS_MESSAGE,{
                    text:'Can`t start device because its not enabled! ' + item.toString(),
                    type:'error'
                });
                setTimeout(function(){
                    dfd.reject();
                },10);
                return dfd;
            }

            var cInfo = this.toDeviceControlInfo(item);
            if(!cInfo){
                dfd.reject('invalid client info, assuming no driver found');
                return dfd;
            }

            if (!cInfo) {
                console.error('couldnt start device, invalid control info '+ cInfo.toString());
                dfd.reject();
                return dfd;
            }

            var hash = cInfo.hash;
            if (this.deviceInstances[hash]) {
                debugDevice && console.error('device already started' + cInfo.toString());
                dfd.resolve(this.deviceInstances[hash]);
                return dfd;
            }

            item.setState(types.DEVICE_STATE.CONNECTING);

            item._userStopped=null;
            item._startDfd = dfd;

            var thiz = this,
                baseDriverPrefix = this.driverScopes['system_drivers'],
                baseDriverRequire = baseDriverPrefix + 'DriverBase';

            function buildMQTTParams(cInfo,driverInstance,deviceItem,driverItem){
                return {
                    driverScopeId:driverInstance.blockScope.id,
                    driverId:driverInstance.driver.id,
                    deviceId:item.path
                };
            }

            try {
                require([baseDriverRequire], function (baseDriver) {
                    baseDriver.prototype.declaredClass = baseDriverRequire;
                    thiz.createDriverInstance(cInfo, baseDriver, item).then(function (driverInstance) {
                        debugCreateInstance && console.info('created driver instance for '+ cInfo.toString());                        
                        cInfo.mqtt = buildMQTTParams(cInfo, driverInstance, item);
                        thiz.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                            text: 'Trying to connect to ' + cInfo.toString(),
                            type: 'info'
                        });
                        thiz.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MANAGER_START_DRIVER, cInfo);
                        delete cInfo.mqtt;
                    });
                });
            }catch(e){
                logError(e,'DeviceManager::startDevice: requiring base driver at ' + baseDriverRequire + ' failed! Base Driver - Prefix : ' + baseDriverPrefix);
            }

            return dfd;
        },
        /**
         * Creates a driver instance per device
         * @param deviceInfo {module:xide/types~DeviceInfo} The device info
         * @param driverBase {module:xcf/driver/DriverBase} The driver base class
         * @param device {module:xcf/model/Device} The device model item
         */
        createDriverInstance: function (deviceInfo, driverBase, device) {

            var hash = deviceInfo.hash,
                driverPrefix = this.driverScopes[deviceInfo.driverScope],
                requirePath = driverPrefix + deviceInfo.driver;
            
            requirePath = requirePath.replace('.js', '').trim();
            
            var thiz = this,
                ctx = thiz.ctx,
                meta = device['user'],
                driverId = utils.getCIInputValueByName(meta, types.DEVICE_PROPERTY.CF_DEVICE_DRIVER),
                driverManager = ctx.getDriverManager(),
                driver = driverManager.getDriverById(driverId),
                dfd = new Deferred(),
                enabled = device.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_ENABLED),
                serverSide = deviceInfo.serverSide;

            debugCreateInstance && console.log('create driver instance : ' + device.path +":"+device.scope + ' from ' + requirePath,{
                driver:driver,
                device:device,
                deviceInfo:deviceInfo
            });

            if(device.isEnabled()===false){
                debugConnect && console.warn('device not enabled, abort ' + deviceInfo.toString());
                setTimeout(function(){
                    dfd.reject();
                });
                return dfd;
            }

            if(isServer && !device.isServerSide()){
                dfd.reject();
                return dfd;
            }
            debugCreateInstance && console.info('------create driver instance with DriverBase at '+requirePath + ' with driver prefix : ' + driverPrefix,this.driverScopes);
            try {
                require([requirePath], function (driverProtoInstance) {
                    var baseClass = driverBase,
                        baseClasses = [baseClass];

                    var driverProto = dcl([baseClass, EventedMixin.dcl, ReloadMixin.dcl,driverProtoInstance],{});
                    var driverInstance = new driverProto();

                    driverInstance.declaredClass = requirePath;
                    driverInstance.options = deviceInfo;
                    driverInstance.baseClass = baseClass.prototype.declaredClass;
                    driverInstance.modulePath = utils.replaceAll('//', '/', requirePath);
                    driverInstance.delegate = thiz;
                    driverInstance.driver = driver;
                    driverInstance.serverSide = deviceInfo.serverSide;
                    driverInstance.utils = utils;
                    driverInstance.types = types;
                    driverInstance.device = device;
                    driverInstance.getDevice = function(){
                        return this.device;
                    }
                    driverInstance.getDeviceInfo = function(){
                        return this.getDevice().info;
                    }


                    var meta = driver['user'];

                    var commandsCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS);
                    if (commandsCI && commandsCI['params']) {
                        driverInstance.sendSettings = utils.getJson(commandsCI['params']);
                    }

                    var responseCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES);
                    if (responseCI && responseCI['params']) {
                        driverInstance.responseSettings = utils.getJson(responseCI['params']);
                    }
                    try {
                        driverInstance.start();
                        driverInstance.initReload();
                    } catch (e) {
                        console.error('crash in driver instance startup! ' + device.toString());
                        logError(e,'crash in driver instance startup!');
                    }

                    thiz.deviceInstances[hash] = driverInstance;
                    // Build an id basing on : driver id + driver path
                    // "235eb680-cb87-11e3-9c1a-....ab5_Marantz/Marantz.20.meta.json"
                    var scopeId = driverId + '_' + hash + '_' + device.path;
                    if (!driver.blox || !driver.blox.blocks) {
                        debugConnect && console.error('Attention : INVALID driver', device.toString());
                        driver.blox = {
                            blocks: []
                        }
                    }
                    if (isServer && driver.blockPath) {
                        var newBlocks = utils.getJson(utils.readFile(driver.blockPath));
                        newBlocks = driver.blox = utils.getJson(utils.readFile(driver.blockPath));
                    }

                    var scope = ctx.getBlockManager().createScope({
                        id: scopeId,
                        device: device,
                        driver: driver,
                        instance: driverInstance,
                        serviceObject: thiz.serviceObject,
                        ctx: ctx,
                        serverSide: serverSide,
                        getContext: function () {
                            return this.instance;
                        }

                    }, dojo.clone(driver.blox.blocks));

                    //important:
                    driverInstance.blockScope = scope;

                    device.blockScope = scope;
                    device.driverInstance = driverInstance;
                    
                    thiz.getDriverInstance(deviceInfo, true);//triggers to resolve settings

                    //add variable && command functions:
                    isIDE && thiz.completeDriverInstance(driver, driverInstance, device);

                    dfd.resolve(driverInstance);

                    return driverInstance;

                });
            }catch(e){
                console.error('DeviceManager::createDriverInstance:: requiring base driver at ' + requirePath + ' failed ' +e.message,utils.inspect(deviceInfo));
            }
            return dfd;
        },
        /**
         * Callback when server returns the variables of a device
         *
         * @param data
         */
        onSetDeviceServerVariables:function(data){

            //debugDevice && console.log('did set device server variables',data);

            var instance = this.getDriverInstance(data.device, true);
            var device = this.getDeviceStoreItem(data.device);


            if(!device){
                debugDevice && console.log('did set device server variables failed, have no device',data);
                return;
            }

            if(instance){
                var variables = data.variables,
                    scope = instance.blockScope;

                device.serverVariables = data.variables;
                _.each(variables,function(variable){
                    var _var = scope.getVariable(variable.name);
                    if(_var){
                        _var.value = variable.value;
                    }
                });
            }

            this.onDeviceConnected(data);
            device.setState(types.DEVICE_STATE.READY);
            device._startDfd && device._startDfd.resolve(device.driverInstance);
            delete device._startDfd;
            device._startDfd = null;
        },
        /**
         *
         * @param data {Object}
         * @param data.device {module:xide/types~DeviceInfo}
         * @returns {*}
         */
        onDeviceConnected:function(data){

            var deviceStoreItem = this.getDeviceStoreItem(data.device);

            if(!deviceStoreItem && data.device && data.device.state){
                //deviceStoreItem = data.device;
                debugger;

            }
            if(data.isReplay && deviceStoreItem && deviceStoreItem.state ===types.DEVICE_STATE.READY){
                return;
            }
            var instance = this.getDriverInstance(data.device, true) || data.instance;
            if(!instance){
                debugStrangers && !isServer && console.error('--cant find device instance',this.deviceInstances);
                deviceStoreItem && deviceStoreItem.setState(types.DEVICE_STATE.DISCONNECTED);
                return;
            }
            if(!deviceStoreItem){
                debugDevice && console.error('onDeviceConnected:: deviceStoreItem is null');
                return;
            }

            //console.error('weird '+data.device.id + ' ' + data.device.state + ' ' + deviceStoreItem.isServerSide());

            var cInfo = this.toDeviceControlInfo(deviceStoreItem);
            if(!cInfo){
                debugDevice && console.error('onDeviceConnected:: device info  is null');
                return;
            }

            if(isServer && !cInfo.serverSide){
                debugDevice && console.error('onDeviceConnected:: device info is not server side, abort');
            }

            if(instance && deviceStoreItem.serverVariables==null){
                deviceStoreItem.setState(types.DEVICE_STATE.CONNECTED);
                this.getDeviceServerVariables(deviceStoreItem,instance);
                return;
            }
            if (!cInfo) {
                console.error('couldnt start device, invalid control info');
                return;
            }

            var hash = cInfo.hash;

            if (this.deviceInstances[hash]) {
                if(!instance.__didStartBlocks){
                    this.onDeviceStarted(instance,deviceStoreItem,instance.driver);
                }else{
                    //console.error('instance.__didStartBlocks bad ' +hash,instance.__didStartBlocks);
                }
                deviceStoreItem.setState(types.DEVICE_STATE.READY);
                this.publish(types.EVENTS.ON_STATUS_MESSAGE,{
                    text:'Device is Ready <span class="text-success">'+ cInfo.host+':'+cInfo.port + '</span>',
                    type:'success'
                });

                return this.deviceInstances[hash];
            }

            var thiz = this;
            var baseDriverPrefix = this.driverScopes['system_drivers'];
            var baseDriverRequire = baseDriverPrefix + 'DriverBase';

            debugDevice && console.log('device conntected, load base driver with prefix : ' +baseDriverPrefix + ' and final require ' + baseDriverRequire);

            try {
                require([baseDriverRequire], function (baseDriver) {
                    baseDriver.prototype.declaredClass = baseDriverRequire;
                    thiz.createDriverInstance(cInfo, baseDriver, deviceStoreItem);
                });
            }catch(e){
                console.error('requiring base driver at ' + baseDriverRequire + ' failed',e);
            }

        },
        onDeviceDisconnected: function (data) {
            if (data && data.device) {
                var error = data.error;
                var code = error && error.code ? error.code :  error || '';
                var deviceStoreItem = this.getDeviceStoreItem(data.device);
                if(!deviceStoreItem){
                    debugDevice && isIDE && console.error('deviceStoreItem is null');
                    return;
                }

                this.publish(types.EVENTS.ON_STATUS_MESSAGE,{
                    text:'Device has been disconnected ' +'<span class="text-warning">'+ data.device.host+':'+data.device.port + '</span>' + ' :  ' + '<span class="text-danger">' + code + '</span>',
                    type:'info'
                });

                var info = this.toDeviceControlInfo(deviceStoreItem);
                if(info && isServer && !info.serverSide){
                    return;
                }

                //kill old instance
                var instance = this.getDriverInstance(data.device, true);
                if (instance) {
                    this.removeDriverInstance(data.device);
                }
                deviceStoreItem.reset();

                if (deviceStoreItem.state === types.DEVICE_STATE.DISABLED) {
                    deviceStoreItem.setState(types.DEVICE_STATE.DISCONNECTED);
                    return;
                }

                deviceStoreItem.setState(types.DEVICE_STATE.DISCONNECTED);
                function shouldRecconect(item){
                    if(item._userStopped || item.state === types.DEVICE_STATE.DISABLED){
                        return false;
                    }
                    enabled = thiz.getMetaValue(item, types.DEVICE_PROPERTY.CF_DEVICE_ENABLED);
                    if(!enabled){
                        return false;
                    }

                    return true;
                }
                if (deviceStoreItem) {
                    var thiz = this;

                    if(deviceStoreItem.reconnect){
                        return;
                    }
                    deviceStoreItem.reconnect = setTimeout(function(){
                        deviceStoreItem.reconnect=null;
                        if(deviceStoreItem.shouldReconnect()) {
                            if(info) {
                                deviceStoreItem.setState(types.DEVICE_STATE.CONNECTING);
                                debugConnect && console.info('trying to reconnect to ' + info.toString());
                            }

                            //thiz.connectDevice(deviceStoreItem);
                            thiz.startDevice(deviceStoreItem);
                        }
                    },thiz.reconnectDevice);
                }
            }
        },
        getDeviceServerVariables:function(device,driverInstance){
            var scope = driverInstance.blockScope;
            if(!scope){
                console.error(' have no block scope');
                return;
            }
            var basicVariables = scope.getVariables({
                group: types.BLOCK_GROUPS.CF_DRIVER_BASIC_VARIABLES
            });

            var out = [];
            for (var i = 0; i < basicVariables.length; i++) {
                out.push({
                    name:basicVariables[i].name,
                    value:basicVariables[i].value,
                    initial:basicVariables[i].value
                })
            }
            device.setState(types.DEVICE_STATE.SYNCHRONIZING);
            this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.GET_DEVICE_VARIABLES, {
                device:this.toDeviceControlInfo(device),
                variables:out
            });
        },

        onCommandFinish:function(deviceData,message){
            var driverInstance = this.getDriverInstance(deviceData, true);
            if (!driverInstance) {
                return;
            }

            var deviceInfo  = deviceData;
            var device = this.getDeviceStoreItem(deviceInfo);
            var params = message.params || {};
            if(params.src && params.id){
                var scope = driverInstance.blockScope;
                var block = scope.getBlockById(params.src);
                if(block && block.onCommandFinish){
                    block.onCommandFinish(message);
                }
            }
        },
        onCommandError:function(deviceData,message){
            var driverInstance = this.getDriverInstance(deviceData, true);
            if (!driverInstance) {
                return;
            }

            var deviceInfo  = deviceData,
                device = this.getDeviceStoreItem(deviceInfo);

            var params = message.params || {};

            if(params.src && params.id){
                var scope = driverInstance.blockScope;
                var block = scope.getBlockById(params.src);
                if(block && block.onCommandError){
                    block.onCommandError(message);
                }
            }
        },
        /**
         * Primary callback when the device server has received a message from a device.
         *
         * @param evt
         */
        onDeviceServerMessage: function (evt) {

            var dataIn = evt['data'];
            var deviceMessageData = null;
            if (_.isString(dataIn) && dataIn.indexOf('{') !=-1){
                try {
                    /*if (! /^[\[|\{](\s|.*|\w)*[\]|\}]$/.test(dataIn)) {*/
                    deviceMessageData = dojo.fromJson(dataIn);
                    /*}else{*/
                    //console.warn('received non json data...'+dataIn);
                    /*}*/
                } catch (e) {
                    console.error('error parsing device message', evt);
                    return;
                }
            }
            if (!deviceMessageData || !deviceMessageData.data || !deviceMessageData.data.device) {
                debug && console.error('bad device message : ',deviceMessageData);
                return;
            }

            var deviceInfo  = deviceMessageData.data.device;
            if(!deviceInfo){
                debug && console.error('onDeviceServerMessage: cant get device info');
                return;
            }

            if(isServer && !deviceInfo.serverSide){
                return;
            }


            //pick driver instance
            var driverInstance = this.getDriverInstance(deviceMessageData.data.device, true);
            if (!driverInstance) {
                debugDevice && console.error(' onDeviceMessage : failed! Have no device instance for ' + deviceMessageData.data.device.host, deviceMessageData);
                return;
            }


            var device = this.getDeviceStoreItem(deviceInfo);

            if(!device){
                console.error('cant find device : ',deviceInfo);
                return;
            }

            //important: use our info now
            deviceInfo = device.info;

            var state = device.get('state');

            function clear(message){
                delete message['resposeSettings'];
                delete message['driver'];
                delete message['lastResponse'];
                delete message['scope'];
                delete message['driverId'];
                delete message['device'];
                //delete message['src'];
                //delete message['id'];
                delete message['sourceHost'];
                delete message['sourcePort'];
            }

            var message = deviceMessageData.data.deviceMessage;
            var messages = [];
            if (_.isString(message)) {
                messages = driverInstance.split(message);
            }else if(_.isObject(message)){
                clear(message);
                messages = [message];
            }

            var deviceMessages = messages;

            driverInstance.onMessageRaw({
                device: deviceMessageData.data.device,
                message:message
            });

            _.each(messages,function(_message){
                //driver replay as individual message
                driverInstance.onMessage({
                    device: deviceMessageData.data.device,
                    message: _message,
                    raw:message
                });


                //driver replay as broadcast message
                driverInstance.onBroadcastMessage({
                    device: deviceMessageData.data.device,
                    message: _message,
                    raw:message
                });

            });


            if(state !==types.DEVICE_STATE.READY){
                device.set('state',types.DEVICE_STATE.READY);
            }
            var debugDevice = device.isDebug();
            //system replay:
            if (deviceMessageData.event) {

                //before publishing on the public system bus, we do bundle the driver instance
                //together with the origin event from the device server:
                deviceMessageData.data['driverInstance'] = driverInstance;
                //now tell everybody!
                //
                // 'deviceMessageData.event' is a system event and defined in xcf.types.EVENTS.ON_DEVICE_MESSAGE
                //
                // 'deviceMessageData.data' is the actual payload, build by the device server. it comes with this structure :
                //
                //  {
                //      device:{
                //          host:'192.168.1.20',
                //          port:'23',
                //          protocol:'tcp'
                //      },
                //      deviceMessage:'MV58\r@VOL:-220\r',
                //
                //  }
                //
                //  Current Subscribers : DriverManager & this
                //
                this.publish(deviceMessageData.event, deviceMessageData.data);
            }

            if(has('xcf-ui')) {

                //console replay
                var hash = deviceInfo.hash,
                    viewId = hash + '-Console',
                    messages = [],
                    consoleViews = this.consoles[viewId];

                debug && console.log('on_device message '+hash,driverInstance.options);

                device.setState(types.DEVICE_STATE.READY);

                if(debugDevice) {
                    var text = deviceMessageData.data.deviceMessage;
                    if (_.isObject(text)) {

                        clear(text)
                        try {
                            text = JSON.stringify(text);
                        } catch (e) {
                            logError(e, 'error serialize message');
                        }
                    }

                    this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                        text: "Device Message from " + driverInstance.options.host + " : " + '<span class="text-info">' + text + '</span>'
                    })
                }
                //var message = deviceMessageData.data.deviceMessage;

                consoleViews && _.each(consoleViews,function(consoleView){

                    if (consoleView) {

                        var split = true;
                        var hex = false;

                        if(consoleView.console) {
                            var _consoleEditor = consoleView.console.getTextEditor();
                            split = _consoleEditor.getAction("Console/Settings/Split").value;
                            hex = _consoleEditor.getAction("Console/Settings/HEX").value;
                        }

                        messages = [];
                        if (_.isString(message)) {
                            messages = split ? driverInstance.split(message) : [message];
                        }else if(_.isObject(message)){
                            clear(message);
                            messages = [message];
                        }

                        for (var i = 0; i < messages.length; i++) {
                            var _message = messages[i];
                            if (_.isString(_message) && _message.length==0) {
                                continue;
                            }
                            if(hex){
                                _message = utils.stringToHex(_message);
                            }
                            consoleView.log(_message,split,true,types.LOG_OUTPUT.RESPONSE);
                        }
                    }
                });
                this.publish(types.EVENTS.ON_DEVICE_MESSAGE_EXT, {
                    device:device,
                    deviceInfo:deviceInfo,
                    raw:message,
                    messages:deviceMessages
                })
            }
        },
        /**
         * Device Server managment interface
         * @param cmd
         * @param data
         */
        sendManagerCommand: function (cmd, data) {

            this.checkDeviceServerConnection();
            var dataOut = {
                manager_command: cmd
            };
            utils.mixin(dataOut, data);
            if(this.deviceServerClient) {
                var res = this.deviceServerClient.emit(null, dataOut, cmd);
                debugServerCommands && console.log('send manager command ' + cmd,[dataOut,res]);
                return res;
            }else{
                console.error('Send Manager Command ' + cmd +' failed, have no  device Server client');
                this.onHaveNoDeviceServer();
            }
        },
        /***
         *
         * @param driverInstance
         * @param data
         */
        sendDeviceCommand: function (driverInstance, data,src,id,print) {
            this.checkDeviceServerConnection();
            var options = driverInstance.getDeviceInfo();
            var sendOptions = utils.mixin({
                src:src
            },options);
            var dataOut = {
                command: data,
                device_command: 'Device_Send',
                options:options

            };
            utils.mixin(dataOut.options,{
                params:{
                    src:src,
                    id:id
                }
            });

            debug && console.log("Device.Manager.Send.Message : " + dataOut.command.substr(0,30), dataOut);//sending device message
            
            var device = this.getDevice(options.id);
            if(device.isDebug()) {
                this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                    text: "Did send message : " + '<span class="text-warnin">' + dataOut.command.substr(0, 30) + '</span>' + " to " + '<span class="text-info">' + dataOut.host + ":" + dataOut.port + "@" + dataOut.protocol + '</span>'
                })
            }

            //console replay
            var hash = MD5(JSON.stringify(driverInstance.options), 1);
            var viewId = hash + '-Console';
            if(this.deviceServerClient) {
                this.deviceServerClient.emit(null, dataOut, 'Device_Send');
                if(has('xcf-ui') && print!==false) {
                    var consoleViews = this.consoles[viewId];
                    _.each(consoleViews,function(view){
                        var text = '<span class="text-info"><b>' + dataOut.command + '</span>';
                        view.printCommand(text,'');
                    })
                }
            }else{
                this.onHaveNoDeviceServer();
                console.error('this.deviceServerClient is null');
                console.error(' Send Device Command ' + data +'failed, have no  device Server client');
            }
            var command = driverInstance.blockScope.getBlockById(src);
            this.publish(types.EVENTS.ON_DEVICE_COMMAND,{
                device:device,
                command:data,
                deviceInfo:this.toDeviceControlInfo(device),
                name:command ? command.name : ""
            })
        },
        /***
         *
         * @param driverInstance
         * @param data
         */
        callMethod: function (driverInstance,method,args,src,id) {

            this.checkDeviceServerConnection();
            var sendOptions = {
                id:id,
                src:src
            };
            var dataOut = {
                method: method,
                args: args,
                device_command: 'Call_Method',
                params: sendOptions,
                options:driverInstance.options
            }

            if(this.deviceServerClient) {
                this.deviceServerClient.emit(null, dataOut, 'Call_Method');
            }else{
                this.onHaveNoDeviceServer();
            }
        },
        /***
         *
         * @param driverInstance
         * @param data
         */
        runShell: function (driverInstance,method,args,src,id) {
            this.checkDeviceServerConnection();

            var options = driverInstance.options,
                sendOptions = {
                    id:id,
                    src:src
                },
                dataOut = {
                    method:method,
                    args: args,
                    manager_command: 'Run_Shell',
                    host: options.host,
                    port: options.port,
                    protocol: options.protocol,
                    options:sendOptions
                };
            if(this.deviceServerClient) {
                this.deviceServerClient.emit(null, dataOut, 'Run_Shell');
            }else{
                this.onHaveNoDeviceServer();
            }
        },
        /**
         * 
         * @param path
         */
        watchDirectory: function (path,watch) {            
            this.checkDeviceServerConnection();            
            var dataOut = {
                    path:path,
                    watch:watch,
                    manager_command: types.SOCKET_SERVER_COMMANDS.WATCH
                };
            if(this.deviceServerClient) {
                this.deviceServerClient.emit(null, dataOut, types.SOCKET_SERVER_COMMANDS.WATCH);
            }else{
                this.onHaveNoDeviceServer();
            }
        },
        createDeviceServerClient:function(store){
            var thiz = this;
            var dfd = new Deferred();
            this.deviceServerClient = null;
            this.deviceServerClient = factory.createClientWithStore(store, 'Device Control Server', {
                delegate: {
                    onConnected:function(){
                        thiz.onDeviceServerConnected();
                        dfd.resolve();
                        thiz.publish(types.EVENTS.ON_DEVICE_SERVER_CONNECTED);
                    },
                    onLostConnection: function(){
                        thiz.onDeviceServerConnectionLost();
                    },
                    onServerResponse: function (data) {
                        var dataIn = data['data'];
                        var msg = null;
                        if (_.isString(dataIn)) {

                            try {
                                msg = dojo.fromJson(dataIn,false);
                            } catch (e) {
                                msg = dataIn;
                            }

                            debug && !msg && console.error('invalid incoming message',data);

                            msg = msg || {};
                            
                            if (msg && msg.data && msg.data.deviceMessage && msg.data.deviceMessage.event === types.EVENTS.ON_COMMAND_FINISH) {
                                thiz.onCommandFinish(msg.data.device,msg.data.deviceMessage);
                                return;
                            }
                            if (msg.data && msg.data.deviceMessage && msg.data.deviceMessage.event === types.EVENTS.ON_COMMAND_ERROR) {
                                thiz.onCommandError(msg.data.device,msg.data.deviceMessage);
                                return;
                            }
                            if (msg.event === types.EVENTS.ON_DEVICE_DISCONNECTED) {
                                thiz.publish(types.EVENTS.ON_DEVICE_DISCONNECTED, msg.data);
                                return;
                            }

                            if (msg.event === types.EVENTS.SET_DEVICE_VARIABLES) {
                                return thiz.onSetDeviceServerVariables(msg.data);
                            }

                            if (msg.event === types.EVENTS.ON_DEVICE_CONNECTED) {
                                thiz.publish(types.EVENTS.ON_DEVICE_CONNECTED, msg.data);
                                return;
                            }

                            if (msg.event === types.EVENTS.ON_SERVER_LOG_MESSAGE) {
                                thiz.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, msg.data);
                                return;
                            }

                            if (msg.event === types.EVENTS.ON_MQTT_MESSAGE) {
                                thiz.publish(types.EVENTS.ON_MQTT_MESSAGE, msg.data);
                                thiz.onMQTTMessage(msg.data);
                                return;
                            }

                            if (msg.event === types.EVENTS.ON_FILE_CHANGED) {
                                return thiz.ctx.onXIDEMessage(dojo.fromJson(data.data));
                            }

                        }
                        thiz.onDeviceServerMessage(data);
                    }
                }
            });
            if (!this.deviceServerClient) {
                debug && console.log('couldnt connect to device server');
                return;
            } else {
                debug && console.log('did connect to device server');
            }
            this.deviceServerClient.dfd = dfd;
            return this.deviceServerClient;
        }
    });
});

/** @module xcf/mixins/LogMixing **/
define('xcf/mixins/LogMixin',[
    "dcl/dcl",
    'xcf/types/Types',
    'xide/utils'
    ],function (dcl, types, utils) {

    var DEFAULT_LOGGING_FLAGS = types.DEFAULT_DEVICE_LOGGING_FLAGS;

    var Module = dcl(null,{
        /**
         *
         * @param deviceInfo {module:xide/types~DeviceInfo}
         * @param flag {LOGGING_FLAGS}
         * @param source {DEVICE_LOGGING_SOURCE}
         * @returns {boolean}
         */
        hasFlagEx:function(deviceInfo,flag,source){

            var LOGGING_FLAGS = types.LOGGING_FLAGS,
                OUTPUT = types.LOG_OUTPUT,
                flags = deviceInfo.loggingFlags; flags = _.isString(flags) ? utils.fromJson(flags) : flags || {};

            var _flag = flags[source] ? flags[source] : DEFAULT_LOGGING_FLAGS[source];

            if(_flag == null){
                return false;
            }

            if(!(_flag & flag)) {
                return false;
            }

            return true;
        }
    });
    
    Module.DEFAULT_LOGGING_FLAGS = DEFAULT_LOGGING_FLAGS;

    return Module;
});


/** @module xcf/manager/DeviceManager */
define('xcf/manager/DeviceManager',[
    'dcl/dcl',
    "xdojo/declare",
    "dojo/_base/lang",
    'xide/encoding/MD5',
    'xide/types',
    'xide/utils',
    'xide/factory',
    'xcf/manager/BeanManager',
    'xide/mixins/ReloadMixin',
    'xide/mixins/EventedMixin',
    './DeviceManager_Server',
    './DeviceManager_DeviceServer',
    'xide/data/TreeMemory',
    'dojo/has',
    'xide/data/ObservableStore',
    'dstore/Trackable',
    'xcf/model/Device',
    'dojo/Deferred',
    "xide/manager/ServerActionBase",
    "xide/data/Reference",
    'xide/utils/StringUtils',
    'xcf/mixins/LogMixin',
    'xdojo/has!xcf-ui?./DeviceManager_UI',
    'xdojo/has!xexpression?xexpression/Expression'
    //'xdojo/has!host-node?nxapp/utils/_console',
    //"xdojo/has!host-node?nxapp/utils"
], function (dcl,declare, lang, MD5,
             types, utils, factory, BeanManager, ReloadMixin, EventedMixin,
             DeviceManager_Server, DeviceManager_DeviceServer,TreeMemory,has,
             ObservableStore,Trackable,Device,Deferred,ServerActionBase,Reference,StringUtils,
             LogMixin,
             DeviceManager_UI,Expression,_console,xUtils) {
    
    var console = typeof window !== 'undefined' ? window.console : console;
    if(_console && _console.error && _console.warn){
        console = _console;
    }

    var bases = [
        ServerActionBase,
        BeanManager,
        DeviceManager_Server,
        DeviceManager_DeviceServer,
        ReloadMixin.dcl,
        LogMixin
    ],
    _debugMQTT = false,
    _debug = true,
    _debugLogging = false,
    _debugConnect = true,
    isServer = !has('host-browser'),
    isIDE = has('xcf-ui'),
    DEVICE_PROPERTY = types.DEVICE_PROPERTY,
    runDrivers = has('runDrivers'),
    EVENTS = types.EVENTS;
    has('xcf-ui') && bases.push(DeviceManager_UI);
    
    /**
     * Common base class, for server and client.
     * @class module:xcf/manager/DeviceManager
     * @augments module:xide/mixins/EventedMixin
     * @extends module:xcf/manager/BeanManager
     */
    return dcl(bases,{
        declaredClass:"xcf.manager.DeviceManager",
        /***
         * The Bean-Manager needs a unique name of the bean:
         * @private
         */
        beanNamespace: 'device',
        /***
         * The Bean-Manager has some generic function like creating Dialogs for adding new items, please
         * provide a title for the interface.
         * @private
         */
        beanName: 'Device',
        /**
         * the icon class for bean edit views
         * @private
         */
        beanIconClass:'fa-sliders',
        /**
         * Bean group type
         * @private
         */
        groupType:types.ITEM_TYPE.DEVICE_GROUP,
        /**
         * Bean item type
         * @private
         */
        itemType:types.ITEM_TYPE.DEVICE,
        /**
         * The name of the CI in the meta database for the title or name.
         * @private
         */
        itemMetaTitleField:DEVICE_PROPERTY.CF_DEVICE_TITLE,
        /**
         * Name of the system scope
         * @private
         */
        systemScope:'system_devices',
        /**
         * Name of the user scope
         * @private
         */
        userScope:'user_devices',
        /**
         * Name of the app scope
         * @private
         */
        appScope:'app_devices',
        /**
         * Name of the default scope for new created items
         * @private
         */
        defaultScope:'system_devices',
        /***
         * The RPC server class:
         * @private
         */
        serviceClass: 'XCF_Device_Service',
        /***
         * A copy of all devices raw data from the server
         * @private
         */
        rawData: null,
        /***
         * @type {module:xcf/data/Store}
         * @private
         */
        store: null,
        /***
         * {xcf.views.DevicesTreeView}
         * @private
         */
        treeView: null,
        /***
         * {xide.client.WebSocket}
         */
        deviceServerClient: null,
        /***
         *  An array of started device instances.
         *  @private
         */
        deviceInstances: null,
        /***
         *  A map of scope names for module hot reloading
         *  @private
         */
        driverScopes: null,
        /***
         * autoConnectDevices does as it says, on app start, it connects to all known devices of the
         * project
         * @param autoConnectDevices
         * @private
         */
        autoConnectDevices: true,
        /**
         * Consoles is an array of {xide.views.ConsoleViews}. There is one console per device possible
         * @private
         */
        consoles: null,
        /**
         * lastUpTime is being used to recognize a computer suspend hibernate
         * @private
         */
        lastUpTime: null,
        /**
         * @private
         */
        reconnectDevice: 5000,
        /**
         * @private
         */
        reconnectDeviceServer: 5000,
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Device-Related
        //
        /////////////////////////////////////////////////////////////////////////////////////
        getSourceHash:function () {

            var userDirectory = this.ctx.getUserDirectory();

            return userDirectory || "no_user_directory";

        },
        /**
         * Make sure we've a connection to our device-server
         * @private
         */
        checkDeviceServerConnection: function () {
            if(!this.ctx.getNodeServiceManager){
                return true;
            }
            if (!this.deviceServerClient && this.ctx.getNodeServiceManager) {
                var store = this.ctx.getNodeServiceManager().getStore();
                if (!store) {
                    console.error('checkDeviceServerConnection : have no service store');
                    return false;
                }
                this.createDeviceServerClient(store);
            }
            return true;
        },
        /**
         *
         * @param target
         * @param source
         * @private
         */
        addDriverFunctions: function (target, source) {
            for (var i in source) {

                if (i === 'constructor' ||
                    i === 'inherited' ||
                    i == 'getInherited' ||
                    i == 'isInstanceOf' ||
                    i == '__inherited' ||
                    i == 'onModuleReloaded' ||
                    i == 'start' ||
                    i == 'publish' ||
                    i == 'subscribe' ||
                    i == 'getInherited' ||
                    i == 'getInherited'
                ) {
                    continue;
                }
                if (_.isFunction(source[i]) && !target[i]) {
                    target[i] = source[i];//swap
                }
            }
        },
        /**
         *
         * @param driver
         * @param instance
         * @private
         */
        addLoggingFunctions: function (driver, instance) {
            var thiz = this;
            instance.log = function (level, type, message, data) {
                data = data || {};
                var oriData = lang.clone(data);
                data.type = data.type || type || 'Driver';
                if (instance.options) {
                    data.device = instance.options;
                }
                thiz.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, {
                    data: data,
                    level: level || 'info',
                    message: message,
                    details:oriData
                });
            }
        },
        /**
         * An instance of a driver class has been created.
         * We mixin new functions: callCommand, set/get-Variable, log
         * @param driver
         * @param instance
         * @param device
         * @private
         */
        completeDriverInstance: function (driver, instance,device) {
            _debug && console.info('complete driver instance');
            var thiz = this,
                scope = instance.blockScope,
                store = scope.blockStore,
                parentId = device.path,
                commandsRoot = parentId + '_commands',
                variablesRoot = parentId + '_variables';

            
            store.on('delete',function(evt){
                var _isVariable = evt.target.declaredClass.indexOf('Variable') !==-1,
                    _parent = _isVariable  ? variablesRoot : commandsRoot,
                    referenceParent = device._store.getSync(_parent);

                if(referenceParent){
                    referenceParent.refresh();
                }

                var referenceId = _parent + '_reference_'+evt.target.id,
                    reference  = device._store.getSync(referenceId);

                if(reference){
                    reference.refresh();
                }
            });

            function createReference(block,driver,title,icon){
                var _isVariable = block.declaredClass.indexOf('Variable') !==-1;
                var _parent = _isVariable  ? variablesRoot : commandsRoot;
                if(block.declaredClass.indexOf( _isVariable? 'Variable' : 'Command')==-1){
                    return;
                }

                var reference  = new Reference({
                    enabled:true,
                    path: _parent + '_reference_'+block.id,
                    name: title,
                    id: block.id,
                    parentId: _parent,
                    _mayHaveChildren: false,
                    virtual: true,
                    tooltip: true,
                    icon:icon,
                    ref: {
                        driver: driver,
                        item: block,
                        device:device
                    },
                    type: types.ITEM_TYPE.BLOCK
                });

                reference = device._store.putSync(reference);

                block.addReference(reference,{
                    properties: {
                        "name":true,
                        "enabled":true,
                        "value":true
                    },
                    onDelete:true
                },true);

                reference.refresh();
            }

            store.on('added',function(block){
                createReference(block,driver,block.name,block.icon || 'fa-exclamation');
            });

            /**
             * Add 'callCommand'
             * @param title
             */
            instance.callCommand = function (title) {
                var _block = this.blockScope.getBlockByName(title);
                if (_block) {
                    _block.solve(this.blockScope);
                }
            };

            /**
             * Add 'setVariable'
             * @param title
             * @param value
             */
            instance.setVariable = function (title, value, save) {
                var _variable = this.blockScope.getVariable(title);
                if (_variable) {
                    _variable.value = value;
                    _variable.set('value',value);
                } else {
                    _debug &&  console.log('no such variable : ' + title);
                    return;
                }
                thiz.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                    item: _variable,
                    scope: this.blockScope,
                    driver: driver,
                    owner: thiz,
                    save: save === true
                });
            };

            /**
             * Add getVariable
             * @param title
             */
            instance.getVariable = function (title) {
                var _variable = this.blockScope.getVariable(title);
                if (_variable) {
                    return _variable._getArg(_variable.value,false);
                }
                return '';
            };

            /**
             * add log function
             * @param level
             * @param type
             * @param message
             * @param data
             */
            instance.log = function (level, type, message, data) {

                data = data || {};
                var oriData = lang.clone(data);
                data.type = data.type || type || 'Driver';
                if (instance.options) {
                    data.device = instance.options;
                }
                thiz.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, {
                    data: data,
                    level: level || 'info',
                    message: message,
                    details:oriData
                });
            };


            for (var i in driver) {

                if (i === 'constructor' ||
                    i === 'inherited' ||
                    i == 'getInherited' ||
                    i == 'isInstanceOf' ||
                    i == '__inherited' ||
                    i == 'onModuleReloaded' ||
                    i == 'start' ||
                    i == 'publish' ||
                    i == 'subscribe' ||
                    i == 'getInherited' ||
                    i == 'getInherited'
                ) {
                    continue;
                }
                if (lang.isFunction(driver[i]) && !instance[i] /*&& lang.isFunction(target[i])*/) {
                    instance[i] = driver[i];//swap
                }
            }
        },
        /**
         * Callback when we are connected to a device.
         * We use this to fire all looping blocks
         * @param driverInstance {module:xcf/driver/DriverBase} the instance of the driver
         * @param deviceStoreItem {module:xcf/model/Device} the device model item
         * @param driver {module:xcf/model/Driver} the driver model item
         */
        onDeviceStarted: function (driverInstance, deviceStoreItem, driver) {

            _debug && console.log('onDeviceStarted');

            if (!driverInstance || !deviceStoreItem || !driver) {
                _debug && console.log('onDeviceStarted failed, invalid params');
                return;
            }

            var info = this.toDeviceControlInfo(deviceStoreItem),
                serverSide = info.serverSide;

            /**
             * Post work :
             * 1. Start all commands with the 'startup' flag!
             * 2. Todo : update last variables from Atomize server
             * 3. Establish long polling
             */

            //1. fire startup blocks
            var blockScope = driverInstance.blockScope;// ctx.getBlockManager().getScope(driver.id);

            if( (isServer && serverSide) || (!serverSide && !isServer && runDrivers)) {

                var autoBlocks = [];

                var initBlocks = blockScope.getBlocks({
                    group: types.COMMAND_TYPES.INIT_COMMAND
                });

                try {
                    _.each(initBlocks, function (block) {
                        //console.error('start block '+block.id);
                        if (block.enabled !== false && block.__started!== true) {
                            block.solve(blockScope);
                            block.__started = true;
                        }

                    });
                }catch(e){
                    logError(e,"starting init blocks failed");
                }
                autoBlocks = autoBlocks.concat(blockScope.getBlocks({
                    group: types.COMMAND_TYPES.BASIC_COMMAND
                }));

                for (var i = 0; i < autoBlocks.length; i++) {
                    if(autoBlocks[i].enabled && autoBlocks[i].start && autoBlocks[i].__started!==true){
                        autoBlocks[i].start();
                        autoBlocks[i].__started=true;
                    }
                }
            }


            //important to set this before publishing the connected event, otherwise it runs an infity loop

            driverInstance.__didStartBlocks = true;
            this.publish(types.EVENTS.ON_DEVICE_DRIVER_INSTANCE_READY, {
                device: deviceStoreItem,
                instance: driverInstance,
                driver: driver,
                blockScope: blockScope
            });

            this.publish(types.EVENTS.ON_DEVICE_CONNECTED, {
                device: info,
                instance: driverInstance,
                driver: driver,
                blockScope: blockScope
            });
            
            this.ctx.getDriverManager().addDeviceInstance(deviceStoreItem,driver);

        },
        getDevice:function(mixed){
            
            var result = mixed;
            if(_.isString(mixed)){                
                var byId = this.getItemById(mixed);                
                if(byId){
                    result = byId;
                }else{
                    var byPath = this.store.getSync(mixed);
                    if(byPath){
                        result = byPath;
                    }
                }
            }
            return result;
        },
        /**
         * Stops a device with a device model item
         * @param item {module:xcf/model/Device|string}
         */
        stopDevice: function (item) {
            item = this.getDevice(item) || item;
            if(!item){
                console.error('cant find device');
                return;
            }
            this.checkDeviceServerConnection();

            item._userStopped = true;

            var cInfo = this.toDeviceControlInfo(item);
            if(!cInfo){
                console.error('cant find device::no device info',item.toString && item.toString());
                return;
            }

            if(isServer && !cInfo.serverSide){
                return;
            }

            var hash = MD5(JSON.stringify(cInfo), 1);
            if (this.deviceInstances[hash]) {
                this._removeInstance(this.deviceInstances[hash], hash,item);
                delete this.deviceInstances[hash];
                _debugConnect && console.log('-- stop device ' + hash,this.deviceInstances);

            }else{
                _debugConnect && console.log('cant find instance ' + hash);
            }

            !isServer && this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MANAGER_STOP_DRIVER, cInfo);

        },
        /**
         * @TODO: remove back compat
         * @param scope
         * @returns {*}
         */
        getStore:function(scope){
            if(!scope || scope==='system_devices') {
                return this.store;
            }
            var store = this.stores[scope];
            if(store){
                return store;
            }
            if(scope){
                return this.ls(scope);
            }
        },
        /**
         * Get all enabled devices
         * @param enabledOnly
         * @param addDriver
         * @returns {module:xcf/model/Device[]}
         */
        getDevices: function (enabledOnly,addDriver) {
            var store = this.getStore();
            if(!store){
                return [];
            }
            var items = utils.queryStore(store, {
                isDir: false
            });
            if (items._S) {
                items = [items];
            }

            var result = [];
            for (var i = 0; i < items.length; i++) {

                var device = items[i];                
                var enabled = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ENABLED);

                if ((enabledOnly === true && enabled == true || enabled == null) || enabledOnly === false) {
                    result.push(device);
                    if(addDriver==true) {
                        var driverId = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_DRIVER);
                        if (!driverId) {
                            _debug && console.error('device has no driver id!');
                            continue;
                        }
                        var driver = this.ctx.getDriverManager().getItemById(driverId);
                        if (driver){
                            device['driver'] = driver;
                        }
                    }
                }
            }
            return result;
        },
        getStores:function(){

            var stores = [];
            for(var scope in this.stores){
                var store = this.stores[scope];
                if(store){
                    stores.push(store);
                }
            }
            return stores;
        },
        /**
         * Connect to all known devices
         * @private
         */
        connectToAllDevices: function () {

            //console.error('connect to all devices');

            var stores = this.getStores(),
                thiz = this;

            function start(device) {
                thiz.startDevice(device);
            };

            function connect(store){
                if(!store){
                    console.error('have no device store');
                    return;
                }

                var items = utils.queryStore(store, {
                    isDir: false
                });
                if (items._S) {
                    items = [items];
                }

                if(!_.isArray(items)){
                    items = [items];
                }
                for (var i = 0; i < items.length; i++) {
                    var device = items[i];
                    var enabled = thiz.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ENABLED);
                    if (enabled == true || enabled == null) {
                        start(device);
                    }
                }            }
            _.each(stores,connect,this);
        },
        /**
         *
         * @private
         */
        _getLogText: function (str) {
            return moment().format("HH:mm:ss:SSS") + ' ::   ' + str + '';
        },
        _parse: function (scope, expression) {
            var str = '' + expression;
            if (str.indexOf('{{') > 0 || str.indexOf('}}') > 0) {
                console.time('parse expression');
                var _parser = new Expression();
                str = _parser.parse(types.EXPRESSION_PARSER.FILTREX,
                    str, this,
                    {
                        variables: scope.getVariablesAsObject(),
                        delimiters: {
                            begin: '{{',
                            end: '}}'
                        }
                    }
                );
                console.timeEnd('parse expression');
            }else{
                var _text = scope.parseExpression(expression);
                if(_text){
                    str = _text;
                }
            }
            return str;
        },
        /**
         *
         * @param driver
         * @param device
         * @private
         */
        runCommand: function (driver, device) {},
        /**
         * @private
         */
        _lastActions: null,
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Data related
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         *
         * @param rawData
         * @private
         */
        onStoreReloaded: function (rawData) {
            this.completeDeviceStore();
        },
        getInstance:function(mixed){
            var deviceInfo = mixed ? mixed._store ? this.toDeviceControlInfo(mixed) : mixed : null;
            if(!deviceInfo){
                return;
            }
            return this.getDriverInstance(deviceInfo,false);
        },
        /***
         * returns driver instance!
         * @param deviceInfo {module:xide/types~DeviceInfo}
         * @param fillSettings will convert and put CI settings into the driver's instance (member variable)
         * @returns {module:xcf/driver/DriverBase}
         * @private
         */
        getDriverInstance: function (deviceInfo, fillSettings) {
            if (!deviceInfo) {
                console.error('getDriverInstance::have no device info')
                return null;
            }
            for (var i in this.deviceInstances) {

                var instance = this.deviceInstances[i];
                var instanceOptions = instance.options;
                if(!instanceOptions){
                    continue;
                }

                if (instanceOptions.port === deviceInfo.port &&
                    instanceOptions.host === deviceInfo.host &&
                    instanceOptions.protocol === deviceInfo.protocol) {

                    if (fillSettings !== false) {
                        //get settings, if not cached already
                        if (instance && !instance.sendSettings) {
                            //pick driver
                            var driver = this.ctx.getDriverManager().getItemById(deviceInfo.driverId);//driverStore item
                            if (driver) {
                                var meta = driver['user'];
                                var commandsCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS);
                                if (commandsCI && commandsCI['params']) {
                                    instance.sendSettings = utils.getJson(commandsCI['params']);
                                }

                                var responseCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES);
                                if (responseCI && responseCI['params']) {
                                    instance.responseSettings = utils.getJson(responseCI['params']);
                                }
                            }else{
                                _debug && console.warn('getDriverInstance:: cant find driver');
                            }
                        }
                    }
                    return instance;
                }
            }
            return null;
        },
        _reconnectServerTimer:null,
        /**
         * @private
         */
        onDeviceServerConnectionLost:function(){

            if (this.deviceServerClient) {
                this.deviceServerClient.destroy();
                this.deviceServerClient = null;
            }

            if(this._reconnectServerTimer){
                return;
            }
            var thiz = this;
            if(isIDE) {
                thiz.ctx.getNotificationManager().postMessage({
                    message: 'Lost connection to device server, try reconnecting in 5 seconds',
                    type: 'error',
                    showCloseButton: true,
                    duration: 3000
                });
            }
            this._reconnectServerTimer = setTimeout(function(){
                thiz.checkDeviceServerConnection();
                thiz._reconnectServerTimer=null;
            },this.reconnectDeviceServer);
        },
        /**
         *
         * @param msg
         * @private
         */
        onMQTTMessage:function(msg){

            var message=utils.getJson(msg.message);
            var isUs=false;
            if(message){
                var sourceHost = message.sourceHost;
                var sourcePort = message.sourcePort;
                var mqttHost = msg.host;
                var mqttPort = msg.port;
                if(sourceHost && sourcePort){
                    if(sourceHost===mqttHost && sourcePort==mqttPort){
                        isUs=true;
                    }
                }
            }

            if(!isUs) {

                _debugMQTT && console.error('on mqtt message ', [message, msg]);
                //
                var parts=msg.topic.split('/');
                if(parts.length==4 && parts[2]=='Variable' && message.device){
                    var _device = this.getDeviceStoreItem(message.device);
                    if(_device){
                        _debugMQTT && console.error(' on mqtt variable topic ' + msg.topic);
                        var _deviceInfo = this.toDeviceControlInfo(message.device);
                        if(_deviceInfo){
                            var driverInstance = this.getDriverInstance(_deviceInfo);
                            if(driverInstance){
                                var scope = driverInstance.blockScope;
                                var _variable = scope.getVariable(parts[3]);
                                if(_variable){
                                    _debugMQTT && console.error('     received MQTT variable ' +_variable.name + ' = ' +message.value);
                                    _variable.set('value',message.value);
                                    _variable.refresh();
                                }
                            }else{
                                _debugMQTT && console.error('cant find driver instance '+msg.topic);
                            }
                        }else{
                            _debugMQTT && console.error('cant find device info');
                        }
                    }else{
                        console.error('cant find device for : ' + msg.topic);
                    }
                }
            }else{
                _debugMQTT && console.error('same source');
            }
        },
        /**
         * Find a block by url in all instances
         * @param url
         * @returns {*}
         */
        getBlock:function(url){
            for (var id in this.deviceInstances) {
                var instance = this.deviceInstances[id];
                var scope = instance.blockScope;
                var block = scope.resolveBlock(url);
                if(block){
                    return block;
                }
            }
            return this.ctx.getDriverManager().getBlock(url);
        },
        /***
         * Callback when the NodeJS service manager initialized its service store. That may
         * happen multiple times as user can reload the store.
         *
         * @param evt
         * @private
         */
        onNodeServiceStoreReady: function (evt) {

            if (this.deviceServerClient) {
                this.deviceServerClient.destroy();
            }
            var store = evt.store,thiz = this;
            var client = this.createDeviceServerClient(store);
            var connect = has('drivers') && has('devices');
            /*
            if(client && client.dfd){
                thiz.connectToAllDevices();
                client.dfd.then(function(){
                    thiz.connectToAllDevices();
                });
            }else {
                */
                if (this.autoConnectDevices && connect) {
                    setTimeout(function () {
                        thiz.connectToAllDevices();
                    }, 3000);
                }
            /*}*/
        },
        /**
         *
         * @param instance
         * @param modulePath
         * @private
         */
        onDriverUpdated: function (instance, modulePath) {
            return;
        },
        /**
         * Some file has changed, update driver instance
         * @param evt
         * @private
         */
        onModuleReloaded: function (evt) {

            if (this.deviceInstances.length == 0) {//nothing to do
                return;
            }
            var modulePath = utils.replaceAll('//', '/', evt.module);
            var newModule = evt.newModule;
            var found = false;
            for (var i in this.deviceInstances) {

                var instance = this.deviceInstances[i];

                if (instance.modulePath === modulePath ||
                    instance.baseClass === modulePath) {
                    this.mergeFunctions(instance, newModule.prototype);
                    found = true;
                    _debug && console.log('Did update driver code : ' + modulePath,newModule.prototype);
                    if (instance.blockScope) {
                        instance.blockScope.expressionModel.expressionCache = {};
                    }
                    this.onDriverUpdated(instance, modulePath);
                }
            }
        },
        /**
         *
         * @param instance
         * @param hash
         * @param device
         * @private
         */
        _removeInstance: function (instance, hash,device) {

            if (instance.destroy) {
                instance.destroy();
            }
            instance.blockScope && instance.blockScope._destroy();
            delete this.deviceInstances[hash];
            this.ctx.getBlockManager().removeScope(instance.options.id);
            this.ctx.getDriverManager().removeDriverInstance(instance,device);
            device.reset();
        },
        /**
         *
         * @param deviceInfo
         * @private
         */
        removeDriverInstance: function (deviceInfo) {
            var instance = this.getDriverInstance(deviceInfo);
            if(instance){
                this.ctx.getBlockManager().removeScope(instance.options.id);
                if(instance.blockScope){
                    instance.blockScope.destroy();
                }
                instance.destroy();
            }else{
                _debugConnect && console.error('remove instance : cant find!');
            }
            for (var i in this.deviceInstances) {
                if(instance == this.deviceInstances[i]){
                    delete this.deviceInstances[i];
                }
            }
        },
        /**
         *
         * @param item {module:xcf/model/Device} the device
         * @param name {string} the name of the CI
         * @returns {string|int|object|null}
         */
        getMetaValue: function (item, name) {
            var meta = item['user'];
            if (meta) {
                return utils.getCIInputValueByName(meta, name);
            }
            return null;
        },
        /**
         * Return device by host and port
         * @param host {string}
         * @param port {string}
         * @returns {module:xcf/model/Device|null}
         */
        getDeviceByHost: function (host,port) {
            var items = utils.queryStore(this.getStore(), {
                isDir: false
            });
            for (var i = 0; i < items.length; i++) {
                var device = items[i];
                var _host = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_HOST);
                var _port = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_PORT);
                if(_host ==host && _port == port){
                    return device;
                }
            }
            return null;
        },
        /**
         * Returns a device by id
         * @param id {string}
         * @returns {module:xcf/model/Device|null}
         */
        getDeviceById: function (id) {
            var items = utils.queryStore(this.getStore(), {
                isDir: false
            });
            if (items._S) {
                items = [items];
            }
            for (var i = 0; i < items.length; i++) {
                var device = items[i];
                var _id = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ID);
                if(_id == id){
                    return device;
                }
            }
            return null;
        },
        /**
         * Returns all devices by driver id
         * @param id {string} the driver id
         * @returns {module:xcf/model/Device[]}
         */
        getDevicesByDriverId: function (id) {

            var items = utils.queryStore(this.getStore(), {
                isDir: false
            });
            if (items._S) {
                items = [items];
            }
            for (var i = 0; i < items.length; i++) {
                var device = items[i];
                var _id = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ID);
                if(_id == id){
                    return device;
                }
            }
            return null;
        },

        getDeviceStoreItem: function (deviceInfo) {
            if(!deviceInfo){
                return;
            }
            //already device
            if(deviceInfo && deviceInfo._store){
                //return deviceInfo;
            }
            var store = this.getStore();
            var scope = deviceInfo.deviceScope;
            if(scope){
                store = this.getStore(scope);
            }

            if(!store){
                return;
            }

            var items = utils.queryStore(store, {
                isDir: false
            });

            if(!items){
                _debug && !isServer && console.error('store returned nothing ' + deviceInfo.deviceScope);
                return null;
            }
            if(items && !_.isArray(items)){
                items = [items];
            }
            for (var i = 0; i < items.length; i++) {
                var device = items[i],
                    meta = device['user'],
                    host = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_HOST),
                    port = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PORT),
                    id = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_ID),
                    protocol = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PROTOCOL);

                if (port === deviceInfo.port &&
                    host === deviceInfo.host &&
                    protocol === deviceInfo.protocol) {
                    return device;
                }
            }
        },
        /**
         *
         * @param ci
         * @param storeRef
         * @private
         */
        onDriverSettingsChanged: function (ci, storeRef) {
            for (var i in this.deviceInstances) {

                var instance = this.deviceInstances[i];
                //get settings, if not cached already
                if (instance && instance.driver == storeRef) {
                    //pick driver
                    var driver = storeRef;// this.ctx.getDriverManager().getItemById(instance.options.id);//driverStore item
                    var meta = driver['user'];
                    var commandsCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS);
                    if (commandsCI && commandsCI['params'] && commandsCI == ci) {
                        instance.sendSettings = utils.getJson(commandsCI['params']);
                    }
                    var responseCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES);
                    if (responseCI && responseCI['params']) {
                        instance.responseSettings = utils.getJson(responseCI['params']);
                    }
                    break;
                }
            }
        },
        /**
         * @private
         */
        onDeviceStateChanged: function (item,silent) {
            if(item._userStopped !==true &&  silent!==true && item.info && item.state && item.state ==types.DEVICE_STATE.DISCONNECTED){
                this.ctx.getNotificationManager().postMessage({
                    message:'Lost connection to ' + item.info.host + ', ...reconnecting',
                    type:'error',
                    showCloseButton: false,
                    duration:1500
                });
            }
            if(silent!==true && item.info && item.state && item.state ==types.DEVICE_STATE.CONNECTED){
                this.ctx.getNotificationManager().postMessage({
                    message:'Connected to ' + item.info.host + '',
                    type:'success',
                    showCloseButton: false,
                    duration:2000
                });
            }
        },
        /**
         *
         * @param item
         * @returns {*}
         * @private
         */
        connectDevice:function(item){
            this.checkDeviceServerConnection();            
            var cInfo = this.toDeviceControlInfo(item);
            if (!cInfo) {
                console.error('couldnt start device, invalid control info');
                return;
            }
            var hash = MD5(JSON.stringify(cInfo), 1);
            if (this.deviceInstances[hash]) {
                _debugConnect && console.log('device already connected', cInfo);
                item.setState(types.DEVICE_STATE.CONNECTED);
                return this.deviceInstances[hash];
            }
            item.setState(types.DEVICE_STATE.CONNECTING);
            this.publish(types.EVENTS.ON_STATUS_MESSAGE,{
                text:'Trying to connect to ' + cInfo.toString(),
                type:'info'
            });
            this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MANAGER_START_DRIVER, cInfo);
        },
        /**
         * client application ready, mixin instances and block scopes
         * @param evt
         * @private
         */
        onAppReady: function (evt) {
            var appContext = evt.context;
            appContext.deviceManager = this;
            appContext.driverManager = this;
            if (appContext.blockManager) {
                utils.mixin(appContext.blockManager.scopes, this.ctx.getBlockManager().scopes);
            }
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Server methods (NodeJs)
        //
        /////////////////////////////////////////////////////////////////////////////////////

        /**
         * @private
         */
        onHaveNoDeviceServer:function(){
            if(!this.ctx.getNotificationManager()){
                return;
            }
            var thiz = this;
            var msg = this.ctx.getNotificationManager().postMessage({
                message:'Have no device server connection',
                type:'error',
                showCloseButton: true,
                duration:1500,
                actions: {
                    reconnect: {
                        label: 'Reconnect',
                        action: function() {
                            thiz.checkDeviceServerConnection();
                            return msg.update({
                                message: 'Reconnecting...',
                                type: 'success',
                                actions: false,
                                duration:1500
                            });
                        }
                    }
                }
            });
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Server methods (PHP)
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /***
         * setDriverScriptContent is storing a driver's actual code in a given scope on the server
         * @param scope {string}
         * @param path  {string}
         * @param content  {string}
         * @param readyCB   {function}
         * @param errorCB   {function}
         * @returns {*}
         * @private
         */
        setDriverScriptContent: function (scope, path, content, readyCB, errorCB) {
            return this.callMethodEx(null, 'setDriverContent', [scope, path, content], readyCB, true);
        },
        /***
         * getDriverScriptContent is receiving a driver's actual code in a given scope
         * @param scope {string}
         * @param path  {string}
         * @param readyCB   {function}
         * @param errorCB   {function}
         * @returns {*}
         */
        getDriverScriptContent: function (scope, path, readyCB, errorCB) {
            return this.callMethodEx(null, 'getDriverContent', [scope, path], readyCB, true);
        },
        createStore:function(data,scope,track){
            var storeClass = declare('deviceStore',[TreeMemory,Trackable,ObservableStore],{});
            var store = new storeClass({
                data: data.items,
                idProperty: 'path',
                Model:Device,
                id:utils.createUUID(),
                scope:scope,
                observedProperties:[
                    "name",
                    "state",
                    "iconClass",
                    "enabled"
                ]
            });
            if(scope && !this.stores[scope] && track!==false){
                this.stores[scope] = store;
            }

            if(!this.store && scope ==='system_devices'){
                this.store = store;
            }
            return store;
        },
        /**
         *
         * @param data
         * @returns {exports|module.exports|module:xcf/data/Store}
         * @private
         */
        initStore: function (data,scope) {
            return this.createStore(data,scope);
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Utils
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         *
         * @param item
         * @private
         */
        fixDeviceCI:function(item){
            var meta = item['user'];
            var driverOptions= utils.getCIByChainAndName(meta, 0, DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS);
            if(!driverOptions) {
                meta.inputs.push({
                    "chainType": 0,
                    "class": "cmx.types.ConfigurableInformation",
                    "dataRef": "",
                    "dataSource": "",
                    "description": null,
                    "enabled": true,
                    "enumType": "-1",
                    "flags": -1,
                    "group": 'Common',
                    "id": DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS,
                    "name": DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS,
                    "order": 1,
                    "params": null,
                    "platform": null,
                    "title": "Driver Options",
                    "type": 5,
                    "uid": "-1",
                    "value":0,
                    "data":[
                        {
                            value: 2,
                            label: 'Runs Server Side'
                        },
                        {
                            value: 4,
                            label: 'Show Debug Messages'
                        },
                        {
                            value: 8,
                            label: 'Allow Multiple Device Connections'
                        }

                    ],
                    "visible": true,
                    "device": item
                });
            }else{
                driverOptions.data = [
                    {
                        value: 2,
                        label: 'Runs Server Side'
                    },
                    {
                        value: 4,
                        label: 'Show Debug Messages'
                    },
                    {
                        value: 8,
                        label: 'Allow Multiple Device Connections'
                    }

                ];

                driverOptions.group = 'Common'
            }


            var loggingFlags= utils.getCIByChainAndName(meta, 0, DEVICE_PROPERTY.CF_DEVICE_LOGGING_FLAGS);
            if(!loggingFlags) {
                meta.inputs.push({
                    "chainType": 0,
                    "class": "cmx.types.ConfigurableInformation",
                    "dataRef": "",
                    "dataSource": "",
                    "description": null,
                    "enabled": true,
                    "enumType": "-1",
                    "flags": -1,
                    "group": 'Logging',
                    "id": DEVICE_PROPERTY.CF_DEVICE_LOGGING_FLAGS,
                    "name": DEVICE_PROPERTY.CF_DEVICE_LOGGING_FLAGS,
                    "order": 1,
                    "params": null,
                    "platform": null,
                    "title": "Logging Flags",
                    "type": DEVICE_PROPERTY.CF_DEVICE_LOGGING_FLAGS,
                    "uid": "-1",
                    "value":0,
                    "data":[
                        {
                            value: 2,
                            label: 'On Connected'
                        },
                        {
                            value: 4,
                            label: 'On Disconnected'
                        },
                        {
                            value: 8,
                            label: 'On Error'
                        },
                        {
                            value: 16,
                            label: 'Commands'
                        },
                        {
                            value: 32,
                            label: 'Responses'
                        }
                    ],
                    "visible": true,
                    "device": item
                });
            }else{
                loggingFlags.group = "Logging"
            }


            var protocolCI = utils.getCIByChainAndName(meta, 0, DEVICE_PROPERTY.CF_DEVICE_PROTOCOL);
            if(protocolCI){
                protocolCI.type = 3;
                protocolCI.options = [
                    {
                        label:"TCP",
                        value:"tcp"
                    },
                    {
                        label:"UDP",
                        value:"udp"
                    },
                    {
                        label:"Driver",
                        value:"driver"
                    },
                    {
                        label:"SSH",
                        value:"ssh"
                    },
                    {
                        label:"Serial",
                        value:"serial"
                    },
                    {
                        label:"MQTT",
                        value:"mqtt"
                    }
                ]
            }
        },
        /**
         * Return handy info for a device
         * @param {module:xcf/model/Device} item
         * @returns {module:xide/types~DeviceInfo|null}
         */
        toDeviceControlInfo: function (item) {            
            if(!item){
                return null;
            }

            if(!item._store && item.id){
                var _item = this.getItemById(item.id);
                if(_item){
                    item = _item;
                }
            }
            if(!item || !item.path){
                _debug && console.error('not a device');
                var _item = this.getDeviceStoreItem(item);
                if(!_item){
                    return null;
                }
            }
            _debug && !item && console.error('toDeviceControlInfo: invalid device item');
            _debug && !item.user && console.error('toDeviceControlInfo: invalid device item, has no meta');
            
            var meta = item['user'],
                host = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_HOST),
                port = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PORT),
                title = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_TITLE),
                protocol = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PROTOCOL),
                driverId = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_DRIVER),
                options = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_OPTIONS),
                loggingFlags = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_LOGGING_FLAGS),
                driverOptions = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS),
                serverSide = item.isServerSide(),
                result = null;

            this.fixDeviceCI(item);
            var driver = this.ctx.getDriverManager().getDriverById(driverId);
            if (driver) {
                var driverMeta = driver['user'],
                    script = utils.getCIInputValueByName(driverMeta, types.DRIVER_PROPERTY.CF_DRIVER_CLASS),
                    responseCI = utils.getCIByChainAndName(driverMeta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES),
                    responseSettings = {},
                    driverScope = driver['scope'];
                if (responseCI && responseCI['params']) {
                    responseSettings = utils.getJson(responseCI['params']);
                }
                result = {
                    host: host,
                    port: port,
                    protocol: protocol,
                    driver: script ? script.replace('./', '') : '',                    
                    driverId:driverId,
                    driverScope: driverScope,
                    id: item.id,
                    devicePath:item.path,
                    deviceScope:item.getScope(),
                    title:title,                    
                    options:options,                    
                    driverOptions:driverOptions,
                    serverSide:serverSide,                    
                    responseSettings:responseSettings,
                    source:isIDE ? 'ide' : 'server',
                    user_devices:this.ctx.getMount(item.getScope()),
                    system_devices:this.ctx.getMount('system_devices'),
                    system_drivers:this.ctx.getMount('system_drivers'),
                    user_drivers:this.ctx.getMount('user_drivers'),
                    loggingFlags:loggingFlags,
                    toString:function(){
                        return item.getScope() +'://' + this.host + ':'+this.port+'@'+this.protocol;
                    }
                };

                result.hash = MD5(JSON.stringify({
                    host: host,
                    port: port,
                    protocol: protocol,
                    driverId:driverId,
                    driverScope: driverScope,
                    id: item.id,
                    devicePath:item.path,
                    deviceScope:item.getScope(),
                    source:isIDE ? 'ide' : 'server',
                    user_devices:this.ctx.getMount(item.getScope()),
                    system_devices:this.ctx.getMount('system_devices'),
                    system_drivers:this.ctx.getMount('system_drivers'),
                    user_drivers:this.ctx.getMount('user_drivers')
                }), 1);
                
                var userDirectory = this.ctx.getUserDirectory();
                
                if(userDirectory){
                    result.userDirectory = userDirectory;
                }
                
            }else{
                _debug && console.error('cant find driver ' + driverId + ' for '+ item.toString());
            }
            item.info = result;            
            return result;
        },
        /**
         * Return device model item by device id
         * @param itemId
         * @returns {module:xcf/model/Device} The device
         */
        getItemById: function (itemId) {
            if(!this.store || !this.store.data){
                _debug && console.error('Device Manager::getItemById : have no valid store');
                return null;
            }
            
            function search(store){
                var data = store.data,
                    device = _.find(data,{
                        id: itemId
                    });
                if(!device){
                    return null;
                }
                return store.getSync(device.path);
            }

            for(var scope in this.stores){
                var store = this.stores[scope];
                var result = search(store);
                if(result){
                    return result;
                }
            }
            _debug && console.error('Device Manager::getItemById : cant find device with id: ' + itemId);
        },
        /**
         *
         * @param evt
         * @private
         */
        onStoreCreated: function (evt) {
            var thiz = this,
                ctx = thiz.ctx,
                type = evt.type,
                data = evt.data,
                store = evt.store,
                items = store ? utils.queryStore(store, { isDir: false}) : [],
                owner = evt.owner,
                driverManager = this.ctx.getDriverManager();

            if(items && !_.isArray(items)){
               items = [items];
            };

            if(type!==types.ITEM_TYPE.DEVICE){
                return;
            }
            for (var i = 0; i < items.length; i++) {

                var item = store.getSync(items[i].path);
                if(!item){
                    console.error('cant find '+items[i].path);
                    continue;
                }
                if (item._completed != null) {
                    continue;
                }
                item._completed = true;

                var driverId = this.getMetaValue(item, DEVICE_PROPERTY.CF_DEVICE_DRIVER);
                if (!driverId) {
                    console.error('device has no driver id!');
                    continue;
                }
                var driver = driverManager.getItemById(driverId),
                    CIS = item.user;

                //complete CIS
                _.each(CIS.inputs,function(ci){
                    ci.device = item;
                    ci.actionTarget = isIDE ? ctx.mainView.getToolbar() : null;
                    ci.ctx = ctx;

                });
                if (!_.isEmpty(driver)) {
                    if(isIDE) {
                        this.completeDevice(store,item,driver);
                        item.iconClass = item.getStateIcon();
                    }
                }
            }
        },
        /**
         *
         * indirect callback for ON_SERVER_LOG_MESSAGE which tells the device server to
         * log something for us. This might be triggered by xblox/model/logging/Log
         *
         * @param evt {object}
         * @param evt.data {object}
         * @param evt.data.device {module:xide/types~DeviceInfo|null}
         * @param evt.data.details {array}
         * @param evt.data.time {integer}
         * @param evt.data.type {string}
         * @param evt.data.level {string}
         */
        onClientMessage:function(evt){
            this.checkDeviceServerConnection();
            if(this.deviceServerClient){
                _debugLogging && console.log('WRITE_LOG_MESSAGE ',evt);
                this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.WRITE_LOG_MESSAGE, evt);

            }
        },
        /**
         * 
         * @param evt
         */
        onClientLogMessage:function(evt){
            if(!isServer){
                this.onClientMessage(evt);
            }
        },
        /**
         *
         * @param evt
         * @private
         */
        onVariableChanged:function(evt){
            var variable = evt.item,
                scope = evt.scope,
                name = variable.name;
            
            if(name==='value'){
                return;
            }
            if(_debug){
                console.log('on variable changed');
            }

            var value = variable.value,
                driver= scope.driver,
                device = scope.device;

            if(!name || value==null){
                console.error('------------invalid params');
            }

            if(device && device.info) {

                var deviceInfo = device.info,
                    mqttTopic = deviceInfo.host + '/' + deviceInfo.port+'/Variable/' + name;

                _debugMQTT && console.log('send mqtt message ' + mqttTopic);
                this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MQTT_PUBLISH, {
                    topic:mqttTopic,
                    data:{
                        value:value,
                        device:deviceInfo
                    }
                });
            }
            _debug && console.error('on variable changed ' + device.toString());
        },
        /***
         * Common manager function, called by the context of the application
         * @private
         */
        init: function () {
            var thiz = this;
            if(this.initUI){
                this.initUI();
            }
            this.stores = {};
            this.subscribe(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, this.onVariableChanged);
            this.subscribe([
                EVENTS.ON_NODE_SERVICE_STORE_READY,
                EVENTS.ON_MODULE_RELOADED,
                EVENTS.ON_DEVICE_DISCONNECTED,
                EVENTS.ON_DEVICE_CONNECTED,
                EVENTS.ON_CLIENT_LOG_MESSAGE,
                EVENTS.ON_STORE_CREATED
            ]);
            this.deviceInstances = this.consoles = {};
            this.driverScopes = {
                "system_drivers": "system_drivers/",
                "user_drivers": "user_drivers/"
            };
            this.lastUpTime = (new Date()).getTime();            
            setInterval(function () {
                var current = (new Date()).getTime();
                if (current - thiz.lastUpTime > 30000) {
                    thiz.lastUpTime = (new Date()).getTime();
                }
                thiz.lastUpTime = current;
            }, 1000);
        },
        onDeviceServerConnected:function(){},
        //nulled in server mode
        addDeviceInstance:function(device,driver){},
        /***
         * ls is enumerating all drivers in a given scope
         * @param scope{string}
         * @returns {Deferred}
         */
        ls: function (scope) {

            function data(data) {

                try {
                    var store = this.initStore(data, scope);
                    if (scope === 'system_devices') {
                        this.store = store;
                    }
                    this.stores[scope] = store;
                    this.onStoreReady(store);
                    this.publish(types.EVENTS.ON_STORE_CREATED, {
                        data: data,
                        owner: this,
                        store: store,
                        type: this.itemType
                    });
                } catch (e) {
                    logError(e, 'error ls drivers');
                }
            }

            if(has('php')) {
                return this.runDeferred(null, 'ls', [scope]).then(data.bind(this));
            }else{
                var def = this._getText(require.toUrl(scope).replace('main.js','') + scope + '.json',{
                    sync: false,
                    handleAs: 'json'
                }).then(data.bind(this));
                return def;
            }
        },
        /**
         *
         * @param scope
         * @returns {*}
         */
        hasStore:function(scope){
            return this.stores[scope];
        }
    });
});

define('xcf/manager/BlockManager',[
    'dcl/dcl',
    "xdojo/declare",
    "dojo/_base/lang",
    'xide/types',
    'xide/utils',
    'xide/factory',
    'xide/manager/ManagerBase',
    'xblox/manager/BlockManager'
], function (dcl,declare, lang, types, utils, factory, ManagerBase, BlockManager) {

    return dcl([ManagerBase, BlockManager], {
        declaredClass:"xcf.manager.BlockManager",
        //nulled for server mode
        onReady:function(){},
        addDriverFunctions: function (target, source) {

            for (var i in source) {
                var o = source[i];
                if (i === 'constructor' || i === 'inherited') {
                    continue;
                }
                if (lang.isFunction(source[i]) /*&& lang.isFunction(target[i])*/) {
                    target[i] = source[i];//swap
                }
            }
        },
        /**
         * One time call per blox scope creation. This adds various functions
         * to the blox's owner object. This enables expressions to access the
         * object but also block specific functions like getVariable
         * @param obj
         * @param scope
         * @param owner
         */
        setScriptFunctions: function (obj, scope, owner) {

            var thiz = owner;
            if (!scope.context) {
                scope.context = obj;//set the context of the blox scope
            }
            /*obj._scope = scope;*/

            if (!obj.blockScope) {
                obj.blockScope = scope;
            }


            var deviceManager = this.ctx.getDeviceManager();

            //add shortcuts to the device
            if (scope.context) {

                if (scope.context.instance) {//no real driver instance!

                    scope.device = scope.context.instance;//but we have a device less instance

                    /*scope.context = scope.context.instance;*/
                    /*this.addDriverFunctions(obj,scope.context.instance);*/

                } else {
                    /*this.addDriverFunctions(obj,scope.context.instance);*/

                    /*
                    scope.device = {//we have a real device : add 'sendMessage'
                        _object: obj,
                        _scope: scope,
                        sendMessage: function (message) {

                            //case when we've been constructed with no real device
                            if (this._scope && this._scope.context && this._scope.context.instance) {
                                this._scope.context.instance.sendMessage(message);
                                return;
                            }
                            //console.log('sending device message : ' + message);
                            //xlog('sending message : ' + message);
                            //xtrace('test');
                            //xtrace('test');
                            //console.trace("Device.Manager.Send.Message : " + message, this);//sending device message
                        }
                    }
                    */
                }
            } else {
                console.error('scope has no context!');
            }

            //add various functions

            ///////////////////////////////////////////////////////////////////////////////
            //
            //  Commands
            //
            ///////////////////////////////////////////////////////////////////////////////
            /**
             * Add 'setVariable'
             * @param title
             * @param value
             */
            if (!obj.callCommand) {
                obj.callCommand = function (title) {
                    var _block = this.blockScope.getBlockByName(title);
                    if (_block) {
                        _block.solve(this.blockScope);
                    } else {
                        console.log('no such variable : ' + title);
                        return;
                    }
                };
            }

            ///////////////////////////////////////////////////////////////////////////////
            //
            //  Variables
            //
            ///////////////////////////////////////////////////////////////////////////////
            /**
             * Add 'setVariable'
             * @param title
             * @param value
             */
            if (!obj.setVariable) {
                obj.setVariable = function (title, value, save, publish, source) {
                    var _variable = this.blockScope.getVariable(title);
                    if (_variable) {

                        _variable.value = value;
                        _variable.set('value',value);
                        console.log('setting variable ' + title + ' to ' + value);
                    } else {
                        console.log('no such variable : ' + title);
                        return;
                    }


                    if (publish !== false) {
                        thiz.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                            item: _variable,
                            scope: scope,
                            driver: obj,
                            owner: thiz,
                            save: save === true,
                            source: source || types.MESSAGE_SOURCE.BLOX  //for prioritizing
                        });
                    }
                };
            }

            /**
             * Add getVariable
             * @param title
             */
            if (!obj.getVariable) {
                obj.getVariable = function (title) {
                    var _variable = this.blockScope.getVariable(title);
                    if (_variable) {
                        return _variable.value;
                    }
                    return '';
                };
            }

            this.inherited(arguments);
        },
        onReloaded: function () {
            this.init();
        },
        getDeviceVariablesAsEventOptions:function(scope){

            var options = [];
            var _item = function(label,value,intend,selected,displayValue){


                var string="<span style=''>" +label + "</span>";
                var pre = "";
                if(intend>0){
                    for (var i = 0; i < intend; i++) {
                        pre+="&nbsp;";
                        pre+="&nbsp;";
                        pre+="&nbsp;";
                    }
                }
                return {
                    label:pre + string,
                    label2:displayValue,
                    value:value/*,
                     selected:selected*/
                };
            };

            var driverManager = this.ctx.getDriverManager();
            var deviceManager = this.ctx.getDeviceManager();
            var items = deviceManager.getDevices(false,true);

            for (var i = 0; i < items.length; i++) {
                var device = items[i];
                var driver = device.driver;
                if(!driver){
                    continue;
                }

                var title = deviceManager.getMetaValue(device, types.DEVICE_PROPERTY.CF_DEVICE_TITLE);
                options.push(_item(title,driver.id+'/' +driver.id,0,false));

                var blockScope = driver.blockScope;
                var variables = blockScope.getVariables();


                for (var j = 0; j < variables.length; j++) {
                    var variable = variables[j];

                    var value = driver.id + '/'+ variable.id;
                    var selected = ci.value ===value;

                    options.push(_item(variable.title,value,1,selected,title + '/' + variable.title));
                }
            }
        },
        /**
         * Callback for VariableSwitch::getFields('variable').
         *
         * @param evt {object}
         * @param evt.CI {xide/types/ConfigurableInformation}
         * @param evt.owner {xblox/model/variables/Variable} The variable
         */
        onCreateVariableCI:function(evt){

            console.log('onCreateVariableCI12',evt);
            /**
             *
             * 1. check its a ui variable:
             * 2. alter CI
             *
             */
            var ci = evt.CI,
                variable = evt.owner,
                scope = variable.scope,
                isDriverVariable = scope.device!=null;

            console.log('ci value ' + ci.value);

            if(!isDriverVariable){
                return;
            }

            //  create filtering select options, pseudo code:
            //
            //  foreach(device in devices)
            //      let driver in device
            //      createSelect(device name)
            //      foreach(variable in driver)
            //          createSelect(variable,value =  )
            //
            //


            var options = [];
            var _item = function(label,value,intend,selected,displayValue){


                var string="<span style=''>" +label + "</span>";
                var pre = "";
                if(intend>0){
                    for (var i = 0; i < intend; i++) {
                        pre+="&nbsp;";
                        pre+="&nbsp;";
                        pre+="&nbsp;";
                    }
                }
                return {
                    label:pre + string,
                    label2:displayValue,
                    value:value/*,
                    selected:selected*/
                };
            };

            var driverManager = this.ctx.getDriverManager();
            var deviceManager = this.ctx.getDeviceManager();
            var items = deviceManager.getDevices(false,true);

            for (var i = 0; i < items.length; i++) {
                var device = items[i];
                var driver = device.driver;
                if(!driver){
                    continue;
                }

                var title = deviceManager.getMetaValue(device, types.DEVICE_PROPERTY.CF_DEVICE_TITLE);
                options.push(_item(title,driver.id+'/' +driver.id,0,false));

                var blockScope = driver.blockScope;
                var variables = blockScope.getVariables();


                for (var j = 0; j < variables.length; j++) {
                    var variable = variables[j];

                    var value = driver.id + '/'+ variable.id;
                    var selected = ci.value ===value;

                    options.push(_item(variable.name,value,1,selected,title + '/' + variable.title));
                }
            }

            ci.options = options;

            ci.widget = {
                "class":"xide.form.FilterSelect"

            }
        }
    });
});

define('xcf/manager/DriverManager_Server',[
    'dcl/dcl',
    "dojo/_base/lang",
    'dojo/_base/declare',
    'xide/types',
    'xide/utils'
], function(dcl,lang,declare,types,utils){

    function isItemPath(startNeedle,path){

        var _start = startNeedle;
        if (path.indexOf(_start) != -1) {
            var libPath = path.substr(path.indexOf(_start) + (_start.length + 1 ), path.length);
            return libPath;
        }
        return null;
    }

    return dcl(null,{
        declaredClass:'xcf.manager.DriverManager_Server',
        onDriverBlocksChanged:function(dataPath,shortPath){


            var options = [];

            var store = this.getStore() || this.store;

            if (!store) {
                console.error('getDriversAsEnumeration:: have no store!');
                return options;
            }

            var items = store.query({
                isDir: false
            });

            for (var i = 0; i < items.length; i++) {
                var driver = items[i];
                var meta = driver['user'];
                var id = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_ID);
                var title = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_NAME);
                if(!meta || !driver.blockPath){
                    continue;
                }


                if(driver.blockPath.indexOf(shortPath)!==-1){

                }


            }

        },
        onFileChanged:function(evt){

            if(evt.type!=='changed'){
                return;
            }
            if(evt._didb){
                return;
            }
            evt._didb=true;

            var path = utils.replaceAll('\\', '/', evt.path);
            path = utils.replaceAll('//', '/', path);
            path = path.replace(/\\/g,"/");

            ////data/system/drivers/SSH/Hercules.xblox'
            var isDriver = isItemPath('system/driver',path);
            if(isDriver && isDriver.indexOf('.xblox')!==-1){
                console.log('driver blocks changed ' + isDriver + ' @ '+ path, evt);
                this.onDriverBlocksChanged(path,isDriver);
            }
        },
        /**
         *
         * @param storeItem
         * @param readyCB
         */
        createDriverInstance:function(storeItem,readyCB){

            var thiz=this;
            var baseDriverPrefix = this.driverScopes['system_drivers'];

            var baseDriverRequire = baseDriverPrefix + 'DriverBase';

            //console.error(baseDriverRequire);

            require([baseDriverRequire],function(baseDriver){

                baseDriver.prototype.declaredClass=baseDriverRequire;

                var meta = storeItem['user'];
                var driverPrefix = thiz.driverScopes[storeItem['scope']];
                var driver  = utils.getCIInputValueByName(meta,types.DRIVER_PROPERTY.CF_DRIVER_CLASS);
                if(!driver){
                    console.error('cant find driver class in meta');
                    return;

                }
                var requirePath  = driverPrefix + driver;
                requirePath=requirePath.replace('.js','');
                requirePath=requirePath.replace('./','');

                console.log('create driver instance ' + requirePath);


                require([requirePath],function(driverProtoInstance){
                    var baseClass = baseDriver;
                    var baseClasses = [baseClass];

                    var driverProto = declare([baseClass],driverProtoInstance.prototype);

                    var driverInstance = new driverProto();
                    driverInstance.baseClass = baseClass.prototype.declaredClass;
                    driverInstance.modulePath = utils.replaceAll('//','/',requirePath);
                    driverInstance.delegate=thiz;
                    storeItem.instance = driverInstance;

                    if(readyCB){
                        readyCB(driverInstance);
                    }

                    try{
                        driverInstance.start();
                    }catch(e){

                    }
                    return driverInstance;
                });
            });
        },
        onDeviceDisconnected:function(evt){
            /*console.log('device disconnected');*/
        },
        onDeviceMessage:function(evt){

            if(evt && evt['device'] && evt['driverInstance']){
                var _deviceInfo=evt['device'];
                var _driverInstance=evt['driverInstance'];
                var _driverOptions =_driverInstance['options'];
                if(!_driverOptions)return;

                //split message;
                var messages=[evt.deviceMessage];
                if( lang.isString(evt.deviceMessage) &&
                    evt.deviceMessage.indexOf(_driverInstance.lineBreak)!=-1){
                    messages=[];
                    messages=evt.deviceMessage.split(_driverInstance.lineBreak);
                }


                //forward to blox
                if(messages.length>0){

                    var scope=this.ctx.getBlockManager().getScope(_driverOptions.id);
                    var blockStore=scope.blockStore;

                    var responseBlocks = scope.getBlocks({
                        group:types.BLOCK_GROUPS.CF_DRIVER_RESPONSE_BLOCKS
                    });

                    var responseVariables = scope.getVariables({
                        group:types.BLOCK_GROUPS.CF_DRIVER_RESPONSE_VARIABLES
                    });

                    if(!responseBlocks || responseBlocks.length==0){
                        console.log('have no response blocks, abort');
                    }
                    var responseVariable = scope.getVariable('value');
                    if(responseVariable){

                    }else{
                        responseVariable = new Variable({
                            id:utils.createUUID(),
                            title : 'value',
                            value : '',
                            scope : scope,
                            type  : 13,
                            group : 'processVariables',
                            gui:false,
                            cmd:false
                        });
                    }

                    for(var i=0; i < messages.length ; i++){

                        if(messages[i].length==0){
                            continue;
                        }

                        //update system variable 'value'
                        responseVariable.value=messages[i];
                        console.log('update process value '+responseVariable.value + ' for ' + _deviceInfo.host);
                        this.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED,{
                            item:responseVariable,
                            scope:scope,
                            owner:this
                        });

                        //now run each top-variabl block in 'conditional process'
                        for(var j=0; j < responseVariables.length ; j++){
                            //console.profile('profiling response variable');
                            if(responseVariables[j].title=='value'){
                                continue;
                            }
                            scope.expressionModel.parseVariable(scope,responseVariables[j]);
                            //console.profileEnd();
                        }

                        //now run each top-level block in 'conditional process'
                        for(var j=0; j < responseBlocks.length ; j++){
                            scope.solveBlock(responseBlocks[j],{highlight:true});
                        }


                    }

                    console.log('forward messages to scope');
                }
            }
        },
        init:function(){
            this.subscribe(types.EVENTS.ON_DEVICE_MESSAGE,this.onDeviceMessage);
            this.subscribe(types.EVENTS.ON_DEVICE_DISCONNECTED,this.onDeviceDisconnected);
        }
    });
});


define('xcf/manager/DriverManager',[
    'dcl/dcl',
    "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/_base/json",
    'xide/types',
    'xcf/types/Types',
    'xide/utils',
    'xcf/manager/BeanManager',
    "xcf/model/Variable",
    'xcf/manager/DriverManager_Server',
    'xide/data/TreeMemory',
    'xide/data/ObservableStore',
    'dstore/Trackable',
    'xdojo/has',
    'xcf/model/Driver',
    "xide/manager/ServerActionBase",
    "xide/data/Reference",
    'xdojo/has!xcf-ui?./DriverManager_UI'
], function (dcl,declare, lang,json,types,fTypes,utils,
             BeanManager,Variable, DriverManager_Server,
             TreeMemory,ObservableStore,Trackable,
             has,Driver,
             ServerActionBase,Reference,DriverManager_UI) {

    var bases = [
        ServerActionBase,
        BeanManager,
        DriverManager_Server
    ],
    debug = false,
    isServer = !has('host-browser'),
    runDrivers = has('runDrivers');

    has('xcf-ui') && bases.push(DriverManager_UI);
/*
    var url = "command://deviceScope=system_devices&device=e5a06e24-6aa4-c8c5-3ffc-9d84d8528a91&driver=235eb680-cb87-11e3-9c1a-0800200c9a66&driverScope=system_drivers&block=53a10527-709b-4c7d-7a90-37f58f17c8db";
    var parts = utils.parse_url(url);//strip scheme

    parts = utils.urlArgs(parts.host);//go on with query string

    //console.error(parts);
    var driverId = parts.driver.value;


    var driverManager = sctx.getDriverManager();
    var _driver = driverManager.getItemById(driverId);
    var block  = null;
    if(_driver && _driver.blockScope){
        block = _driver.blockScope.getBlockById(parts.block.value);
    }
    console.error(block);
    */


    return dcl(bases, {
        getBlock:function(url){
            var parts = utils.parse_url(url);
            parts = utils.urlArgs(parts.host);//go on with query string
            var _driver = this.getItemById(parts.driver.value),
                block  = null;

            if(_driver && _driver.blockScope){
                block = _driver.blockScope.getBlockById(parts.block.value);
            }
            return block;
        },
        declaredClass:"xcf.manager.DriverManager",
        /**
         *
         * @param device
         * @param driver
         */
        addDeviceInstance:function(device,driver){

            driver.directory = true;

            var store = driver._store,
                parentId = driver.path,
                deviceManager = this.ctx.getDeviceManager(),
                instances = store.getSync(parentId + '_instances');

            instances = instances || store.putSync({
                    path: parentId + '_instances',
                    name: 'Instances',
                    isDir: true,
                    type: 'leaf',
                    parentId: parentId,
                    virtual: true,
                    isCommand:false,
                    icon:'fa-folder',
                    children:[]
                });



            var deviceName = deviceManager.getMetaValue(device, types.DEVICE_PROPERTY.CF_DEVICE_TITLE),
                deviceId = device.path,
                instance  = store.putSync(new Reference({
                    name:deviceName,
                    isCommand:false,
                    path: instances.path + '_instance_'+deviceId,
                    isDir: false,
                    type: 'driver_instance',
                    parentId:instances.path,
                    device:device,
                    driver:driver,
                    _mayHaveChildren:false,
                    icon:device.iconClass,
                    state:device.state
                }));

            instances.children.push(instance);

            device.addReference(instance,{
                properties: {
                    "name":true,
                    "enabled":true,
                    "state":true,
                    "iconClass":true
                },
                onDelete:false
            },true);


            !driver.instances && (driver.instances =[]);

            driver.instances.push(instance);
        },
        /***
         * The Bean-Manager needs a unique name of the bean:
         */
        beanNamespace: 'driver',
        /***
         * The Bean-Manager has some generic function like creating Dialogs for adding new items, please
         * provide a title for the interface.
         */
        beanName: 'Driver',
        /**
         * the icon class for bean edit views
         */
        beanIconClass:'fa-exchange',
        /**
         * Bean group type
         */
        groupType: types.ITEM_TYPE.DRIVER_GROUP,
        /**
         * Bean item type
         */
        itemType: types.ITEM_TYPE.DRIVER,
        /**
         * The name of the CI in the meta database for the title or name.
         */
        itemMetaTitleField:types.DRIVER_PROPERTY.CF_DRIVER_NAME,
        /**
         * the default scope for new items
         */
        defaultScope: 'system_drivers',
        /***
         * The RPC server class:
         */
        serviceClass: 'XCF_Driver_Service',
        /***
         * A copy of all divers raw da4ta from the server
         */
        rawData: null,
        /***
         * {module:xide/data/TreeMemory}
         */
        store: null,
        /***
         * {xcf.views.DriverTreeView}
         */
        treeView: null,
        /**
         * array of driver store scopes : TODO : tbr
         */
        driverScopes: null,
        _isLoading: false,
        removeDriverInstance:function(instance,device){

            var driver = instance.driver,
                driverStore = driver._store,
                parentId = driver.path,
                deviceId = device.path,
                instanceId = parentId + '_instances' + '_instance_'+deviceId,
                instanceReferenceItem = driverStore.getSync(instanceId);

            instanceReferenceItem && driverStore.removeSync(instanceId);

            driver.instances.remove(instanceReferenceItem);
            device.removeReference(instanceReferenceItem);

            if(instanceReferenceItem) {
                instanceReferenceItem.refresh();
                driverStore.getSync(parentId + '_instances').refresh();
            }else{
                debug && console.error('bad!! cant find reference for instance',arguments);;
            }

        },
        onReloaded: function () {
            return;
        },
        _onReloaded: function () {

            return;

            /*

            var currentItem = this.getItem();
            if (!currentItem) {
                currentItem = {
                    path: ""
                }
            }
            var parent = currentItem ? currentItem.isDir === true ? currentItem.path : '' : '';
            var scope = 'system_drivers';


            var templateUrlMeta = require.toUrl('xcfnode/data/driver/system/Default.meta.json');
            var meta = utils.getJson(this._getText(templateUrlMeta));


            var templateUrlDriverCode = require.toUrl('xcfnode/data/driver/system/Default.js');
            var driverCode = this._getText(templateUrlDriverCode);

            //console.log('template url : ' + templateUrlDriverCode + " : " + driverCode );
            //console.log('template url : ' + templateUrlDriverCode + " : " + driverCode );
            console.log('get json : ', meta);


            var nameCi = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_NAME);
            var idCi = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_ID);
            idCi.value = utils.createUUID();

            nameCi.value = 'My New Driver2';


            var thiz = this;
            var actionDialog = new CIActionDialog({
                title: 'New Driver',
                resizable: true,
                delegate: {
                    onOk: function (dlg, data) {
                        if (nameCi.value !== 'Default') {
                            try {
                                var metaOut = JSON.stringify(meta, null, 2);
                                if (parent.length == 0) {
                                    parent = "/";
                                }
                                thiz.createItem(scope, parent, nameCi.value, metaOut, driverCode).then(function (data) {

                                    var newItem = thiz.createNewItem(title, scope, parent);
                                    newItem.user = meta;
                                    thiz.store.putSync(newItem);

                                    thiz.publish(types.EVENTS.ON_STORE_CHANGED, {
                                        owner: thiz,
                                        store: thiz.store,
                                        action: types.NEW_FILE,
                                        item: newItem
                                    });

                                    //console.log('did create driver ', data);


                                });
                            } catch (e) {
                                console.error('error in CIDialog', e);
                            }
                        }
                    }
                },
                cis: [
                    nameCi,
                    utils.createCI('Scope', 3, 'system_devices', {
                        group: 'Common',
                        options: [
                            {
                                label: 'System',
                                value: 'system_devices'
                            },
                            {
                                label: 'User',
                                value: 'user_devices'
                            },
                            {
                                label: 'App',
                                value: 'app_devices'
                            }
                        ]
                    })
                ]
            });
            actionDialog.show();
            actionDialog.resize();*/
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Device messaging
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         * Secondary entry for incoming device messages. This is a regular callback
         * for the system event xcf.types.EVENTS.ON_DEVICE_MESSAGE emitted by the
         * DeviceManager. It comes with the device info, a driver instance and the
         * unfiltered device message.
         *
         * This function is primarily in charge to :
         * 1. split the message by a delimiter (driver settings)
         * 2. pass the device messages to the actual driver
         * 3. pass the device message to blox
         * 4.
         *
         * @param evt
         */

        onDeviceMessage: function (evt) {


            if (!evt || !evt.device || !evt.driverInstance) {
                return;
            }
            var _deviceInfo = evt['device'],
                _driverInstance = evt['driverInstance'],
                _driverOptions = _driverInstance['options'];

            if (!_driverOptions)return;

            if (!_driverInstance.responseSettings) {
                console.error('driver has no response settings!');
                return;
            }

            var serverSide = _driverOptions.serverSide;


            //split string into messages, using the driver's delimiter
            var messages = [evt.deviceMessage];
            if (_.isString(evt.deviceMessage)) {
                messages = _driverInstance.split(evt.deviceMessage);
            }

            /***
             * At this point, we should reject incoming traffic
             */
            if (_driverInstance.hasMessages() && _driverInstance.sendSettings.send.mode) {
                //console.error('abort incoming, have still messages to send');
                //return;
            }


            //forward to blox
            if (messages.length > 0) {

                var scope = _driverInstance.blockScope;

                var responseBlocks = scope.getBlocks({
                    group: types.BLOCK_GROUPS.CF_DRIVER_RESPONSE_BLOCKS
                });

                var responseVariables = scope.getVariables({
                    group: types.BLOCK_GROUPS.CF_DRIVER_RESPONSE_VARIABLES
                });

                if (!responseBlocks || responseBlocks.length == 0) {
                    //console.log('have no response blocks, abort');
                }
                var responseVariable = scope.getVariable('value');
                if (responseVariable) {

                } else {

                    responseVariable = new Variable({
                        id: utils.createUUID(),
                        name: 'value',
                        value: '',
                        scope: scope,
                        type: 13,
                        group: 'processVariables',
                        gui: false,
                        cmd: false
                    });
                    scope.blockStore.putSync(responseVariable);
                }


                for (var i = 0; i < messages.length; i++) {

                   if (messages[i].length == 0) {
                        continue;
                    }
                    responseVariable.value = messages[i];

                    this.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                        item: responseVariable,
                        scope: scope,
                        owner: this,
                        save: false,                         //dont save it
                        source: types.MESSAGE_SOURCE.DEVICE  //for prioritizing
                    });
                    var runVariables = false;
                    var runBlocks = false;

                    //now run each top-variabl block in 'conditional process'
                    for (var j = 0; j < responseVariables.length; j++) {

                        var _var = responseVariables[j];
                        if (responseVariables[j].title == 'value') {
                            continue;
                        }

                        var _varResult = null;
                        var _cValue = responseVariable.value;


                        if (!(typeof _cValue == "number")) {
                            _cValue = '' + _cValue;
                            _cValue = "'" + _cValue + "'";
                        }


                        var prefix = "var value = " + _cValue + ";";

                        var _varResult = _cValue;

                        /*
                        try {
                            //_varResult = scope.expressionModel.parseVariable(scope, _var, prefix, false, false);
                        } catch (e) {
                            console.error('parsing response variable ' + _var.title + ' failed');
                            this.publish(types.EVENTS.ON_BLOCK_EXPRESSION_FAILED, {
                                item: _var,
                                scope: scope,
                                owner: this,
                                deviceInfo: _deviceInfo
                            });
                        }
                        */

                        if (_var.target && _var.target != 'None' && _varResult != null && _varResult != 'null' && _varResult != "'null'") {

                            var targetVariable = scope.getVariable(_var.target);
                            if (targetVariable) {

                                targetVariable.value = _varResult;
                                this.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                                    item: targetVariable,
                                    scope: scope,
                                    owner: this,
                                    save: false,
                                    source: types.MESSAGE_SOURCE.BLOX  //for prioritizing
                                });
                            }
                        }
                    }

                    if( (isServer && serverSide) || (!serverSide && !isServer)) {

                        for (var j = 0; j < messages.length; j++) {
                            var message = messages[j];
                            if(_.isObject(message)) {
                                if (message.src) {

                                    var block = scope.getBlockById(message.src);
                                    if(block && block.onData){
                                        block.onData(message);
                                    }
                                }
                            }
                        }


                        if(!runDrivers){
                            return;
                        }
                        //now run each top-level block in 'conditional process'
                        for (var j = 0; j < responseBlocks.length; j++) {

                            var block = responseBlocks[j];

                            if (block.enabled == false) {
                                continue;
                            }
                            block.override = {
                                args: _var ? [_var.value] : null
                            };
                            try {
                                scope.solveBlock(responseBlocks[j], {
                                    highlight: isServer ? false : true
                                });
                            } catch (e) {
                                logError(e,'----solving response block crashed ')
                                debug && console.trace();
                            }
                        }
                    }
                }
            }
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  CI related
        //
        /////////////////////////////////////////////////////////////////////////////////////
        getDriverById: function (id) {

            var options = [];
            var result = null;

            function search(store) {

                var items = utils.queryStore(store, {
                    isDir: false
                });

                if (!_.isArray(items)) {
                    items = [items];
                }

                for (var i = 0; i < items.length; i++) {
                    var driver = items[i];
                    var meta = driver['user'];
                    var _id = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_ID);
                    if (!_id) {
                        continue;
                    }
                    if (_id.value == id) {
                        return store.getSync(driver.path);
                        return driver;
                    }
                }
                return null;
            }

            for(var scope in this.stores){

                var store = this.stores[scope];
                result = search(store);
                if(result){
                    return result;
                }
            }
            return null;
        },
        getDriverByPath: function (path) {

            var options = [];
            var result = null;

            function search(store) {

                var items = utils.queryStore(store, {
                    isDir: false
                });

                if (!_.isArray(items)) {
                    items = [items];
                }

                for (var i = 0; i < items.length; i++) {
                    var driver = items[i];
                    if (driver.path == path) {
                        return driver;
                    }
                }
                return null;
            }

            for(var scope in this.stores){

                var store = this.stores[scope];
                result = search(store);
                if(result){
                    return result;
                }
            }
            return null;
        },

        getItemById: function (itemId) {
            return this.getDriverById(itemId);

            if(!this.store || !this.store.data){
                debug && console.error('Driver Manager::getItemById : have no valid store');
                return null;
            }
            var data = this.store.data,
                driver = _.find(data,{
                    id: itemId
                });

            if(!driver){
                debug && console.error('Driver Manager::getItemById : cant find driver with id: ' + itemId,data);
            }
            return driver;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Data related
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         *  Callback when a blox scope has been created. This is being used
         *  to deserialize the driver's CI meta settings into a blox scope : variables, commands
         * @param scope
         */
        onNewDriverScopeCreated: function (scope) {},
        onScopeCreated: function (evt) {},
        onDeviceDisconnected: function (evt) {},
        onDriverCreated: function (store) {
            has('xcf-ui') && types.registerEnumeration('Driver', this.getDriversAsEnumeration(store));
        },
        onDriverRemoved: function (store,item) {
            has('xcf-ui') && types.registerEnumeration('Driver', this.getDriversAsEnumeration(store));
        },
        onStoreReady: function (store) {
            has('xcf-ui') && types.registerEnumeration('Driver', this.getDriversAsEnumeration(store));
        },
        onStoreCreated: function (evt) {

            var type = evt.type,
                data = evt.data,
                store = evt.store,
                items = store.query({
                    isDir: false
                }),
                owner = evt.owner;

            if(type!==types.ITEM_TYPE.DRIVER){
                return;
            }

            for (var i = 0; i < items.length; i++) {

                var item = items[i];
                if (item._completed != null || item.name === 'Default') {
                    continue;
                }
                item._completed = true;

                if(has('xcf-ui')) {
                    this.completeDriver(store, item, item);
                }
            }
        },

        /***
         * Inits the store with the driver data
         * @param data
         * @returns {xide.data.TreeMemory}
         */
        createStore:function(data,scope,track){

            var storeClass = declare('driverStore',[TreeMemory,Trackable,ObservableStore],{});

            var store = new storeClass({
                data: data.items,
                Model:Driver,
                idProperty: 'path',
                //parentField:'path',
                scope:scope,
                observedProperties:[
                    "name",
                    "enabled"
                ]
            });

            if(scope && !this.stores[scope] && track!==false){
                this.stores[scope] = store;
            }

            if(!this.store && scope ==='system_drivers'){
                this.store = store;
            }
            return store;
        },
        /***
         * Inits the store with the driver data
         * @param data
         * @returns {xide.data.TreeMemory}
         */
        initStore:function(data,scope){
            var store = this.createStore(data,scope);
            return store;
        },
        getStore:function(scope){

            if(!scope || scope==='system_drivers') {
                return this.store;
            }

            var store = this.stores[scope];
            if(store){
                return store;
            }

            if(scope){
                return this.ls(scope);
            }
        },
        /***
         * ls is enumerating all drivers in a given scope
         * @param scope{string}
         * @returns {Deferred}
         */
        ls: function (scope) {

            function data(data) {
                try {
                    var store = this.initStore(data, scope);
                    if (scope === 'system_drivers') {
                        this.store = store;
                    }
                    this.stores[scope] = store;
                    this.onStoreReady(store);
                    this.publish(types.EVENTS.ON_STORE_CREATED, {
                        data: data,
                        owner: this,
                        store: store,
                        type: this.itemType
                    });
                } catch (e) {
                    logError(e, 'error ls drivers');
                }
            }

            if(has('php')) {
                return this.runDeferred(null, 'ls', [scope]).then(data.bind(this));
            }else{
                var def = this._getText(require.toUrl(scope).replace('main.js','') + scope + '.json',{
                    sync: false,
                    handleAs: 'json'
                }).then(data.bind(this));
                return def;
            }
        },
        /***
         * Common manager function, called by the context of the application
         */
        init: function () {
            var thiz = this,
                EVENTS = types.EVENTS;
            this.stores = {};
            this.subscribe([
                EVENTS.ON_SCOPE_CREATED,
                EVENTS.ON_STORE_CREATED
            ]);

            //replay block exceptions to log messages
            this.subscribe(EVENTS.ON_BLOCK_EXPRESSION_FAILED, function (evt) {

                thiz.publish(EVENTS.ON_SERVER_LOG_MESSAGE, {
                    data: {
                        type: 'Expression',
                        device: evt.deviceInfo
                    },
                    level: 'error',
                    message: 'Expression Failed: ' + evt.item.title + ' : ' + evt.item.value
                });
            });

            this.driverScopes = {
                "system_drivers": "system_drivers/",
                "user_drivers": "user_drivers/"
            };
        }
    });
});

define('xcf/mainr',[
    "xcf/types",
    "xcf/types/Types",
    "xcf/model/Command",
    "xcf/model/Device",
    "xcf/model/Driver",
    "xcf/model/ModelBase",
    "xcf/model/Variable",
    "xcf/factory/Blocks",
    "xcf/manager/BeanManager",
    "xcf/manager/DeviceManager",
    "xcf/manager/BlockManager",
    "xcf/manager/DriverManager",
    "xcf/manager/DriverManager_Server"
], function () {

});

/** @module xnode/manager/NodeServiceManager **/
define('xnode/manager/NodeServiceManager',[
    "dcl/dcl",
    "xide/manager/ServerActionBase",
    "xide/manager/BeanManager",
    'xide/types',
    'xide/factory',
    'xide/data/Memory',
    'xide/client/WebSocket',
    'xdojo/has',
    'xide/factory/Clients',
    'dojo/Deferred',
    'xdojo/has!xnode-ui?./NodeServiceManagerUI'
], function (dcl, ServerActionBase, BeanManager, types,factory,Memory,WebSocket,has,Clients,Deferred,NodeServiceManagerUI) {
    var bases = [ServerActionBase, BeanManager];

    if(NodeServiceManagerUI){
        bases.push(NodeServiceManagerUI);
    }
    /**
     * Manager dealing with Node-Services though PHP shell (XPHP). This is is a typical
     * 'bean-manager' implementation.
     *
     * @class module: xnode/manager/NodeServiceManager
     */

    var NodeServiceManager = dcl(bases, {
        declaredClass:"xnode.manager.NodeServiceManager",
        serviceClass: 'XIDE_NodeJS_Service',
        cookiePrefix: 'nodeJSServices',
        singleton: true,
        serviceView: null,
        clients: null,
        beanNamespace: 'serviceConsoleView',
        consoles: {},
        /**
         * Create a socket client to the service (service shell) if applicaple.
         * @param item
         * @returns {*}
         */
        createClient: function (item) {

            if (!item.info) {
                console.error('NodeJs service has no host infos');
                return;
            }

            
            if (!this.clients)this.clients = {};
            var hash = this.getViewId(item);

            if (this.clients[hash]) {
                return this.clients[hash];
            }
            var client = new WebSocket({});
            this.clients[hash] = client;
            client.init({
                options: {
                    host: item.info.host,
                    port: item.info.port,
                    debug: {
                        "all": false,
                        "protocol_connection": true,
                        "protocol_messages": true,
                        "socket_server": true,
                        "socket_client": true,
                        "socket_messages": true,
                        "main": true
                    }
                }
            });
            client.connect();
            return client;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Public API
        //
        /////////////////////////////////////////////////////////////////////////////////////
        getStore: function () {
            return this.store;
        },
        /***
         * Common function that this instance is in a valid state
         * @returns {boolean}
         */
        isValid: function () {
            return this.store != null;
        },
        /***
         * Init our store
         * @param data
         * @returns {xide.data.Memory}
         */
        initStore: function (data) {

            var sdata = {
                identifier: "name",
                label: "Name",
                items: data
            };

            this.store = new Memory({
                data: sdata,
                idProperty:'name'
            });
            return this.store;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Main entries, called by the context
        //
        /////////////////////////////////////////////////////////////////////////////////////
        init: function () {
            return this.ls();
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Server methods
        //
        /////////////////////////////////////////////////////////////////////////////////////
        getDefaults: function (readyCB) {
            return this.callMethodEx(null, 'getDefaults', null, readyCB, true);
        },
        checkServer: function (settings, readyCB) {
            return this.callMethodEx(null, 'checkServer', [settings], readyCB, true);
        },

        runServer: function (settings, readyCB) {
            return this.callMethodEx(null, 'runDebugServer', [settings], readyCB, true);
        },

        runDebug: function (settings, readyCB) {
            return this.callMethodEx(null, 'run', [settings], readyCB, true);
        },
        stopServer: function (services, readyCB) {
            return this.callMethodEx(null, 'stop', [services], readyCB, true);
        },
        startServer: function (services, readyCB) {
            return this.callMethodEx(null, 'start', [services], readyCB, true);
        },
        /***
         * ls is enumerating all drivers in a given scope
         * @param readyCB   {function}
         * @param errorCB   {function}
         * @param emit   {Boolean}
         * @returns {*}
         */
        ls: function (readyCB, errorCB, emit) {
            //console.log('xnode : ls ' + this.serviceUrl,this);
            var thiz = this;
            var dfd = null;

            function ready(data) {
                thiz.rawData = data;
                thiz.initStore(data);
                if (emit !== false) {
                    thiz.publish(types.EVENTS.ON_NODE_SERVICE_STORE_READY, {store: thiz.store});
                }
                if (readyCB) {
                    readyCB(data);
                }
            }

            if(this.services){
                dfd = new Deferred();
                ready(this.services);
                dfd.resolve();
                return dfd;
            }


            dfd = this.runDeferred(null, 'ls');

            try {
                dfd.then(function (data) {
                    ready(data);
                });
            }catch(e){
                console.error('error loading store',e)
                logError(e,"error loading store");
            }

            return dfd;
        }

    });
    return NodeServiceManager;
});

define('xapp/manager/Application',[
    "dcl/dcl",
    'dojo/Deferred',
    'xide/types',
    'xide/utils',
    //'dojo/dom-construct',
    "xide/manager/ManagerBase"
], function (dcl,Deferred,types, utils,ManagerBase) {

    var debugBootstrap = true;
    var debugBlocks = true;

    //Application
    return dcl([ManagerBase],{
        declaredClass:"xapp/manager/Application",
        delegate:null,
        settings:null,
        constructor:function(args){
            utils.mixin(this,args);
            this.id = utils.createUUID();
        },
        runBlox:function(path,id,context,settings){
            var parts = utils.parse_url(path);
            debugBlocks && console.log('run blox: ' + id + ' with ',settings);
            var bm = this.ctx.getBlockManager();
            bm.load(parts.scheme,parts.host).then(function(scope){
                var block = scope.getBlockById(id);
                if(block){
                    block.context = context;
                    if(settings) {
                        block.override = settings;
                    }
                    return block.solve(block.scope);
                }else{
                    debugBlocks && console.error('have no block !');
                }
            },function(e){
                debugBlocks && console.error('error loading block files ' +e,e);
            });
        },
        onReloaded:function(){
            console.log('on reloaded',arguments);
        },

        run:function(settings){
            this.settings = settings;
        },
        loadScript:function(url){
            /*
            debugger;
            domConstruct.create('script', {
                src:url
            }, query('head')[0]);*/
        },
        onReady:function(){
            
            debugBootstrap && console.log('   Checkpoint 5.3 managers ready');
            
            this.publish(types.EVENTS.ON_APP_READY,{
                context:this.ctx,
                application:this,
                delegate:this.delegate
            });

        },
        onXBloxReady:function() {
            var _re = require,
                thiz = this;
            debugBootstrap && console.log('   Checkpoint 5.2 xblox component ready');

            _re(['xblox/embedded', 'xblox/manager/BlockManager'], function (embedded, BlockManager) {

                debugBootstrap && console.log('   Checkpoint 5.2 setup xblox');
                
                //IDE's block manager
                if(thiz.delegate && thiz.delegate.ctx){

                    var ctx = thiz.delegate.ctx;
                    if(ctx.getBlockManager()) {
                        thiz.ctx.blockManager = ctx.getBlockManager();
                    }

                    if(ctx.getDriverManager()) {
                        thiz.ctx.driverManager = ctx.getDriverManager();
                        thiz.ctx.deviceManager = ctx.getDeviceManager();
                    }
                    if(ctx.nodeServiceManager) {
                        thiz.ctx.nodeServiceManager = ctx.nodeServiceManager;
                    }

                    thiz.onReady();


                }else{

                    var blockManagerInstance = new BlockManager();
                    blockManagerInstance.ctx = thiz.ctx;
                    thiz.ctx.blockManager = blockManagerInstance;
                }
                thiz.onReady();
            });
        },
        /**
         *
         * @param settings {Object}
         * @param settings.delegate {xideve/manager/WidgetManager}
         * @returns {Deferred}
         */
        start:function(settings){
            this.initReload && this.initReload();
            debugBootstrap && console.log('xapp/Application::start ', settings);
            var def = new Deferred();
            var thiz = this;
            this.delegate = settings.delegate;
            debugBootstrap &&  console.log('Checkpoint 5 xapp/manager/Application->start, load xblox');
            try {
                this.ctx.pluginManager.loadComponent('xblox').then(function () {
                    debugBootstrap && console.log('   Checkpoint 5.1 xblox component loaded');
                    def.resolve(thiz.ctx);
                    thiz.onXBloxReady()
                }, function (e) {
                    debugBootstrap &&  console.error('error loading xblox - component ' + e, e);
                });
            }catch(e){
                console.error('error loading xblox '+e,e);
                def.reject(e);
            }
            return def;
        }
    });
});

define('xapp/manager/_WidgetPickerMixin',[
    "dcl/dcl",
    'dojo/_base/declare',
    "dojo/dom-class",
    "dojo/dom-construct",
    'xide/utils',
    'xide/registry'
],function(dcl,declare,domClass,domConstruct,utils,registry){

        var outlineVisible = false;
        var boxModelVisible = false;
        var outlineElements = {};
        var isIE =false;
        var isIEStantandMode=false;
        var offlineFragment = null;
        var boxModel, boxModelStyle,
            boxMargin, boxMarginStyle,
            boxBorder, boxBorderStyle,
            boxPadding, boxPaddingStyle,
            boxContent, boxContentStyle;

        var outline = {
            "fbOutlineT": "fbHorizontalLine",
            "fbOutlineL": "fbVerticalLine",
            "fbOutlineB": "fbHorizontalLine",
            "fbOutlineR": "fbVerticalLine"
        };

        var outlineStyle = {
            fbHorizontalLine: "background: #00d706;height: 2px;",
            fbVerticalLine: "background: #00d706;width: 2px;"
        };

        var resetStyle = "margin:0; padding:0; border:0; position:absolute; overflow:hidden; display:block;";
        var offscreenStyle = resetStyle + "top:-1234px; left:-1234px;";

        var inspectStyle = resetStyle + "z-index: 2147483500;";
        var inspectModelOpacity = isIE ? "filter:alpha(opacity=80);" : "opacity:0.8;";
        var inspectModelStyle = inspectStyle + inspectModelOpacity;
        var inspectMarginStyle = inspectStyle + "background: #EDFF64; height:100%; width:100%;";
        var inspectBorderStyle = inspectStyle + "background: #666;";
        var inspectPaddingStyle = inspectStyle + "background: SlateBlue;";
        var inspectContentStyle = inspectStyle + "background: SkyBlue;";

        var createBoxModelInspector = function createBoxModelInspector(){
            boxModel = domConstruct.create("div");
            boxModel.id = "fbBoxModel";
            boxModel.firebugIgnore = true;
            boxModelStyle = boxModel.style;
            boxModelStyle.cssText = inspectModelStyle;

            boxMargin = domConstruct.create("div");
            boxMargin.id = "fbBoxMargin";
            boxMarginStyle = boxMargin.style;
            boxMarginStyle.cssText = inspectMarginStyle;
            boxModel.appendChild(boxMargin);

            boxBorder = domConstruct.create("div");
            boxBorder.id = "fbBoxBorder";
            boxBorderStyle = boxBorder.style;
            boxBorderStyle.cssText = inspectBorderStyle;
            boxModel.appendChild(boxBorder);

            boxPadding = domConstruct.create("div");
            boxPadding.id = "fbBoxPadding";
            boxPaddingStyle = boxPadding.style;
            boxPaddingStyle.cssText = inspectPaddingStyle;
            boxModel.appendChild(boxPadding);

            boxContent = domConstruct.create("div");
            boxContent.id = "fbBoxContent";
            boxContentStyle = boxContent.style;
            boxContentStyle.cssText = inspectContentStyle;
            boxModel.appendChild(boxContent);

            offlineFragment.appendChild(boxModel);
        };
        var createOutlineInspector = function createOutlineInspector()
        {
            for (var name in outline)
            {
                var el = outlineElements[name] = domConstruct.create("div");
                el.id = name;
                el.firebugIgnore = true;
                el.style.cssText = inspectStyle + outlineStyle[outline[name]];
                offlineFragment.appendChild(el);
            }
        };
        var destroyBoxModelInspector = function destroyBoxModelInspector()
        {
            boxModel.parentNode.removeChild(boxModel);
        };

        var destroyOutlineInspector = function destroyOutlineInspector()
        {
            for (var name in outline)
            {
                var el = outlineElements[name];
                el.parentNode.removeChild(el);
            }
        };


        return dcl(null,{
            declaredClass:"xide.widgets._WidgetPickerMixin",
            _inspectFrame:null,
            _isInspecting:false,
            _lastInspecting:0,
            inspectorMask:{
            },
            shouldShowOutline:function(el){
            },
            getWindowSize: function()
            {
                var width=0, height=0, el;

                if (typeof this.window.innerWidth == "number")
                {
                    width = this.window.innerWidth;
                    height = this.window.innerHeight;
                }
                else if ((el=this.document.documentElement) && (el.clientHeight || el.clientWidth))
                {
                    width = el.clientWidth;
                    height = el.clientHeight;
                }
                else if ((el=this.document.body) && (el.clientHeight || el.clientWidth))
                {
                    width = el.clientWidth;
                    height = el.clientHeight;
                }

                return {width: width, height: height};
            },
            addEvent:function(object, name, handler, useCapture)
            {
                if (object.addEventListener)
                    object.addEventListener(name, handler, useCapture);
                else
                    object.attachEvent("on"+name, handler);
            },
            removeEvent : function(object, name, handler, useCapture)
            {
                try
                {
                    if (object.removeEventListener)
                        object.removeEventListener(name, handler, useCapture);
                    else
                        object.detachEvent("on"+name, handler);
                }
                catch(e)
                {

                }
            },
            getWindowScrollSize: function()
            {
                var width=0, height=0, el,isIEQuiksMode =false;

                // first try the document.documentElement scroll size
                if (!isIEQuiksMode && (el=this.document.documentElement) &&
                    (el.scrollHeight || el.scrollWidth))
                {
                    width = el.scrollWidth;
                    height = el.scrollHeight;
                }

                // then we need to check if document.body has a bigger scroll size value
                // because sometimes depending on the browser and the page, the document.body
                // scroll size returns a smaller (and wrong) measure
                if ((el=this.document.body) && (el.scrollHeight || el.scrollWidth) &&
                    (el.scrollWidth > width || el.scrollHeight > height))
                {
                    width = el.scrollWidth;
                    height = el.scrollHeight;
                }

                return {width: width, height: height};
            },
            getElementFromPoint: function(x, y)
            {
                var shouldFixElementFromPoint=false;
                if (shouldFixElementFromPoint)
                {
                    var scroll = this.getWindowScrollPosition();
                    return this.document.elementFromPoint(x + scroll.left, y + scroll.top);
                }
                else
                    return this.document.elementFromPoint(x, y);
            },
            getWindowScrollPosition: function()
            {
                var top=0, left=0, el;

                if(typeof this.window.pageYOffset == "number")
                {
                    top = this.window.pageYOffset;
                    left = this.window.pageXOffset;
                }
                else if((el=this.document.body) && (el.scrollTop || el.scrollLeft))
                {
                    top = el.scrollTop;
                    left = el.scrollLeft;
                }
                else if((el=this.document.documentElement) && (el.scrollTop || el.scrollLeft))
                {
                    top = el.scrollTop;
                    left = el.scrollLeft;
                }

                return {top:top, left:left};
            },
            getElementPosition: function(el)
            {
                var left = 0;
                var top = 0;

                do
                {
                    left += el.offsetLeft;
                    top += el.offsetTop;
                }
                while (el = el.offsetParent);

                return {left:left, top:top};
            },
            getElementBox: function(el)
            {
                var result = {};

                if (el.getBoundingClientRect)
                {
                    var rect = el.getBoundingClientRect();

                    // fix IE problem with offset when not in fullscreen mode
                    var offset = 0;//BrowserDetection.IE ?  this.document.body.clientTop || this.document.documentElement.clientTop: 0;

                    var scroll = this.getWindowScrollPosition();

                    result.top = Math.round(rect.top - offset + scroll.top);
                    result.left = Math.round(rect.left - offset + scroll.left);
                    result.height = Math.round(rect.bottom - rect.top);
                    result.width = Math.round(rect.right - rect.left);
                }
                else
                {
                    var position = this.getElementPosition(el);

                    result.top = position.top;
                    result.left = position.left;
                    result.height = el.offsetHeight;
                    result.width = el.offsetWidth;
                }

                return result;
            },
            hideBoxModel: function()
            {
                if (!boxModelVisible) return;

                offlineFragment.appendChild(boxModel);
                boxModelVisible = false;
            },
            hideOutline: function(){
                if (!outlineVisible) return;

                for (var name in outline)
                    offlineFragment.appendChild(outlineElements[name]);

                outlineVisible = false;
            },
            showOutline: function(){

                if (outlineVisible) return;

                if (boxModelVisible) this.hideBoxModel();

                for (var name in outline) {
                    this.document.getElementsByTagName("body")[0].appendChild(outlineElements[name]);
                }

                outlineVisible = true;
            },
            getCSSAutoMarginBox: function(el)
            {
                if (isIE && " meta title input script link a ".indexOf(" "+el.nodeName.toLowerCase()+" ") != -1)
                    return {top:0, left:0, bottom:0, right:0};
                /**/

                if (isIE && " h1 h2 h3 h4 h5 h6 h7 ul p ".indexOf(" "+el.nodeName.toLowerCase()+" ") == -1)
                    return {top:0, left:0, bottom:0, right:0};
                /**/

                var offsetTop = 0;
                if (false && isIEStantandMode)
                {
                    var scrollSize = this.getWindowScrollSize();
                    offsetTop = scrollSize.height;
                }

                var box = this.document.createElement("div");
                //box.style.cssText = "margin:0; padding:1px; border: 0; position:static; overflow:hidden; visibility: hidden;";
                box.style.cssText = "margin:0; padding:1px; border: 0; visibility: hidden;";

                var clone = el.cloneNode(false);
                var text = this.document.createTextNode("&nbsp;");
                clone.appendChild(text);

                box.appendChild(clone);

                this.document.body.appendChild(box);

                var marginTop = clone.offsetTop - box.offsetTop - 1;
                var marginBottom = box.offsetHeight - clone.offsetHeight - 2 - marginTop;

                var marginLeft = clone.offsetLeft - box.offsetLeft - 1;
                var marginRight = box.offsetWidth - clone.offsetWidth - 2 - marginLeft;

                this.document.body.removeChild(box);

                return {top:marginTop+offsetTop, left:marginLeft, bottom:marginBottom-offsetTop, right:marginRight};
            },
            getMeasurementInPixels: function(el, name)
            {
                if (!el) return null;

                var m = this.getMeasurement(el, name);
                var value = m.value;
                var unit = m.unit;

                if (unit == "px")
                    return value;

                else if (unit == "pt")
                    return this.pointsToPixels(name, value);

                else if (unit == "em")
                    return this.emToPixels(el, value);

                else if (unit == "%")
                    return this.percentToPixels(el, value);

                else if (unit == "ex")
                    return this.exToPixels(el, value);

                // TODO: add other units. Maybe create a better general way
                // to calculate measurements in different units.
            },
            getMeasurementBox: function(el, name)
            {
                var result = [];
                var sufixes = name == "border" ?
                    ["TopWidth", "LeftWidth", "BottomWidth", "RightWidth"] :
                    ["Top", "Left", "Bottom", "Right"];

                if (isIE)
                {
                    var propName, cssValue;
                    var autoMargin = null;

                    for(var i=0, sufix; sufix=sufixes[i]; i++)
                    {
                        propName = name + sufix;

                        cssValue = el.currentStyle[propName] || el.style[propName];

                        if (cssValue == "auto")
                        {
                            if (!autoMargin)
                                autoMargin = this.getCSSAutoMarginBox(el);

                            result[i] = autoMargin[sufix.toLowerCase()];
                        }
                        else
                            result[i] = this.getMeasurementInPixels(el, propName);

                    }

                }
                else
                {
                    for(var i=0, sufix; sufix=sufixes[i]; i++)
                        result[i] = this.getMeasurementInPixels(el, name + sufix);
                }

                return {top:result[0], left:result[1], bottom:result[2], right:result[3]};
            },
            drawBoxModel: function(el)
            {
                console.log('-draw');
                // avoid error when the element is not attached a document
                if (!el || !el.parentNode)
                    return;

                var box = this.getElementBox(el);

                var windowSize = this.getWindowSize();
                var scrollPosition = this.getWindowScrollPosition();

                // element may be occluded by the chrome, when in frame mode
                var offsetHeight = 0;//Firebug.chrome.type == "frame" ? Firebug.context.persistedState.height : 0;

                // if element box is not inside the viewport, don't draw the box model
                if (box.top > scrollPosition.top + windowSize.height - offsetHeight ||
                    box.left > scrollPosition.left + windowSize.width ||
                    scrollPosition.top > box.top + box.height ||
                    scrollPosition.left > box.left + box.width )
                    return;

                var top = box.top;
                var left = box.left;
                var height = box.height;
                var width = box.width;

                var margin = Firebug.browser.getMeasurementBox(el, "margin");
                var padding = Firebug.browser.getMeasurementBox(el, "padding");
                var border = Firebug.browser.getMeasurementBox(el, "border");

                boxModelStyle.top = top - margin.top + "px";
                boxModelStyle.left = left - margin.left + "px";
                boxModelStyle.height = height + margin.top + margin.bottom + "px";
                boxModelStyle.width = width + margin.left + margin.right + "px";

                boxBorderStyle.top = margin.top + "px";
                boxBorderStyle.left = margin.left + "px";
                boxBorderStyle.height = height + "px";
                boxBorderStyle.width = width + "px";

                boxPaddingStyle.top = margin.top + border.top + "px";
                boxPaddingStyle.left = margin.left + border.left + "px";
                boxPaddingStyle.height = height - border.top - border.bottom + "px";
                boxPaddingStyle.width = width - border.left - border.right + "px";

                boxContentStyle.top = margin.top + border.top + padding.top + "px";
                boxContentStyle.left = margin.left + border.left + padding.left + "px";
                boxContentStyle.height = height - border.top - padding.top - padding.bottom - border.bottom + "px";
                boxContentStyle.width = width - border.left - padding.left - padding.right - border.right + "px";

                if (!boxModelVisible) this.showBoxModel();
            },
            drawOutline: function(el)
            {
                console.log('-draw outline');
                var border = 2;
                var scrollbarSize = 17;

                var windowSize = this.getWindowSize();
                var scrollSize = this.getWindowScrollSize();
                var scrollPosition = this.getWindowScrollPosition();

                var box = this.getElementBox(el);

                var top = box.top;
                var left = box.left;
                var height = box.height;
                var width = box.width;
                var isIE = false;


                //console.dir(outlineElements);
                var freeHorizontalSpace = scrollPosition.left + windowSize.width - left - width -
                    (!isIE && scrollSize.height > windowSize.height ? // is *vertical* scrollbar visible
                        scrollbarSize : 0);

                var freeVerticalSpace = scrollPosition.top + windowSize.height - top - height -
                    (!isIE && scrollSize.width > windowSize.width ? // is *horizontal* scrollbar visible
                        scrollbarSize : 0);

                var numVerticalBorders = freeVerticalSpace > 0 ? 2 : 1;

                var o = outlineElements;
                var style;

                style = o.fbOutlineT.style;
                style.top = top-border + "px";
                style.left = left + "px";
                style.height = border + "px";  // TODO: on initialize()
                style.width = width + "px";

                style = o.fbOutlineL.style;
                style.top = top-border + "px";
                style.left = left-border + "px";
                style.height = height+ numVerticalBorders*border + "px";
                style.width = border + "px";  // TODO: on initialize()

                style = o.fbOutlineB.style;
                if (freeVerticalSpace > 0)
                {
                    style.top = top+height + "px";
                    style.left = left + "px";
                    style.width = width + "px";
                    //style.height = border + "px"; // TODO: on initialize() or worst case?
                }
                else
                {
                    style.top = -2*border + "px";
                    style.left = -2*border + "px";
                    style.width = border + "px";
                    //style.height = border + "px";
                }

                style = o.fbOutlineR.style;
                if (freeHorizontalSpace > 0)
                {
                    style.top = top-border + "px";
                    style.left = left+width + "px";
                    style.height = height + numVerticalBorders*border + "px";
                    style.width = (freeHorizontalSpace < border ? freeHorizontalSpace : border) + "px";
                }
                else
                {
                    style.top = -2*border + "px";
                    style.left = -2*border + "px";
                    style.height = border + "px";
                    style.width = border + "px";
                }

                if (!outlineVisible) this.showOutline();
            },
            onInspecting: function(e) {

                if (new Date().getTime() - this._lastInspecting > 30) {

                    this._inspectFrame.style.display = "none";
                    var targ = this.getElementFromPoint(e.clientX, e.clientY);

                    this._inspectFrame.style.display = "block";

                    // Avoid inspecting the outline, and the FirebugUI
                    var id = targ.id;
                    if (id && /^fbOutline\w$/.test(id)) return;
                    if (id == "FirebugUI") return;

                    // Avoid looking at text nodes in Opera
                    while (targ.nodeType != 1) targ = targ.parentNode;

                    if (targ.nodeName.toLowerCase() == "body") return;


                    //decided by sub class
                    if(this.isPickable){

                        if(this.isPickable(targ)){
                            this.drawOutline(targ);
                        }else{
                            //console.log('skip !');
                            return;
                        }
                    }else {
                        this.drawOutline(targ);
                    }

/*
                    if (ElementCache(targ)) {
                        var target = "" + ElementCache.key(targ);
                        var lazySelect = function () {
                            inspectorTS = new Date().getTime();

                            if (Firebug.HTML)
                                Firebug.HTML.selectTreeNode("" + ElementCache.key(targ));
                        };

                        if (inspectorTimer) {
                            clearTimeout(inspectorTimer);
                            inspectorTimer = null;
                        }

                        if (new Date().getTime() - inspectorTS > 200)
                            setTimeout(lazySelect, 0);
                        else
                            inspectorTimer = setTimeout(lazySelect, 300);
                    }
*/
                    this._lastInspecting = new Date().getTime();
                }
            },
            destroyInspectorFrame:function (){
                if (this._inspectFrame)
                {
                    this.document.getElementsByTagName("body")[0].removeChild(this._inspectFrame);
                    this._inspectFrame = null;
                }
            },
            stopInspecting: function()
            {
                this._isInspecting= false;

                if (outlineVisible) this.hideOutline();

                this.removeEvent(this._inspectFrame, "mousemove", this.onInspecting);
                this.removeEvent(this._inspectFrame, "mousedown", this.onInspectingClick);
                this.destroyInspectorFrame();
                //Firebug.chrome.inspectButton.restore();
            },
            onInspectingClick: function(e)
            {
                this._inspectFrame.style.display = "none";
                var targ = this.getElementFromPoint(e.clientX, e.clientY);
                this._inspectFrame.style.display = "block";

                // Avoid inspecting the outline, and the FirebugUI
                var id = targ.id;
                if (id && /^fbOutline\w$/.test(id)) return;
                if (id == "FirebugUI") return;

                // Avoid looking at text nodes in Opera
                while (targ.nodeType != 1) targ = targ.parentNode;
                //console.log(targ);
                if(this.onNodePicked){
                    this.onNodePicked(targ);
                }
                this.stopInspecting();
                this._destroy();
            },
            _destroy: function()
            {
                destroyBoxModelInspector();
                destroyOutlineInspector();

                offlineFragment = null;
            },
            _createInspectorFrame:function()
            {
                var resetStyle = "margin:0; padding:0; border:0; position:absolute; overflow:hidden; display:block;";

                //var inspectFrameStyle = resetStyle + "z-index: 2147483550; top:0; left:0; background:url(" +"pixel_transparent.gif);";
                var inspectFrameStyle = resetStyle + "z-index: 2147483550; top:0; left:0;";

                this._inspectFrame= domConstruct.create('div',{

                });

                this._inspectFrame.style.cssText = inspectFrameStyle;
                this.document.getElementsByTagName("body")[0].appendChild(this._inspectFrame);

                var size = this.getWindowScrollSize();
                var thiz = this;

                this._inspectFrame.style.width = size.width + "px";
                this._inspectFrame.style.height = size.height + "px";

                this.addEvent(this._inspectFrame, "mousemove", function(e){
                    thiz.onInspecting(e);
                });
                this.addEvent(this._inspectFrame, "mousedown", function(e){
                    thiz.onInspectingClick(e);
                });

            },
            initInspector : function(){
                offlineFragment = document.createDocumentFragment();
                createBoxModelInspector();
                createOutlineInspector();
            },
            isPickable: function (node) {

                if (this.allowWidgets) {
                    var widget = registry.getEnclosingWidget(node);
                    if (widget) {
                        if (this.skipWidgetClasses.indexOf(widget.declaredClass) > -1) {
                            return false;
                        }
                        if (node.id && node.id == widget.id) {
                            return true;
                        } else {
                        }
                    } else {
                        return false;
                    }

                } else if (this.allowHTMLNodes) {
                    return true;
                }

                return false;

            },
            startInspecting: function()
            {
                this._isInspecting = true;
                var data = this.userData;

                this.window=window;
                this.document=/*data.document || */document;
                this.initInspector();
                this._createInspectorFrame();
            },
            _pick:function(){
                try {
                    this.startInspecting();
                }catch(e){
                    console.error('inspector crash!');
                }
            }

        });
    });
/** @module xapp/manager/Context */
define('xapp/manager/Context',[
    "dcl/dcl",
    'xide/manager/ContextBase',
    'xide/manager/PluginManager',
    'xapp/manager/Application',
    'xide/manager/ResourceManager',
    'xide/mixins/EventedMixin',
    'xide/types',
    'xide/utils',
    './_WidgetPickerMixin',
    'require',
    'xide/manager/Reloadable',
    'xcf/types/Types',
    'xdojo/has'

], function (dcl, ContextBase, PluginManager, Application, ResourceManager, EventedMixin, types, utils, _WidgetPickerMixin, require, Reloadable,Types,has,on) {

    var isIDE = has('xcf-ui');
    var debugWire = true;
    var debugBoot = true;
    var debugRun = true;

    /**
     * Lightweight context for end-user apps
     * @class module:xapp/manager/Context
     * @augments module:xide/mixins/EventedMixin
     * @extends module:xide/manager/ContextBase
     */
    return dcl([ContextBase, Reloadable, _WidgetPickerMixin], {
        declaredClass:"xapp/manager/Context",
        settings: null,
        application: null,
        blockManager: null,
        getUserDirectory(){
            var resourceManager = this.getResourceManager(),
                userDir =  resourceManager ? resourceManager.getVariable('USER_DIRECTORY') || {} : null;

            return userDir;

        },
        getResourceManager:function(){
            return this.resourceManager;
        },
        getMount:function(mount){

            var resourceManager = this.getResourceManager(),
                vfsConfig =  resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;

            if(vfsConfig && vfsConfig[mount]) {
                return vfsConfig[mount];
            }
            return null;
        },
        getVariable: function (deviceId, driverId, variableId) {
            var deviceManager = ctx.getDeviceManager();
            var device = deviceManager.getDeviceById(deviceId),
                result = null;
            if (!device) {
                return null;
            }

            var driverScope = device.driver;
            //not initiated driver!
            if (driverScope && driverScope.blockScope) {
                driverScope = driverScope.blockScope;
            }

            if (!driverScope) {
                console.error('have no driver, use driver from DB');
                if (device) {
                    var driverId = deviceManager.getMetaValue(device, types.DEVICE_PROPERTY.CF_DEVICE_DRIVER);
                    driverScope = ctx.getBlockManager().getScope(driverId);

                    result = driverScope.getVariableById(driverId + '/' + variableId);

                }
            }

            return result;
        },
        wireNode: function (widget, event, block, params) {

            var thiz = this,
                rejectFunction = null,
                onBeforeRun = null;

            if(!widget['__setup']){
                widget['__setup']={};
            }

            if(widget['__setup'][block.id]){
               return;
            }

            widget['__setup'][block.id]=true;

            if (params) {
                if (event === types.EVENTS.ON_DRIVER_VARIABLE_CHANGED) {

                    var varParams = params.params;
                    var deviceId = varParams[0],
                        driverId = varParams[1],
                        variableId = varParams[2];


                    var variable = this.getVariable(deviceId, driverId, variableId);

                    rejectFunction = function (evt) {

                        var variable = evt.item;
                        if (variable.id === variableId) {
                            return false;
                        }
                        return true;
                    };

                    onBeforeRun = function (block, evt) {

                        var variable = evt.item;
                        block.override = {
                            variables: {
                                value: variable.value
                            }
                        };
                    }
                }

            }


            if (!widget) {
                console.error('have no widget for event ' + event);
                return;
            }
            if (!block) {
                console.error('have no block for event ' + event);
                return;
            }

            if (!event) {
                console.error('have no event');
                return;
            }

            if (!_.isString(event)) {
                console.error('event not string ', event);
                return;
            }

            debugWire && console.log('wire node : ' + event);


            /**
             *
             * @param event
             * @param value: original event data
             * @param block
             * @param widget
             */
            var run = function (event, value, block, widget) {

                if(event==='load' && widget.__didRunLoad){
                    return;
                }
                if(event==='load'){
                    widget.__didRunLoad=true;
                }

                if (thiz.delegate && thiz.delegate.isDesignMode && thiz.delegate.isDesignMode()) {
                    return;
                }

                //filter, custom reject function
                if (rejectFunction) {

                    var abort = rejectFunction(value);
                    if (abort) {
                        return;
                    }
                }
                debugRun && console.log('run ! ' + event + ' for block '+block.name + ':' +block.id );
                if (block._destroyed) {
                    console.error('run failed block invalid, block has been removed');
                    return;
                }

                if (!block.enabled) {
                    return;
                }
                var context = widget,
                    result;
                if (block && context) {
                    block.context = context;
                    block._targetReference = context;

                    if (onBeforeRun) {
                        onBeforeRun(block, value);
                    }

                    result = block.solve(block.scope, {
                        highlight: true
                    });
                    debugWire && console.log('run ' + block.name + ' for even ' + event, result + ' for ' + this.id);
                }
            };

            //patch the target
            if (!widget.subscribe) {
                utils.mixin(widget, EventedMixin.prototype);
            }

            var _target = widget.domNode || widget,
                _event = event,
                _isWidget = widget.declaredClass || widget.startup,
                _hasWidgetCallback = widget.on != null && widget['on' + utils.capitalize(_event)] != null,
                _handle = null,
                _isDelite = _target.render != null && _target.on != null;


            if (_isWidget &&
                    //dijit
                (widget.baseClass && widget.baseClass.indexOf('dijitContentPane') != -1)
                    //delite
                || widget.render != null || widget.on != null) {
                _isWidget = false;//use on
            }

            if (_target) {

                //plain node
                if (!_isDelite && (!_hasWidgetCallback || !_isWidget)) {
                    _handle = widget.__on(_target, event, function (evt) {
                        run(event, evt, block, widget);

                    });

                    //_handle = on(_target, event, function (evt) {
                        //run(event, evt, block, widget);
                    //});

                } else {

                    _target = widget;
                    var useOn = true;
                    if (useOn) {
                        if (!_isDelite) {
                            var _e = 'on' + utils.capitalize(_event);

                            widget[_e] = function (val, nada) {
                                if (_target.ignore !== true) {
                                    run(event, val);
                                }
                            }
                        } else {
                            if (utils.isSystemEvent(event)) {
                                _handle = _target.subscribe(event, function (evt) {
                                    run(event, evt, block, widget);
                                }.bind(this), widget);

                            }
                            else {

                                if (utils.isNativeEvent(event)) {
                                    event = event.replace('on', '');
                                }
                                _handle = _target.on(event, function (evt) {
                                    run(event, evt.currentTarget.value, block, widget);
                                }.bind(this));
                            }
                        }

                    } else {
                        widget['on' + utils.capitalize(_event)] = function (val) {
                            if (_target.ignore !== true) {
                                run(event, val);
                            }
                        }
                    }
                }

                if (_handle) {

                    if (widget.addHandle) {
                        widget.addHandle(event, _handle);
                    }
                    if (!block._widgetHandles) {
                        block._widgetHandles = [];
                    }
                    block._widgetHandles.push(_handle);

                }else{
                    console.error('wire widget: have no handle',widget);
                }
            }
        },
        wireWidget: function (scope, widget, node, event, group, params) {

            var blocks = scope.getBlocks({
                group: group
            });

            debugWire && console.log('wire widget : ' + event + ' for group ' + group, blocks);
            if (!blocks || !blocks.length) {
                debugWire && console.log('have no blocks for group : ' + group);
            }
            for (var j = 0; j < blocks.length; j++) {

                var block = blocks[j];
                debugWire && console.log('activate block : ' + block.name + ' for ' + event, block);
                this.wireNode(widget, event, block, params);
            }

        },
        wireScope: function (scope) {


            debugWire && console.log('wire scope');

            var allGroups = scope.allGroups(),
                thiz = this,
                delegate = thiz.delegate || {},
                widgets =[];

            var getParams = function (group) {
                var event = null,
                    widgetId = null,
                    parts = group.split('__'),
                    params = [];

                //no element:
                if (parts.length == 1) {
                    event = parts[0];
                    widgetId = 'body';
                    if(isIDE) {
                        var _body = editorContext.rootWidget;
                        _body.domNode.runExpression = editorContext.global.runExpression;
                    }else{

                    }

                }

                if (parts.length == 2) {
                    event = parts[1];
                    widgetId = parts[0];
                }

                if (parts.length == 5) {
                    event = parts[1];
                    widgetId = parts[0];
                    params = [
                        parts[2],
                        parts[3],
                        parts[4]
                    ]

                }

                if (event && widgetId) {
                    var widget = document.getElementById(widgetId);
                    if (!widget && widgetId === 'body') {
                        widget = document.body;
                    }
                    return {
                        event: event,
                        widgetId: widgetId,
                        widget: widget,
                        params: params
                    }
                }

                return null;
            };

            var wireBlock = function (block) {
                block._on(types.EVENTS.ON_ITEM_REMOVED, function (evt) {
                    try {
                        //console.log('on block removed', evt.item);
                        if (block._widgetHandles) {
                            var _handles = block._widgetHandles;
                            for (var i = 0; i < _handles.length; i++) {
                                if (_handles[i].remove) {
                                    _handles[i].remove();
                                }
                            }
                            delete block._widgetHandles;

                        }
                    } catch (e) {
                        console.error('troubble!' + e, e);
                    }
                }, this);
            };
            for (var i = 0; i < allGroups.length; i++) {

                var group = allGroups[i];

                var params = getParams(group);

                if (params && params.widget) {
                    this.wireWidget(scope, params.widget, params.widget.domNode || params.widget, params.event, group, params);
                }else{
                    console.error('invalid params');
                }

                var blocks = scope.getBlocks({
                    group: group
                });

                if (!blocks || !blocks.length) {
                    debugWire && console.warn('have no blocks for group : ' + group);
                }

                if(isIDE) {
                    for (var j = 0; j < blocks.length; j++) {
                        var block = blocks[j];
                        wireBlock(block);
                    }
                }


                params.widget && widgets.indexOf(params.widget) ==-1 && widgets.push(params.widget);
            }

            for (var i = 0; i < widgets.length; i++) {
                var widget = widgets[i];
                if(widget.__didEmitLoad){
                    return;
                }
                debugBoot && console.log('emit load',widget);
                widget.__didEmitLoad=true;
                if(widget.nodeName==='BODY'){
                    $(widget.nodeName).trigger('load');
                }else {
                    if (widget.emit) {
                        widget.emit('load', widget);
                    }
                }
            }

            isIDE && scope._on(types.EVENTS.ON_ITEM_ADDED, function (evt) {

                var params = getParams(evt.item.group);
                if (params && params.widget) {
                    debugWire && console.log('on item added', arguments);
                    var item = evt.item;
                    var editorContext = delegate.getEditorContext ? delegate.getEditorContext() : null ;
                    var widget = params.widget.domNode || params.widget;
                    thiz.wireNode(widget, params.event, evt.item, editorContext, params);
                    wireBlock(evt.item);
                }
            });

        },
        onBlockFilesLoaded: function (scopes) {

            debugBoot && console.log('xapp:onSceneBlocksLoaded, wire scope!', scopes);
            for (var i = 0; i < scopes.length; i++) {
                var scope = scopes[i];
                try {
                    this.wireScope(scope);
                } catch (e) {
                    logError(e,'onBlockFilesLoaded')
                }
            }
        },
        loadXBloxFiles: function (files) {

            var thiz = this;

            function loadXBLOXFiles() {

                thiz.getBlockManager().loadFiles(files).then(function (scopes) {

                    debugBoot && console.log('   Checkpoint 8.1. xapp/manager/context->xblox files loaded');

                    thiz.onBlockFilesLoaded(scopes);
                })
            }

            files = [];
            if (files.length == 0) {

                var item = this.settings.item;
                if (item) {
                    var mount = utils.replaceAll('/', '', item.mount);
                    var extension = utils.getFileExtension(item.path);

                    var path = item.path.replace('.' + extension, '.xblox');
                    var sceneBloxItem = {
                        mount: mount,
                        path: path
                    };

                    files.push(sceneBloxItem);

                    var content = {
                        "blocks": [],
                        "variables": []
                    };
                    this.getFileManager().mkfile(mount, path, JSON.stringify(content, null, 2)).then(function () {
                        loadXBLOXFiles();
                    });
                }
            }
        },
        /**
         * Called when all managers and minimum dependencies are loaded.
         *
         * At this point we're load our xblox files and fire them!
         *
         *
         */
        onReady: function () {
            debugBoot && console.log('Checkpoint 8. xapp/manager->onReady');
            var xbloxFiles = this.settings.xbloxScripts;
            this.loadXBloxFiles(xbloxFiles);
            var thiz = this;
            debugBoot && console.info('-app ready',this);
            this.application.onReady();
        },
        init: function (settings) {

            this.settings = settings;

            if(settings && settings.mixins){
                this.doMixins(settings.mixins);
            }

            debugBoot && console.log('Checkpoint 7. xapp/manager->init(settings)',settings);

            var thiz = this;
            this.subscribe(types.EVENTS.ON_DEVICE_DRIVER_INSTANCE_READY, function () {
                debugBoot && console.log('driver instance ready');
                setTimeout(function () {
                    thiz.publish(types.EVENTS.ON_APP_READY, {
                        context: thiz
                    });
                }, 1000);
            });
            if(has('debug')) {
                this.loadXIDE();
            }

            require([
                'xfile/manager/FileManager',
                'xide/manager/ResourceManager',
                'xnode/manager/NodeServiceManager',
                'xcf/manager/DriverManager',
                'xcf/manager/DeviceManager',
                'xcf/manager/BlockManager',
                'xcf/model/ModelBase',
                'xcf/model/Command',
                'xcf/model/Variable',
                'xcf/factory/Blocks'
            ], function (FileManager, ResourceManager, NodeServiceManager, DriverManager, DeviceManager, BlockManager) {

                debugBoot && console.log('Checkpoint 7.0 xapp/Context::init');


                thiz.blockManager = thiz.createManager(BlockManager);
                thiz.blockManager.init();

                thiz.fileManager = thiz.createManager(FileManager, settings.xFileConfig, {
                    serviceUrl: settings.rpcUrl,
                    singleton: true
                });
                thiz.fileManager.init();


                thiz.resourceManager = thiz.createManager(ResourceManager, settings.xFileConfig, {
                    serviceUrl: settings.rpcUrl,
                    singleton: true
                });
                thiz.resourceManager.init();

                thiz.driverManager = thiz.createManager(DriverManager, null, {
                        serviceUrl: settings.rpcUrl,
                        singleton: true
                    }
                );
                thiz.driverManager.init();

                try {
                    thiz.driverManager.ls('system_drivers').then(function () {
                        thiz.driverManager.ls('user_drivers').then(function () {
                            debugBoot && console.log('Checkpoint 7.1 drivers loaded');
                            thiz.deviceManager = thiz.createManager(DeviceManager, null, {
                                    serviceUrl: settings.rpcUrl,
                                    singleton: true
                                }
                            );
                            thiz.deviceManager.init();
                            thiz.deviceManager.ls('system_devices').then(function () {
                                thiz.deviceManager.ls('user_devices').then(function () {
                                    debugBoot && console.log('Checkpoint 7.1.1 devices loaded');
                                    thiz.nodeServiceManager = thiz.createManager(NodeServiceManager, null, {
                                        serviceUrl: settings.rpcUrl,
                                        singleton: true,
                                        services:settings.NODE_SERVICES
                                    });
                                    thiz.nodeServiceManager.init();
                                    thiz.onReady();
                                });

                            });
                        });
                    });
                } catch (e) {
                    logError(e);
                }
            });


        },
        mergeFunctions: function (target, source) {

            for (var i in source) {
                var o = source[i];
                if (_.isFunction(source[i]) /*&& lang.isFunction(target[i])*/) {
                    debugBoot && console.log('override ' + i);
                    target[i] = o;
                }

            }

        },
        onModuleUpdated: function (evt) {

            var _obj = dojo.getObject(evt.moduleClass);

            if (_obj && _obj.prototype) {
                this.mergeFunctions(_obj.prototype, evt.moduleProto);
            }

        },
        getApplication: function () {
            return this.application;
        },
        getBlockManager: function () {
            return this.blockManager;
        },
        getFileManager: function () {
            return this.fileManager;
        },
        getDriverManager: function () {
            return this.driverManager;
        },
        /**
         *
         * @returns {module:xcf.manager.DeviceManager}
         */
        getDeviceManager: function () {
            return this.deviceManager;
        },
        getNodeServiceManager: function () {
            return this.nodeServiceManager;
        },
        initManagers: function () {
            this.pluginManager.init();
            this.application.init();
        },
        constructManagers: function () {
            this.pluginManager = this.createManager(PluginManager);
            this.application = this.createManager(Application);
        }
    });
});

/** @module decor/Evented */
define('decor/Evented',["dcl/dcl", "dcl/advise"], function (dcl, advise) {
	/**
	 * Base class to add `on()` and `emit()` methods to a class for listening for events and emitting events.
	 * @example
	 * var EventedSubClass = dcl(Evented, {...});
	 * var instance = new EventedSubClass();
	 * instance.on("open", function (event) {
	 *     ... do something with event
	 * });
	 * instance.emit("open", {name: "some event", ...});
	 * @mixin module:decor/Evented
	 */
	return dcl(null, /** @lends module:decor/Evented# */ {
		/**
		 * Setup listener to be called when specified event is fired.
		 * @param {string} type - Name of event.
		 * @param {Function} listener - Callback for when event occurs.
		 * @returns {Object} Handle with `destroy()` method to stop listening to event.
		 */
		on: function (type, listener) {
			return advise.before(this, "on" + type, listener);
		},

		/**
		 * Emit specified event.
		 * @param {string} type - Name of event.
		 * @param {...anything} var_args Parameters to pass to the listeners for this event.
		 */
		emit: function (type) {
			var func = "on" + type;
			if (this[func]) {
				var args = Array.prototype.slice.call(arguments, 1);
				this[func].apply(this, args);
			}
		}
	});
});

/** @module decor/Invalidating */
define('decor/Invalidating',[
	"dcl/dcl",
	"./Stateful",
	"./Destroyable"
], function (dcl, Stateful, Destroyable) {
	/**
	 * Mixin class for widgets
	 * that want to calculate computed properties at once and/or to render UI at once upon multiple property changes.
	 * @class module:decor/Invalidating
	 */
	var Invalidating = dcl([Stateful, Destroyable], /** @lends module:decor/Invalidating# */ {
		// Call initializeInvalidating() right after class is constructed.  Note though that this code won't run for
		// custom elements, since they call createdCallback() rather than constructor().
		// Instead, delite/Widget calls initializeInvalidating() directly.
		constructor: dcl.after(function () {
			this.initializeInvalidating();
		}),

		/**
		 * Make initial calls to `computeProperties()`, `initializeRendering()`, and `refreshRendering()`,
		 * and setup observers so those methods are called whenever properties are modified in the future.
		 * Normally this method is called automatically by the constructor, and should not be called manually,
		 * but the method is exposed for custom elements since they do not call the `constructor()` method.
		 * @protected
		 */
		initializeInvalidating: function () {
			if (!this._hComputing && !this._hRendering) {
				// Make initial call to computeProperties() and setup listener for future calls to computeProperties().
				// Any call to computeProperties(), including the initial call, may trigger more immediate calls to
				// computeProperties().
				this.own(this._hComputing = this.observe(function (oldValues) {
					this.computeProperties(oldValues);
					this.deliverComputing();
				}));
				this.computeProperties(this, true);

				// Make initial call to initializeRendering() and refreshRendering(), and setup listener for future
				// calls.
				this.initializeRendering(this);
				this.refreshRendering(this, true);
				this.own(this._hRendering = this.observe(function (oldValues) {
					var shouldInitializeRendering = this.shouldInitializeRendering(oldValues);
					if (shouldInitializeRendering) {
						this.initializeRendering(oldValues);
						this.refreshRendering(this, true);
					} else {
						this.refreshRendering(oldValues);
					}
				}));
			}
		},

		/**
		 * Synchronously deliver change records for computed properties
		 * so that `computeProperties()` is called if there are pending change records.
		 */
		deliverComputing: function () {
			this._hComputing && this._hComputing.deliver();
			return this._hComputing;
		},

		/**
		 * Discard change records for computed properties.
		 */
		discardComputing: function () {
			this._hComputing && this._hComputing.discardChanges();
			return this._hComputing;
		},

		/**
		 * Function to return if rendering should be initialized.
		 * (Instead of making partial changes for post-initialization)
		 * @param {Object} oldValues The hash table of old property values, keyed by property names.
		 * @param {boolean} isAfterCreation True if this call is right after instantiation.
		 * @return {boolean} True if rendering should be initialized.
		 */
		shouldInitializeRendering: function () {},

		/**
		 * Callback function to calculate computed properties upon property changes.
		 * @param {Object} oldValues The hash table of old property values, keyed by property names.
		 * @param {boolean} isAfterCreation True if this call is right after instantiation.
		 */
		computeProperties: function () {},

		/**
		 * Callback function to initialize rendering.
		 * @param {Object} oldValues The hash table of old property values, keyed by property names.
		 */
		initializeRendering: function () {},

		/**
		 * Callback function to render UI upon property changes.
		 * @param {Object} oldValues The hash table of old property values, keyed by property names.
		 * @param {boolean} isAfterInitialRendering True if this call is right after `initializeRendering()`.
		 */
		refreshRendering: function () {}
	});

	dcl.chainAfter(Invalidating, "computeProperties");
	dcl.chainAfter(Invalidating, "refreshRendering");

	return Invalidating;
});

/** @module liaison/ObservableArray */
define('decor/ObservableArray',[
	"requirejs-dplugins/has",
	"./Observable"
], function (has, Observable) {
	"use strict";

	/**
	 * The same argument list of Array, taking the length of the new array or the initial list of array elements.
	 * @typedef {number|...Anything} module:liaison/ObservableArray~CtorArguments
	 */

	/**
	 * An observable array, working as a shim
	 * of {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
	 * @class
	 * @alias module:liaison/ObservableArray
	 * @augments module:decor/Observable
	 * @param {module:decor/ObservableArray~CtorArguments} [args]
	 *     The length of the new array or the initial list of array elements.
	 */
	var ObservableArray,
		augmentedMethods,
		defineProperty = Object.defineProperty,
		EMPTY_ARRAY = [],
		REGEXP_GLOBAL_OBJECT = /\[\s*object\s+global\s*\]/i; // Global object in node.js

	(function () {
		var observableArrayMarker = "_observableArray";

		if (has("object-observe-api")) {
			// For useNative case, make ObservableArray an instance of Array instead of an inheritance,
			// so that Array.observe() emits splices for .length update
			ObservableArray = function (length) {
				var self = [];
				Observable.call(self);
				// Make ObservableArray marker not enumerable, configurable or writable
				defineProperty(self, observableArrayMarker, {value: 1});
				defineProperty(self, "set", Object.getOwnPropertyDescriptor(Observable.prototype, "set"));
				if (typeof length === "number" && arguments.length === 1) {
					self.length = length;
				} else {
					EMPTY_ARRAY.push.apply(self, arguments);
				}
				return self;
			};
		} else {
			// TODO(asudoh):
			// Document that ObservableArray cannot be observed by Observable.observe()
			// without "splice" in accept list.
			// We need to create large amount of change records to do so,
			// when splice happens with large amount of removals/adds
			ObservableArray = function (length) {
				var beingConstructed = this && !REGEXP_GLOBAL_OBJECT.test(this) && !this.hasOwnProperty("length"),
					// If this is called as regular function (instead of constructor), work with a new instance
					self = beingConstructed ? [] : new ObservableArray();
				if (beingConstructed) {
					Observable.call(self);
					// Make ObservableArray marker not enumerable, configurable or writable
					defineProperty(self, observableArrayMarker, {value: 1});
					// Make those methods not enumerable
					for (var s in augmentedMethods) {
						defineProperty(self, s, {
							value: augmentedMethods[s],
							configurable: true,
							writable: true
						});
					}
				}
				if (typeof length === "number" && arguments.length === 1) {
					self.length = length;
				} else {
					EMPTY_ARRAY.push.apply(self, arguments);
				}
				return self;
			};
		}

		/**
		 * @method module:liaison/ObservableArray.test
		 * @param {Array} a The array to test.
		 * @returns {boolean} true if o is an instance of {@link module:liaison/ObservableArray ObservableArray}.
		 */
		ObservableArray.test = function (a) {
			return a && a[observableArrayMarker];
		};
	})();

	/**
	 * @method module:liaison/ObservableArray.canObserve
	 * @param {Array} a The array to test.
	 * @returns {boolean}
	 *     true if o can be observed with {@link module:liaison/ObservableArray.observe ObservableArray.observe()}.
	 */
	if (has("object-observe-api")) {
		ObservableArray.canObserve = function (a) {
			return typeof (a || {}).splice === "function";
		};
	} else {
		ObservableArray.canObserve = ObservableArray.test;
	}

	if (!has("object-observe-api")) {
		(function () {
			/**
			 * Adds and/or removes elements from an array
			 * and automatically emits a change record compatible
			 * with {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
			 * @param {number} index Index at which to start changing the array.
			 * @param {number} removeCount [An integer indicating the number of old array elements to remove.
			 * @param {...Anything} [var_args] The elements to add to the array.
			 * @return {Array} An array containing the removed elements.
			 * @memberof module:liaison/ObservableArray#
			 */
			function splice(index, removeCount) {
				/* jshint validthis: true */
				if (index < 0) {
					index = this.length + index;
				}
				var oldLength = this.length,
					changeRecord = {
						index: index,
						removed: this.slice(index, index + removeCount),
						addedCount: arguments.length - 2
					},
					result = EMPTY_ARRAY.splice.apply(this, arguments),
					lengthRecord = oldLength !== this.length && {
						type: "update",
						object: this,
						name: "length",
						oldValue: oldLength
					},
					notifier = Observable.getNotifier(this);
				notifier.performChange("splice", function () {
					lengthRecord && notifier.notify(lengthRecord);
					return changeRecord;
				});
				return result;
			}

			augmentedMethods = /** @lends module:liaison/ObservableArray# */ {
				splice: splice,

				/**
				 * Sets a value and automatically emits change record(s)
				 * compatible with
				 * {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
				 * @param {string} name The property name.
				 * @param value The property value.
				 * @returns The value set.
				 */
				set: function (name, value) {
					var args;
					if (name === "length") {
						args = new Array(Math.max(value - this.length, 0));
						args.unshift(Math.min(this.length, value), Math.max(this.length - value, 0));
						splice.apply(this, args);
					} else if (!isNaN(name) && +name >= this.length) {
						args = new Array(name - this.length);
						args.push(value);
						args.unshift(this.length, 0);
						splice.apply(this, args);
					} else {
						Observable.prototype.set.call(this, name, value);
					}
					return value;
				},

				/**
				 * Removes the last element from an array
				 * and automatically emits a change record compatible with
				 * {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
				 * @returns The element removed.
				 */
				pop: function () {
					return splice.call(this, -1, 1)[0];
				},

				/**
				 * Adds one or more elements to the end of an array
				 * and automatically emits a change record compatible with
				 * {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
				 * @param {...Anything} var_args The elements to add to the end of the array.
				 * @returns The new length of the array.
				 */
				push: function () {
					var args = [this.length, 0];
					EMPTY_ARRAY.push.apply(args, arguments);
					splice.apply(this, args);
					return this.length;
				},

				/**
				 * Reverses the order of the elements of an array
				 * and automatically emits a splice type of change record.
				 * @returns {Array} The array itself.
				 */
				reverse: function () {
					var changeRecord = {
							type: "splice",
							object: this,
							index: 0,
							removed: this.slice(),
							addedCount: this.length
						},
						result = EMPTY_ARRAY.reverse.apply(this, arguments);
					// Treat this change as a splice instead of updates in each entry
					Observable.getNotifier(this).notify(changeRecord);
					return result;
				},

				/**
				 * Removes the first element from an array
				 * and automatically emits a change record compatible with
				 * {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
				 * @returns The element removed.
				 */
				shift: function () {
					return splice.call(this, 0, 1)[0];
				},

				/**
				 * Sorts the elements of an array in place
				 * and automatically emits a splice type of change record.
				 * @returns {Array} The array itself.
				 */
				sort: function () {
					var changeRecord = {
							type: "splice",
							object: this,
							index: 0,
							removed: this.slice(),
							addedCount: this.length
						},
						result = EMPTY_ARRAY.sort.apply(this, arguments);
					// Treat this change as a splice instead of updates in each entry
					Observable.getNotifier(this).notify(changeRecord);
					return result;
				},

				/**
				 * Adds one or more elements to the front of an array
				 * and automatically emits a change record compatible with
				 * {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
				 * @param {...Anything} var_args The elements to add to the front of the array.
				 * @returns The new length of the array.
				 */
				unshift: function () {
					var args = [0, 0];
					EMPTY_ARRAY.push.apply(args, arguments);
					splice.apply(this, args);
					return this.length;
				}
			};
		})();
	}

	/**
	 * Observes an ObservableArray for changes.
	 * Internally calls {@link module:decor/Observable.observe Observable.observe()}
	 * observing for the following types of change records:
	 * [
	 *     "add",
	 *     "update",
	 *     "delete",
	 *     "splice"
	 * ]
	 * All change records will be converted to "splice" and are sorted by index and merged to smaller number
	 * of change records.
	 * @method
	 * @param {Object} observable The {@link module:liaison/ObservableArray ObservableArray} to observe.
	 * @param {module:decor/Observable~ChangeCallback} callback The change callback.
	 * @returns {Handle} The handle to stop observing.
	 * @throws {TypeError} If the 1st argument is non-object or null.
	 */
	ObservableArray.observe = (function () {
		function intersect(start1, end1, start2, end2) {
			return end1 <= start2 ? end1 - start2 : // Adjacent or distant
				end2 <= start1 ? end2 - start1 : // Adjacent or distant
				Math.min(end1, end2) - Math.max(start1, start2); // Intersected or contained
		}
		function normalize(record) {
			return record.type !== "add" && record.type !== "update" ? record :
				{
					type: "splice",
					object: record.object,
					index: +record.name,
					removed: [record.oldValue],
					addedCount: 1
				};
		}
		function observeSpliceCallback(callback, records) {
			var merged = [];
			records.forEach(function (incoming) {
				incoming = normalize(incoming);
				var doneIncoming = false,
					indexAdjustment = 0;
				for (var i = 0; i < merged.length; ++i) {
					var entry;
					if (!has("object-observe-api") || !Object.isFrozen(merged[i])) {
						entry = merged[i];
						entry.index += indexAdjustment;
					} else {
						entry = merged[i] = {
							type: "splice",
							object: merged[i].object,
							index: merged[i].index + indexAdjustment,
							removed: merged[i].removed,
							addedCount: merged[i].addedCount
						};
					}
					/* jshint maxlen:150 */
					var amount = intersect(entry.index, entry.index + entry.addedCount, incoming.index, incoming.index + incoming.removed.length);
					if (amount >= 0) {
						// Merge splices
						merged.splice(i--, 1);
						var removed,
							addedCount = entry.addedCount - amount + incoming.addedCount;
						if (entry.index < incoming.index) {
							removed = incoming.removed.slice(Math.max(amount, 0));
							EMPTY_ARRAY.unshift.apply(removed, entry.removed);
						} else {
							removed = incoming.removed.slice(0, amount > 0 ? entry.index - incoming.index : incoming.length);
							EMPTY_ARRAY.push.apply(removed, entry.removed);
							// Append happens when second splice's range contains first splice's range
							EMPTY_ARRAY.push.apply(removed, incoming.removed.slice(entry.index + entry.addedCount - incoming.index));
						}
						/* jshint maxlen:120 */
						if (removed.length === 0 && addedCount === 0) {
							doneIncoming = true;
						} else {
							incoming = {
								type: "splice",
								object: entry.object,
								index: Math.min(entry.index, incoming.index),
								removed: removed,
								addedCount: addedCount
							};
						}
						indexAdjustment -= entry.addedCount - entry.removed.length; // entry is subsumed by incoming
					} else if (incoming.index < entry.index) {
						// Insert the new splice
						var adjustment = incoming.addedCount - incoming.removed.length;
						entry.index += adjustment;
						indexAdjustment += adjustment;
						merged.splice(i++, 0, incoming);
						doneIncoming = true;
					}
				}
				if (!doneIncoming) {
					merged.push(incoming);
				}
			});
			if (merged.length > 0) {
				callback(merged);
			}
		}
		if (has("object-observe-api")) {
			return function (observableArray, callback) {
				Array.observe(observableArray, callback = observeSpliceCallback.bind(observableArray, callback));
				return {
					deliver: Object.deliverChangeRecords.bind(Object, callback),
					remove: Array.unobserve.bind(Array, observableArray, callback)
				};
			};
		} else {
			return function (observableArray, callback) {
				var h = Object.create(Observable.observe(observableArray,
					callback = observeSpliceCallback.bind(observableArray, callback), [
					"add",
					"update",
					"delete",
					"splice"
				]));
				h.deliver = Observable.deliverChangeRecords.bind(Observable, callback);
				return h;
			};
		}
	})();

	return ObservableArray;
});

/**
 * This module sets has() flags based on the current browser:
 *
 * - `has("webkit")`, `has("chrome")`, `has("safari")`
 * - `has("mozilla")`, `has("ff")`
 * - `has("ie")`
 * - `has("ios")`
 * - `has("android")`
 * - `has("wp")`
 *
 * It returns the `has()` function.
 * @module decor/sniff
 */
define('decor/sniff',["./features"], function (has) {
	/* jshint maxcomplexity:20 */

	if (has("host-browser")) {
		var n = navigator,
			dua = n.userAgent,
			dav = n.appVersion;

		// Platform detection
		has.add("mac", /Macintosh/.test(dav));
		if (dua.match(/(iPhone|iPod|iPad)/)) {
			var p = RegExp.$1.replace(/P/, "p");
			var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
			var os = parseFloat(v.replace(/_/, ".").replace(/_/g, ""));
			has.add(p, os);		// "iphone", "ipad" or "ipod"
			has.add("ios", os);
		}
		has.add("android", parseFloat(dua.split("Android ")[1]) || undefined);

		has.add("msapp", parseFloat(dua.split("MSAppHost/")[1]) || undefined);

		has.add("wp", parseFloat(dua.split("Windows Phone ")[1]) || undefined);

		// Browser detection
		var version;
		if ((version = parseFloat(dua.split("Edge/")[1]))) {
			has.add("edge", version);
		} else if ((version = parseFloat(dua.split("WebKit/")[1]))) {
			has.add("webkit", version);
			has.add("chrome", parseFloat(dua.split("Chrome/")[1]) || undefined);
			has.add("safari", /Safari/.test(dav) && !has("chrome") && !has("android") ?
					parseFloat(dav.split("Version/")[1]) : undefined);
		} else if (/Trident/.test(dav)) {
			// IE8+
			has.add("ie", document.documentMode || parseFloat(dav.split("rv:")[1]));
		} else if ((version = parseFloat(dua.split("Firefox/")[1]))) {
			has.add("ff", version);
		}
	}

	return has;
});

/**
 * 
 */
define('dpointer/handlers/features',[
	"requirejs-dplugins/has"
], function (has) {
	if (typeof document !== "undefined") {
		has.add("touch-events", "ontouchstart" in document); // UA supports Touch Events
		has.add("pointer-events", "onpointerdown" in document); // UA supports Pointer Events
		has.add("mspointer-events", "onmspointerdown" in document); // UA supports Pointer Events (IE10+IE11 preview)
		has.add("touch-device", /(mobile)|(android)/i.test(navigator.userAgent)); // mobile device
		has.add("css-touch-action", "touchAction" in document.body.style);// touch-action CSS
		has.add("css-ms-touch-action", "msTouchAction" in document.body.style);// -ms-touch-action CSS
	}
	return has;
});
/**
 * Pointer Events utilities
 */
define('dpointer/handlers/utils',[

], function () {
	"use strict";

	var utils = {
		events: { // pointer events names
			DOWN: "pointerdown",
			UP: "pointerup",
			CANCEL: "pointercancel",
			MOVE: "pointermove",
			OVER: "pointerover",
			OUT: "pointerout",
			ENTER: "pointerenter",
			LEAVE: "pointerleave",
			GOTCAPTURE: "gotpointercapture",
			LOSTCAPTURE: "lostpointercapture"
		},
		TouchAction: { // touch action
			ATTR_NAME: "touch-action",
			AUTO: 0,  // 0000
			PAN_X: 1, // 0001
			PAN_Y: 2, // 0010
			NONE: 3   // 0011
		}
	};

	// Properties and their default value used to create synthetic "Pointer Events" 
	var eventPropDesc = {
		// MouseEvent interface properties
		screenX: 0,
		screenY: 0,
		clientX: 0,
		clientY: 0,
		ctrlKey: null,
		shiftKey: null,
		altKey: null,
		metaKey: null,
		button: 0,
		relatedTarget: null,
		// MouseEvent non standard properties
		which: 0,
		pageX: 0,
		pageY: 0,
		buttons: 0,
		// PointerEvent interface properties
		pointerId: 0,
		width: 0,
		height: 0,
		pressure: 0,
		tiltX: 0,
		tiltY: 0,
		pointerType: "",
		isPrimary: false
	};

	// Pointer Events properties depending on the event type
	var eventTypeDesc = {
		pointerover: {bubbles: true, cancelable: true},
		pointerenter: {bubbles: false, cancelable: false},
		pointerdown: {bubbles: true, cancelable: true},
		pointermove: {bubbles: true, cancelable: true},
		pointerup: {bubbles: true, cancelable: true},
		pointercancel: {bubbles: true, cancelable: false},
		pointerout: {bubbles: true, cancelable: true},
		pointerleave: {bubbles: false, cancelable: false},
		gotpointercapture: {bubbles: true, cancelable: false},
		lostpointercapture: {bubbles: true, cancelable: false}
	};

	// Check if all properties can be redefined using a UIEvent.
	// Synthetic Pointer Event are created from a UIEvent.
	// "MouseEvent" would be too restrictive when it comes to redefine properties. 
	// "Event" may be better for performance and lest restrictive to redefine properties, but it causes weird/unstable
	// behavior on some Samsung/Android 4.2.2 browsers (fast moving of a Slider cause event.target to be null at
	// some point...)
	var canRedefineUIEvent = (function () {
		try {
			defineEventProperties(document.createEvent("UIEvent"), {});
			return true;
		} catch (error) {
			eventPropDesc.view = null;
			eventPropDesc.detail = 0;
			return false;
		}
	})();

	/**
	 * Pointer Event constructor.
	 *
	 * @param pointerType pointer event type name ("pointerdown", "pointerup"...)
	 * @param nativeEvent underlying event which contributes to this pointer event.
	 * @param props event properties (optional). Note that "bubbles", "cancelable", "view" and "detail" are ignored. 
	 * @returns Event a  Pointer event
	 */
	utils.Pointer = function (pointerType, nativeEvent, props) {
		var event;
		// set bubbles and cancelable value according to pointer event type
		props.bubbles = eventTypeDesc[pointerType].bubbles;
		props.cancelable = eventTypeDesc[pointerType].cancelable;
		// create the base event
		if (canRedefineUIEvent) {
			event = document.createEvent("UIEvent");
			event.initUIEvent(
				pointerType, props.bubbles, props.cancelable, nativeEvent.view || null, nativeEvent.detail || 0
			);
		} else {
			// fallback (iOS 7 disallows to redefine property value/getter)
			event = document.createEvent("Event");
			event.initEvent(pointerType, props.bubbles, props.cancelable);
			// view and detail properties are not available in Event constructor 
			props.view = nativeEvent.view || null;
			props.detail = nativeEvent.detail || 0;
		}
		// redefine event properties
		defineEventProperties(event, props);
		// map functions
		mapNativeFunctions(event, nativeEvent);

		return event;
	};

	/**
	 * @param e event
	 * @param props event properties
	 * @returns Event
	 */
	function defineEventProperties(e, props) {
		props.pressure = props.pressure || (props.buttons ? 0.5 : 0);
		var propsDesc = {};
		Object.keys(eventPropDesc).forEach(function (name) {
			if (name in e) {
				this[name] = {
					get: function () {
						return props[name] || eventPropDesc[name];
					}
				};
			} else {
				this[name] = {
					value: props[name] || eventPropDesc[name]
				};
			}
		}, propsDesc);
		Object.defineProperties(e, propsDesc);
		return e;
	}

	/**
	 * creates a synthetic click event with properties based on another event.
	 *
	 * @param sourceEvent the underlying event which contributes to the creation of this event.
	 * @param dblClick set to true to generate a dblclick event, otherwise a click event is generated
	 * @returns {Event} the event (click or dblclick)
	 */
	utils.createSyntheticClick = function (sourceEvent, dblClick) {
		var e = document.createEvent("MouseEvents");
		if (e.isTrusted === undefined) { // Android 4.1.1 does not implement isTrusted
			Object.defineProperty(e, "isTrusted", {
				value: false,
				enumerable: true,
				writable: false,
				configurable: false
			});
		}
		e.initMouseEvent(dblClick ? "dblclick" : "click", true, // bubbles
			true, // cancelable
			sourceEvent.view,
			dblClick ? 2 : 1,
			sourceEvent.screenX,
			sourceEvent.screenY,
			sourceEvent.clientX,
			sourceEvent.clientY,
			sourceEvent.ctrlKey,
			sourceEvent.altKey,
			sourceEvent.shiftKey,
			sourceEvent.metaKey, 0, // button property (touch: always 0)
			null); // no related target
		return e;
	};

	/**
	 * returns true for a native click event, false for a synthetic click event.
	 *
	 * @param e an event
	 * @returns true if native event, false for synthetic event.
	 */
	utils.isNativeClickEvent = function (e) {
		return (e.isTrusted === undefined || e.isTrusted);
	};

	/**
	 * returns the value of MouseEvent.buttons from MouseEvent.which.
	 *
	 * @param whichValue value of a MouseEvent.which property
	 * @returns Number the value MouseEvent.buttons should have
	 */
	utils.which2buttons = function (whichValue) {
		switch (whichValue) {
		case 0:
			return 0;
		case 1:
			return 1;
		case 2:
			return 4;
		case 3:
			return 2;
		default:
			return Math.pow(2, (whichValue - 1));
		}
	};

	/**
	 * Registers the event handler eventListener on target element targetElement
	 * for events of type eventName.
	 *
	 * @param targetElement DOM element to attach the event listener
	 * @param eventName the event type name ("mousedown", "touchstart"...)
	 * @param eventListener an event listener function
	 * @param useCapture set to true to set the handler at the event capture phase
	 */
	utils.addEventListener = function (targetElement, eventName, eventListener, useCapture) {
		targetElement.addEventListener(eventName, eventListener, useCapture);
	};

	/**
	 * Unregister an existing handler.
	 *
	 * @param targetElement DOM element where the event listener is attached
	 * @param eventName  the event type name ("mousedown", "touchstart"...)
	 * @param eventListener the event listener function to remove
	 * @param useCapture set to true if the handler is set at the event capture phase
	 */
	utils.removeEventListener = function (targetElement, eventName, eventListener, useCapture) {
		targetElement.removeEventListener(eventName, eventListener, useCapture);
	};

	/**
	 * Dispatch an event.
	 *
	 * @param targetElement DOM element
	 * @param event event
	 */
		// possible optimization:
		// Chrome: use getEventListeners() to dispatch event ONLY if there is a listener for the target event type
		// other: hook HTMLElement.prototype.addEventListener to keep a record of active [element|event type]
	utils.dispatchEvent = function (targetElement, event) {
		if (!targetElement) {
			// handle case when  moving a pointer outside the window (elementFromTouch return null)
			return false;
		}
		if (!(targetElement.dispatchEvent)) {
			throw new Error("dispatchEvent not supported on targetElement");
		}
		return targetElement.dispatchEvent(event);
	};

	/**
	 * Dispatch pointerleave events.
	 *
	 * @param target DOM element
	 * @param relatedTarget DOM element
	 * @param syntheticEvent the pointerleave event to dispatch
	 */
	utils.dispatchLeaveEvents = function (target, relatedTarget, syntheticEvent) {
		if (target != null &&
			relatedTarget != null &&
			target !== relatedTarget && !(target.compareDocumentPosition(relatedTarget) & 16)) {
			return this.dispatchEvent(target, syntheticEvent) &&
				this.dispatchLeaveEvents(target.parentNode, relatedTarget, syntheticEvent);
		}
		return true;
	};

	/**
	 * Dispatch pointerenter events.
	 *
	 * @param target DOM element
	 * @param relatedTarget DOM element
	 * @param syntheticEvent the pointerenter event to dispatch
	 */
	utils.dispatchEnterEvents = function (target, relatedTarget, syntheticEvent) {
		if (target != null &&
			relatedTarget != null &&
			target !== relatedTarget && !(target.compareDocumentPosition(relatedTarget) & 16)) {
			return this.dispatchEnterEvents(target.parentNode, relatedTarget, syntheticEvent) &&
				this.dispatchEvent(target, syntheticEvent);
		}
		return true;
	};

	/**
	 * @param e event
	 * @param nativeEvent underlying event which contributes to this pointer event.
	 */
	function mapNativeFunctions(e, nativeEvent) {
		if (e.type === utils.GOTCAPTURE || e.type === utils.LOSTCAPTURE) {
			return; //no default action on pointercapture events
		}
		if (e.bubbles) {
			var _stopPropagation = e.stopPropagation;
			e.stopPropagation = function () {
				nativeEvent.stopPropagation();
				_stopPropagation.apply(this);
			};
			if (e.stopImmediatePropagation) {
				var _stopImmediatePropagation = e.stopImmediatePropagation;
				e.stopImmediatePropagation = function () {
					nativeEvent.stopImmediatePropagation();
					_stopImmediatePropagation.apply(this);
				};
			}
		}
		if (eventTypeDesc[e.type].cancelable) {
			var _preventDefault = e.preventDefault;
			e.preventDefault = function () {
				nativeEvent.preventDefault();
				_preventDefault.apply(this);
			};
		}
	}

	return utils;
});
define('dpointer/handlers/touchTracker',[
	"./utils"
], function (utils) {
	"use strict";

	var TouchInfo = function (touchAction, pageX, pageY) {
		this.touchAction = touchAction;
		this.lastNativeEvent = null; // undefined
		this.lastTouch = null; // undefined
		this.capturedTarget = null; // undefined, rename capturedTarget
		this.lastTargetElement = null;
		this.firstMove = {
			startX: pageX,
			startY: pageY
		};
		this.enforceTouchAction = (touchAction === utils.TouchAction.AUTO);
	};

	// touchId of the primary pointer, or -1 if no primary pointer set.
	var primaryTouchId = -1,
		t = {},
		canScroll = function (a1, b1, a2, b2) {
			return Math.abs(a2 - a1) / Math.abs(b2 - b1) > 0.7;
		};

	return {

		register: function (touchId, touchAction, touch) {
			// the first touch to register becomes the primary pointer
			if (primaryTouchId === -1) {
				primaryTouchId = touchId;
			}
			t[touchId] = new TouchInfo(touchAction, touch.pageX, touch.pageY);
		},

		unregister: function (touchId) {
			if (primaryTouchId === touchId) {
				primaryTouchId = -1;
			}
			return (delete t[touchId]);
		},

		update: function (touch, touchEvent, targetElement) {
			t[touch.identifier].lastTouch = touch;
			t[touch.identifier].lastNativeEvent = touchEvent;
			t[touch.identifier].lastTargetElement = targetElement;
		},

		isActive: function (touchId) {
			return (touchId in t);
		},

		isPrimary: function (touchId) {
			return (touchId === primaryTouchId);
		},

		getTouchAction: function (touchId) {
			return t[touchId].touchAction;
		},

		updateScroll: function (touch) {
			if (t[touch.identifier].firstMove) {
				var touchInfo = t[touch.identifier];
				if (touchInfo.touchAction === utils.TouchAction.PAN_Y) {
					touchInfo.enforceTouchAction =
						canScroll(touchInfo.firstMove.startY, touchInfo.firstMove.startX, touch.pageY, touch.pageX);
				} else {
					if (touchInfo.touchAction === utils.TouchAction.PAN_X) {
						touchInfo.enforceTouchAction =
							canScroll(touchInfo.firstMove.startX, touchInfo.firstMove.startY, touch.pageX, touch.pageY);
					}
				}
				touchInfo.firstMove = false;
			}
		},


		isTouchActionEnforced: function (touchId) {
			return t[touchId].enforceTouchAction;
		},

		getLastTouch: function (touchId) {
			return t[touchId].lastTouch;
		},

		getTargetElement: function (touchId) {
			return t[touchId].lastTargetElement;
		},

		getTouchEvent: function (touchId) {
			return t[touchId].lastNativeEvent;
		},

		hasPrimary: function () {
			return (primaryTouchId !== -1);
		},

		getPrimaryTouchEvent: function () {
			return t[primaryTouchId].lastNativeEvent;
		},

		getPrimaryTouch: function () {
			return t[primaryTouchId].lastTouch;
		},

		// touch target depends whether capture has been set on the pointer
		identifyTouchTarget: function (touchId, nonCapturedElement) {
			return (t[touchId] && t[touchId].capturedTarget) || nonCapturedElement;
		},

		identifyPrimaryTouchTarget: function (nonCapturedElement) {
			return this.identifyTouchTarget(primaryTouchId, nonCapturedElement);
		},

		hasCapture: function (touchId) {
			return !!(t[touchId].capturedTarget);
		},

		setCapture: function (touchId, targetElement) {
			// 1. check if pointer is active, otw throw DOMException with the name InvalidPointerId.
			if (!this.isActive(touchId)) {
				throw new Error("InvalidPointerId");
			}
			// todo: 2. pointer must have active buttons, otherwise return
			// 3. register capture on this element.
			t[touchId].capturedTarget = targetElement;
		},

		releaseCapture: function (touchId, targetElement) {
			// 1. check if pointerId is active, otw throw DOMException with the name InvalidPointerId.
			if (!this.isActive(touchId)) {
				throw new Error("InvalidPointerId");
			}
			if (targetElement && targetElement !== t[touchId].capturedTarget) {
				// explicit release but capture element doesn't match
				return false;
			}
			if (t[touchId].capturedTarget) {
				t[touchId].capturedTarget = null;
				return true;
			} else {
				return false;
			}
		}
	};
});
/**
 * this module listen to touch events and generates corresponding pointer events.
 *
 * http://www.w3.org/TR/touch-events/#list-of-touchevent-types
 * todo: pointerenter/pointerleave: generate on capture when target is the originated element.
 */
define('dpointer/handlers/touch',[
	"./features",
	"./touchTracker",
	"./utils"
], function (has, tracker, utils) {
	"use strict";

	var TouchEvents = {
			touchstart: "touchstart",
			touchmove: "touchmove",
			touchend: "touchend",
			touchcancel: "touchcancel"
		},
		DoubleTap = { // allow to track click and determine if a double click/tap event can be fired.
			TAP_DELAY: 250, // maximum delay between 2 clicks in ms, after this delay a dblclick won't be generated
			lastClickTS: 0, // timestamp of the last click
			hasFirstClick: false, // are we waiting for a second click?
			targetElement: null, // element which received the click
			isEligible: function (target) {
				return this.hasFirstClick && (this.targetElement === target) &&
					((new Date().getTime()) - this.lastClickTS < this.TAP_DELAY);
			}
		};

	/**
	 * touchstart event handler.
	 *
	 * @param e touch event
	 */
	function touchstart(e) {
		var touch, touchTarget, touchAction;
		for (var l = e.changedTouches.length, i = 0; i < l; i++) {
			touch = e.changedTouches.item(i);
			touchTarget = null;
			touchAction = determineTouchActionFromAttr(touch.target);
			// before doing anything, we check if there is already an active primary pointer:
			// if default touch action!=auto on the target element, the touch action must be
			// handled by the user agent. The current event is related to a new pointer which contributes to a
			// multi touch gesture: we must absorb this event and cancel the primary pointer to let the user agent
			// handle the default action.
			if (tracker.hasPrimary() && (touchAction === utils.TouchAction.AUTO)) {
				// fire pointerout > pointercancel for current primary pointer
				var lastNativeEvent = tracker.getPrimaryTouchEvent();
				var lastTouch = tracker.getPrimaryTouch();
				touchTarget = tracker.identifyPrimaryTouchTarget(lastTouch.target);
				utils.dispatchEvent(touchTarget, createPointer(utils.events.OUT, lastNativeEvent, lastTouch, {}));
				utils.dispatchEvent(touchTarget, createPointer(utils.events.CANCEL, lastNativeEvent, lastTouch, {}));
				releaseCapture(lastTouch.identifier); //implicit release
				// cancel the primary pointer to avoid duplicate generation of PointerOut > PointerCancel
				tracker.unregister(lastTouch.identifier);
			} else {
				if (touchAction !== utils.TouchAction.AUTO) {
					if (DoubleTap.isEligible(touch.target)) {
						e.preventDefault(); // prevent zoom on double tap
					}
				}
				// primary touch pointer must be defined in case an event handler on pointerdown decides
				// to set a pointer capture on the element, so we must:
				// - register the pointer *before* firing the events.
				// - update the tracker *before* firing the events.
				tracker.register(touch.identifier, touchAction, touch);
				tracker.update(touch, e, touch.target);
				// fire pointerover > pointerdown
				utils.dispatchEvent(touch.target, createPointer(utils.events.OVER, e, touch, {}));
				utils.dispatchEvent(touch.target, createPointer(utils.events.DOWN, e, touch, {}));
			}
		}
	}

	/**
	 * touchmove event handler.
	 *
	 * @param e touch event
	 */
	function touchmove(e) {
		var touch;
		for (var l = e.changedTouches.length, i = 0; i < l; i++) {
			touch = e.changedTouches.item(i);
			if (!tracker.isActive(touch.identifier)) {
				return;
			}
			tracker.updateScroll(touch);
			// browser default actions
			if (tracker.isTouchActionEnforced(touch.identifier)) {
				var lastNativeEventType = tracker.getTouchEvent(touch.identifier).type;
				switch (lastNativeEventType) {
				case TouchEvents.touchstart:
					// (1) fire PointerOut > PointerCancel
					utils.dispatchEvent(touch.target, createPointer(utils.events.OUT, e, touch, {}));
					utils.dispatchEvent(touch.target, createPointer(utils.events.CANCEL, e, touch, {}));
					break;
				case TouchEvents.touchmove:
					// (2) do not fire synthetic event: absorb the touchmove.
					break;
				default:
					// events flow already ended (previous touchmove already removed pointer from tracker to
					// prevent PointerEvent to be fired)
				}
				releaseCapture(touch.identifier); //implicit release
				tracker.unregister(touch.identifier);
			} else { // always map PointerMove when touch action is set (none/pan-x/pan-y)
				var touchTarget = tracker.identifyTouchTarget(touch.identifier, elementFromTouch(touch));
				var lastElementFromPoint = tracker.getTargetElement(touch.identifier);
				// check if the pointer is moving out from the current target element
				if (touchTarget !== lastElementFromPoint) {
					// expected sequence of events:
					// PointerOut (on previous elt) > PointerMove (on current elt) >  PointerOver (on current elt)
					utils.dispatchEvent(lastElementFromPoint,
						createPointer(utils.events.OUT, e, touch, {relatedTarget: touchTarget}));
					// generate pointerleave event(s)
					utils.dispatchLeaveEvents(lastElementFromPoint, touchTarget,
						createPointer(utils.events.LEAVE, e, touch, {relatedTarget: touchTarget}));
					// generate pointermove
					utils.dispatchEvent(touchTarget, createPointer(utils.events.MOVE, e, touch, {}));
					// generate pointerover
					utils.dispatchEvent(touchTarget,
						createPointer(utils.events.OVER, e, touch, {relatedTarget: lastElementFromPoint}));
					// generate pointerenter event(s)
					utils.dispatchEnterEvents(touchTarget, lastElementFromPoint,
						createPointer(utils.events.ENTER, e, touch,
							{relatedTarget: lastElementFromPoint}));
				} else {
					utils.dispatchEvent(touchTarget, createPointer(utils.events.MOVE, e, touch, {}));
				}
				tracker.update(touch, e, touchTarget);
				// touch default actions must be prevented.
				// Let user agent handle it if it supports the touch-action CSS property.
				if (!has("css-touch-action")) {
					e.preventDefault();
				}
			}
		}
	}

	/**
	 * touchend event handler.
	 *
	 * @param e touch event
	 */
	function touchend(e) {
		var touch;
		for (var l = e.changedTouches.length, i = 0; i < l; i++) {
			touch = e.changedTouches.item(i);
			if (!tracker.isActive(touch.identifier)) {
				return;
			}
			var lastNativeEventType = tracker.getTouchEvent(touch.identifier).type;
			// elementFromPoint may return null on android when user makes a pinch 2 zoom gesture
			// in that case we use the current touch.target.
			var elementFromPoint = elementFromTouch(touch) || touch.target;
			var touchTarget = tracker.identifyTouchTarget(touch.identifier, elementFromPoint);
			if (tracker.isTouchActionEnforced(touch.identifier)) {
				// default action handled by user agent
				switch (lastNativeEventType) {
				case TouchEvents.touchmove:
					// (3) do not generate pointer event
					break;
				case TouchEvents.touchstart:
					// (5) fire pointermove > pointerup > pointerOut
					utils.dispatchEvent(touchTarget, createPointer(utils.events.MOVE, e, touch, {}));
					utils.dispatchEvent(touchTarget, createPointer(utils.events.UP, e, touch, {}));
					utils.dispatchEvent(touchTarget, createPointer(utils.events.OUT, e, touch, {}));
					break;
				default:
					// unexpected behavior:
					// touchend event with touch action=auto and lastNativeEventType=[" + lastNativeEventType + "]");
				}
			} else {
				switch (lastNativeEventType) {
				case TouchEvents.touchstart:
					// (6) fire pointermove > pointerup > fast click > pointerout
					utils.dispatchEvent(touchTarget, createPointer(utils.events.MOVE, e, touch, {}));
					utils.dispatchEvent(touchTarget, createPointer(utils.events.UP, e, touch, {}));
					e.preventDefault();
					fireSyntheticClick(touchTarget, touch);
					utils.dispatchEvent(touchTarget, createPointer(utils.events.OUT, e, touch, {}));
					break;
				case TouchEvents.touchmove:
					// (4) fire pointerup > fast click > pointerout
					utils.dispatchEvent(touchTarget, createPointer(utils.events.UP, e, touch, {}));
					// fire synthetic click only if pointer is released on the origin element
					// (touch.target is the target element from the touchstart)
					if (elementFromPoint === touch.target) {
						e.preventDefault();
						fireSyntheticClick(touchTarget, touch);
					}
					utils.dispatchEvent(touchTarget, createPointer(utils.events.OUT, e, touch, {}));
					break;
				default:
					// unexpected behavior:
					// "touchend event with touch action!=auto and lastNativeEventType=[" + lastNativeEventType + "]"
				}
			}
			releaseCapture(touch.identifier); // implicit release
			tracker.unregister(touch.identifier);
		}
	}

	/**
	 * touchcancel event handler.
	 *
	 * @param e touch event
	 */
	function touchcancel(e) {
		var touch;
		for (var l = e.changedTouches.length, i = 0; i < l; i++) {
			touch = e.changedTouches.item(i);
			if (!tracker.isActive(touch.identifier)) {
				return;
			}
			utils.dispatchEvent(tracker.identifyTouchTarget(touch.identifier, elementFromTouch(touch)),
				createPointer(utils.events.CANCEL, e, touch, {}));
			releaseCapture(touch.identifier); // implicit release
			tracker.unregister(touch.identifier);
		}
	}

	/**
	 * create a synthetic Pointer event based on a touch event.
	 *
	 * @param pointerType pointer event type name ("pointerdown", "pointerup"...)
	 * @param touchEvent the underlying touch event which contributes to the creation of the pointer event.
	 * @param touch the underlying touch element which contributes to the creation of the pointer event.
	 * @param props event properties (optional)
	 * @returns {utils.Pointer}
	 */
	function createPointer(pointerType, touchEvent, touch, props) {
		props = props || {};
		// Mouse Event properties
		props.screenX = touch.screenX;
		props.screenY = touch.screenY;
		props.clientX = touch.clientX;
		props.clientY = touch.clientY;
		props.ctrlKey = touchEvent.ctrlKey;
		props.altKey = touchEvent.altKey;
		props.shiftKey = touchEvent.shiftKey;
		props.metaKey = touchEvent.metaKey;
		props.pageX = touch.pageX;
		props.pageY = touch.pageY;
		if (tracker.hasCapture(touch.identifier)) {  // W3C spec §10.1
			props.relatedTarget = null;
		}
		// normalize button/buttons values
		// http://www.w3.org/TR/pointerevents/#chorded-button-interactions
		props.button = (pointerType === utils.events.MOVE) ? -1 : 0;
		props.buttons = 1;
		props.which = props.button + 1;
		// Pointer Events properties
		props.pointerId = touch.identifier + 2; // avoid id collision: 1 is reserved for mouse events mapping
		props.pointerType = "touch";
		props.isPrimary = tracker.isPrimary(touch.identifier);
		return new utils.Pointer(pointerType, touchEvent, props);
	}

	/**
	 * Create and dispatch synthetic events click and dblclick (if eligible).
	 *
	 * @param target
	 * @param touch
	 */
	function fireSyntheticClick(target, touch) {
		// IE10 always generates a click for every pointer when there is multiple touches
		// todo: investigate how IE11 handles clicks when there is multiple touches
		if (tracker.isPrimary(touch.identifier)) {
			// here we choose to fire click/dblclick only for primary pointer
			utils.dispatchEvent(target, utils.createSyntheticClick(touch));
			// dispatch double tap if eligible
			if (DoubleTap.isEligible(target)) {
				utils.dispatchEvent(target, utils.createSyntheticClick(touch, true));
				DoubleTap.hasFirstClick = false;
			} else {
				// remember first click
				DoubleTap.hasFirstClick = true;
				DoubleTap.lastClickTS = (new Date().getTime());
				DoubleTap.targetElement = target;
			}
		}
	}

	/**
	 * returns the deeply nested dom element at window coordinates from a touch element.
	 *
	 * @param touch the touch element
	 * @return HTMLElement the DOM element.
	 */
	function elementFromTouch(touch) {
		return touch.target.ownerDocument.elementFromPoint(touch.clientX, touch.clientY);
	}

	function releaseCapture(touchId, targetElement) {
		if (tracker.releaseCapture(touchId, targetElement)) {
			// 4. Fire a lostpointercapture event at the targetElement
			utils.dispatchEvent(
				tracker.getLastTouch(touchId).target,
				createPointer(utils.events.LOSTCAPTURE,
					tracker.getTouchEvent(touchId),
					tracker.getLastTouch(touchId), {}
				)
			);
			return true;
		}
		return false;
	}

	/**
	 * With touch events there is no CSS property touch-action: Touch action
	 * is specified by the value of the HTML attribute touch-action.
	 * This function returns the touch action which applies to the element, based on "touch action"
	 * from its ancestors.
	 * To be used only when underlying native events are touch events.
	 *
	 * @param targetNode DOM element
	 * @return Number touch action value which applies to the element (auto: 0, pan-x:1, pan-y:2, none: 3)
	 */
	function determineTouchActionFromAttr(targetNode) {
		// touch-action default value: allow default behavior (no prevent default on touch).
		var nodeValue = utils.TouchAction.AUTO;
		// find ancestors with "touch action" and define behavior accordingly.
		do {
			switch (targetNode.getAttribute && targetNode.getAttribute(utils.TouchAction.ATTR_NAME)) {
			case "auto":
				nodeValue = nodeValue | utils.TouchAction.AUTO;
				break;
			case "pan-x":
				nodeValue = nodeValue | utils.TouchAction.PAN_X;
				break;
			case "pan-y":
				nodeValue = nodeValue | utils.TouchAction.PAN_Y;
				break;
			case "none":
				nodeValue = nodeValue | utils.TouchAction.NONE;
				break;
			}
		} while ((nodeValue !== utils.TouchAction.NONE) && (targetNode = targetNode.parentNode));
		return nodeValue;
	}

	return {
		/**
		 * register touch events handlers.
		 *
		 * @param targetElement target element for touch event listeners
		 */
		registerHandlers: function (targetElement) {
			targetElement = targetElement || window.document;
			utils.addEventListener(targetElement, TouchEvents.touchstart, touchstart, true);
			utils.addEventListener(targetElement, TouchEvents.touchmove, touchmove, true);
			utils.addEventListener(targetElement, TouchEvents.touchend, touchend, true);
			utils.addEventListener(targetElement, TouchEvents.touchcancel, touchcancel, true);
		},

		/**
		 * deregister touch events handlers.
		 *
		 * @param targetElement target element for touch  event listeners
		 */
		deregisterHandlers: function (targetElement) {
			utils.removeEventListener(targetElement, TouchEvents.touchstart, touchstart, true);
			utils.removeEventListener(targetElement, TouchEvents.touchmove, touchmove, true);
			utils.removeEventListener(targetElement, TouchEvents.touchend, touchend, true);
			utils.removeEventListener(targetElement, TouchEvents.touchcancel, touchcancel, true);
		},

		/**
		 * Set Pointer capture.
		 *
		 * @param targetElement DOM element to be captured by the pointer
		 * @param pointerId Id of the capturing Pointer
		 */
		setPointerCapture: function (targetElement, pointerId) {
			var touchId = pointerId - 2;
			tracker.setCapture(touchId, targetElement);
			// 4. Fire a gotpointercapture event at the targetElement
			utils.dispatchEvent(
				tracker.getLastTouch(touchId).target,
				createPointer(utils.events.GOTCAPTURE,
					tracker.getTouchEvent(touchId),
					tracker.getLastTouch(touchId), {}
				)
			);
			return true;
		},

		/**
		 * Release Pointer capture.
		 *
		 * @param targetElement DOM element to be captured by the pointer
		 * @param pointerId Id of the capturing Pointer
		 */
		releasePointerCapture: function (targetElement, pointerId) {
			return releaseCapture(pointerId - 2, targetElement);
		},

		/**
		 * @param targetNode DOM element
		 * @return Number touch action value which applies to the element (auto: 0, pan-x:1, pan-y:2, none: 3)
		 */
		determineTouchAction: function (targetNode) {
			return determineTouchActionFromAttr(targetNode);
		}
	};
});
/**
 * This module listens to mouse events and generates corresponding pointer events.
 *
 * http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-mouseevents
 * http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevent-event-order
 */
define('dpointer/handlers/mouse',[
	"./utils"
], function (utils) {
	"use strict";

	var MouseEvents = {
			mousedown: "mousedown",
			mousemove: "mousemove",
			mouseout: "mouseout",
			mouseover: "mouseover",
			mouseup: "mouseup"
		},
		isScrolling = false; // indicates if the mouse is scrolling an element with CSS overflow=auto|scroll.

	/**
	 * mousedown event handler.
	 *
	 * @param e mouse event
	 */
	function mousedown(e) {
		MouseTracker.update(e);
		utils.dispatchEvent(e.target, createPointer(utils.events.DOWN, e, {}));
		// Firefox continues to send mouse event while dragging the scrollbar:
		// if overflow CSS style is set at target element, fire a PointerCancel,
		// then track and absorb subsequent mouse events until a mouseup occurs
		var overflow = (window.getComputedStyle(e.target).overflow);
		if (overflow && (overflow === "auto" || overflow === "scroll")) {
			isScrolling = true;
			utils.dispatchEvent(e.target, createPointer(utils.events.CANCEL, e, {}));
		}
	}

	/**
	 * mousemove event handler.
	 *
	 * @param e mouse event
	 */
	function mousemove(e) {
		if (isScrolling) {
			return;
		}
		utils.dispatchEvent(MouseTracker.identifyTarget(e.target), createPointer(utils.events.MOVE, e, {}));
		MouseTracker.update(e);
	}

	/**
	 * mouseout event handler.
	 *
	 * @param e mouse event
	 */
	function mouseout(e) {
		if (isScrolling || MouseTracker.hasCapture()) {
			return;
		}
		if (e.relatedTarget) {
			utils.dispatchEvent(e.target, createPointer(utils.events.OUT, e, {}));
			// generate pointerleave events
			utils.dispatchLeaveEvents(e.target, e.relatedTarget,
				createPointer(utils.events.LEAVE, e));
		}
		MouseTracker.update(e);
	}

	/**
	 * mouseover event handler.
	 *
	 * @param e mouse event
	 */
	function mouseover(e) {
		if (isScrolling || MouseTracker.hasCapture()) {
			return;
		}
		if (e.relatedTarget) {
			utils.dispatchEvent(e.target, createPointer(utils.events.OVER, e, {}));
			// generate pointerenter events
			utils.dispatchEnterEvents(e.target, e.relatedTarget,
				createPointer(utils.events.ENTER, e));
		}
		MouseTracker.update(e);
	}

	/**
	 * mouseup event handler.
	 *
	 * @param e mouse event
	 */
	function mouseup(e) {
		if (isScrolling) {
			isScrolling = false;
		} else {
			utils.dispatchEvent(MouseTracker.identifyTarget(e.target), createPointer(utils.events.UP, e, {}));
			MouseTracker.implicitReleaseCapture();
			MouseTracker.update(e);
		}
	}

	/**
	 * Create a synthetic pointer from a mouse event.
	 *
	 * @param pointerType pointer event type name ("pointerdown", "pointerup"...)
	 * @param mouseEvent the underlying mouse event which contributes to the creation of the pointer event.
	 * @param props event properties (optional)
	 * @returns {utils.Pointer}
	 */
	function createPointer(pointerType, mouseEvent, props) {
		props = props || {};
		// Mouse Events properties
		props.screenX = mouseEvent.screenX;
		props.screenY = mouseEvent.screenY;
		props.clientX = mouseEvent.clientX;
		props.clientY = mouseEvent.clientY;
		props.ctrlKey = mouseEvent.ctrlKey;
		props.altKey = mouseEvent.altKey;
		props.shiftKey = mouseEvent.shiftKey;
		props.metaKey = mouseEvent.metaKey;
		props.pageX = mouseEvent.pageX;
		props.pageY = mouseEvent.pageY;
		// normalize button/buttons values
		// http://www.w3.org/TR/pointerevents/#chorded-button-interactions
		var buttonValue = mouseEvent.button,
			buttonsValue = (mouseEvent.buttons !== undefined) ? mouseEvent.buttons :
				utils.which2buttons(mouseEvent.which);

		if (mouseEvent.type === "mousemove") {
			buttonValue = -1;
		}
		props.button = buttonValue;
		props.buttons = buttonsValue;
		props.which = buttonValue + 1;
		if (MouseTracker.hasCapture()) {  // Pointer events Spec §10.1: related target must be null on pointer capture
			props.relatedTarget = null;
		} else {
			props.relatedTarget = mouseEvent.relatedTarget;
		}
		// Pointer Events properties
		props.pointerId = 1;
		props.pointerType = "mouse";
		props.isPrimary = true;
		return new utils.Pointer(pointerType, mouseEvent, props);
	}

	var MouseTracker = {
		_lastNativeEvent: null,
		_captureTarget: null,
		register: function () {
		},
		update: function (mouseEvent) {
			this._lastNativeEvent = mouseEvent;
		},
		setCapture: function (targetElement) {
			// 1. check if pointerId is active, otw throw DOMException with the name InvalidPointerId.
			if (!this._lastNativeEvent) {
				throw "InvalidPointerId";
			}
			// 2. at least one button must be pressed
			if (this._lastNativeEvent.buttons === 0) {
				return false;
			}
			// 3. set PointerCapture=true
			this._captureTarget = targetElement;
			// 4. Fire a gotpointercapture event at the targetElement
			utils.dispatchEvent(this._lastNativeEvent.target,
				createPointer(utils.events.GOTCAPTURE, this._lastNativeEvent, {}));
			return true;
		},
		hasCapture: function () {
			return !!(this._captureTarget);
		},
		identifyTarget: function (nonCapturedElement) {
			return (this._captureTarget) || nonCapturedElement;
		},
		releaseCapture: function (targetElement, implicit) {
			// 1. check if pointerId is active, otw throw DOMException with the name InvalidPointerId.
			if (!this._lastNativeEvent) {
				throw "InvalidPointerId";
			}
			// 2. if pointer capture not set at targetElement, return
			if (!implicit && (this._captureTarget !== targetElement)) {
				return false;
			}
			// 3. release capture
			if (this._captureTarget) {
				// 4. Fire a lostpointercapture event at the targetElement
				utils.dispatchEvent(this._captureTarget,
					createPointer(utils.events.LOSTCAPTURE, this._lastNativeEvent, {}));
				this._captureTarget = null;
			}
			return true;
		},
		implicitReleaseCapture: function () {
			return this.releaseCapture(null, true);
		}
	};

	return {
		/**
		 * register mouse events handlers.
		 *
		 * @param targetElement target element for mouse event listeners
		 */
		registerHandlers: function (targetElement) {
			targetElement = targetElement || window.document;
			utils.addEventListener(targetElement, MouseEvents.mousedown, mousedown, true);
			utils.addEventListener(targetElement, MouseEvents.mousemove, mousemove, true);
			utils.addEventListener(targetElement, MouseEvents.mouseout, mouseout, true);
			utils.addEventListener(targetElement, MouseEvents.mouseover, mouseover, true);
			utils.addEventListener(targetElement, MouseEvents.mouseup, mouseup, true);
		},

		/**
		 * deregister mouse events handlers.
		 * @param targetElement target element for mouse event listeners
		 */
		deregisterHandlers: function (targetElement) {
			utils.removeEventListener(targetElement, MouseEvents.mousedown, mousedown, true);
			utils.removeEventListener(targetElement, MouseEvents.mousemove, mousemove, true);
			utils.removeEventListener(targetElement, MouseEvents.mouseout, mouseout, true);
			utils.removeEventListener(targetElement, MouseEvents.mouseover, mouseover, true);
			utils.removeEventListener(targetElement, MouseEvents.mouseup, mouseup, true);
		},

		/**
		 * set pointer capture.
		 *
		 * @param targetElement DOM element to be captured by the pointer
		 * @returns true if pointer is captured.
		 */
		setPointerCapture: function (targetElement) {
			return MouseTracker.setCapture(targetElement);
		},

		/**
		 * release pointer capture.
		 *
		 * @param targetElement DOM element to be captured by the pointer
		 * @returns true is pointer is released.
		 */
		releasePointerCapture: function (targetElement) {
			return MouseTracker.releaseCapture(targetElement, false);
		}
	};
});

/**
 * Pointer Events shim
 */
define('dpointer/events',[
	"./handlers/features",
	"./handlers/utils",
	"./handlers/touch",
	"./handlers/mouse",
	"./handlers/features!mspointer-events?./handlers/mspointer"
], function (has, utils, touch, mouse, mspointer) {
	"use strict";

	var pointerEvents = {_targetElement: null};

	/**
	 * Enable Pointer events. Register native event handlers. Importing this module automatically register native
	 * event handlers on window.document, unless you specify a target element.
	 *
	 * @param targetElement DOM element on which to attach handlers.
	 * @default window.document
	 */
	pointerEvents.enable = function (targetElement) {
		targetElement = targetElement || window.document;
		if (this._targetElement) {
			return;// already initialized
		}
		if (!has("pointer-events")) {
			if (has("mspointer-events")) {
				mspointer.registerHandlers(targetElement);
			} else {
				if (has("touch-events") && has("touch-device")) {
					touch.registerHandlers(targetElement);
				} else {
					mouse.registerHandlers(targetElement);
				}
			}
		}
		this._targetElement = targetElement;
	};

	/**
	 * Disable Pointer events. Unregister native event handlers.
	 */
	pointerEvents.disable = function () {
		if (this._targetElement) {
			touch.deregisterHandlers(this._targetElement);
			mouse.deregisterHandlers(this._targetElement);
			mspointer && mspointer.deregisterHandlers(this._targetElement);
		}
		this._targetElement = null;
	};

	/**
	 * Set the attribute touch-action on the target element.
	 * Supported touch-actions are "auto" (user agent handles touch actions
	 * default behaviors), "none" (disable user agent default behavior), pan-x and pan-y.
	 *
	 * @param targetElement a DOM element
	 * @param actionType touch action type: "auto", "none", "pan-x" or "pan-y"
	 */
	pointerEvents.setTouchAction = function (targetElement, actionType) {
		targetElement.setAttribute(utils.TouchAction.ATTR_NAME, actionType);
	};

	/**
	 * Set pointer capture on a DOM element.
	 *
	 * @param targetElement DOM element
	 * @param pointerId Pointer ID
	 */
	pointerEvents.setPointerCapture = function (targetElement, pointerId) {
		// todo: Internet Explorer automatically set pointer capture on form controls when touch-action is none
		// todo: manage a list of element type to apply pointer capture automatically when touch-action=none is set??
		if (!this._targetElement) {
			return false;// not initialized
		}
		if (has("pointer-events")) {
			return targetElement.setPointerCapture(pointerId);// use native Pointer Events method
		} else {
			if (has("mspointer-events")) {
				return targetElement.msSetPointerCapture(pointerId);// use native Pointer Events method
			} else {
				if (pointerId === 1) { // mouse always gets ID = 1
					return mouse.setPointerCapture(targetElement);
				} else {
					return touch.setPointerCapture(targetElement, pointerId);
				}
			}
		}
	};

	/**
	 * Unset pointer capture on a DOM element.
	 *
	 * @param targetElement DOM element
	 * @param pointerId Pointer ID
	 */
	pointerEvents.releasePointerCapture = function (targetElement, pointerId) {
		if (!this._targetElement) {
			return false;
		}
		if (has("pointer-events")) {
			return targetElement.releasePointerCapture(pointerId);
		} else {
			if (has("mspointer-events")) {
				return targetElement.msReleasePointerCapture(pointerId);
			} else {
				if (pointerId === 1) {
					return mouse.releasePointerCapture(targetElement);
				} else {
					return touch.releasePointerCapture(targetElement, pointerId);
				}
			}
		}
	};

	/**
	 * CSS rule to define touch-action or -ms-touch-action when touch-action attribute is set on Elements.
	 *
	 * @param styleName should be touch-action or -ms-touch-action
	 */
	function insertTouchActionCSSRule(styleName) {
		var styleElement = document.createElement("style"),
			attributeName = utils.TouchAction.ATTR_NAME;
		styleElement.textContent = "[" + attributeName + "='none']  { " + styleName + ": none; }" +
			"[" + attributeName + "='auto']  { " + styleName + ": auto; }" +
			"[" + attributeName + "='pan-x'] { " + styleName + ": pan-x; }" +
			"[" + attributeName + "='pan-y'] { " + styleName + ": pan-y; }" +
			"[" + attributeName + "='pan-x pan-y'],[" + styleName + "='pan-y pan-x'] " +
			"{ " + styleName + ": pan-x pan-y; }";
		document.head.insertBefore(styleElement, document.head.firstChild);
	}

	// CSS rule when user agent implements W3C Pointer Events or when a polyfill is in place.
	if (has("pointer-events")) {
		insertTouchActionCSSRule("touch-action");
	}

		// CSS rule for IE10 and IE11 preview
	if (has("mspointer-events")) {
		insertTouchActionCSSRule("-ms-touch-action");
	}
	// CSS rule to map CSS attribute in case user agent has native support for touch-action or -ms-touch-action
	// CSS property.
	if (has("css-touch-action")) {
		insertTouchActionCSSRule("touch-action");
	} else {
		// CSS rule for IE10 and IE11 preview
		if (has("css-ms-touch-action")) {
			insertTouchActionCSSRule("-ms-touch-action");
		}
	}

	// start listening to native events
	pointerEvents.enable();

	return pointerEvents;
});
define('xapp/mainr.js',[
    "dojo/_base/kernel",
    "dojo/_base/lang",
    "dojo/_base/declare",
    "dojo/Deferred",
    "dojo/has",
    "xdojo/declare",
    "xdojo/has",
    'dcl/dcl',
    'dcl/advise',
    'dcl/mini',
    'dstore/mainr',
    'xdojo/declare',
    'dstore/Filter',
    'xblox/mainr',
    "xblox/RunScript",
    "xblox/CSSState",
    "xblox/StyleState",
    'xide/mainr',

    'xfile/manager/FileManager',
    'xfile/manager/FileManagerActions',

    'xwire/main',
    'xcf/mainr',
    'xide/utils',
    'xnode/manager/NodeServiceManager',
    'xapp/manager/Application',
    'xapp/manager/Context',
    'decor/Evented',
    'decor/Invalidating',
    'decor/ObservableArray',
    'decor/features',
    'decor/schedule',
    'decor/sniff',

    'dpointer/events',
    'dpointer/handlers/features',
    'dpointer/handlers/mouse',
    'dpointer/handlers/touch',
    'dpointer/handlers/touchTracker',
    'dpointer/handlers/utils'
    //"xdeliteful/Button"
    /*
    
    "deliteful/Button",
    "deliteful/Slider",
    "deliteful/Combobox",
    "deliteful/Checkbox",
    "deliteful/RadioButton",
    "deliteful/ToggleButton",
    "deliteful/Switch"
    */
], function(){});

